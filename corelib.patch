This patch is applied to the downloaded corelib, to remove tests for
unimplemented libfuncs. This patch allows us to not need to add the full corelib
to the repository.

To generate the patch:
1. Extract corelib to cairo2/corelib and cairo2/corelib_1
2. Modify the corelib
3. Run `diff -crN cairo2/corelib_1/ cairo2/corelib > corelib.patch`

diff --color=auto -crN cairo2/corelib_1/src/starknet/account.cairo cairo2/corelib/src/starknet/account.cairo
*** cairo2/corelib_1/src/starknet/account.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/starknet/account.cairo	Thu Dec 18 12:52:06 2025
***************
*** 51,919 ****
      fn __execute__(ref self: TContractState, calls: Array<Call>) -> Array<Span<felt252>>;
  }
  
- 
- // Generate code.
- 
- impl AccountContractDispatcherStore<> of starknet::Store<AccountContractDispatcher> {
-     fn read(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress,
-     ) -> starknet::SyscallResult<AccountContractDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > {
-             value: starknet::Store::<
-                 starknet::ContractAddress,
-             >::read(__store_derive_address_domain__, __store_derive_base__)?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractDispatcher { contract_address: contract_address.value },
-         )
-     }
-     fn write(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         value: AccountContractDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let AccountContractDispatcher { contract_address } = value;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > { value: contract_address };
-         starknet::Store::<
-             starknet::ContractAddress,
-         >::write(__store_derive_address_domain__, __store_derive_base__, contract_address.value)?;
-         starknet::SyscallResult::Ok(())
-     }
-     fn read_at_offset(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8,
-     ) -> starknet::SyscallResult<AccountContractDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > {
-             value: starknet::Store::<
-                 starknet::ContractAddress,
-             >::read_at_offset(
-                 __store_derive_address_domain__, __store_derive_base__, __store_derive_offset__,
-             )?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractDispatcher { contract_address: contract_address.value },
-         )
-     }
-     #[inline(always)]
-     fn write_at_offset(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         offset: u8,
-         value: AccountContractDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let AccountContractDispatcher { contract_address } = value;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > { value: contract_address };
-         starknet::Store::<
-             starknet::ContractAddress,
-         >::write_at_offset(
-             __store_derive_address_domain__,
-             __store_derive_base__,
-             __store_derive_offset__,
-             contract_address.value,
-         )?;
-         starknet::SyscallResult::Ok(())
-     }
-     #[inline(always)]
-     fn size() -> u8 {
-         starknet::Store::<starknet::ContractAddress>::size()
-     }
- }
- 
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractDispatcherSubPointers {
-     pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
- }
- #[doc(hidden)]
- impl AccountContractDispatcherSubPointersImpl of starknet::storage::SubPointers<
-     AccountContractDispatcher,
- > {
-     type SubPointersType = AccountContractDispatcherSubPointers;
-     fn sub_pointers(
-         self: starknet::storage::StoragePointer<AccountContractDispatcher>,
-     ) -> AccountContractDispatcherSubPointers {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __contract_address_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractDispatcherSubPointers { contract_address: __contract_address_value__ }
-     }
- }
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractDispatcherSubPointersMut {
-     pub contract_address: starknet::storage::StoragePointer<
-         starknet::storage::Mutable<starknet::ContractAddress>,
-     >,
- }
- #[doc(hidden)]
- impl AccountContractDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<
-     AccountContractDispatcher,
- > {
-     type SubPointersType = AccountContractDispatcherSubPointersMut;
-     fn sub_pointers_mut(
-         self: starknet::storage::StoragePointer<
-             starknet::storage::Mutable<AccountContractDispatcher>,
-         >,
-     ) -> AccountContractDispatcherSubPointersMut {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __contract_address_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractDispatcherSubPointersMut { contract_address: __contract_address_value__ }
-     }
- }
- 
- impl AccountContractLibraryDispatcherStore<> of starknet::Store<AccountContractLibraryDispatcher> {
-     fn read(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress,
-     ) -> starknet::SyscallResult<AccountContractLibraryDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let class_hash = core::internal::InferDestruct::<
-             starknet::ClassHash,
-         > {
-             value: starknet::Store::<
-                 starknet::ClassHash,
-             >::read(__store_derive_address_domain__, __store_derive_base__)?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractLibraryDispatcher { class_hash: class_hash.value },
-         )
-     }
-     fn write(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         value: AccountContractLibraryDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let AccountContractLibraryDispatcher { class_hash } = value;
-         let class_hash = core::internal::InferDestruct::<starknet::ClassHash> { value: class_hash };
-         starknet::Store::<
-             starknet::ClassHash,
-         >::write(__store_derive_address_domain__, __store_derive_base__, class_hash.value)?;
-         starknet::SyscallResult::Ok(())
-     }
-     fn read_at_offset(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8,
-     ) -> starknet::SyscallResult<AccountContractLibraryDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let class_hash = core::internal::InferDestruct::<
-             starknet::ClassHash,
-         > {
-             value: starknet::Store::<
-                 starknet::ClassHash,
-             >::read_at_offset(
-                 __store_derive_address_domain__, __store_derive_base__, __store_derive_offset__,
-             )?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractLibraryDispatcher { class_hash: class_hash.value },
-         )
-     }
-     #[inline(always)]
-     fn write_at_offset(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         offset: u8,
-         value: AccountContractLibraryDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let AccountContractLibraryDispatcher { class_hash } = value;
-         let class_hash = core::internal::InferDestruct::<starknet::ClassHash> { value: class_hash };
-         starknet::Store::<
-             starknet::ClassHash,
-         >::write_at_offset(
-             __store_derive_address_domain__,
-             __store_derive_base__,
-             __store_derive_offset__,
-             class_hash.value,
-         )?;
-         starknet::SyscallResult::Ok(())
-     }
-     #[inline(always)]
-     fn size() -> u8 {
-         starknet::Store::<starknet::ClassHash>::size()
-     }
- }
- 
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractLibraryDispatcherSubPointers {
-     pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
- }
- #[doc(hidden)]
- impl AccountContractLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<
-     AccountContractLibraryDispatcher,
- > {
-     type SubPointersType = AccountContractLibraryDispatcherSubPointers;
-     fn sub_pointers(
-         self: starknet::storage::StoragePointer<AccountContractLibraryDispatcher>,
-     ) -> AccountContractLibraryDispatcherSubPointers {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __class_hash_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractLibraryDispatcherSubPointers { class_hash: __class_hash_value__ }
-     }
- }
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractLibraryDispatcherSubPointersMut {
-     pub class_hash: starknet::storage::StoragePointer<
-         starknet::storage::Mutable<starknet::ClassHash>,
-     >,
- }
- #[doc(hidden)]
- impl AccountContractLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<
-     AccountContractLibraryDispatcher,
- > {
-     type SubPointersType = AccountContractLibraryDispatcherSubPointersMut;
-     fn sub_pointers_mut(
-         self: starknet::storage::StoragePointer<
-             starknet::storage::Mutable<AccountContractLibraryDispatcher>,
-         >,
-     ) -> AccountContractLibraryDispatcherSubPointersMut {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __class_hash_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractLibraryDispatcherSubPointersMut { class_hash: __class_hash_value__ }
-     }
- }
- 
- impl AccountContractSafeLibraryDispatcherStore<> of starknet::Store<
-     AccountContractSafeLibraryDispatcher,
- > {
-     fn read(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress,
-     ) -> starknet::SyscallResult<AccountContractSafeLibraryDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let class_hash = core::internal::InferDestruct::<
-             starknet::ClassHash,
-         > {
-             value: starknet::Store::<
-                 starknet::ClassHash,
-             >::read(__store_derive_address_domain__, __store_derive_base__)?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractSafeLibraryDispatcher { class_hash: class_hash.value },
-         )
-     }
-     fn write(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         value: AccountContractSafeLibraryDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let AccountContractSafeLibraryDispatcher { class_hash } = value;
-         let class_hash = core::internal::InferDestruct::<starknet::ClassHash> { value: class_hash };
-         starknet::Store::<
-             starknet::ClassHash,
-         >::write(__store_derive_address_domain__, __store_derive_base__, class_hash.value)?;
-         starknet::SyscallResult::Ok(())
-     }
-     fn read_at_offset(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8,
-     ) -> starknet::SyscallResult<AccountContractSafeLibraryDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let class_hash = core::internal::InferDestruct::<
-             starknet::ClassHash,
-         > {
-             value: starknet::Store::<
-                 starknet::ClassHash,
-             >::read_at_offset(
-                 __store_derive_address_domain__, __store_derive_base__, __store_derive_offset__,
-             )?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractSafeLibraryDispatcher { class_hash: class_hash.value },
-         )
-     }
-     #[inline(always)]
-     fn write_at_offset(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         offset: u8,
-         value: AccountContractSafeLibraryDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let AccountContractSafeLibraryDispatcher { class_hash } = value;
-         let class_hash = core::internal::InferDestruct::<starknet::ClassHash> { value: class_hash };
-         starknet::Store::<
-             starknet::ClassHash,
-         >::write_at_offset(
-             __store_derive_address_domain__,
-             __store_derive_base__,
-             __store_derive_offset__,
-             class_hash.value,
-         )?;
-         starknet::SyscallResult::Ok(())
-     }
-     #[inline(always)]
-     fn size() -> u8 {
-         starknet::Store::<starknet::ClassHash>::size()
-     }
- }
- 
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractSafeLibraryDispatcherSubPointers {
-     pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
- }
- #[doc(hidden)]
- impl AccountContractSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<
-     AccountContractSafeLibraryDispatcher,
- > {
-     type SubPointersType = AccountContractSafeLibraryDispatcherSubPointers;
-     fn sub_pointers(
-         self: starknet::storage::StoragePointer<AccountContractSafeLibraryDispatcher>,
-     ) -> AccountContractSafeLibraryDispatcherSubPointers {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __class_hash_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractSafeLibraryDispatcherSubPointers { class_hash: __class_hash_value__ }
-     }
- }
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractSafeLibraryDispatcherSubPointersMut {
-     pub class_hash: starknet::storage::StoragePointer<
-         starknet::storage::Mutable<starknet::ClassHash>,
-     >,
- }
- #[doc(hidden)]
- impl AccountContractSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<
-     AccountContractSafeLibraryDispatcher,
- > {
-     type SubPointersType = AccountContractSafeLibraryDispatcherSubPointersMut;
-     fn sub_pointers_mut(
-         self: starknet::storage::StoragePointer<
-             starknet::storage::Mutable<AccountContractSafeLibraryDispatcher>,
-         >,
-     ) -> AccountContractSafeLibraryDispatcherSubPointersMut {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __class_hash_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractSafeLibraryDispatcherSubPointersMut { class_hash: __class_hash_value__ }
-     }
- }
- 
- impl AccountContractSafeDispatcherStore<> of starknet::Store<AccountContractSafeDispatcher> {
-     fn read(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress,
-     ) -> starknet::SyscallResult<AccountContractSafeDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > {
-             value: starknet::Store::<
-                 starknet::ContractAddress,
-             >::read(__store_derive_address_domain__, __store_derive_base__)?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractSafeDispatcher { contract_address: contract_address.value },
-         )
-     }
-     fn write(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         value: AccountContractSafeDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let AccountContractSafeDispatcher { contract_address } = value;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > { value: contract_address };
-         starknet::Store::<
-             starknet::ContractAddress,
-         >::write(__store_derive_address_domain__, __store_derive_base__, contract_address.value)?;
-         starknet::SyscallResult::Ok(())
-     }
-     fn read_at_offset(
-         address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8,
-     ) -> starknet::SyscallResult<AccountContractSafeDispatcher> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > {
-             value: starknet::Store::<
-                 starknet::ContractAddress,
-             >::read_at_offset(
-                 __store_derive_address_domain__, __store_derive_base__, __store_derive_offset__,
-             )?,
-         };
-         starknet::SyscallResult::Ok(
-             AccountContractSafeDispatcher { contract_address: contract_address.value },
-         )
-     }
-     #[inline(always)]
-     fn write_at_offset(
-         address_domain: u32,
-         base: starknet::storage_access::StorageBaseAddress,
-         offset: u8,
-         value: AccountContractSafeDispatcher,
-     ) -> starknet::SyscallResult<()> {
-         let __store_derive_address_domain__ = address_domain;
-         let __store_derive_base__ = base;
-         let __store_derive_offset__ = offset;
-         let AccountContractSafeDispatcher { contract_address } = value;
-         let contract_address = core::internal::InferDestruct::<
-             starknet::ContractAddress,
-         > { value: contract_address };
-         starknet::Store::<
-             starknet::ContractAddress,
-         >::write_at_offset(
-             __store_derive_address_domain__,
-             __store_derive_base__,
-             __store_derive_offset__,
-             contract_address.value,
-         )?;
-         starknet::SyscallResult::Ok(())
-     }
-     #[inline(always)]
-     fn size() -> u8 {
-         starknet::Store::<starknet::ContractAddress>::size()
-     }
- }
- 
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractSafeDispatcherSubPointers {
-     pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
- }
- #[doc(hidden)]
- impl AccountContractSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<
-     AccountContractSafeDispatcher,
- > {
-     type SubPointersType = AccountContractSafeDispatcherSubPointers;
-     fn sub_pointers(
-         self: starknet::storage::StoragePointer<AccountContractSafeDispatcher>,
-     ) -> AccountContractSafeDispatcherSubPointers {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __contract_address_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractSafeDispatcherSubPointers { contract_address: __contract_address_value__ }
-     }
- }
- #[derive(Drop, Copy)]
- #[doc(hidden)]
- pub struct AccountContractSafeDispatcherSubPointersMut {
-     pub contract_address: starknet::storage::StoragePointer<
-         starknet::storage::Mutable<starknet::ContractAddress>,
-     >,
- }
- #[doc(hidden)]
- impl AccountContractSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<
-     AccountContractSafeDispatcher,
- > {
-     type SubPointersType = AccountContractSafeDispatcherSubPointersMut;
-     fn sub_pointers_mut(
-         self: starknet::storage::StoragePointer<
-             starknet::storage::Mutable<AccountContractSafeDispatcher>,
-         >,
-     ) -> AccountContractSafeDispatcherSubPointersMut {
-         let base_address = self.__storage_pointer_address__;
-         let mut current_offset = self.__storage_pointer_offset__;
-         let __contract_address_value__ = starknet::storage::StoragePointer {
-             __storage_pointer_address__: base_address, __storage_pointer_offset__: current_offset,
-         };
-         AccountContractSafeDispatcherSubPointersMut { contract_address: __contract_address_value__ }
-     }
- }
- 
- pub trait AccountContractDispatcherTrait<T> {
-     /// An entry point that is called to check if the account is willing to pay for the declaration
-     /// of the class with the given hash.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the declaration.
-     fn __validate_declare__(self: T, class_hash: felt252) -> felt252;
- 
-     /// An entry point that is called to check if the account is willing to pay for
-     /// executing a given set of calls.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the execution, in which case `__execute__` will be called on the same set of calls.
-     fn __validate__(self: T, calls: Array<Call>) -> felt252;
- 
-     /// An entry point that is called to execute a given set of calls.
-     /// This entry point should block the deprecated v0 invoke transactions as they do not go
-     /// through the `__validate__` entry point.
-     fn __execute__(self: T, calls: Array<Call>) -> Array<Span<felt252>>;
- }
- 
- #[derive(Copy, Drop, Serde)]
- pub struct AccountContractDispatcher {
-     pub contract_address: starknet::ContractAddress,
- }
- 
- impl AccountContractDispatcherImpl of AccountContractDispatcherTrait<AccountContractDispatcher> {
-     /// An entry point that is called to check if the account is willing to pay for the declaration
-     /// of the class with the given hash.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the declaration.
-     fn __validate_declare__(self: AccountContractDispatcher, class_hash: felt252) -> felt252 {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<felt252>::serialize(@class_hash, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
-             self.contract_address,
-             0x289da278a8dc833409cabfdad1581e8e7d40e42dcaed693fa4008dcdb4963b3,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
-             __dispatcher_return_data__,
-         );
-         core::option::OptionTrait::expect(
-             core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-             'Returned data too short',
-         )
-     }
- 
-     /// An entry point that is called to check if the account is willing to pay for
-     /// executing a given set of calls.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the execution, in which case `__execute__` will be called on the same set of calls.
-     fn __validate__(self: AccountContractDispatcher, calls: Array<Call>) -> felt252 {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
-             self.contract_address,
-             0x162da33a4585851fe8d3af3c2a9c60b557814e221e0d4f30ff0b2189d9c7775,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
-             __dispatcher_return_data__,
-         );
-         core::option::OptionTrait::expect(
-             core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-             'Returned data too short',
-         )
-     }
- 
-     /// An entry point that is called to execute a given set of calls.
-     /// This entry point should block the deprecated v0 invoke transactions as they do not go
-     /// through the `__validate__` entry point.
-     fn __execute__(self: AccountContractDispatcher, calls: Array<Call>) -> Array<Span<felt252>> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
-             self.contract_address,
-             0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
-             __dispatcher_return_data__,
-         );
-         core::option::OptionTrait::expect(
-             core::serde::Serde::<Array<Span<felt252>>>::deserialize(ref __dispatcher_return_data__),
-             'Returned data too short',
-         )
-     }
- }
- 
- #[derive(Copy, Drop, Serde)]
- pub struct AccountContractLibraryDispatcher {
-     pub class_hash: starknet::ClassHash,
- }
- 
- impl AccountContractLibraryDispatcherImpl of AccountContractDispatcherTrait<
-     AccountContractLibraryDispatcher,
- > {
-     /// An entry point that is called to check if the account is willing to pay for the declaration
-     /// of the class with the given hash.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the declaration.
-     fn __validate_declare__(
-         self: AccountContractLibraryDispatcher, class_hash: felt252,
-     ) -> felt252 {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<felt252>::serialize(@class_hash, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
-             self.class_hash,
-             0x289da278a8dc833409cabfdad1581e8e7d40e42dcaed693fa4008dcdb4963b3,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
-             __dispatcher_return_data__,
-         );
-         core::option::OptionTrait::expect(
-             core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-             'Returned data too short',
-         )
-     }
- 
-     /// An entry point that is called to check if the account is willing to pay for
-     /// executing a given set of calls.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the execution, in which case `__execute__` will be called on the same set of calls.
-     fn __validate__(self: AccountContractLibraryDispatcher, calls: Array<Call>) -> felt252 {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
-             self.class_hash,
-             0x162da33a4585851fe8d3af3c2a9c60b557814e221e0d4f30ff0b2189d9c7775,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
-             __dispatcher_return_data__,
-         );
-         core::option::OptionTrait::expect(
-             core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-             'Returned data too short',
-         )
-     }
- 
-     /// An entry point that is called to execute a given set of calls.
-     /// This entry point should block the deprecated v0 invoke transactions as they do not go
-     /// through the `__validate__` entry point.
-     fn __execute__(
-         self: AccountContractLibraryDispatcher, calls: Array<Call>,
-     ) -> Array<Span<felt252>> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
-             self.class_hash,
-             0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(
-             __dispatcher_return_data__,
-         );
-         core::option::OptionTrait::expect(
-             core::serde::Serde::<Array<Span<felt252>>>::deserialize(ref __dispatcher_return_data__),
-             'Returned data too short',
-         )
-     }
- }
- 
- pub trait AccountContractSafeDispatcherTrait<T> {
-     #[unstable(feature: "safe_dispatcher")]
-     /// An entry point that is called to check if the account is willing to pay for the declaration
-     /// of the class with the given hash.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the declaration.
-     fn __validate_declare__(self: T, class_hash: felt252) -> starknet::SyscallResult<felt252>;
-     #[unstable(feature: "safe_dispatcher")]
-     /// An entry point that is called to check if the account is willing to pay for
-     /// executing a given set of calls.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the execution, in which case `__execute__` will be called on the same set of calls.
-     fn __validate__(self: T, calls: Array<Call>) -> starknet::SyscallResult<felt252>;
-     #[unstable(feature: "safe_dispatcher")]
-     /// An entry point that is called to execute a given set of calls.
-     /// This entry point should block the deprecated v0 invoke transactions as they do not go
-     /// through the `__validate__` entry point.
-     fn __execute__(self: T, calls: Array<Call>) -> starknet::SyscallResult<Array<Span<felt252>>>;
- }
- 
- #[derive(Copy, Drop, Serde)]
- pub struct AccountContractSafeLibraryDispatcher {
-     pub class_hash: starknet::ClassHash,
- }
- 
- impl AccountContractSafeLibraryDispatcherImpl of AccountContractSafeDispatcherTrait<
-     AccountContractSafeLibraryDispatcher,
- > {
-     /// An entry point that is called to check if the account is willing to pay for the declaration
-     /// of the class with the given hash.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the declaration.
-     fn __validate_declare__(
-         self: AccountContractSafeLibraryDispatcher, class_hash: felt252,
-     ) -> starknet::SyscallResult<felt252> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<felt252>::serialize(@class_hash, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
-             self.class_hash,
-             0x289da278a8dc833409cabfdad1581e8e7d40e42dcaed693fa4008dcdb4963b3,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
-         Result::Ok(
-             core::option::OptionTrait::expect(
-                 core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-                 'Returned data too short',
-             ),
-         )
-     }
- 
-     /// An entry point that is called to check if the account is willing to pay for
-     /// executing a given set of calls.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the execution, in which case `__execute__` will be called on the same set of calls.
-     fn __validate__(
-         self: AccountContractSafeLibraryDispatcher, calls: Array<Call>,
-     ) -> starknet::SyscallResult<felt252> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
-             self.class_hash,
-             0x162da33a4585851fe8d3af3c2a9c60b557814e221e0d4f30ff0b2189d9c7775,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
-         Result::Ok(
-             core::option::OptionTrait::expect(
-                 core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-                 'Returned data too short',
-             ),
-         )
-     }
- 
-     /// An entry point that is called to execute a given set of calls.
-     /// This entry point should block the deprecated v0 invoke transactions as they do not go
-     /// through the `__validate__` entry point.
-     fn __execute__(
-         self: AccountContractSafeLibraryDispatcher, calls: Array<Call>,
-     ) -> starknet::SyscallResult<Array<Span<felt252>>> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
-             self.class_hash,
-             0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
-         Result::Ok(
-             core::option::OptionTrait::expect(
-                 core::serde::Serde::<
-                     Array<Span<felt252>>,
-                 >::deserialize(ref __dispatcher_return_data__),
-                 'Returned data too short',
-             ),
-         )
-     }
- }
- 
- 
- #[derive(Copy, Drop, Serde)]
- pub struct AccountContractSafeDispatcher {
-     pub contract_address: starknet::ContractAddress,
- }
- 
- impl AccountContractSafeDispatcherImpl of AccountContractSafeDispatcherTrait<
-     AccountContractSafeDispatcher,
- > {
-     /// An entry point that is called to check if the account is willing to pay for the declaration
-     /// of the class with the given hash.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the declaration.
-     fn __validate_declare__(
-         self: AccountContractSafeDispatcher, class_hash: felt252,
-     ) -> starknet::SyscallResult<felt252> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<felt252>::serialize(@class_hash, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
-             self.contract_address,
-             0x289da278a8dc833409cabfdad1581e8e7d40e42dcaed693fa4008dcdb4963b3,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
-         Result::Ok(
-             core::option::OptionTrait::expect(
-                 core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-                 'Returned data too short',
-             ),
-         )
-     }
- 
-     /// An entry point that is called to check if the account is willing to pay for
-     /// executing a given set of calls.
-     /// The entry point should return `starknet::VALIDATED` if the account is willing to pay
-     /// for the execution, in which case `__execute__` will be called on the same set of calls.
-     fn __validate__(
-         self: AccountContractSafeDispatcher, calls: Array<Call>,
-     ) -> starknet::SyscallResult<felt252> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
-             self.contract_address,
-             0x162da33a4585851fe8d3af3c2a9c60b557814e221e0d4f30ff0b2189d9c7775,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
-         Result::Ok(
-             core::option::OptionTrait::expect(
-                 core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
-                 'Returned data too short',
-             ),
-         )
-     }
- 
-     /// An entry point that is called to execute a given set of calls.
-     /// This entry point should block the deprecated v0 invoke transactions as they do not go
-     /// through the `__validate__` entry point.
-     fn __execute__(
-         self: AccountContractSafeDispatcher, calls: Array<Call>,
-     ) -> starknet::SyscallResult<Array<Span<felt252>>> {
-         let mut __calldata__ = core::traits::Default::default();
-         core::serde::Serde::<Array<Call>>::serialize(@calls, ref __calldata__);
- 
-         let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
-             self.contract_address,
-             0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad,
-             core::array::ArrayTrait::span(@__calldata__),
-         );
-         let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
-         Result::Ok(
-             core::option::OptionTrait::expect(
-                 core::serde::Serde::<
-                     Array<Span<felt252>>,
-                 >::deserialize(ref __dispatcher_return_data__),
-                 'Returned data too short',
-             ),
-         )
-     }
- }
--- 51,53 ----
diff --color=auto -crN cairo2/corelib_1/src/test/dict_test.cairo cairo2/corelib/src/test/dict_test.cairo
*** cairo2/corelib_1/src/test/dict_test.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/test/dict_test.cairo	Thu Dec 18 12:33:31 2025
***************
*** 177,186 ****
      assert_eq!(dict[0], 2);
  }
  
! #[test]
! fn test_array_from_squash_dict() {
!     let mut dict: Felt252Dict<u32> = (0..5_u32).into_iter().map(|x| (x.into(), x)).collect();
!     assert_eq!(
!         dict.squash().into_entries(), array![(0, 0, 0), (1, 0, 1), (2, 0, 2), (3, 0, 3), (4, 0, 4)],
!     );
! }
--- 177,186 ----
      assert_eq!(dict[0], 2);
  }
  
! // #[test]
! // fn test_array_from_squash_dict() {
! //     let mut dict: Felt252Dict<u32> = (0..5_u32).into_iter().map(|x| (x.into(), x)).collect();
! //     assert_eq!(
! //         dict.squash().into_entries(), array![(0, 0, 0), (1, 0, 1), (2, 0, 2), (3, 0, 3), (4, 0, 4)],
! //     );
! // }
diff --color=auto -crN cairo2/corelib_1/src/test/gas_reserve_test.cairo cairo2/corelib/src/test/gas_reserve_test.cairo
*** cairo2/corelib_1/src/test/gas_reserve_test.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/test/gas_reserve_test.cairo	Thu Dec 18 12:33:31 2025
***************
*** 1,29 ****
! use core::gas::{GasReserve, gas_reserve_create, gas_reserve_utilize};
  
  // Allow implicitly dropping GasReserve instances.
! impl GasReserveDrop of Drop<GasReserve> {}
  
! #[test]
! fn test_create_and_utilize_gas_reserve() {
!     let gas0 = crate::testing::get_available_gas();
  
!     // Buy and redeposit a GasReserve.
!     let reserve1 = gas_reserve_create(1000).unwrap();
!     let gas1 = crate::testing::get_available_gas();
!     gas_reserve_utilize(reserve1);
!     let gas2 = crate::testing::get_available_gas();
  
!     // Buy the rest of the available gas.
!     let reserve2 = gas_reserve_create(gas2).unwrap();
!     let gas3 = crate::testing::get_available_gas();
  
!     // Try to buy another reserve. This should fail.
!     let reserve3_opt = gas_reserve_create(1);
  
!     gas_reserve_utilize(reserve2);
!     assert!(reserve3_opt.is_none());
  
!     assert_eq!(gas1, gas0 - 1000);
!     assert_eq!(gas2, gas0);
!     assert_eq!(gas3, 0);
! }
--- 1,29 ----
! // use core::gas::{GasReserve, gas_reserve_create, gas_reserve_utilize};
  
  // Allow implicitly dropping GasReserve instances.
! // impl GasReserveDrop of Drop<GasReserve> {}
  
! // #[test]
! // fn test_create_and_utilize_gas_reserve() {
! //     let gas0 = crate::testing::get_available_gas();
  
! //     // Buy and redeposit a GasReserve.
! //     let reserve1 = gas_reserve_create(1000).unwrap();
! //     let gas1 = crate::testing::get_available_gas();
! //     gas_reserve_utilize(reserve1);
! //     let gas2 = crate::testing::get_available_gas();
  
! //     // Buy the rest of the available gas.
! //     let reserve2 = gas_reserve_create(gas2).unwrap();
! //     let gas3 = crate::testing::get_available_gas();
  
! //     // Try to buy another reserve. This should fail.
! //     let reserve3_opt = gas_reserve_create(1);
  
! //     gas_reserve_utilize(reserve2);
! //     assert!(reserve3_opt.is_none());
  
! //     assert_eq!(gas1, gas0 - 1000);
! //     assert_eq!(gas2, gas0);
! //     assert_eq!(gas3, 0);
! // }
diff --color=auto -crN cairo2/corelib_1/src/test/hash_test.cairo cairo2/corelib/src/test/hash_test.cairo
*** cairo2/corelib_1/src/test/hash_test.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/test/hash_test.cairo	Thu Dec 18 12:33:31 2025
***************
*** 1,4 ****
! use crate::blake::{blake2s_compress, blake2s_finalize};
  use crate::hash::{HashStateExTrait, HashStateTrait};
  use crate::poseidon::PoseidonTrait;
  use crate::test::test_utils::assert_eq;
--- 1,4 ----
! // use crate::blake::{blake2s_compress, blake2s_finalize};
  use crate::hash::{HashStateExTrait, HashStateTrait};
  use crate::poseidon::PoseidonTrait;
  use crate::test::test_utils::assert_eq;
***************
*** 88,131 ****
  }
  
  
! #[test]
! fn test_blake2s() {
!     let state = BoxTrait::new([0_u32; 8]);
!     let msg = BoxTrait::new([0_u32; 16]);
!     let byte_count = 64_u32;
!     assert_eq!(
!         blake2s_compress(state, byte_count, msg).unbox(),
!         [
!             0xe816e42a, 0x7d9875d8, 0xfda62c55, 0xa2c6f449, 0xca7af611, 0xdd2f7629, 0xbcd92323,
!             0x15c3ab3b,
!         ],
!     );
!     assert_eq!(
!         blake2s_finalize(state, byte_count, msg).unbox(),
!         [
!             0x7a59305, 0x56b8b489, 0xbe3bb37e, 0x58ec6ba0, 0x2f53d5d3, 0x26cd7988, 0xde14c740,
!             0x3e3f372e,
!         ],
!     );
! }
  
! #[test]
! fn test_blake2s_with_abc() {
!     // hashing `abc` as it is done in RFC 7693 Appendix B.
!     // Initial state is the IV, with keylen 0 and output length 32.
!     let state = BoxTrait::new(
!         [
!             0x6A09E667 ^ (0x01010000 ^ 0x20), 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F,
!             0x9B05688C, 0x1F83D9AB, 0x5BE0CD19,
!         ],
!     );
!     // Message `abc` padded with zeros.
!     let msg = BoxTrait::new(['cba', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
!     assert_eq!(
!         blake2s_finalize(state, 3, msg).unbox(),
!         [
!             0x8c5e8c50, 0xe2147c32, 0xa32ba7e1, 0x2f45eb4e, 0x208b4537, 0x293ad69e, 0x4c9b994d,
!             0x82596786,
!         ],
!     );
! }
--- 88,131 ----
  }
  
  
! // #[test]
! // fn test_blake2s() {
! //     let state = BoxTrait::new([0_u32; 8]);
! //     let msg = BoxTrait::new([0_u32; 16]);
! //     let byte_count = 64_u32;
! //     assert_eq!(
! //         blake2s_compress(state, byte_count, msg).unbox(),
! //         [
! //             0xe816e42a, 0x7d9875d8, 0xfda62c55, 0xa2c6f449, 0xca7af611, 0xdd2f7629, 0xbcd92323,
! //             0x15c3ab3b,
! //         ],
! //     );
! //     assert_eq!(
! //         blake2s_finalize(state, byte_count, msg).unbox(),
! //         [
! //             0x7a59305, 0x56b8b489, 0xbe3bb37e, 0x58ec6ba0, 0x2f53d5d3, 0x26cd7988, 0xde14c740,
! //             0x3e3f372e,
! //         ],
! //     );
! // }
  
! // #[test]
! // fn test_blake2s_with_abc() {
! //     // hashing `abc` as it is done in RFC 7693 Appendix B.
! //     // Initial state is the IV, with keylen 0 and output length 32.
! //     let state = BoxTrait::new(
! //         [
! //             0x6A09E667 ^ (0x01010000 ^ 0x20), 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F,
! //             0x9B05688C, 0x1F83D9AB, 0x5BE0CD19,
! //         ],
! //     );
! //     // Message `abc` padded with zeros.
! //     let msg = BoxTrait::new(['cba', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
! //     assert_eq!(
! //         blake2s_finalize(state, 3, msg).unbox(),
! //         [
! //             0x8c5e8c50, 0xe2147c32, 0xa32ba7e1, 0x2f45eb4e, 0x208b4537, 0x293ad69e, 0x4c9b994d,
! //             0x82596786,
! //         ],
! //     );
! // }
diff --color=auto -crN cairo2/corelib_1/src/test/language_features/box_test.cairo cairo2/corelib/src/test/language_features/box_test.cairo
*** cairo2/corelib_1/src/test/language_features/box_test.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/test/language_features/box_test.cairo	Thu Dec 18 12:33:31 2025
***************
*** 7,18 ****
      local_into_box(value)
  }
  
! #[test]
! fn test_local_into_box() {
!     assert_eq!(into_box((1, 2_u256, 3)).unbox(), (1, 2, 3));
!     assert_eq!(into_box(()).unbox(), ());
!     assert_eq!(into_box(Some(6_u8)).unbox(), Some(6));
!     assert_eq!(into_box(None::<u8>).unbox(), None);
!     assert_eq!(into_box(Ok::<u16, u256>(7)).unbox(), Ok(7));
!     assert_eq!(into_box(Err::<u16, u256>(8)).unbox(), Err(8));
! }
--- 7,18 ----
      local_into_box(value)
  }
  
! // #[test]
! // fn test_local_into_box() {
! //     assert_eq!(into_box((1, 2_u256, 3)).unbox(), (1, 2, 3));
! //     assert_eq!(into_box(()).unbox(), ());
! //     assert_eq!(into_box(Some(6_u8)).unbox(), Some(6));
! //     assert_eq!(into_box(None::<u8>).unbox(), None);
! //     assert_eq!(into_box(Ok::<u16, u256>(7)).unbox(), Ok(7));
! //     assert_eq!(into_box(Err::<u16, u256>(8)).unbox(), Err(8));
! // }
diff --color=auto -crN cairo2/corelib_1/src/test/qm31_test.cairo cairo2/corelib/src/test/qm31_test.cairo
*** cairo2/corelib_1/src/test/qm31_test.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/test/qm31_test.cairo	Thu Dec 18 12:33:31 2025
***************
*** 1,67 ****
! use core::qm31::{QM31Trait, m31, qm31, qm31_const};
  
! #[test]
! fn test_qm31_add_and_sub() {
!     let a = qm31_const::<0x544b2fba, 0x673cff77, 0x60713d44, 0x499602d2>();
!     let b = qm31_const::<0x499602d2, 0x544b2fba, 0x673cff77, 0x60713d44>();
!     let c = qm31_const::<0x1de1328d, 0x3b882f32, 0x47ae3cbc, 0x2a074017>();
!     assert!(a + b == c);
!     assert!(b + a == c);
!     assert!(c - a == b);
!     assert!(c - b == a);
! }
  
! #[test]
! fn test_qm31_mul_and_div() {
!     let a = qm31_const::<0x544b2fba, 0x673cff77, 0x60713d44, 0x499602d2>();
!     let b = qm31_const::<0x4b18de99, 0x55f6fb62, 0x6e2290d9, 0x7cd851b9>();
!     let c = qm31_const::<0x38810ab4, 0x5a0fd30a, 0x2527b81e, 0x4b1ed1cd>();
!     assert!(a * b == c);
!     assert!(b * a == c);
!     assert!(c / a == b);
!     assert!(c / b == a);
! }
  
! #[test]
! fn test_qm31_inverse() {
!     let one = qm31_const::<1, 0, 0, 0>();
!     let a = qm31_const::<0x4b18de99, 0x55f6fb62, 0x6e2290d9, 0x7cd851b9>();
!     assert!((one / a) * a == one);
!     let a = qm31_const::<1, 2, 3, 4>();
!     assert!((one / a) * a == one);
!     let a = qm31_const::<0x6849959f, 0x31bf5a51, 0x730c2120, 0x7b0430a5>();
!     assert!((one / a) * a == one);
! }
  
! #[test]
! fn test_pack() {
!     assert!(QM31Trait::new(1, 2, 3, 4) == qm31_const::<1, 2, 3, 4>());
!     assert!(QM31Trait::new(2, 3, 4, 1) == qm31_const::<2, 3, 4, 1>());
!     assert!(QM31Trait::new(3, 4, 1, 2) == qm31_const::<3, 4, 1, 2>());
!     assert!(QM31Trait::new(4, 1, 2, 3) == qm31_const::<4, 1, 2, 3>());
! }
  
! #[test]
! fn test_unpack() {
!     assert_eq!(qm31_const::<1, 2, 3, 4>().unpack(), [1, 2, 3, 4]);
!     assert_eq!(qm31_const::<2, 3, 4, 1>().unpack(), [2, 3, 4, 1]);
!     assert_eq!(qm31_const::<3, 4, 1, 2>().unpack(), [3, 4, 1, 2]);
!     assert_eq!(qm31_const::<4, 1, 2, 3>().unpack(), [4, 1, 2, 3]);
! }
  
! #[test]
! fn test_m31_into_qm31() {
!     assert_eq!(Into::<m31, qm31>::into(1).unpack(), [1, 0, 0, 0]);
!     assert_eq!(Into::<m31, qm31>::into(2).unpack(), [2, 0, 0, 0]);
!     assert_eq!(Into::<m31, qm31>::into(3).unpack(), [3, 0, 0, 0]);
!     assert_eq!(Into::<m31, qm31>::into(4).unpack(), [4, 0, 0, 0]);
! }
! use core::qm31::m31_ops;
  
! #[test]
! fn test_m31_ops() {
!     assert_eq!(m31_ops::add(0x544b2fba, 0x4b18de99), 0x1f640e54);
!     assert_eq!(m31_ops::sub(0x4b18de99, 0x544b2fba), 0x76cdaede);
!     assert_eq!(m31_ops::mul(0x544b2fba, 0x4b18de99), 0x3d3740d1);
!     assert_eq!(m31_ops::div(0x544b2fba, 0x4b18de99), 0x4b887296);
! }
--- 1,67 ----
! // use core::qm31::{QM31Trait, m31, qm31, qm31_const};
  
! // #[test]
! // fn test_qm31_add_and_sub() {
! //     let a = qm31_const::<0x544b2fba, 0x673cff77, 0x60713d44, 0x499602d2>();
! //     let b = qm31_const::<0x499602d2, 0x544b2fba, 0x673cff77, 0x60713d44>();
! //     let c = qm31_const::<0x1de1328d, 0x3b882f32, 0x47ae3cbc, 0x2a074017>();
! //     assert!(a + b == c);
! //     assert!(b + a == c);
! //     assert!(c - a == b);
! //     assert!(c - b == a);
! // }
  
! // #[test]
! // fn test_qm31_mul_and_div() {
! //     let a = qm31_const::<0x544b2fba, 0x673cff77, 0x60713d44, 0x499602d2>();
! //     let b = qm31_const::<0x4b18de99, 0x55f6fb62, 0x6e2290d9, 0x7cd851b9>();
! //     let c = qm31_const::<0x38810ab4, 0x5a0fd30a, 0x2527b81e, 0x4b1ed1cd>();
! //     assert!(a * b == c);
! //     assert!(b * a == c);
! //     assert!(c / a == b);
! //     assert!(c / b == a);
! // }
  
! // #[test]
! // fn test_qm31_inverse() {
! //     let one = qm31_const::<1, 0, 0, 0>();
! //     let a = qm31_const::<0x4b18de99, 0x55f6fb62, 0x6e2290d9, 0x7cd851b9>();
! //     assert!((one / a) * a == one);
! //     let a = qm31_const::<1, 2, 3, 4>();
! //     assert!((one / a) * a == one);
! //     let a = qm31_const::<0x6849959f, 0x31bf5a51, 0x730c2120, 0x7b0430a5>();
! //     assert!((one / a) * a == one);
! // }
  
! // #[test]
! // fn test_pack() {
! //     assert!(QM31Trait::new(1, 2, 3, 4) == qm31_const::<1, 2, 3, 4>());
! //     assert!(QM31Trait::new(2, 3, 4, 1) == qm31_const::<2, 3, 4, 1>());
! //     assert!(QM31Trait::new(3, 4, 1, 2) == qm31_const::<3, 4, 1, 2>());
! //     assert!(QM31Trait::new(4, 1, 2, 3) == qm31_const::<4, 1, 2, 3>());
! // }
  
! // #[test]
! // fn test_unpack() {
! //     assert_eq!(qm31_const::<1, 2, 3, 4>().unpack(), [1, 2, 3, 4]);
! //     assert_eq!(qm31_const::<2, 3, 4, 1>().unpack(), [2, 3, 4, 1]);
! //     assert_eq!(qm31_const::<3, 4, 1, 2>().unpack(), [3, 4, 1, 2]);
! //     assert_eq!(qm31_const::<4, 1, 2, 3>().unpack(), [4, 1, 2, 3]);
! // }
  
! // #[test]
! // fn test_m31_into_qm31() {
! //     assert_eq!(Into::<m31, qm31>::into(1).unpack(), [1, 0, 0, 0]);
! //     assert_eq!(Into::<m31, qm31>::into(2).unpack(), [2, 0, 0, 0]);
! //     assert_eq!(Into::<m31, qm31>::into(3).unpack(), [3, 0, 0, 0]);
! //     assert_eq!(Into::<m31, qm31>::into(4).unpack(), [4, 0, 0, 0]);
! // }
! // use core::qm31::m31_ops;
  
! // #[test]
! // fn test_m31_ops() {
! //     assert_eq!(m31_ops::add(0x544b2fba, 0x4b18de99), 0x1f640e54);
! //     assert_eq!(m31_ops::sub(0x4b18de99, 0x544b2fba), 0x76cdaede);
! //     assert_eq!(m31_ops::mul(0x544b2fba, 0x4b18de99), 0x3d3740d1);
! //     assert_eq!(m31_ops::div(0x544b2fba, 0x4b18de99), 0x4b887296);
! // }
diff --color=auto -crN cairo2/corelib_1/src/test/testing_test.cairo cairo2/corelib/src/test/testing_test.cairo
*** cairo2/corelib_1/src/test/testing_test.cairo	Sun Dec 14 15:13:21 2025
--- cairo2/corelib/src/test/testing_test.cairo	Thu Dec 18 12:33:31 2025
***************
*** 135,152 ****
      t
  }
  
! #[test]
! fn test_get_unspent_gas() {
!     let one = identity(1);
!     let two = identity(2);
!     let prev = crate::testing::get_unspent_gas();
!     let _three = identity(one + two);
!     let after = crate::testing::get_unspent_gas();
!     let expected_cost = 100 // `one + two`.
!         + 300 // `identity(...)`.
!         + 2300; // `get_unspent_gas()`.
!     assert_eq!(prev - after, expected_cost);
! }
  
  #[derive(Drop, Debug, PartialEq)]
  struct NoCopy {
--- 135,152 ----
      t
  }
  
! // #[test]
! // fn test_get_unspent_gas() {
! //     let one = identity(1);
! //     let two = identity(2);
! //     let prev = crate::testing::get_unspent_gas();
! //     let _three = identity(one + two);
! //     let after = crate::testing::get_unspent_gas();
! //     let expected_cost = 100 // `one + two`.
! //         + 300 // `identity(...)`.
! //         + 2300; // `get_unspent_gas()`.
! //     assert_eq!(prev - after, expected_cost);
! // }
  
  #[derive(Drop, Debug, PartialEq)]
  struct NoCopy {
