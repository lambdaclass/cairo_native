; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128-Fn32"
target triple = "arm64-apple-darwin24.6.0"

@assert_msg_170 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_169 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_168 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_167 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_166 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_165 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_164 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_163 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_162 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_161 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_160 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_159 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_158 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_157 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_156 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_155 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_154 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_153 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_152 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_151 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_150 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_149 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_148 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_147 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_146 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_145 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_144 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_143 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_142 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_141 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_140 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_139 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_138 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_137 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_136 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_135 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_134 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_133 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_132 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_131 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_130 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_129 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_128 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_127 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_126 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_125 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_124 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_123 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_122 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_121 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_120 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_119 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_118 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_117 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_116 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_115 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_114 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_113 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_112 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_111 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_110 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_109 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_108 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_107 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_106 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_105 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_104 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_103 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_102 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_101 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_100 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_99 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_98 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_97 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_96 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_95 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_94 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_93 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_92 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_91 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_90 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_89 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_88 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_87 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_86 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_85 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_84 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_83 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_82 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_81 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_80 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_79 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_78 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_77 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_76 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_75 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_74 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_73 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_72 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_71 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_70 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_69 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_68 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_67 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_66 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_65 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_64 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_63 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_62 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_61 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_60 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_59 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_58 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_57 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_56 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_55 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_54 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_53 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_52 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_51 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_50 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_49 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_48 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_47 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_46 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_45 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_44 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_43 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_42 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_41 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_40 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_39 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_38 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_37 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_36 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_35 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_34 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_33 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_32 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_31 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_30 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_29 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_28 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_27 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_26 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_25 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_24 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_23 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_22 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_21 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_20 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_19 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_18 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_17 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_16 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_15 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_14 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_13 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_12 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_11 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_10 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_9 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_8 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_7 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_6 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_5 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_4 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_3 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_2 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_1 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_0 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg = private constant [18 x i8] c"Invalid enum tag.\00"
@cairo_native__get_costs_builtin = weak global ptr undef
@cairo_native__libfunc__pedersen = weak global ptr undef
@cairo_native__libfunc__hades_permutation = weak global ptr undef

declare void @abort()

declare void @puts(ptr)

declare ptr @realloc(ptr, i64)

declare void @free(ptr)

define private void @"drop$26"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$27"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$26"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$27"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$28"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$27"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$27"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$404"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$404"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { {}, { ptr, i32, i32, i32 } } %0, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { {}, { ptr, i32, i32, i32 } } %0, 0
  %3 = insertvalue { {}, { ptr, i32, i32, i32 } } %0, {} %2, 0
  %4 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %2, 0
  %5 = extractvalue { {}, { ptr, i32, i32, i32 } } %0, 1
  %6 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %5)
  %7 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 1
  %9 = insertvalue { {}, { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %7, 1
  %10 = insertvalue { {}, { ptr, i32, i32, i32 } } %4, { ptr, i32, i32, i32 } %8, 1
  %11 = insertvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %9, 0
  %12 = insertvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %11, { {}, { ptr, i32, i32, i32 } } %10, 1
  ret { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %12
}

define private void @"drop$408"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, 1
  call void @"drop$404"({ { { ptr, i32, i32, i32 } } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$408"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$404"({ { { ptr, i32, i32, i32 } } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, { { { ptr, i32, i32, i32 } } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, { { { ptr, i32, i32, i32 } } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$409"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$409"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$405"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$405"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i32, i32, i32, i32 } } }, ptr %2, align 4
  %6 = extractvalue { i1, { { i32, i32, i32, i32 } } } %5, 1
  %7 = insertvalue { i1, { { i32, i32, i32, i32 } } } %5, { { i32, i32, i32, i32 } } %6, 1
  store { i1, { { i32, i32, i32, i32 } } } %7, ptr %2, align 4
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { i32, i32, i32, i32 } } } %5, { { i32, i32, i32, i32 } } %6, 1
  store { i1, { { i32, i32, i32, i32 } } } %9, ptr %2, align 4
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f0"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = add i64 %1, 1
  %16 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %17 = call ptr %16()
  %18 = icmp uge i64 %4, 0
  %19 = call i64 @llvm.usub.sat.i64(i64 %4, i64 0)
  br i1 %18, label %20, label %291

20:                                               ; preds = %7
  %21 = phi { { ptr, i32, i32, i32 } } [ %6, %7 ]
  %22 = extractvalue { { ptr, i32, i32, i32 } } %21, 0
  %23 = extractvalue { ptr, i32, i32, i32 } %22, 1
  %24 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %25 = sub i32 %24, %23
  %26 = icmp uge i32 %25, 1
  br i1 %26, label %27, label %266

27:                                               ; preds = %20
  %28 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %29 = load ptr, ptr %28, align 8
  %30 = zext i32 %23 to i64
  %31 = mul i64 %30, 32
  %32 = getelementptr inbounds i8, ptr %29, i64 %31
  %33 = add i32 %23, 1
  %34 = insertvalue { ptr, i32, i32, i32 } %22, i32 %33, 1
  %35 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %35, ptr %32, i64 32, i1 false)
  %36 = load i252, ptr %35, align 16
  call void @free(ptr %35)
  %37 = add i64 %1, 4
  %38 = icmp ult i252 %36, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %38, label %39, label %259

39:                                               ; preds = %27
  %40 = phi { ptr, i32, i32, i32 } [ %34, %27 ]
  %41 = extractvalue { ptr, i32, i32, i32 } %40, 1
  %42 = extractvalue { ptr, i32, i32, i32 } %40, 2
  %43 = sub i32 %42, %41
  %44 = icmp uge i32 %43, 1
  br i1 %44, label %45, label %234

45:                                               ; preds = %39
  %46 = extractvalue { ptr, i32, i32, i32 } %40, 0
  %47 = load ptr, ptr %46, align 8
  %48 = zext i32 %41 to i64
  %49 = mul i64 %48, 32
  %50 = getelementptr inbounds i8, ptr %47, i64 %49
  %51 = add i32 %41, 1
  %52 = insertvalue { ptr, i32, i32, i32 } %40, i32 %51, 1
  %53 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %53, ptr %50, i64 32, i1 false)
  %54 = load i252, ptr %53, align 16
  call void @free(ptr %53)
  %55 = trunc i252 %54 to i128
  %56 = lshr i252 %54, 128
  %57 = trunc i252 %56 to i128
  %58 = icmp ne i128 %57, 0
  %59 = add i64 %1, 7
  %60 = add i64 %1, 5
  %61 = select i1 %58, i64 %59, i64 %60
  br i1 %58, label %227, label %62

62:                                               ; preds = %45
  %63 = phi { ptr, i32, i32, i32 } [ %52, %45 ]
  %64 = extractvalue { ptr, i32, i32, i32 } %63, 1
  %65 = extractvalue { ptr, i32, i32, i32 } %63, 2
  %66 = sub i32 %65, %64
  %67 = icmp uge i32 %66, 1
  br i1 %67, label %68, label %220

68:                                               ; preds = %62
  %69 = extractvalue { ptr, i32, i32, i32 } %63, 0
  %70 = load ptr, ptr %69, align 8
  %71 = zext i32 %64 to i64
  %72 = mul i64 %71, 32
  %73 = getelementptr inbounds i8, ptr %70, i64 %72
  %74 = add i32 %64, 1
  %75 = insertvalue { ptr, i32, i32, i32 } %63, i32 %74, 1
  %76 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %76, ptr %73, i64 32, i1 false)
  %77 = load i252, ptr %76, align 16
  call void @free(ptr %76)
  %78 = trunc i252 %77 to i128
  %79 = lshr i252 %77, 128
  %80 = trunc i252 %79 to i128
  %81 = icmp ne i128 %80, 0
  %82 = add i64 %61, 3
  %83 = add i64 %61, 1
  %84 = select i1 %81, i64 %82, i64 %83
  br i1 %81, label %213, label %85

85:                                               ; preds = %68
  %86 = phi { ptr, i32, i32, i32 } [ %75, %68 ]
  %87 = extractvalue { ptr, i32, i32, i32 } %86, 1
  %88 = extractvalue { ptr, i32, i32, i32 } %86, 2
  %89 = sub i32 %88, %87
  %90 = icmp uge i32 %89, 1
  br i1 %90, label %91, label %111

91:                                               ; preds = %85
  %92 = extractvalue { ptr, i32, i32, i32 } %86, 0
  %93 = load ptr, ptr %92, align 8
  %94 = zext i32 %87 to i64
  %95 = mul i64 %94, 32
  %96 = getelementptr inbounds i8, ptr %93, i64 %95
  %97 = add i32 %87, 1
  %98 = insertvalue { ptr, i32, i32, i32 } %86, i32 %97, 1
  %99 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %99, ptr %96, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %98)
  call void @"drop$409"(ptr %99)
  %100 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %101 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %100, 0
  %102 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %101, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %102, ptr %14, align 8
  %103 = load { i64, [24 x i8] }, ptr %14, align 8
  %104 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %105 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %104, i64 %84, 1
  %106 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %105, i64 %2, 2
  %107 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %106, i64 %3, 3
  %108 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %107, i64 %19, 4
  %109 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %108, ptr %5, 5
  %110 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %109, { i64, [24 x i8] } %103, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %110

111:                                              ; preds = %85
  %112 = phi { ptr, i32, i32, i32 } [ %86, %85 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %112)
  %113 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %114 = call ptr %113()
  %115 = add i64 %84, 1
  %116 = getelementptr inbounds i64, ptr %114, i32 1
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 2
  %119 = getelementptr inbounds i64, ptr %114, i32 2
  %120 = load i64, ptr %119, align 8
  %121 = mul i64 %120, 4
  %122 = add i64 %118, %121
  %123 = load i64, ptr %114, align 8
  %124 = mul i64 %123, 54780
  %125 = add i64 %122, %124
  %126 = icmp uge i64 %19, %125
  %127 = call i64 @llvm.usub.sat.i64(i64 %19, i64 %125)
  br i1 %126, label %128, label %206

128:                                              ; preds = %111
  %129 = phi i128 [ %55, %111 ]
  %130 = phi i128 [ %78, %111 ]
  %131 = insertvalue { i128, i128 } undef, i128 %129, 0
  %132 = insertvalue { i128, i128 } %131, i128 %130, 1
  %133 = call fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f13"(i64 %115, i64 %127, i64 %2, i64 %0, i64 %3, ptr %5, { {} } undef, i252 %36, { i128, i128 } %132)
  %134 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 0
  %135 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 1
  %136 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 2
  %137 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 3
  %138 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 4
  %139 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 5
  %140 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, 6
  store { i64, [24 x i8] } %140, ptr %11, align 8
  %141 = load i1, ptr %11, align 1
  switch i1 %141, label %142 [
    i1 false, label %144
    i1 true, label %194
  ]

142:                                              ; preds = %128
  br i1 false, label %143, label %316

143:                                              ; preds = %142
  unreachable

144:                                              ; preds = %128
  %145 = load { i1, { { i32, i32, i32, i32 } } }, ptr %11, align 4
  %146 = extractvalue { i1, { { i32, i32, i32, i32 } } } %145, 1
  %147 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %148 = call ptr %147()
  %149 = call i64 @llvm.uadd.sat.i64(i64 %135, i64 0)
  %150 = extractvalue { { i32, i32, i32, i32 } } %146, 0
  %151 = extractvalue { i32, i32, i32, i32 } %150, 0
  %152 = zext i32 %151 to i252
  %153 = extractvalue { i32, i32, i32, i32 } %150, 1
  %154 = zext i32 %153 to i252
  %155 = extractvalue { i32, i32, i32, i32 } %150, 2
  %156 = zext i32 %155 to i252
  %157 = extractvalue { i32, i32, i32, i32 } %150, 3
  %158 = zext i32 %157 to i252
  %159 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %159, align 4
  %160 = getelementptr inbounds i8, ptr %159, i32 4
  store i32 0, ptr %160, align 4
  %161 = getelementptr inbounds i8, ptr %159, i32 16
  %162 = call ptr @realloc(ptr null, i64 8)
  store ptr %161, ptr %162, align 8
  %163 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %162, 0
  %164 = insertvalue { ptr, i32, i32, i32 } %163, i32 8, 3
  %165 = load ptr, ptr %162, align 8
  store i252 %152, ptr %165, align 16
  %166 = insertvalue { ptr, i32, i32, i32 } %164, i32 1, 2
  %167 = getelementptr inbounds i8, ptr %165, i32 -12
  store i32 1, ptr %167, align 4
  %168 = load ptr, ptr %162, align 8
  %169 = getelementptr inbounds i8, ptr %168, i32 32
  store i252 %154, ptr %169, align 16
  %170 = insertvalue { ptr, i32, i32, i32 } %166, i32 2, 2
  %171 = getelementptr inbounds i8, ptr %168, i32 -12
  store i32 2, ptr %171, align 4
  %172 = load ptr, ptr %162, align 8
  %173 = getelementptr inbounds i8, ptr %172, i32 64
  store i252 %156, ptr %173, align 16
  %174 = insertvalue { ptr, i32, i32, i32 } %170, i32 3, 2
  %175 = getelementptr inbounds i8, ptr %172, i32 -12
  store i32 3, ptr %175, align 4
  %176 = load ptr, ptr %162, align 8
  %177 = getelementptr inbounds i8, ptr %176, i32 96
  store i252 %158, ptr %177, align 16
  %178 = insertvalue { ptr, i32, i32, i32 } %174, i32 4, 2
  %179 = getelementptr inbounds i8, ptr %176, i32 -12
  store i32 4, ptr %179, align 4
  %180 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %178)
  %181 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %180, 0
  %182 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %180, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %181)
  %183 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %182, 0
  %184 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %183, 0
  %185 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %184, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %185, ptr %13, align 8
  %186 = load { i64, [24 x i8] }, ptr %13, align 8
  %187 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %137, 0
  %188 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %187, i64 %134, 1
  %189 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %188, i64 %136, 2
  %190 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %189, i64 %138, 3
  %191 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %190, i64 %149, 4
  %192 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %191, ptr %139, 5
  %193 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %192, { i64, [24 x i8] } %186, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %193

194:                                              ; preds = %128
  %195 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %196 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %195, 1
  %197 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %196, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %197, ptr %12, align 8
  %198 = load { i64, [24 x i8] }, ptr %12, align 8
  %199 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %137, 0
  %200 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %199, i64 %134, 1
  %201 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %200, i64 %136, 2
  %202 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %201, i64 %138, 3
  %203 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %202, i64 %135, 4
  %204 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %203, ptr %139, 5
  %205 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %204, { i64, [24 x i8] } %198, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %205

206:                                              ; preds = %111
  %207 = phi i64 [ %19, %111 ]
  %208 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %209 = call ptr %208()
  %210 = load i64, ptr %209, align 8
  %211 = mul i64 %210, 2710
  %212 = call i64 @llvm.uadd.sat.i64(i64 %207, i64 %211)
  br label %298

213:                                              ; preds = %68
  %214 = phi { ptr, i32, i32, i32 } [ %75, %68 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %214)
  %215 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %216 = call ptr %215()
  %217 = load i64, ptr %216, align 8
  %218 = mul i64 %217, 3740
  %219 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %218)
  br label %241

220:                                              ; preds = %62
  %221 = phi { ptr, i32, i32, i32 } [ %63, %62 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %221)
  %222 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %223 = call ptr %222()
  %224 = load i64, ptr %223, align 8
  %225 = mul i64 %224, 5050
  %226 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %225)
  br label %241

227:                                              ; preds = %45
  %228 = phi { ptr, i32, i32, i32 } [ %52, %45 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %228)
  %229 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %230 = call ptr %229()
  %231 = load i64, ptr %230, align 8
  %232 = mul i64 %231, 4510
  %233 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %232)
  br label %241

234:                                              ; preds = %39
  %235 = phi { ptr, i32, i32, i32 } [ %40, %39 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %235)
  %236 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %237 = call ptr %236()
  %238 = load i64, ptr %237, align 8
  %239 = mul i64 %238, 5920
  %240 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %239)
  br label %241

241:                                              ; preds = %227, %213, %220, %234
  %242 = phi i64 [ %0, %234 ], [ %0, %227 ], [ %0, %220 ], [ %0, %213 ]
  %243 = phi i64 [ %2, %234 ], [ %2, %227 ], [ %2, %220 ], [ %2, %213 ]
  %244 = phi i64 [ %3, %234 ], [ %3, %227 ], [ %3, %220 ], [ %3, %213 ]
  %245 = phi ptr [ %5, %234 ], [ %5, %227 ], [ %5, %220 ], [ %5, %213 ]
  %246 = phi i64 [ %37, %234 ], [ %61, %227 ], [ %61, %220 ], [ %84, %213 ]
  %247 = phi i64 [ %240, %234 ], [ %233, %227 ], [ %226, %220 ], [ %219, %213 ]
  %248 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %249 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %248, 0
  %250 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %249, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %250, ptr %10, align 8
  %251 = load { i64, [24 x i8] }, ptr %10, align 8
  %252 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %242, 0
  %253 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %252, i64 %246, 1
  %254 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %253, i64 %243, 2
  %255 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %254, i64 %244, 3
  %256 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %255, i64 %247, 4
  %257 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %256, ptr %245, 5
  %258 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %257, { i64, [24 x i8] } %251, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %258

259:                                              ; preds = %27
  %260 = phi { ptr, i32, i32, i32 } [ %34, %27 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %260)
  %261 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %262 = call ptr %261()
  %263 = load i64, ptr %262, align 8
  %264 = mul i64 %263, 6120
  %265 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %264)
  br label %273

266:                                              ; preds = %20
  %267 = phi { ptr, i32, i32, i32 } [ %22, %20 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %267)
  %268 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %269 = call ptr %268()
  %270 = load i64, ptr %269, align 8
  %271 = mul i64 %270, 7330
  %272 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %271)
  br label %273

273:                                              ; preds = %259, %266
  %274 = phi i64 [ %0, %266 ], [ %0, %259 ]
  %275 = phi i64 [ %2, %266 ], [ %2, %259 ]
  %276 = phi i64 [ %3, %266 ], [ %3, %259 ]
  %277 = phi ptr [ %5, %266 ], [ %5, %259 ]
  %278 = phi i64 [ %15, %266 ], [ %37, %259 ]
  %279 = phi i64 [ %272, %266 ], [ %265, %259 ]
  %280 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %281 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %280, 0
  %282 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %281, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %282, ptr %9, align 8
  %283 = load { i64, [24 x i8] }, ptr %9, align 8
  %284 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %274, 0
  %285 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %284, i64 %278, 1
  %286 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %285, i64 %275, 2
  %287 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %286, i64 %276, 3
  %288 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %287, i64 %279, 4
  %289 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %288, ptr %277, 5
  %290 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %289, { i64, [24 x i8] } %283, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %290

291:                                              ; preds = %7
  %292 = phi { { ptr, i32, i32, i32 } } [ %6, %7 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %292)
  %293 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %294 = call ptr %293()
  %295 = load i64, ptr %294, align 8
  %296 = mul i64 %295, 7530
  %297 = call i64 @llvm.uadd.sat.i64(i64 %4, i64 %296)
  br label %298

298:                                              ; preds = %206, %291
  %299 = phi i64 [ %0, %291 ], [ %0, %206 ]
  %300 = phi i64 [ %2, %291 ], [ %2, %206 ]
  %301 = phi i64 [ %3, %291 ], [ %3, %206 ]
  %302 = phi ptr [ %5, %291 ], [ %5, %206 ]
  %303 = phi i64 [ %15, %291 ], [ %115, %206 ]
  %304 = phi i64 [ %297, %291 ], [ %212, %206 ]
  %305 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %306 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %305, 0
  %307 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %306, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %307, ptr %8, align 8
  %308 = load { i64, [24 x i8] }, ptr %8, align 8
  %309 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %299, 0
  %310 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %309, i64 %303, 1
  %311 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %310, i64 %300, 2
  %312 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %311, i64 %301, 3
  %313 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %312, i64 %304, 4
  %314 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %313, ptr %302, 5
  %315 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %314, { i64, [24 x i8] } %308, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %315

316:                                              ; preds = %142
  call void @puts(ptr @assert_msg)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f0(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f0"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  %9 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 5
  %15 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 6
  %16 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %9, 0
  %17 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %10, 1
  %18 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %11, 2
  %19 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %12, 3
  %20 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, i64 %13, 4
  %21 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, ptr %14, 5
  %22 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21, { i64, [24 x i8] } %15, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %22
}

define void @_mlir_ciface_f0(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { { ptr, i32, i32, i32 } } %7) {
  %9 = call { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f0(i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { { ptr, i32, i32, i32 } } %7)
  store { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, ptr %0, align 8
  ret void
}

define private void @"drop$212"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -4
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 24
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { ptr, i32, i32, i32 }, ptr %22, align 8
  call void @"drop$26"({ ptr, i32, i32, i32 } %23)
  %24 = add i64 %19, 24
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$394"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$394"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$395"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$394"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$395"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$394"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$396"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$395"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$396"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$395"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$392"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$26"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$392"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$393"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %5, 1
  call void @"drop$392"({ { ptr, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$393"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$392"({ { ptr, i32, i32, i32 } } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %8, 1
  store { i1, { { ptr, i32, i32, i32 } } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %9, 1
  store { i1, { { ptr, i32, i32, i32 } } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$159"({ { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$26"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } @"dup$159"({ { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 }, {} } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = insertvalue { { ptr, i32, i32, i32 }, {} } %6, {} %8, 1
  %10 = insertvalue { { ptr, i32, i32, i32 }, {} } %7, {} %8, 1
  %11 = insertvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } undef, { { ptr, i32, i32, i32 }, {} } %9, 0
  %12 = insertvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %11, { { ptr, i32, i32, i32 }, {} } %10, 1
  ret { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %12
}

define private void @"drop$391"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$159"({ { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$391"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } @"dup$159"({ { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, { { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, { { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f1"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = add i64 %1, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 490
  %25 = icmp uge i64 %3, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %3, i64 %24)
  br i1 %25, label %27, label %370

27:                                               ; preds = %6
  %28 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %347

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 32
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %42, ptr %39, i64 32, i1 false)
  %43 = load i252, ptr %42, align 16
  call void @free(ptr %42)
  %44 = add i64 %1, 4
  %45 = icmp ult i252 %43, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %45, label %46, label %340

46:                                               ; preds = %34
  %47 = phi { ptr, i32, i32, i32 } [ %41, %34 ]
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %52, label %317

52:                                               ; preds = %46
  %53 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %54 = load ptr, ptr %53, align 8
  %55 = zext i32 %48 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %54, i64 %56
  %58 = add i32 %48, 1
  %59 = insertvalue { ptr, i32, i32, i32 } %47, i32 %58, 1
  %60 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %60, ptr %57, i64 32, i1 false)
  %61 = load i252, ptr %60, align 16
  call void @free(ptr %60)
  %62 = trunc i252 %61 to i128
  %63 = lshr i252 %61, 128
  %64 = trunc i252 %63 to i128
  %65 = icmp ne i128 %64, 0
  %66 = add i64 %1, 7
  %67 = add i64 %1, 5
  %68 = select i1 %65, i64 %66, i64 %67
  br i1 %65, label %310, label %69

69:                                               ; preds = %52
  %70 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  %71 = extractvalue { ptr, i32, i32, i32 } %70, 1
  %72 = extractvalue { ptr, i32, i32, i32 } %70, 2
  %73 = sub i32 %72, %71
  %74 = icmp uge i32 %73, 1
  br i1 %74, label %75, label %303

75:                                               ; preds = %69
  %76 = extractvalue { ptr, i32, i32, i32 } %70, 0
  %77 = load ptr, ptr %76, align 8
  %78 = zext i32 %71 to i64
  %79 = mul i64 %78, 32
  %80 = getelementptr inbounds i8, ptr %77, i64 %79
  %81 = add i32 %71, 1
  %82 = insertvalue { ptr, i32, i32, i32 } %70, i32 %81, 1
  %83 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %83, ptr %80, i64 32, i1 false)
  %84 = load i252, ptr %83, align 16
  call void @free(ptr %83)
  %85 = trunc i252 %84 to i128
  %86 = lshr i252 %84, 128
  %87 = trunc i252 %86 to i128
  %88 = icmp ne i128 %87, 0
  %89 = add i64 %68, 3
  %90 = add i64 %68, 1
  %91 = select i1 %88, i64 %89, i64 %90
  br i1 %88, label %296, label %92

92:                                               ; preds = %75
  %93 = phi { ptr, i32, i32, i32 } [ %82, %75 ]
  %94 = extractvalue { ptr, i32, i32, i32 } %93, 1
  %95 = extractvalue { ptr, i32, i32, i32 } %93, 2
  %96 = sub i32 %95, %94
  %97 = icmp uge i32 %96, 1
  br i1 %97, label %98, label %273

98:                                               ; preds = %92
  %99 = extractvalue { ptr, i32, i32, i32 } %93, 0
  %100 = load ptr, ptr %99, align 8
  %101 = zext i32 %94 to i64
  %102 = mul i64 %101, 32
  %103 = getelementptr inbounds i8, ptr %100, i64 %102
  %104 = add i32 %94, 1
  %105 = insertvalue { ptr, i32, i32, i32 } %93, i32 %104, 1
  %106 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %103, i64 32, i1 false)
  %107 = load i252, ptr %106, align 16
  call void @free(ptr %106)
  %108 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %105, 0
  %109 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f17"(i64 %91, i64 %26, { { ptr, i32, i32, i32 } } %108, { ptr, i32, i32, i32 } zeroinitializer, i252 %107)
  %110 = extractvalue { i64, i64, { i64, [56 x i8] } } %109, 0
  %111 = extractvalue { i64, i64, { i64, [56 x i8] } } %109, 1
  %112 = extractvalue { i64, i64, { i64, [56 x i8] } } %109, 2
  store { i64, [56 x i8] } %112, ptr %11, align 8
  %113 = load i1, ptr %11, align 1
  switch i1 %113, label %114 [
    i1 false, label %116
    i1 true, label %122
  ]

114:                                              ; preds = %98
  br i1 false, label %115, label %393

115:                                              ; preds = %114
  unreachable

116:                                              ; preds = %98
  %117 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %11, align 8
  %118 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %117, 1
  %119 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %118, 0
  %120 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %118, 1
  store { i64, [24 x i8] } %120, ptr %13, align 8
  %121 = load i1, ptr %13, align 1
  switch i1 %121, label %133 [
    i1 false, label %135
    i1 true, label %143
  ]

122:                                              ; preds = %98
  %123 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %124 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %123, 1
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %12, align 8
  %126 = load { i64, [24 x i8] }, ptr %12, align 8
  %127 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %128 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %110, 1
  %129 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %2, 2
  %130 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %111, 3
  %131 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, ptr %4, 4
  %132 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %131, { i64, [24 x i8] } %126, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %132

133:                                              ; preds = %116
  br i1 false, label %134, label %394

134:                                              ; preds = %133
  unreachable

135:                                              ; preds = %116
  %136 = load { i1, { ptr, i32, i32, i32 } }, ptr %13, align 8
  %137 = extractvalue { i1, { ptr, i32, i32, i32 } } %136, 1
  %138 = extractvalue { { ptr, i32, i32, i32 } } %119, 0
  %139 = extractvalue { ptr, i32, i32, i32 } %138, 1
  %140 = extractvalue { ptr, i32, i32, i32 } %138, 2
  %141 = sub i32 %140, %139
  %142 = icmp uge i32 %141, 1
  br i1 %142, label %149, label %168

143:                                              ; preds = %116
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %119)
  %144 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %145 = call ptr %144()
  %146 = load i64, ptr %145, align 8
  %147 = mul i64 %146, 1470
  %148 = call i64 @llvm.uadd.sat.i64(i64 %111, i64 %147)
  br label %280

149:                                              ; preds = %135
  %150 = extractvalue { ptr, i32, i32, i32 } %138, 0
  %151 = load ptr, ptr %150, align 8
  %152 = zext i32 %139 to i64
  %153 = mul i64 %152, 32
  %154 = getelementptr inbounds i8, ptr %151, i64 %153
  %155 = add i32 %139, 1
  %156 = insertvalue { ptr, i32, i32, i32 } %138, i32 %155, 1
  %157 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %157, ptr %154, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %156)
  call void @"drop$409"(ptr %157)
  call void @"drop$212"({ ptr, i32, i32, i32 } %137)
  %158 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %159 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %158, 0
  %160 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %159, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %160, ptr %19, align 8
  %161 = load { i64, [24 x i8] }, ptr %19, align 8
  %162 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %163 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %162, i64 %110, 1
  %164 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %163, i64 %2, 2
  %165 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %164, i64 %111, 3
  %166 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %165, ptr %4, 4
  %167 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %166, { i64, [24 x i8] } %161, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %167

168:                                              ; preds = %135
  %169 = phi { ptr, i32, i32, i32 } [ %138, %135 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %169)
  %170 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %171 = call ptr %170()
  %172 = add i64 %110, 1
  %173 = getelementptr inbounds i64, ptr %171, i32 1
  %174 = load i64, ptr %173, align 8
  %175 = load i64, ptr %171, align 8
  %176 = mul i64 %175, 46780
  %177 = add i64 %174, %176
  %178 = icmp uge i64 %111, %177
  %179 = call i64 @llvm.usub.sat.i64(i64 %111, i64 %177)
  br i1 %178, label %180, label %268

180:                                              ; preds = %168
  %181 = phi i128 [ %62, %168 ]
  %182 = phi i128 [ %85, %168 ]
  %183 = insertvalue { i128, i128 } undef, i128 %181, 0
  %184 = insertvalue { i128, i128 } %183, i128 %182, 1
  %185 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f18"(i64 %172, i64 %179, i64 %0, i64 %2, ptr %4, { {} } undef, i252 %43, { i128, i128 } %184, { ptr, i32, i32, i32 } %137)
  %186 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %185, 0
  %187 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %185, 1
  %188 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %185, 2
  %189 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %185, 3
  %190 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %185, 4
  %191 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %185, 5
  store { i64, [24 x i8] } %191, ptr %14, align 8
  %192 = load i1, ptr %14, align 1
  switch i1 %192, label %193 [
    i1 false, label %195
    i1 true, label %224
  ]

193:                                              ; preds = %180
  br i1 false, label %194, label %395

194:                                              ; preds = %193
  unreachable

195:                                              ; preds = %180
  %196 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %197 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %196, 1
  %198 = extractvalue { { ptr, i32, i32, i32 } } %197, 0
  %199 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %198)
  %200 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %199, 0
  %201 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %199, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %200)
  %202 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$27"({ ptr, i32, i32, i32 } %201)
  %203 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %202, 0
  %204 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %202, 1
  %205 = extractvalue { ptr, i32, i32, i32 } %204, 1
  %206 = extractvalue { ptr, i32, i32, i32 } %204, 2
  %207 = sub i32 %206, %205
  call void @"drop$27"({ ptr, i32, i32, i32 } %204)
  %208 = zext i32 %207 to i252
  %209 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %209, align 4
  %210 = getelementptr inbounds i8, ptr %209, i32 4
  store i32 0, ptr %210, align 4
  %211 = getelementptr inbounds i8, ptr %209, i32 16
  %212 = call ptr @realloc(ptr null, i64 8)
  store ptr %211, ptr %212, align 8
  %213 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %212, 0
  %214 = insertvalue { ptr, i32, i32, i32 } %213, i32 8, 3
  %215 = load ptr, ptr %212, align 8
  store i252 %208, ptr %215, align 16
  %216 = insertvalue { ptr, i32, i32, i32 } %214, i32 1, 2
  %217 = getelementptr inbounds i8, ptr %215, i32 -12
  store i32 1, ptr %217, align 4
  %218 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %203, 0
  %219 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %186, i64 %187, { { ptr, i32, i32, i32 } } %218, { ptr, i32, i32, i32 } %216)
  %220 = extractvalue { i64, i64, { i64, [24 x i8] } } %219, 0
  %221 = extractvalue { i64, i64, { i64, [24 x i8] } } %219, 1
  %222 = extractvalue { i64, i64, { i64, [24 x i8] } } %219, 2
  store { i64, [24 x i8] } %222, ptr %16, align 8
  %223 = load i1, ptr %16, align 1
  switch i1 %223, label %235 [
    i1 false, label %237
    i1 true, label %257
  ]

224:                                              ; preds = %180
  %225 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %226 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %225, 1
  %227 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %226, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %227, ptr %15, align 8
  %228 = load { i64, [24 x i8] }, ptr %15, align 8
  %229 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %188, 0
  %230 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %229, i64 %186, 1
  %231 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %230, i64 %189, 2
  %232 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %231, i64 %187, 3
  %233 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %232, ptr %190, 4
  %234 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %233, { i64, [24 x i8] } %228, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %234

235:                                              ; preds = %195
  br i1 false, label %236, label %396

236:                                              ; preds = %235
  unreachable

237:                                              ; preds = %195
  %238 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %16, align 8
  %239 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %238, 1
  %240 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %241 = call ptr %240()
  %242 = call i64 @llvm.uadd.sat.i64(i64 %221, i64 0)
  %243 = extractvalue { { ptr, i32, i32, i32 }, {} } %239, 0
  %244 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %243)
  %245 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %244, 0
  %246 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %244, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %245)
  %247 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %246, 0
  %248 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %247, 0
  %249 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %248, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %249, ptr %18, align 8
  %250 = load { i64, [24 x i8] }, ptr %18, align 8
  %251 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %188, 0
  %252 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %251, i64 %220, 1
  %253 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %252, i64 %189, 2
  %254 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %253, i64 %242, 3
  %255 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %254, ptr %190, 4
  %256 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %255, { i64, [24 x i8] } %250, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %256

257:                                              ; preds = %195
  %258 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %259 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %258, 1
  %260 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %259, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %260, ptr %17, align 8
  %261 = load { i64, [24 x i8] }, ptr %17, align 8
  %262 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %188, 0
  %263 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %262, i64 %220, 1
  %264 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %263, i64 %189, 2
  %265 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %264, i64 %221, 3
  %266 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %265, ptr %190, 4
  %267 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %266, { i64, [24 x i8] } %261, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %267

268:                                              ; preds = %168
  %269 = phi { ptr, i32, i32, i32 } [ %137, %168 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %269)
  %270 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %271 = call ptr %270()
  %272 = call i64 @llvm.uadd.sat.i64(i64 %111, i64 0)
  br label %377

273:                                              ; preds = %92
  %274 = phi { ptr, i32, i32, i32 } [ %93, %92 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %274)
  %275 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %276 = call ptr %275()
  %277 = load i64, ptr %276, align 8
  %278 = mul i64 %277, 4840
  %279 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %278)
  br label %280

280:                                              ; preds = %143, %273
  %281 = phi i64 [ %0, %273 ], [ %0, %143 ]
  %282 = phi i64 [ %2, %273 ], [ %2, %143 ]
  %283 = phi ptr [ %4, %273 ], [ %4, %143 ]
  %284 = phi i64 [ %91, %273 ], [ %110, %143 ]
  %285 = phi i64 [ %279, %273 ], [ %148, %143 ]
  %286 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f20"()
  %287 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %286, 0
  %288 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %287, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %288, ptr %10, align 8
  %289 = load { i64, [24 x i8] }, ptr %10, align 8
  %290 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %281, 0
  %291 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %290, i64 %284, 1
  %292 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %291, i64 %282, 2
  %293 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %292, i64 %285, 3
  %294 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %293, ptr %283, 4
  %295 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %294, { i64, [24 x i8] } %289, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %295

296:                                              ; preds = %75
  %297 = phi { ptr, i32, i32, i32 } [ %82, %75 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %297)
  %298 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %299 = call ptr %298()
  %300 = load i64, ptr %299, align 8
  %301 = mul i64 %300, 4200
  %302 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %301)
  br label %324

303:                                              ; preds = %69
  %304 = phi { ptr, i32, i32, i32 } [ %70, %69 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %304)
  %305 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %306 = call ptr %305()
  %307 = load i64, ptr %306, align 8
  %308 = mul i64 %307, 5500
  %309 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %308)
  br label %324

310:                                              ; preds = %52
  %311 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %311)
  %312 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %313 = call ptr %312()
  %314 = load i64, ptr %313, align 8
  %315 = mul i64 %314, 4960
  %316 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %315)
  br label %324

317:                                              ; preds = %46
  %318 = phi { ptr, i32, i32, i32 } [ %47, %46 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %318)
  %319 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %320 = call ptr %319()
  %321 = load i64, ptr %320, align 8
  %322 = mul i64 %321, 6360
  %323 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %322)
  br label %324

324:                                              ; preds = %310, %296, %303, %317
  %325 = phi i64 [ %0, %317 ], [ %0, %310 ], [ %0, %303 ], [ %0, %296 ]
  %326 = phi i64 [ %2, %317 ], [ %2, %310 ], [ %2, %303 ], [ %2, %296 ]
  %327 = phi ptr [ %4, %317 ], [ %4, %310 ], [ %4, %303 ], [ %4, %296 ]
  %328 = phi i64 [ %44, %317 ], [ %68, %310 ], [ %68, %303 ], [ %91, %296 ]
  %329 = phi i64 [ %323, %317 ], [ %316, %310 ], [ %309, %303 ], [ %302, %296 ]
  %330 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %331 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %330, 0
  %332 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %331, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %332, ptr %9, align 8
  %333 = load { i64, [24 x i8] }, ptr %9, align 8
  %334 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %325, 0
  %335 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %334, i64 %328, 1
  %336 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %335, i64 %326, 2
  %337 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %336, i64 %329, 3
  %338 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %337, ptr %327, 4
  %339 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %338, { i64, [24 x i8] } %333, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %339

340:                                              ; preds = %34
  %341 = phi { ptr, i32, i32, i32 } [ %41, %34 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %341)
  %342 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %343 = call ptr %342()
  %344 = load i64, ptr %343, align 8
  %345 = mul i64 %344, 6560
  %346 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %345)
  br label %354

347:                                              ; preds = %27
  %348 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %348)
  %349 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %350 = call ptr %349()
  %351 = load i64, ptr %350, align 8
  %352 = mul i64 %351, 7760
  %353 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %352)
  br label %354

354:                                              ; preds = %340, %347
  %355 = phi i64 [ %0, %347 ], [ %0, %340 ]
  %356 = phi i64 [ %2, %347 ], [ %2, %340 ]
  %357 = phi ptr [ %4, %347 ], [ %4, %340 ]
  %358 = phi i64 [ %20, %347 ], [ %44, %340 ]
  %359 = phi i64 [ %353, %347 ], [ %346, %340 ]
  %360 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %361 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %360, 0
  %362 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %361, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %362, ptr %8, align 8
  %363 = load { i64, [24 x i8] }, ptr %8, align 8
  %364 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %355, 0
  %365 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %364, i64 %358, 1
  %366 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %365, i64 %356, 2
  %367 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %366, i64 %359, 3
  %368 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %367, ptr %357, 4
  %369 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %368, { i64, [24 x i8] } %363, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %369

370:                                              ; preds = %6
  %371 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %371)
  %372 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %373 = call ptr %372()
  %374 = load i64, ptr %373, align 8
  %375 = mul i64 %374, 7470
  %376 = call i64 @llvm.uadd.sat.i64(i64 %3, i64 %375)
  br label %377

377:                                              ; preds = %268, %370
  %378 = phi i64 [ %0, %370 ], [ %0, %268 ]
  %379 = phi i64 [ %2, %370 ], [ %2, %268 ]
  %380 = phi ptr [ %4, %370 ], [ %4, %268 ]
  %381 = phi i64 [ %20, %370 ], [ %172, %268 ]
  %382 = phi i64 [ %376, %370 ], [ %272, %268 ]
  %383 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %384 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %383, 0
  %385 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %384, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %385, ptr %7, align 8
  %386 = load { i64, [24 x i8] }, ptr %7, align 8
  %387 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %378, 0
  %388 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %387, i64 %381, 1
  %389 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %388, i64 %379, 2
  %390 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %389, i64 %382, 3
  %391 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %390, ptr %380, 4
  %392 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %391, { i64, [24 x i8] } %386, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %392

393:                                              ; preds = %114
  call void @puts(ptr @assert_msg_0)
  call void @abort()
  unreachable

394:                                              ; preds = %133
  call void @puts(ptr @assert_msg_1)
  call void @abort()
  unreachable

395:                                              ; preds = %193
  call void @puts(ptr @assert_msg_2)
  call void @abort()
  unreachable

396:                                              ; preds = %235
  call void @puts(ptr @assert_msg_3)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f1(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f1"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f1(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f1(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 0
  %3 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, { i32, i32, i32, i32 } %2, 0
  %4 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { i32, i32, i32, i32 } %2, 0
  %5 = extractvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 1
  %6 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %5)
  %7 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 1
  %9 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %7, 1
  %10 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, { ptr, i32, i32, i32 } %8, 1
  %11 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %12 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %11, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10, 1
  ret { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %12
}

define private void @"drop$387"({ { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } @"dup$387"({ { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } undef, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %8, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$388"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, 1
  call void @"drop$387"({ { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [40 x i8] }, { i64, [40 x i8] } } @"dup$388"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, 1
  %7 = call { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } @"dup$387"({ { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6)
  %8 = extractvalue { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %7, 1
  %10 = insertvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %8, 1
  store { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %10, ptr %2, align 8
  %11 = load { i64, [40 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %9, 1
  store { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %12, ptr %2, align 8
  %13 = load { i64, [40 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %11, 0
  %15 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %14, { i64, [40 x i8] } %13, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [40 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [40 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %23, 0
  %27 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %26, { i64, [40 x i8] } %25, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$386"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  call void @"drop$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0)
  ret void
}

define private { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$386"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = call { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0)
  %3 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %2, 0
  %4 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %2, 1
  %5 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %6 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 1
  ret { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6
}

define private fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f2"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [56 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [40 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = add i64 %1, 1
  %22 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %23 = call ptr %22()
  %24 = load i64, ptr %23, align 8
  %25 = mul i64 %24, 1000
  %26 = icmp uge i64 %4, %25
  %27 = call i64 @llvm.usub.sat.i64(i64 %4, i64 %25)
  br i1 %26, label %28, label %414

28:                                               ; preds = %7
  %29 = phi { { ptr, i32, i32, i32 } } [ %6, %7 ]
  %30 = extractvalue { { ptr, i32, i32, i32 } } %29, 0
  %31 = extractvalue { ptr, i32, i32, i32 } %30, 1
  %32 = extractvalue { ptr, i32, i32, i32 } %30, 2
  %33 = sub i32 %32, %31
  %34 = icmp uge i32 %33, 1
  br i1 %34, label %35, label %389

35:                                               ; preds = %28
  %36 = extractvalue { ptr, i32, i32, i32 } %30, 0
  %37 = load ptr, ptr %36, align 8
  %38 = zext i32 %31 to i64
  %39 = mul i64 %38, 32
  %40 = getelementptr inbounds i8, ptr %37, i64 %39
  %41 = add i32 %31, 1
  %42 = insertvalue { ptr, i32, i32, i32 } %30, i32 %41, 1
  %43 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %43, ptr %40, i64 32, i1 false)
  %44 = load i252, ptr %43, align 16
  call void @free(ptr %43)
  %45 = add i64 %1, 4
  %46 = icmp ult i252 %44, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %46, label %47, label %382

47:                                               ; preds = %35
  %48 = phi { ptr, i32, i32, i32 } [ %42, %35 ]
  %49 = extractvalue { ptr, i32, i32, i32 } %48, 1
  %50 = extractvalue { ptr, i32, i32, i32 } %48, 2
  %51 = sub i32 %50, %49
  %52 = icmp uge i32 %51, 1
  br i1 %52, label %53, label %357

53:                                               ; preds = %47
  %54 = extractvalue { ptr, i32, i32, i32 } %48, 0
  %55 = load ptr, ptr %54, align 8
  %56 = zext i32 %49 to i64
  %57 = mul i64 %56, 32
  %58 = getelementptr inbounds i8, ptr %55, i64 %57
  %59 = add i32 %49, 1
  %60 = insertvalue { ptr, i32, i32, i32 } %48, i32 %59, 1
  %61 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %61, ptr %58, i64 32, i1 false)
  %62 = load i252, ptr %61, align 16
  call void @free(ptr %61)
  %63 = trunc i252 %62 to i128
  %64 = lshr i252 %62, 128
  %65 = trunc i252 %64 to i128
  %66 = icmp ne i128 %65, 0
  %67 = add i64 %1, 7
  %68 = add i64 %1, 5
  %69 = select i1 %66, i64 %67, i64 %68
  br i1 %66, label %350, label %70

70:                                               ; preds = %53
  %71 = phi { ptr, i32, i32, i32 } [ %60, %53 ]
  %72 = extractvalue { ptr, i32, i32, i32 } %71, 1
  %73 = extractvalue { ptr, i32, i32, i32 } %71, 2
  %74 = sub i32 %73, %72
  %75 = icmp uge i32 %74, 1
  br i1 %75, label %76, label %343

76:                                               ; preds = %70
  %77 = extractvalue { ptr, i32, i32, i32 } %71, 0
  %78 = load ptr, ptr %77, align 8
  %79 = zext i32 %72 to i64
  %80 = mul i64 %79, 32
  %81 = getelementptr inbounds i8, ptr %78, i64 %80
  %82 = add i32 %72, 1
  %83 = insertvalue { ptr, i32, i32, i32 } %71, i32 %82, 1
  %84 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %84, ptr %81, i64 32, i1 false)
  %85 = load i252, ptr %84, align 16
  call void @free(ptr %84)
  %86 = trunc i252 %85 to i128
  %87 = lshr i252 %85, 128
  %88 = trunc i252 %87 to i128
  %89 = icmp ne i128 %88, 0
  %90 = add i64 %69, 3
  %91 = add i64 %69, 1
  %92 = select i1 %89, i64 %90, i64 %91
  br i1 %89, label %336, label %93

93:                                               ; preds = %76
  %94 = phi { ptr, i32, i32, i32 } [ %83, %76 ]
  %95 = extractvalue { ptr, i32, i32, i32 } %94, 1
  %96 = extractvalue { ptr, i32, i32, i32 } %94, 2
  %97 = sub i32 %96, %95
  %98 = icmp uge i32 %97, 1
  br i1 %98, label %99, label %311

99:                                               ; preds = %93
  %100 = extractvalue { ptr, i32, i32, i32 } %94, 0
  %101 = load ptr, ptr %100, align 8
  %102 = zext i32 %95 to i64
  %103 = mul i64 %102, 32
  %104 = getelementptr inbounds i8, ptr %101, i64 %103
  %105 = add i32 %95, 1
  %106 = insertvalue { ptr, i32, i32, i32 } %94, i32 %105, 1
  %107 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %107, ptr %104, i64 32, i1 false)
  %108 = load i252, ptr %107, align 16
  call void @free(ptr %107)
  %109 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %106, 0
  %110 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f17"(i64 %92, i64 %27, { { ptr, i32, i32, i32 } } %109, { ptr, i32, i32, i32 } zeroinitializer, i252 %108)
  %111 = extractvalue { i64, i64, { i64, [56 x i8] } } %110, 0
  %112 = extractvalue { i64, i64, { i64, [56 x i8] } } %110, 1
  %113 = extractvalue { i64, i64, { i64, [56 x i8] } } %110, 2
  store { i64, [56 x i8] } %113, ptr %12, align 8
  %114 = load i1, ptr %12, align 1
  switch i1 %114, label %115 [
    i1 false, label %117
    i1 true, label %123
  ]

115:                                              ; preds = %99
  br i1 false, label %116, label %439

116:                                              ; preds = %115
  unreachable

117:                                              ; preds = %99
  %118 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %12, align 8
  %119 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %118, 1
  %120 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %119, 0
  %121 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %119, 1
  store { i64, [24 x i8] } %121, ptr %14, align 8
  %122 = load i1, ptr %14, align 1
  switch i1 %122, label %135 [
    i1 false, label %137
    i1 true, label %145
  ]

123:                                              ; preds = %99
  %124 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %125 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %124, 1
  %126 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %125, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %126, ptr %13, align 8
  %127 = load { i64, [24 x i8] }, ptr %13, align 8
  %128 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %129 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %111, 1
  %130 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %2, 2
  %131 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %3, 3
  %132 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %112, 4
  %133 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %132, ptr %5, 5
  %134 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, { i64, [24 x i8] } %127, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %134

135:                                              ; preds = %117
  br i1 false, label %136, label %440

136:                                              ; preds = %135
  unreachable

137:                                              ; preds = %117
  %138 = load { i1, { ptr, i32, i32, i32 } }, ptr %14, align 8
  %139 = extractvalue { i1, { ptr, i32, i32, i32 } } %138, 1
  %140 = extractvalue { { ptr, i32, i32, i32 } } %120, 0
  %141 = extractvalue { ptr, i32, i32, i32 } %140, 1
  %142 = extractvalue { ptr, i32, i32, i32 } %140, 2
  %143 = sub i32 %142, %141
  %144 = icmp uge i32 %143, 1
  br i1 %144, label %151, label %171

145:                                              ; preds = %117
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %120)
  %146 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %147 = call ptr %146()
  %148 = load i64, ptr %147, align 8
  %149 = mul i64 %148, 1870
  %150 = call i64 @llvm.uadd.sat.i64(i64 %112, i64 %149)
  br label %318

151:                                              ; preds = %137
  %152 = extractvalue { ptr, i32, i32, i32 } %140, 0
  %153 = load ptr, ptr %152, align 8
  %154 = zext i32 %141 to i64
  %155 = mul i64 %154, 32
  %156 = getelementptr inbounds i8, ptr %153, i64 %155
  %157 = add i32 %141, 1
  %158 = insertvalue { ptr, i32, i32, i32 } %140, i32 %157, 1
  %159 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %159, ptr %156, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %158)
  call void @"drop$409"(ptr %159)
  call void @"drop$212"({ ptr, i32, i32, i32 } %139)
  %160 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %161 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %160, 0
  %162 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %161, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %162, ptr %20, align 8
  %163 = load { i64, [24 x i8] }, ptr %20, align 8
  %164 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %165 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %164, i64 %111, 1
  %166 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %165, i64 %2, 2
  %167 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %166, i64 %3, 3
  %168 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %167, i64 %112, 4
  %169 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %168, ptr %5, 5
  %170 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %169, { i64, [24 x i8] } %163, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %170

171:                                              ; preds = %137
  %172 = phi { ptr, i32, i32, i32 } [ %140, %137 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %172)
  %173 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %174 = call ptr %173()
  %175 = add i64 %111, 1
  %176 = getelementptr inbounds i64, ptr %174, i32 1
  %177 = load i64, ptr %176, align 8
  %178 = mul i64 %177, 2
  %179 = getelementptr inbounds i64, ptr %174, i32 2
  %180 = load i64, ptr %179, align 8
  %181 = mul i64 %180, 4
  %182 = add i64 %178, %181
  %183 = load i64, ptr %174, align 8
  %184 = mul i64 %183, 66500
  %185 = add i64 %182, %184
  %186 = icmp uge i64 %112, %185
  %187 = call i64 @llvm.usub.sat.i64(i64 %112, i64 %185)
  br i1 %186, label %188, label %306

188:                                              ; preds = %171
  %189 = phi i128 [ %63, %171 ]
  %190 = phi i128 [ %86, %171 ]
  %191 = insertvalue { i128, i128 } undef, i128 %189, 0
  %192 = insertvalue { i128, i128 } %191, i128 %190, 1
  %193 = call fastcc { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f21"(i64 %175, i64 %187, i64 %2, i64 %0, i64 %3, ptr %5, { {} } undef, i252 %44, { i128, i128 } %192, { ptr, i32, i32, i32 } %139)
  %194 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 0
  %195 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 1
  %196 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 2
  %197 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 3
  %198 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 4
  %199 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 5
  %200 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %193, 6
  store { i64, [40 x i8] } %200, ptr %15, align 8
  %201 = load i1, ptr %15, align 1
  switch i1 %201, label %202 [
    i1 false, label %204
    i1 true, label %259
  ]

202:                                              ; preds = %188
  br i1 false, label %203, label %441

203:                                              ; preds = %202
  unreachable

204:                                              ; preds = %188
  %205 = load { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } }, ptr %15, align 8
  %206 = extractvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %205, 1
  %207 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %206, 0
  %208 = call { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %207)
  %209 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %208, 0
  %210 = extractvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %208, 1
  call void @"drop$385"({ { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %209)
  %211 = extractvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %210, 0
  %212 = extractvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %210, 1
  %213 = extractvalue { i32, i32, i32, i32 } %211, 0
  %214 = zext i32 %213 to i252
  %215 = extractvalue { i32, i32, i32, i32 } %211, 1
  %216 = zext i32 %215 to i252
  %217 = extractvalue { i32, i32, i32, i32 } %211, 2
  %218 = zext i32 %217 to i252
  %219 = extractvalue { i32, i32, i32, i32 } %211, 3
  %220 = zext i32 %219 to i252
  %221 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$27"({ ptr, i32, i32, i32 } %212)
  %222 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %221, 0
  %223 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %221, 1
  %224 = extractvalue { ptr, i32, i32, i32 } %223, 1
  %225 = extractvalue { ptr, i32, i32, i32 } %223, 2
  %226 = sub i32 %225, %224
  call void @"drop$27"({ ptr, i32, i32, i32 } %223)
  %227 = zext i32 %226 to i252
  %228 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %228, align 4
  %229 = getelementptr inbounds i8, ptr %228, i32 4
  store i32 0, ptr %229, align 4
  %230 = getelementptr inbounds i8, ptr %228, i32 16
  %231 = call ptr @realloc(ptr null, i64 8)
  store ptr %230, ptr %231, align 8
  %232 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %231, 0
  %233 = insertvalue { ptr, i32, i32, i32 } %232, i32 8, 3
  %234 = load ptr, ptr %231, align 8
  store i252 %214, ptr %234, align 16
  %235 = insertvalue { ptr, i32, i32, i32 } %233, i32 1, 2
  %236 = getelementptr inbounds i8, ptr %234, i32 -12
  store i32 1, ptr %236, align 4
  %237 = load ptr, ptr %231, align 8
  %238 = getelementptr inbounds i8, ptr %237, i32 32
  store i252 %216, ptr %238, align 16
  %239 = insertvalue { ptr, i32, i32, i32 } %235, i32 2, 2
  %240 = getelementptr inbounds i8, ptr %237, i32 -12
  store i32 2, ptr %240, align 4
  %241 = load ptr, ptr %231, align 8
  %242 = getelementptr inbounds i8, ptr %241, i32 64
  store i252 %218, ptr %242, align 16
  %243 = insertvalue { ptr, i32, i32, i32 } %239, i32 3, 2
  %244 = getelementptr inbounds i8, ptr %241, i32 -12
  store i32 3, ptr %244, align 4
  %245 = load ptr, ptr %231, align 8
  %246 = getelementptr inbounds i8, ptr %245, i32 96
  store i252 %220, ptr %246, align 16
  %247 = insertvalue { ptr, i32, i32, i32 } %243, i32 4, 2
  %248 = getelementptr inbounds i8, ptr %245, i32 -12
  store i32 4, ptr %248, align 4
  %249 = load ptr, ptr %231, align 8
  %250 = getelementptr inbounds i8, ptr %249, i32 128
  store i252 %227, ptr %250, align 16
  %251 = insertvalue { ptr, i32, i32, i32 } %247, i32 5, 2
  %252 = getelementptr inbounds i8, ptr %249, i32 -12
  store i32 5, ptr %252, align 4
  %253 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %222, 0
  %254 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %194, i64 %195, { { ptr, i32, i32, i32 } } %253, { ptr, i32, i32, i32 } %251)
  %255 = extractvalue { i64, i64, { i64, [24 x i8] } } %254, 0
  %256 = extractvalue { i64, i64, { i64, [24 x i8] } } %254, 1
  %257 = extractvalue { i64, i64, { i64, [24 x i8] } } %254, 2
  store { i64, [24 x i8] } %257, ptr %17, align 8
  %258 = load i1, ptr %17, align 1
  switch i1 %258, label %271 [
    i1 false, label %273
    i1 true, label %294
  ]

259:                                              ; preds = %188
  %260 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %261 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %260, 1
  %262 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %261, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %262, ptr %16, align 8
  %263 = load { i64, [24 x i8] }, ptr %16, align 8
  %264 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %197, 0
  %265 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %264, i64 %194, 1
  %266 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %265, i64 %196, 2
  %267 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %266, i64 %198, 3
  %268 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %267, i64 %195, 4
  %269 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %268, ptr %199, 5
  %270 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, { i64, [24 x i8] } %263, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %270

271:                                              ; preds = %204
  br i1 false, label %272, label %442

272:                                              ; preds = %271
  unreachable

273:                                              ; preds = %204
  %274 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %17, align 8
  %275 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %274, 1
  %276 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %277 = call ptr %276()
  %278 = call i64 @llvm.uadd.sat.i64(i64 %256, i64 0)
  %279 = extractvalue { { ptr, i32, i32, i32 }, {} } %275, 0
  %280 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %279)
  %281 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %280, 0
  %282 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %280, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %281)
  %283 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %282, 0
  %284 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %283, 0
  %285 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %284, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %285, ptr %19, align 8
  %286 = load { i64, [24 x i8] }, ptr %19, align 8
  %287 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %197, 0
  %288 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %287, i64 %255, 1
  %289 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %288, i64 %196, 2
  %290 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %289, i64 %198, 3
  %291 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %290, i64 %278, 4
  %292 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %291, ptr %199, 5
  %293 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %292, { i64, [24 x i8] } %286, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %293

294:                                              ; preds = %204
  %295 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %296 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %295, 1
  %297 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %296, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %297, ptr %18, align 8
  %298 = load { i64, [24 x i8] }, ptr %18, align 8
  %299 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %197, 0
  %300 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %299, i64 %255, 1
  %301 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %300, i64 %196, 2
  %302 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %301, i64 %198, 3
  %303 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %302, i64 %256, 4
  %304 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %303, ptr %199, 5
  %305 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %304, { i64, [24 x i8] } %298, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305

306:                                              ; preds = %171
  %307 = phi { ptr, i32, i32, i32 } [ %139, %171 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %307)
  %308 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %309 = call ptr %308()
  %310 = call i64 @llvm.uadd.sat.i64(i64 %112, i64 0)
  br label %421

311:                                              ; preds = %93
  %312 = phi { ptr, i32, i32, i32 } [ %94, %93 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %312)
  %313 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %314 = call ptr %313()
  %315 = load i64, ptr %314, align 8
  %316 = mul i64 %315, 5240
  %317 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %316)
  br label %318

318:                                              ; preds = %145, %311
  %319 = phi i64 [ %0, %311 ], [ %0, %145 ]
  %320 = phi i64 [ %2, %311 ], [ %2, %145 ]
  %321 = phi i64 [ %3, %311 ], [ %3, %145 ]
  %322 = phi ptr [ %5, %311 ], [ %5, %145 ]
  %323 = phi i64 [ %92, %311 ], [ %111, %145 ]
  %324 = phi i64 [ %317, %311 ], [ %150, %145 ]
  %325 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f20"()
  %326 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %325, 0
  %327 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %326, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %327, ptr %11, align 8
  %328 = load { i64, [24 x i8] }, ptr %11, align 8
  %329 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %319, 0
  %330 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %329, i64 %323, 1
  %331 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %330, i64 %320, 2
  %332 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %331, i64 %321, 3
  %333 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %332, i64 %324, 4
  %334 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %333, ptr %322, 5
  %335 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %334, { i64, [24 x i8] } %328, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %335

336:                                              ; preds = %76
  %337 = phi { ptr, i32, i32, i32 } [ %83, %76 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %337)
  %338 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %339 = call ptr %338()
  %340 = load i64, ptr %339, align 8
  %341 = mul i64 %340, 4600
  %342 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %341)
  br label %364

343:                                              ; preds = %70
  %344 = phi { ptr, i32, i32, i32 } [ %71, %70 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %344)
  %345 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %346 = call ptr %345()
  %347 = load i64, ptr %346, align 8
  %348 = mul i64 %347, 5900
  %349 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %348)
  br label %364

350:                                              ; preds = %53
  %351 = phi { ptr, i32, i32, i32 } [ %60, %53 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %351)
  %352 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %353 = call ptr %352()
  %354 = load i64, ptr %353, align 8
  %355 = mul i64 %354, 5360
  %356 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %355)
  br label %364

357:                                              ; preds = %47
  %358 = phi { ptr, i32, i32, i32 } [ %48, %47 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %358)
  %359 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %360 = call ptr %359()
  %361 = load i64, ptr %360, align 8
  %362 = mul i64 %361, 6760
  %363 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %362)
  br label %364

364:                                              ; preds = %350, %336, %343, %357
  %365 = phi i64 [ %0, %357 ], [ %0, %350 ], [ %0, %343 ], [ %0, %336 ]
  %366 = phi i64 [ %2, %357 ], [ %2, %350 ], [ %2, %343 ], [ %2, %336 ]
  %367 = phi i64 [ %3, %357 ], [ %3, %350 ], [ %3, %343 ], [ %3, %336 ]
  %368 = phi ptr [ %5, %357 ], [ %5, %350 ], [ %5, %343 ], [ %5, %336 ]
  %369 = phi i64 [ %45, %357 ], [ %69, %350 ], [ %69, %343 ], [ %92, %336 ]
  %370 = phi i64 [ %363, %357 ], [ %356, %350 ], [ %349, %343 ], [ %342, %336 ]
  %371 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %372 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %371, 0
  %373 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %372, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %373, ptr %10, align 8
  %374 = load { i64, [24 x i8] }, ptr %10, align 8
  %375 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %365, 0
  %376 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %375, i64 %369, 1
  %377 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %376, i64 %366, 2
  %378 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %377, i64 %367, 3
  %379 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %378, i64 %370, 4
  %380 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %379, ptr %368, 5
  %381 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %380, { i64, [24 x i8] } %374, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %381

382:                                              ; preds = %35
  %383 = phi { ptr, i32, i32, i32 } [ %42, %35 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %383)
  %384 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %385 = call ptr %384()
  %386 = load i64, ptr %385, align 8
  %387 = mul i64 %386, 6960
  %388 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %387)
  br label %396

389:                                              ; preds = %28
  %390 = phi { ptr, i32, i32, i32 } [ %30, %28 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %390)
  %391 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %392 = call ptr %391()
  %393 = load i64, ptr %392, align 8
  %394 = mul i64 %393, 8160
  %395 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %394)
  br label %396

396:                                              ; preds = %382, %389
  %397 = phi i64 [ %0, %389 ], [ %0, %382 ]
  %398 = phi i64 [ %2, %389 ], [ %2, %382 ]
  %399 = phi i64 [ %3, %389 ], [ %3, %382 ]
  %400 = phi ptr [ %5, %389 ], [ %5, %382 ]
  %401 = phi i64 [ %21, %389 ], [ %45, %382 ]
  %402 = phi i64 [ %395, %389 ], [ %388, %382 ]
  %403 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %404 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %403, 0
  %405 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %404, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %405, ptr %9, align 8
  %406 = load { i64, [24 x i8] }, ptr %9, align 8
  %407 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %397, 0
  %408 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %407, i64 %401, 1
  %409 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %408, i64 %398, 2
  %410 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %409, i64 %399, 3
  %411 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %410, i64 %402, 4
  %412 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %411, ptr %400, 5
  %413 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %412, { i64, [24 x i8] } %406, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %413

414:                                              ; preds = %7
  %415 = phi { { ptr, i32, i32, i32 } } [ %6, %7 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %415)
  %416 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %417 = call ptr %416()
  %418 = load i64, ptr %417, align 8
  %419 = mul i64 %418, 7360
  %420 = call i64 @llvm.uadd.sat.i64(i64 %4, i64 %419)
  br label %421

421:                                              ; preds = %306, %414
  %422 = phi i64 [ %0, %414 ], [ %0, %306 ]
  %423 = phi i64 [ %2, %414 ], [ %2, %306 ]
  %424 = phi i64 [ %3, %414 ], [ %3, %306 ]
  %425 = phi ptr [ %5, %414 ], [ %5, %306 ]
  %426 = phi i64 [ %21, %414 ], [ %175, %306 ]
  %427 = phi i64 [ %420, %414 ], [ %310, %306 ]
  %428 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %429 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %428, 0
  %430 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %429, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %430, ptr %8, align 8
  %431 = load { i64, [24 x i8] }, ptr %8, align 8
  %432 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %422, 0
  %433 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %432, i64 %426, 1
  %434 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %433, i64 %423, 2
  %435 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %434, i64 %424, 3
  %436 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %435, i64 %427, 4
  %437 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %436, ptr %425, 5
  %438 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %437, { i64, [24 x i8] } %431, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %438

439:                                              ; preds = %115
  call void @puts(ptr @assert_msg_4)
  call void @abort()
  unreachable

440:                                              ; preds = %135
  call void @puts(ptr @assert_msg_5)
  call void @abort()
  unreachable

441:                                              ; preds = %202
  call void @puts(ptr @assert_msg_6)
  call void @abort()
  unreachable

442:                                              ; preds = %271
  call void @puts(ptr @assert_msg_7)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f2(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f2"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  %9 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 5
  %15 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 6
  %16 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %9, 0
  %17 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %10, 1
  %18 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %11, 2
  %19 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %12, 3
  %20 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, i64 %13, 4
  %21 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, ptr %14, 5
  %22 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21, { i64, [24 x i8] } %15, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %22
}

define void @_mlir_ciface_f2(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { { ptr, i32, i32, i32 } } %7) {
  %9 = call { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f2(i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { { ptr, i32, i32, i32 } } %7)
  store { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, ptr %0, align 8
  ret void
}

define private void @"drop$40"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$40"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 0
  call void @"drop$40"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$40"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 1
  %9 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %6, i252 %8, 1
  %10 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %7, i252 %8, 1
  %11 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 2
  %12 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %9, i32 %11, 2
  %13 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %10, i32 %11, 2
  %14 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %12, 0
  %15 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %14, { { ptr, i32, i32, i32 }, i252, i32 } %13, 1
  ret { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %15
}

define private void @"drop$379"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$379"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, { { ptr, i32, i32, i32 }, i252, i32 } %8, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %10, ptr %2, align 16
  %11 = load { i128, [80 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, { { ptr, i32, i32, i32 }, i252, i32 } %9, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %12, ptr %2, align 16
  %13 = load { i128, [80 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %11, 0
  %15 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %14, { i128, [80 x i8] } %13, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [80 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [80 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %20, 0
  %24 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %23, { i128, [80 x i8] } %22, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$380"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  call void @"drop$379"({ i128, [80 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$380"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  %9 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$379"({ i128, [80 x i8] } %8)
  %10 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %9, 0
  %11 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6, { i128, [80 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %7, { i128, [80 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %15
}

define private void @"drop$381"({ i128, [128 x i8] } %0) {
  %2 = alloca { i128, [128 x i8] }, i64 1, align 16
  store { i128, [128 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, 1
  call void @"drop$380"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [128 x i8] }, { i128, [128 x i8] } } @"dup$381"({ i128, [128 x i8] } %0) {
  %2 = alloca { i128, [128 x i8] }, i64 1, align 16
  store { i128, [128 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$380"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [128 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [128 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } undef, { i128, [128 x i8] } %11, 0
  %15 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } %14, { i128, [128 x i8] } %13, 1
  ret { { i128, [128 x i8] }, { i128, [128 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [128 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [128 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } undef, { i128, [128 x i8] } %23, 0
  %27 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } %26, { i128, [128 x i8] } %25, 1
  ret { { i128, [128 x i8] }, { i128, [128 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$15"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$15"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 4
  call void @"drop$15"({ ptr, i32, i32, i32 } %3)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 5
  call void @"drop$15"({ ptr, i32, i32, i32 } %4)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, i32 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, i32 %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, i8 %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10, i8 %11, 2
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 3
  %15 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, i8 %14, 3
  %16 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13, i8 %14, 3
  %17 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 4
  %18 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$15"({ ptr, i32, i32, i32 } %17)
  %19 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 0
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 1
  %21 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %15, { ptr, i32, i32, i32 } %19, 4
  %22 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %16, { ptr, i32, i32, i32 } %20, 4
  %23 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 5
  %24 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$15"({ ptr, i32, i32, i32 } %23)
  %25 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %24, 0
  %26 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %24, 1
  %27 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %21, { ptr, i32, i32, i32 } %25, 5
  %28 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %22, { ptr, i32, i32, i32 } %26, 5
  %29 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %27, 0
  %30 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %29, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %28, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %30
}

define private void @"drop$103"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i2, ptr %2, align 1
  switch i2 %3, label %11 [
    i2 0, label %4
    i2 1, label %5
    i2 -2, label %8
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %7 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %7)
  ret void

8:                                                ; preds = %1
  %9 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %10 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %9, 1
  call void @"drop$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10)
  ret void

11:                                               ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$103"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i2, ptr %2, align 1
  switch i2 %3, label %37 [
    i2 0, label %4
    i2 1, label %13
    i2 -2, label %25
  ]

4:                                                ; preds = %1
  %5 = load { i2, i252 }, ptr %2, align 16
  %6 = extractvalue { i2, i252 } %5, 1
  %7 = insertvalue { i2, i252 } %5, i252 %6, 1
  store { i2, i252 } %7, ptr %2, align 16
  %8 = load { i128, [144 x i8] }, ptr %2, align 16
  %9 = insertvalue { i2, i252 } %5, i252 %6, 1
  store { i2, i252 } %9, ptr %2, align 16
  %10 = load { i128, [144 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %8, 0
  %12 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %11, { i128, [144 x i8] } %10, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %15 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %14, 1
  %16 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %15)
  %17 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %16, 0
  %18 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %16, 1
  %19 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %14, { { ptr, i32, i32, i32 }, i252, i32 } %17, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %19, ptr %2, align 16
  %20 = load { i128, [144 x i8] }, ptr %2, align 16
  %21 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %14, { { ptr, i32, i32, i32 }, i252, i32 } %18, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %21, ptr %2, align 16
  %22 = load { i128, [144 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %20, 0
  %24 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %23, { i128, [144 x i8] } %22, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %24

25:                                               ; preds = %1
  %26 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %27 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %26, 1
  %28 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %27)
  %29 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %28, 0
  %30 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %28, 1
  %31 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %26, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %29, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %31, ptr %2, align 16
  %32 = load { i128, [144 x i8] }, ptr %2, align 16
  %33 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %26, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %30, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %33, ptr %2, align 16
  %34 = load { i128, [144 x i8] }, ptr %2, align 16
  %35 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %32, 0
  %36 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %35, { i128, [144 x i8] } %34, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %36

37:                                               ; preds = %1
  unreachable
}

define private void @"drop$106"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 160
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i128, [144 x i8] }, ptr %22, align 16
  call void @"drop$103"({ i128, [144 x i8] } %23)
  %24 = add i64 %19, 160
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$376"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$106"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$376"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$377"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$376"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$377"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$376"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$378"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$377"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$378"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$377"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$375"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$375"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { {} }, {} } }, ptr %2, align 1
  %6 = extractvalue { i1, { { {} }, {} } } %5, 1
  %7 = insertvalue { i1, { { {} }, {} } } %5, { { {} }, {} } %6, 1
  store { i1, { { {} }, {} } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { {} }, {} } } %5, { { {} }, {} } %6, 1
  store { i1, { { {} }, {} } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f3"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i32, [8 x i8] }, i64 1, align 4
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i128, [128 x i8] }, i64 1, align 16
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i32, [4 x i8] }, i64 1, align 4
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = add i64 %1, 1
  %25 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %26 = call ptr %25()
  %27 = load i64, ptr %26, align 8
  %28 = mul i64 %27, 14760
  %29 = icmp uge i64 %3, %28
  %30 = call i64 @llvm.usub.sat.i64(i64 %3, i64 %28)
  br i1 %29, label %31, label %413

31:                                               ; preds = %6
  %32 = phi i64 [ %24, %6 ]
  %33 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f22"(i64 %32, { { ptr, i32, i32, i32 } } %5)
  %34 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %33, 0
  %35 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %33, 1
  %36 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %33, 2
  store { i32, [8 x i8] } %36, ptr %8, align 4
  %37 = load i1, ptr %8, align 1
  switch i1 %37, label %38 [
    i1 false, label %40
    i1 true, label %48
  ]

38:                                               ; preds = %31
  br i1 false, label %39, label %436

39:                                               ; preds = %38
  unreachable

40:                                               ; preds = %31
  %41 = load { i1, { i32, [4 x i8] } }, ptr %8, align 4
  %42 = extractvalue { i1, { i32, [4 x i8] } } %41, 1
  %43 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f23"(i64 %34, i64 %30, { { ptr, i32, i32, i32 } } %35)
  %44 = extractvalue { i64, i64, { i128, [128 x i8] } } %43, 0
  %45 = extractvalue { i64, i64, { i128, [128 x i8] } } %43, 1
  %46 = extractvalue { i64, i64, { i128, [128 x i8] } } %43, 2
  store { i128, [128 x i8] } %46, ptr %10, align 16
  %47 = load i1, ptr %10, align 1
  switch i1 %47, label %59 [
    i1 false, label %61
    i1 true, label %67
  ]

48:                                               ; preds = %31
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %35)
  %49 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %50 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %49, 0
  %51 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %50, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %51, ptr %9, align 8
  %52 = load { i64, [24 x i8] }, ptr %9, align 8
  %53 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %54 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %53, i64 %34, 1
  %55 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %54, i64 %2, 2
  %56 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %55, i64 %30, 3
  %57 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %56, ptr %4, 4
  %58 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %57, { i64, [24 x i8] } %52, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %58

59:                                               ; preds = %40
  br i1 false, label %60, label %437

60:                                               ; preds = %59
  unreachable

61:                                               ; preds = %40
  %62 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %10, align 16
  %63 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %62, 1
  %64 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %63, 0
  %65 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %63, 1
  store { i128, [80 x i8] } %65, ptr %12, align 16
  %66 = load i1, ptr %12, align 1
  switch i1 %66, label %78 [
    i1 false, label %80
    i1 true, label %88
  ]

67:                                               ; preds = %40
  %68 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %69 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %68, 1
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %11, align 8
  %71 = load { i64, [24 x i8] }, ptr %11, align 8
  %72 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %73 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %72, i64 %44, 1
  %74 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %73, i64 %2, 2
  %75 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %74, i64 %45, 3
  %76 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %75, ptr %4, 4
  %77 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %76, { i64, [24 x i8] } %71, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %77

78:                                               ; preds = %61
  br i1 false, label %79, label %438

79:                                               ; preds = %78
  unreachable

80:                                               ; preds = %61
  %81 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %12, align 16
  %82 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %81, 1
  %83 = extractvalue { { ptr, i32, i32, i32 } } %64, 0
  %84 = extractvalue { ptr, i32, i32, i32 } %83, 1
  %85 = extractvalue { ptr, i32, i32, i32 } %83, 2
  %86 = sub i32 %85, %84
  %87 = icmp uge i32 %86, 1
  br i1 %87, label %99, label %390

88:                                               ; preds = %61
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %64)
  %89 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %90 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %89, 0
  %91 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %90, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %91, ptr %13, align 8
  %92 = load { i64, [24 x i8] }, ptr %13, align 8
  %93 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %94 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %44, 1
  %95 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %2, 2
  %96 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %45, 3
  %97 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %96, ptr %4, 4
  %98 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %97, { i64, [24 x i8] } %92, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %98

99:                                               ; preds = %80
  %100 = extractvalue { ptr, i32, i32, i32 } %83, 0
  %101 = load ptr, ptr %100, align 8
  %102 = zext i32 %84 to i64
  %103 = mul i64 %102, 32
  %104 = getelementptr inbounds i8, ptr %101, i64 %103
  %105 = add i32 %84, 1
  %106 = insertvalue { ptr, i32, i32, i32 } %83, i32 %105, 1
  %107 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %107, ptr %104, i64 32, i1 false)
  %108 = load i252, ptr %107, align 16
  call void @free(ptr %107)
  %109 = icmp ult i252 %108, 4294967296
  %110 = add i64 %44, 2
  %111 = add i64 %44, 3
  %112 = select i1 %109, i64 %110, i64 %111
  %113 = trunc i252 %108 to i32
  br i1 %109, label %114, label %383

114:                                              ; preds = %99
  %115 = phi { ptr, i32, i32, i32 } [ %106, %99 ]
  %116 = extractvalue { ptr, i32, i32, i32 } %115, 1
  %117 = extractvalue { ptr, i32, i32, i32 } %115, 2
  %118 = sub i32 %117, %116
  %119 = icmp uge i32 %118, 1
  br i1 %119, label %120, label %376

120:                                              ; preds = %114
  %121 = extractvalue { ptr, i32, i32, i32 } %115, 0
  %122 = load ptr, ptr %121, align 8
  %123 = zext i32 %116 to i64
  %124 = mul i64 %123, 32
  %125 = getelementptr inbounds i8, ptr %122, i64 %124
  %126 = add i32 %116, 1
  %127 = insertvalue { ptr, i32, i32, i32 } %115, i32 %126, 1
  %128 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %128, ptr %125, i64 32, i1 false)
  %129 = load i252, ptr %128, align 16
  call void @free(ptr %128)
  %130 = icmp ult i252 %129, 4294967296
  %131 = add i64 %112, 2
  %132 = add i64 %112, 3
  %133 = select i1 %130, i64 %131, i64 %132
  %134 = trunc i252 %129 to i32
  br i1 %130, label %135, label %369

135:                                              ; preds = %120
  %136 = phi { ptr, i32, i32, i32 } [ %127, %120 ]
  %137 = extractvalue { ptr, i32, i32, i32 } %136, 1
  %138 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %139 = sub i32 %138, %137
  %140 = icmp uge i32 %139, 1
  br i1 %140, label %141, label %362

141:                                              ; preds = %135
  %142 = extractvalue { ptr, i32, i32, i32 } %136, 0
  %143 = load ptr, ptr %142, align 8
  %144 = zext i32 %137 to i64
  %145 = mul i64 %144, 32
  %146 = getelementptr inbounds i8, ptr %143, i64 %145
  %147 = add i32 %137, 1
  %148 = insertvalue { ptr, i32, i32, i32 } %136, i32 %147, 1
  %149 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %149, ptr %146, i64 32, i1 false)
  %150 = load i252, ptr %149, align 16
  call void @free(ptr %149)
  %151 = icmp ult i252 %150, 4294967296
  %152 = add i64 %133, 2
  %153 = add i64 %133, 3
  %154 = select i1 %151, i64 %152, i64 %153
  %155 = trunc i252 %150 to i32
  br i1 %151, label %156, label %355

156:                                              ; preds = %141
  %157 = phi { ptr, i32, i32, i32 } [ %148, %141 ]
  %158 = extractvalue { ptr, i32, i32, i32 } %157, 1
  %159 = extractvalue { ptr, i32, i32, i32 } %157, 2
  %160 = sub i32 %159, %158
  %161 = icmp uge i32 %160, 1
  br i1 %161, label %162, label %348

162:                                              ; preds = %156
  %163 = extractvalue { ptr, i32, i32, i32 } %157, 0
  %164 = load ptr, ptr %163, align 8
  %165 = zext i32 %158 to i64
  %166 = mul i64 %165, 32
  %167 = getelementptr inbounds i8, ptr %164, i64 %166
  %168 = add i32 %158, 1
  %169 = insertvalue { ptr, i32, i32, i32 } %157, i32 %168, 1
  %170 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %170, ptr %167, i64 32, i1 false)
  %171 = load i252, ptr %170, align 16
  call void @free(ptr %170)
  %172 = icmp ult i252 %171, 4294967296
  %173 = add i64 %154, 2
  %174 = add i64 %154, 3
  %175 = select i1 %172, i64 %173, i64 %174
  %176 = trunc i252 %171 to i32
  br i1 %172, label %177, label %341

177:                                              ; preds = %162
  %178 = phi { ptr, i32, i32, i32 } [ %169, %162 ]
  %179 = extractvalue { ptr, i32, i32, i32 } %178, 1
  %180 = extractvalue { ptr, i32, i32, i32 } %178, 2
  %181 = sub i32 %180, %179
  %182 = icmp uge i32 %181, 1
  br i1 %182, label %183, label %318

183:                                              ; preds = %177
  %184 = extractvalue { ptr, i32, i32, i32 } %178, 0
  %185 = load ptr, ptr %184, align 8
  %186 = zext i32 %179 to i64
  %187 = mul i64 %186, 32
  %188 = getelementptr inbounds i8, ptr %185, i64 %187
  %189 = add i32 %179, 1
  %190 = insertvalue { ptr, i32, i32, i32 } %178, i32 %189, 1
  %191 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %191, ptr %188, i64 32, i1 false)
  %192 = load i252, ptr %191, align 16
  call void @free(ptr %191)
  %193 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %190, 0
  %194 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f24"(i64 %175, i64 %45, { { ptr, i32, i32, i32 } } %193, { ptr, i32, i32, i32 } zeroinitializer, i252 %192)
  %195 = extractvalue { i64, i64, { i64, [56 x i8] } } %194, 0
  %196 = extractvalue { i64, i64, { i64, [56 x i8] } } %194, 1
  %197 = extractvalue { i64, i64, { i64, [56 x i8] } } %194, 2
  store { i64, [56 x i8] } %197, ptr %16, align 8
  %198 = load i1, ptr %16, align 1
  switch i1 %198, label %199 [
    i1 false, label %201
    i1 true, label %207
  ]

199:                                              ; preds = %183
  br i1 false, label %200, label %439

200:                                              ; preds = %199
  unreachable

201:                                              ; preds = %183
  %202 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %16, align 8
  %203 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %202, 1
  %204 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %203, 0
  %205 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %203, 1
  store { i64, [24 x i8] } %205, ptr %18, align 8
  %206 = load i1, ptr %18, align 1
  switch i1 %206, label %218 [
    i1 false, label %220
    i1 true, label %228
  ]

207:                                              ; preds = %183
  %208 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %209 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %208, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %210 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %209, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %210, ptr %17, align 8
  %211 = load { i64, [24 x i8] }, ptr %17, align 8
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %212, i64 %195, 1
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, i64 %2, 2
  %215 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %214, i64 %196, 3
  %216 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %215, ptr %4, 4
  %217 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %216, { i64, [24 x i8] } %211, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %217

218:                                              ; preds = %201
  br i1 false, label %219, label %440

219:                                              ; preds = %218
  unreachable

220:                                              ; preds = %201
  %221 = load { i1, { ptr, i32, i32, i32 } }, ptr %18, align 8
  %222 = extractvalue { i1, { ptr, i32, i32, i32 } } %221, 1
  %223 = extractvalue { { ptr, i32, i32, i32 } } %204, 0
  %224 = extractvalue { ptr, i32, i32, i32 } %223, 1
  %225 = extractvalue { ptr, i32, i32, i32 } %223, 2
  %226 = sub i32 %225, %224
  %227 = icmp uge i32 %226, 1
  br i1 %227, label %234, label %253

228:                                              ; preds = %201
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %204)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %229 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %230 = call ptr %229()
  %231 = load i64, ptr %230, align 8
  %232 = mul i64 %231, 1570
  %233 = call i64 @llvm.uadd.sat.i64(i64 %196, i64 %232)
  br label %325

234:                                              ; preds = %220
  %235 = extractvalue { ptr, i32, i32, i32 } %223, 0
  %236 = load ptr, ptr %235, align 8
  %237 = zext i32 %224 to i64
  %238 = mul i64 %237, 32
  %239 = getelementptr inbounds i8, ptr %236, i64 %238
  %240 = add i32 %224, 1
  %241 = insertvalue { ptr, i32, i32, i32 } %223, i32 %240, 1
  %242 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %242, ptr %239, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %241)
  call void @"drop$409"(ptr %242)
  call void @"drop$106"({ ptr, i32, i32, i32 } %222)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %243 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %244 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %243, 0
  %245 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %244, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %245, ptr %23, align 8
  %246 = load { i64, [24 x i8] }, ptr %23, align 8
  %247 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %248 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %195, 1
  %249 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %248, i64 %2, 2
  %250 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %249, i64 %196, 3
  %251 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %250, ptr %4, 4
  %252 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %251, { i64, [24 x i8] } %246, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %252

253:                                              ; preds = %220
  %254 = phi { ptr, i32, i32, i32 } [ %223, %220 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %254)
  %255 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %256 = call ptr %255()
  %257 = add i64 %195, 1
  %258 = getelementptr inbounds i64, ptr %256, i32 1
  %259 = load i64, ptr %258, align 8
  %260 = mul i64 %259, 2
  %261 = load i64, ptr %256, align 8
  %262 = mul i64 %261, 146990
  %263 = add i64 %260, %262
  %264 = icmp uge i64 %196, %263
  %265 = call i64 @llvm.usub.sat.i64(i64 %196, i64 %263)
  br i1 %264, label %266, label %313

266:                                              ; preds = %253
  %267 = phi i32 [ %113, %253 ]
  %268 = phi i32 [ %134, %253 ]
  %269 = phi i32 [ %155, %253 ]
  %270 = phi i32 [ %176, %253 ]
  %271 = insertvalue { i32, i32, i32, i32 } undef, i32 %267, 0
  %272 = insertvalue { i32, i32, i32, i32 } %271, i32 %268, 1
  %273 = insertvalue { i32, i32, i32, i32 } %272, i32 %269, 2
  %274 = insertvalue { i32, i32, i32, i32 } %273, i32 %270, 3
  store { i32, [4 x i8] } %42, ptr %19, align 4
  %275 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f25"(i64 %257, i64 %265, i64 %0, i64 %2, ptr %4, { {} } undef, ptr %19, { { ptr, i32, i32, i32 }, i252, i32 } %82, { i32, i32, i32, i32 } %274, { ptr, i32, i32, i32 } %222)
  %276 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %275, 0
  %277 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %275, 1
  %278 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %275, 2
  %279 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %275, 3
  %280 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %275, 4
  %281 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %275, 5
  store { i64, [24 x i8] } %281, ptr %20, align 8
  %282 = load i1, ptr %20, align 1
  switch i1 %282, label %283 [
    i1 false, label %285
    i1 true, label %302
  ]

283:                                              ; preds = %266
  br i1 false, label %284, label %441

284:                                              ; preds = %283
  unreachable

285:                                              ; preds = %266
  %286 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %287 = call ptr %286()
  %288 = call i64 @llvm.uadd.sat.i64(i64 %277, i64 0)
  %289 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %290 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %289, 0
  %291 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %289, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %290)
  %292 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %291, 0
  %293 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %292, 0
  %294 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %293, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %294, ptr %22, align 8
  %295 = load { i64, [24 x i8] }, ptr %22, align 8
  %296 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %278, 0
  %297 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %296, i64 %276, 1
  %298 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %297, i64 %279, 2
  %299 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %298, i64 %288, 3
  %300 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %299, ptr %280, 4
  %301 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %300, { i64, [24 x i8] } %295, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %301

302:                                              ; preds = %266
  %303 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %20, align 8
  %304 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %303, 1
  %305 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %304, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %305, ptr %21, align 8
  %306 = load { i64, [24 x i8] }, ptr %21, align 8
  %307 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %278, 0
  %308 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %307, i64 %276, 1
  %309 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %308, i64 %279, 2
  %310 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %309, i64 %277, 3
  %311 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %310, ptr %280, 4
  %312 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %311, { i64, [24 x i8] } %306, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %312

313:                                              ; preds = %253
  %314 = phi { ptr, i32, i32, i32 } [ %222, %253 ]
  call void @"drop$106"({ ptr, i32, i32, i32 } %314)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %315 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %316 = call ptr %315()
  %317 = call i64 @llvm.uadd.sat.i64(i64 %196, i64 0)
  br label %420

318:                                              ; preds = %177
  %319 = phi { ptr, i32, i32, i32 } [ %178, %177 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %319)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %320 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %321 = call ptr %320()
  %322 = load i64, ptr %321, align 8
  %323 = mul i64 %322, 4940
  %324 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %323)
  br label %325

325:                                              ; preds = %228, %318
  %326 = phi i64 [ %0, %318 ], [ %0, %228 ]
  %327 = phi i64 [ %2, %318 ], [ %2, %228 ]
  %328 = phi ptr [ %4, %318 ], [ %4, %228 ]
  %329 = phi i64 [ %175, %318 ], [ %195, %228 ]
  %330 = phi i64 [ %324, %318 ], [ %233, %228 ]
  %331 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f26"()
  %332 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %331, 0
  %333 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %332, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %333, ptr %15, align 8
  %334 = load { i64, [24 x i8] }, ptr %15, align 8
  %335 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %326, 0
  %336 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %335, i64 %329, 1
  %337 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %336, i64 %327, 2
  %338 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %337, i64 %330, 3
  %339 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %338, ptr %328, 4
  %340 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %339, { i64, [24 x i8] } %334, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %340

341:                                              ; preds = %162
  %342 = phi { ptr, i32, i32, i32 } [ %169, %162 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %342)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %343 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %344 = call ptr %343()
  %345 = load i64, ptr %344, align 8
  %346 = mul i64 %345, 4670
  %347 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %346)
  br label %397

348:                                              ; preds = %156
  %349 = phi { ptr, i32, i32, i32 } [ %157, %156 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %349)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %350 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %351 = call ptr %350()
  %352 = load i64, ptr %351, align 8
  %353 = mul i64 %352, 5870
  %354 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %353)
  br label %397

355:                                              ; preds = %141
  %356 = phi { ptr, i32, i32, i32 } [ %148, %141 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %356)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %357 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %358 = call ptr %357()
  %359 = load i64, ptr %358, align 8
  %360 = mul i64 %359, 5700
  %361 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %360)
  br label %397

362:                                              ; preds = %135
  %363 = phi { ptr, i32, i32, i32 } [ %136, %135 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %363)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %364 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %365 = call ptr %364()
  %366 = load i64, ptr %365, align 8
  %367 = mul i64 %366, 6900
  %368 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %367)
  br label %397

369:                                              ; preds = %120
  %370 = phi { ptr, i32, i32, i32 } [ %127, %120 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %370)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %371 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %372 = call ptr %371()
  %373 = load i64, ptr %372, align 8
  %374 = mul i64 %373, 6730
  %375 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %374)
  br label %397

376:                                              ; preds = %114
  %377 = phi { ptr, i32, i32, i32 } [ %115, %114 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %377)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %378 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %379 = call ptr %378()
  %380 = load i64, ptr %379, align 8
  %381 = mul i64 %380, 7930
  %382 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %381)
  br label %397

383:                                              ; preds = %99
  %384 = phi { ptr, i32, i32, i32 } [ %106, %99 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %384)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %385 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %386 = call ptr %385()
  %387 = load i64, ptr %386, align 8
  %388 = mul i64 %387, 7760
  %389 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %388)
  br label %397

390:                                              ; preds = %80
  %391 = phi { ptr, i32, i32, i32 } [ %83, %80 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %391)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %82)
  %392 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %393 = call ptr %392()
  %394 = load i64, ptr %393, align 8
  %395 = mul i64 %394, 9060
  %396 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %395)
  br label %397

397:                                              ; preds = %341, %348, %355, %362, %369, %376, %383, %390
  %398 = phi i64 [ %0, %390 ], [ %0, %383 ], [ %0, %376 ], [ %0, %369 ], [ %0, %362 ], [ %0, %355 ], [ %0, %348 ], [ %0, %341 ]
  %399 = phi i64 [ %2, %390 ], [ %2, %383 ], [ %2, %376 ], [ %2, %369 ], [ %2, %362 ], [ %2, %355 ], [ %2, %348 ], [ %2, %341 ]
  %400 = phi ptr [ %4, %390 ], [ %4, %383 ], [ %4, %376 ], [ %4, %369 ], [ %4, %362 ], [ %4, %355 ], [ %4, %348 ], [ %4, %341 ]
  %401 = phi i64 [ %44, %390 ], [ %112, %383 ], [ %112, %376 ], [ %133, %369 ], [ %133, %362 ], [ %154, %355 ], [ %154, %348 ], [ %175, %341 ]
  %402 = phi i64 [ %396, %390 ], [ %389, %383 ], [ %382, %376 ], [ %375, %369 ], [ %368, %362 ], [ %361, %355 ], [ %354, %348 ], [ %347, %341 ]
  %403 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f20"()
  %404 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %403, 0
  %405 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %404, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %405, ptr %14, align 8
  %406 = load { i64, [24 x i8] }, ptr %14, align 8
  %407 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %398, 0
  %408 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %407, i64 %401, 1
  %409 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %408, i64 %399, 2
  %410 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %409, i64 %402, 3
  %411 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %410, ptr %400, 4
  %412 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %411, { i64, [24 x i8] } %406, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %412

413:                                              ; preds = %6
  %414 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %414)
  %415 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %416 = call ptr %415()
  %417 = load i64, ptr %416, align 8
  %418 = mul i64 %417, 7430
  %419 = call i64 @llvm.uadd.sat.i64(i64 %3, i64 %418)
  br label %420

420:                                              ; preds = %313, %413
  %421 = phi i64 [ %0, %413 ], [ %0, %313 ]
  %422 = phi i64 [ %2, %413 ], [ %2, %313 ]
  %423 = phi ptr [ %4, %413 ], [ %4, %313 ]
  %424 = phi i64 [ %24, %413 ], [ %257, %313 ]
  %425 = phi i64 [ %419, %413 ], [ %317, %313 ]
  %426 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %427 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %426, 0
  %428 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %427, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %428, ptr %7, align 8
  %429 = load { i64, [24 x i8] }, ptr %7, align 8
  %430 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %421, 0
  %431 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %430, i64 %424, 1
  %432 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %431, i64 %422, 2
  %433 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %432, i64 %425, 3
  %434 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %433, ptr %423, 4
  %435 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %434, { i64, [24 x i8] } %429, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %435

436:                                              ; preds = %38
  call void @puts(ptr @assert_msg_8)
  call void @abort()
  unreachable

437:                                              ; preds = %59
  call void @puts(ptr @assert_msg_9)
  call void @abort()
  unreachable

438:                                              ; preds = %78
  call void @puts(ptr @assert_msg_10)
  call void @abort()
  unreachable

439:                                              ; preds = %199
  call void @puts(ptr @assert_msg_11)
  call void @abort()
  unreachable

440:                                              ; preds = %218
  call void @puts(ptr @assert_msg_12)
  call void @abort()
  unreachable

441:                                              ; preds = %283
  call void @puts(ptr @assert_msg_13)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f3(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f3"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f3(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f3(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 3
  call void @"drop$106"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 0
  %3 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, { i32, [4 x i8] } %2, 0
  %4 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { i32, [4 x i8] } %2, 0
  %5 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 1
  %9 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, { { ptr, i32, i32, i32 }, i252, i32 } %7, 1
  %10 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, { { ptr, i32, i32, i32 }, i252, i32 } %8, 1
  %11 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 2
  %12 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, { i32, i32, i32, i32 } %11, 2
  %13 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10, { i32, i32, i32, i32 } %11, 2
  %14 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 3
  %15 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %14)
  %16 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %15, 0
  %17 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %15, 1
  %18 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %16, 3
  %19 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13, { ptr, i32, i32, i32 } %17, 3
  %20 = insertvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 0
  %21 = insertvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %20, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 1
  ret { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %21
}

define private void @"drop$189"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 144
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, ptr %22, align 16
  call void @"drop$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %23)
  %24 = add i64 %19, 144
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$189"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$371"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$371"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$189"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$372"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$371"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$372"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$371"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$373"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$372"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$373"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$372"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f4"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [56 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = add i64 %1, 1
  %17 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %18 = call ptr %17()
  %19 = icmp uge i64 %3, 0
  %20 = call i64 @llvm.usub.sat.i64(i64 %3, i64 0)
  br i1 %19, label %21, label %181

21:                                               ; preds = %6
  %22 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  %23 = extractvalue { { ptr, i32, i32, i32 } } %22, 0
  %24 = extractvalue { ptr, i32, i32, i32 } %23, 1
  %25 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %26 = sub i32 %25, %24
  %27 = icmp uge i32 %26, 1
  br i1 %27, label %28, label %158

28:                                               ; preds = %21
  %29 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %30 = load ptr, ptr %29, align 8
  %31 = zext i32 %24 to i64
  %32 = mul i64 %31, 32
  %33 = getelementptr inbounds i8, ptr %30, i64 %32
  %34 = add i32 %24, 1
  %35 = insertvalue { ptr, i32, i32, i32 } %23, i32 %34, 1
  %36 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %36, ptr %33, i64 32, i1 false)
  %37 = load i252, ptr %36, align 16
  call void @free(ptr %36)
  %38 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %35, 0
  %39 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f27"(i64 %16, i64 %20, { { ptr, i32, i32, i32 } } %38, { ptr, i32, i32, i32 } zeroinitializer, i252 %37)
  %40 = extractvalue { i64, i64, { i64, [56 x i8] } } %39, 0
  %41 = extractvalue { i64, i64, { i64, [56 x i8] } } %39, 1
  %42 = extractvalue { i64, i64, { i64, [56 x i8] } } %39, 2
  store { i64, [56 x i8] } %42, ptr %9, align 8
  %43 = load i1, ptr %9, align 1
  switch i1 %43, label %44 [
    i1 false, label %46
    i1 true, label %52
  ]

44:                                               ; preds = %28
  br i1 false, label %45, label %204

45:                                               ; preds = %44
  unreachable

46:                                               ; preds = %28
  %47 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %9, align 8
  %48 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %47, 1
  %49 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %48, 1
  store { i64, [24 x i8] } %50, ptr %11, align 8
  %51 = load i1, ptr %11, align 1
  switch i1 %51, label %63 [
    i1 false, label %65
    i1 true, label %73
  ]

52:                                               ; preds = %28
  %53 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %54 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %53, 1
  %55 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %54, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %55, ptr %10, align 8
  %56 = load { i64, [24 x i8] }, ptr %10, align 8
  %57 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %58 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %57, i64 %40, 1
  %59 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %58, i64 %2, 2
  %60 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %59, i64 %41, 3
  %61 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %60, ptr %4, 4
  %62 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %61, { i64, [24 x i8] } %56, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %62

63:                                               ; preds = %46
  br i1 false, label %64, label %205

64:                                               ; preds = %63
  unreachable

65:                                               ; preds = %46
  %66 = load { i1, { ptr, i32, i32, i32 } }, ptr %11, align 8
  %67 = extractvalue { i1, { ptr, i32, i32, i32 } } %66, 1
  %68 = extractvalue { { ptr, i32, i32, i32 } } %49, 0
  %69 = extractvalue { ptr, i32, i32, i32 } %68, 1
  %70 = extractvalue { ptr, i32, i32, i32 } %68, 2
  %71 = sub i32 %70, %69
  %72 = icmp uge i32 %71, 1
  br i1 %72, label %79, label %98

73:                                               ; preds = %46
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %49)
  %74 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %75 = call ptr %74()
  %76 = load i64, ptr %75, align 8
  %77 = mul i64 %76, 4060
  %78 = call i64 @llvm.uadd.sat.i64(i64 %41, i64 %77)
  br label %165

79:                                               ; preds = %65
  %80 = extractvalue { ptr, i32, i32, i32 } %68, 0
  %81 = load ptr, ptr %80, align 8
  %82 = zext i32 %69 to i64
  %83 = mul i64 %82, 32
  %84 = getelementptr inbounds i8, ptr %81, i64 %83
  %85 = add i32 %69, 1
  %86 = insertvalue { ptr, i32, i32, i32 } %68, i32 %85, 1
  %87 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %87, ptr %84, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %86)
  call void @"drop$409"(ptr %87)
  call void @"drop$189"({ ptr, i32, i32, i32 } %67)
  %88 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %89 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %88, 0
  %90 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %89, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %90, ptr %15, align 8
  %91 = load { i64, [24 x i8] }, ptr %15, align 8
  %92 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %93 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %92, i64 %40, 1
  %94 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %2, 2
  %95 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %41, 3
  %96 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %95, ptr %4, 4
  %97 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %91, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %97

98:                                               ; preds = %65
  %99 = phi { ptr, i32, i32, i32 } [ %68, %65 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %99)
  %100 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %101 = call ptr %100()
  %102 = add i64 %40, 1
  %103 = getelementptr inbounds i64, ptr %101, i32 1
  %104 = load i64, ptr %103, align 8
  %105 = load i64, ptr %101, align 8
  %106 = mul i64 %105, 84850
  %107 = add i64 %104, %106
  %108 = icmp uge i64 %41, %107
  %109 = call i64 @llvm.usub.sat.i64(i64 %41, i64 %107)
  br i1 %108, label %110, label %151

110:                                              ; preds = %98
  %111 = phi {} [ undef, %98 ]
  %112 = insertvalue { {} } undef, {} %111, 0
  %113 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f28"(i64 %102, i64 %109, i64 %0, i64 %2, ptr %4, { {} } %112, { ptr, i32, i32, i32 } %67)
  %114 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %113, 0
  %115 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %113, 1
  %116 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %113, 2
  %117 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %113, 3
  %118 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %113, 4
  %119 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %113, 5
  store { i64, [24 x i8] } %119, ptr %12, align 8
  %120 = load i1, ptr %12, align 1
  switch i1 %120, label %121 [
    i1 false, label %123
    i1 true, label %140
  ]

121:                                              ; preds = %110
  br i1 false, label %122, label %206

122:                                              ; preds = %121
  unreachable

123:                                              ; preds = %110
  %124 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %125 = call ptr %124()
  %126 = call i64 @llvm.uadd.sat.i64(i64 %115, i64 0)
  %127 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %128 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %127, 0
  %129 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %127, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %128)
  %130 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %129, 0
  %131 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %130, 0
  %132 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %131, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %132, ptr %14, align 8
  %133 = load { i64, [24 x i8] }, ptr %14, align 8
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %116, 0
  %135 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %134, i64 %114, 1
  %136 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %117, 2
  %137 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %126, 3
  %138 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %137, ptr %118, 4
  %139 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %138, { i64, [24 x i8] } %133, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %139

140:                                              ; preds = %110
  %141 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %142 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %141, 1
  %143 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %142, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %143, ptr %13, align 8
  %144 = load { i64, [24 x i8] }, ptr %13, align 8
  %145 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %116, 0
  %146 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %145, i64 %114, 1
  %147 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %146, i64 %117, 2
  %148 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %147, i64 %115, 3
  %149 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %148, ptr %118, 4
  %150 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %149, { i64, [24 x i8] } %144, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %150

151:                                              ; preds = %98
  %152 = phi { ptr, i32, i32, i32 } [ %67, %98 ]
  call void @"drop$189"({ ptr, i32, i32, i32 } %152)
  %153 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %154 = call ptr %153()
  %155 = load i64, ptr %154, align 8
  %156 = mul i64 %155, 2590
  %157 = call i64 @llvm.uadd.sat.i64(i64 %41, i64 %156)
  br label %188

158:                                              ; preds = %21
  %159 = phi { ptr, i32, i32, i32 } [ %23, %21 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %159)
  %160 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %161 = call ptr %160()
  %162 = load i64, ptr %161, align 8
  %163 = mul i64 %162, 7430
  %164 = call i64 @llvm.uadd.sat.i64(i64 %20, i64 %163)
  br label %165

165:                                              ; preds = %73, %158
  %166 = phi i64 [ %0, %158 ], [ %0, %73 ]
  %167 = phi i64 [ %2, %158 ], [ %2, %73 ]
  %168 = phi ptr [ %4, %158 ], [ %4, %73 ]
  %169 = phi i64 [ %16, %158 ], [ %40, %73 ]
  %170 = phi i64 [ %164, %158 ], [ %78, %73 ]
  %171 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %172 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %171, 0
  %173 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %172, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %173, ptr %8, align 8
  %174 = load { i64, [24 x i8] }, ptr %8, align 8
  %175 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %166, 0
  %176 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %175, i64 %169, 1
  %177 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %176, i64 %167, 2
  %178 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %177, i64 %170, 3
  %179 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %178, ptr %168, 4
  %180 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %179, { i64, [24 x i8] } %174, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %180

181:                                              ; preds = %6
  %182 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %182)
  %183 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %184 = call ptr %183()
  %185 = load i64, ptr %184, align 8
  %186 = mul i64 %185, 7630
  %187 = call i64 @llvm.uadd.sat.i64(i64 %3, i64 %186)
  br label %188

188:                                              ; preds = %151, %181
  %189 = phi i64 [ %0, %181 ], [ %0, %151 ]
  %190 = phi i64 [ %2, %181 ], [ %2, %151 ]
  %191 = phi ptr [ %4, %181 ], [ %4, %151 ]
  %192 = phi i64 [ %16, %181 ], [ %102, %151 ]
  %193 = phi i64 [ %187, %181 ], [ %157, %151 ]
  %194 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %195 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %194, 0
  %196 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %195, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %196, ptr %7, align 8
  %197 = load { i64, [24 x i8] }, ptr %7, align 8
  %198 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %189, 0
  %199 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %198, i64 %192, 1
  %200 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %199, i64 %190, 2
  %201 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %200, i64 %193, 3
  %202 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %201, ptr %191, 4
  %203 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %202, { i64, [24 x i8] } %197, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %203

204:                                              ; preds = %44
  call void @puts(ptr @assert_msg_14)
  call void @abort()
  unreachable

205:                                              ; preds = %63
  call void @puts(ptr @assert_msg_15)
  call void @abort()
  unreachable

206:                                              ; preds = %121
  call void @puts(ptr @assert_msg_16)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f4(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f4"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f4(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f4(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f5"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca { i1, [47 x i8] }, i64 1, align 16
  %12 = alloca i64, i64 1, align 8
  %13 = alloca i252, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = icmp uge i64 %2, 0
  %21 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %20, label %22, label %251

22:                                               ; preds = %5
  %23 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %24 = extractvalue { { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  %28 = icmp uge i32 %27, 1
  br i1 %28, label %29, label %230

29:                                               ; preds = %22
  %30 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %31 = load ptr, ptr %30, align 8
  %32 = zext i32 %25 to i64
  %33 = mul i64 %32, 32
  %34 = getelementptr inbounds i8, ptr %31, i64 %33
  %35 = add i32 %25, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %24, i32 %35, 1
  %37 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %37, ptr %34, i64 32, i1 false)
  %38 = load i252, ptr %37, align 16
  call void @free(ptr %37)
  %39 = add i64 %1, 4
  %40 = icmp ult i252 %38, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %40, label %41, label %223

41:                                               ; preds = %29
  %42 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %65

47:                                               ; preds = %41
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %54)
  call void @"drop$409"(ptr %55)
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %57, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %58, ptr %16, align 8
  %59 = load { i64, [24 x i8] }, ptr %16, align 8
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, i64 %39, 1
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %21, 2
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, ptr %3, 3
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, { i64, [24 x i8] } %59, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %64

65:                                               ; preds = %41
  %66 = phi { ptr, i32, i32, i32 } [ %42, %41 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %66)
  %67 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %68 = call ptr %67()
  %69 = add i64 %1, 5
  %70 = getelementptr inbounds i64, ptr %68, i32 1
  %71 = load i64, ptr %70, align 8
  %72 = load i64, ptr %68, align 8
  %73 = mul i64 %72, 7560
  %74 = add i64 %71, %73
  %75 = icmp uge i64 %21, %74
  %76 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %74)
  br i1 %75, label %77, label %216

77:                                               ; preds = %65
  %78 = phi i252 [ %38, %65 ]
  %79 = add i64 %0, 3
  %80 = zext i252 %78 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %8, align 16
  store i256 %80, ptr %9, align 16
  %81 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %81(ptr %10, ptr %8, ptr %9)
  %82 = load i256, ptr %10, align 16
  %83 = trunc i256 %82 to i252
  %84 = add i64 %1, 8
  %85 = sub i252 %83, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %86 = icmp ult i252 %83, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %87 = select i1 %86, i252 %83, i252 %85
  %88 = load ptr, ptr %3, align 8
  store i64 %76, ptr %12, align 8
  store i252 %87, ptr %13, align 16
  %89 = getelementptr inbounds ptr, ptr %3, i32 8
  %90 = load ptr, ptr %89, align 8
  call void %90(ptr %11, ptr %88, ptr %12, i32 0, ptr %13)
  %91 = load { i1, [47 x i8] }, ptr %11, align 1
  %92 = extractvalue { i1, [47 x i8] } %91, 0
  %93 = getelementptr inbounds i8, ptr %11, i32 16
  %94 = load i252, ptr %93, align 16
  %95 = getelementptr inbounds i8, ptr %11, i32 8
  %96 = load { ptr, i32, i32, i32 }, ptr %95, align 8
  %97 = load i64, ptr %12, align 8
  br i1 %92, label %204, label %98

98:                                               ; preds = %77
  %99 = phi i252 [ %94, %77 ]
  %100 = icmp eq i252 %99, 0
  br i1 %100, label %101, label %106

101:                                              ; preds = %98
  %102 = phi i64 [ %97, %98 ]
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 0)
  br label %113

106:                                              ; preds = %98
  %107 = phi i64 [ %97, %98 ]
  %108 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %109 = call ptr %108()
  %110 = load i64, ptr %109, align 8
  %111 = mul i64 %110, 100
  %112 = call i64 @llvm.uadd.sat.i64(i64 %107, i64 %111)
  br label %113

113:                                              ; preds = %101, %106
  %114 = phi i64 [ %79, %106 ], [ %79, %101 ]
  %115 = phi i64 [ %84, %106 ], [ %84, %101 ]
  %116 = phi ptr [ %3, %106 ], [ %3, %101 ]
  %117 = phi i64 [ %112, %106 ], [ %105, %101 ]
  %118 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %106 ], [ { i1 true, [0 x i8] undef }, %101 ]
  %119 = extractvalue { i1, [0 x i8] } %118, 0
  %120 = xor i1 %119, true
  switch i1 %120, label %121 [
    i1 false, label %123
    i1 true, label %128
  ]

121:                                              ; preds = %113
  br i1 false, label %122, label %272

122:                                              ; preds = %121
  unreachable

123:                                              ; preds = %113
  %124 = phi i64 [ %117, %113 ]
  %125 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %126 = call ptr %125()
  %127 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 0)
  br label %135

128:                                              ; preds = %113
  %129 = phi i64 [ %117, %113 ]
  %130 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %131 = call ptr %130()
  %132 = load i64, ptr %131, align 8
  %133 = mul i64 %132, 100
  %134 = call i64 @llvm.uadd.sat.i64(i64 %129, i64 %133)
  br label %135

135:                                              ; preds = %123, %128
  %136 = phi i64 [ %114, %128 ], [ %114, %123 ]
  %137 = phi i64 [ %115, %128 ], [ %115, %123 ]
  %138 = phi ptr [ %116, %128 ], [ %116, %123 ]
  %139 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %128 ], [ zeroinitializer, %123 ]
  %140 = phi i64 [ %134, %128 ], [ %127, %123 ]
  %141 = phi i252 [ 1, %128 ], [ 0, %123 ]
  %142 = extractvalue { ptr, i32, i32, i32 } %139, 3
  %143 = icmp eq i32 %142, 0
  br i1 %143, label %144, label %158

144:                                              ; preds = %135
  %145 = shl i32 %142, 1
  %146 = call i32 @llvm.umin.i32(i32 %145, i32 1024)
  %147 = add i32 %146, %142
  %148 = call i32 @llvm.umax.i32(i32 %147, i32 8)
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 32
  %151 = add i64 %150, 16
  %152 = call ptr @realloc(ptr null, i64 %151)
  store i32 1, ptr %152, align 4
  %153 = getelementptr inbounds i8, ptr %152, i32 4
  store i32 0, ptr %153, align 4
  %154 = getelementptr inbounds i8, ptr %152, i32 16
  %155 = call ptr @realloc(ptr null, i64 8)
  store ptr %154, ptr %155, align 8
  %156 = insertvalue { ptr, i32, i32, i32 } %139, ptr %155, 0
  %157 = insertvalue { ptr, i32, i32, i32 } %156, i32 %148, 3
  br label %179

158:                                              ; preds = %135
  %159 = extractvalue { ptr, i32, i32, i32 } %139, 2
  %160 = icmp ult i32 %159, %142
  br i1 %160, label %161, label %162

161:                                              ; preds = %158
  br label %176

162:                                              ; preds = %158
  %163 = shl i32 %142, 1
  %164 = call i32 @llvm.umin.i32(i32 %163, i32 1024)
  %165 = add i32 %164, %142
  %166 = call i32 @llvm.umax.i32(i32 %165, i32 8)
  %167 = zext i32 %166 to i64
  %168 = mul i64 %167, 32
  %169 = add i64 %168, 16
  %170 = extractvalue { ptr, i32, i32, i32 } %139, 0
  %171 = load ptr, ptr %170, align 8
  %172 = getelementptr inbounds i8, ptr %171, i32 -16
  %173 = call ptr @realloc(ptr %172, i64 %169)
  %174 = getelementptr inbounds i8, ptr %173, i32 16
  store ptr %174, ptr %170, align 8
  %175 = insertvalue { ptr, i32, i32, i32 } %139, i32 %166, 3
  br label %176

176:                                              ; preds = %161, %162
  %177 = phi { ptr, i32, i32, i32 } [ %175, %162 ], [ %139, %161 ]
  br label %178

178:                                              ; preds = %176
  br label %179

179:                                              ; preds = %144, %178
  %180 = phi { ptr, i32, i32, i32 } [ %177, %178 ], [ %157, %144 ]
  br label %181

181:                                              ; preds = %179
  %182 = extractvalue { ptr, i32, i32, i32 } %180, 0
  %183 = load ptr, ptr %182, align 8
  %184 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %185 = zext i32 %184 to i64
  %186 = mul i64 %185, 32
  %187 = getelementptr inbounds i8, ptr %183, i64 %186
  store i252 %141, ptr %187, align 16
  %188 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %189 = add i32 %188, 1
  %190 = insertvalue { ptr, i32, i32, i32 } %180, i32 %189, 2
  %191 = getelementptr inbounds i8, ptr %183, i32 -12
  store i32 %189, ptr %191, align 4
  %192 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %190)
  %193 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %192, 0
  %194 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %192, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %193)
  %195 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %194, 0
  %196 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %195, 0
  %197 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %196, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %197, ptr %15, align 8
  %198 = load { i64, [24 x i8] }, ptr %15, align 8
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %136, 0
  %200 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %199, i64 %137, 1
  %201 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %200, i64 %140, 2
  %202 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, ptr %138, 3
  %203 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %202, { i64, [24 x i8] } %198, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %203

204:                                              ; preds = %77
  %205 = phi {} [ undef, %77 ]
  %206 = phi { ptr, i32, i32, i32 } [ %96, %77 ]
  %207 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %205, 0
  %208 = insertvalue { {}, { ptr, i32, i32, i32 } } %207, { ptr, i32, i32, i32 } %206, 1
  %209 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %208, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %209, ptr %14, align 8
  %210 = load { i64, [24 x i8] }, ptr %14, align 8
  %211 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %79, 0
  %212 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %211, i64 %84, 1
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %212, i64 %97, 2
  %214 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %213, ptr %3, 3
  %215 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %214, { i64, [24 x i8] } %210, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %215

216:                                              ; preds = %65
  %217 = phi i64 [ %21, %65 ]
  %218 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %219 = call ptr %218()
  %220 = load i64, ptr %219, align 8
  %221 = mul i64 %220, 4850
  %222 = call i64 @llvm.uadd.sat.i64(i64 %217, i64 %221)
  br label %258

223:                                              ; preds = %29
  %224 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %224)
  %225 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %226 = call ptr %225()
  %227 = load i64, ptr %226, align 8
  %228 = mul i64 %227, 6320
  %229 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %228)
  br label %237

230:                                              ; preds = %22
  %231 = phi { ptr, i32, i32, i32 } [ %24, %22 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %231)
  %232 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %233 = call ptr %232()
  %234 = load i64, ptr %233, align 8
  %235 = mul i64 %234, 7530
  %236 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %235)
  br label %237

237:                                              ; preds = %223, %230
  %238 = phi i64 [ %0, %230 ], [ %0, %223 ]
  %239 = phi ptr [ %3, %230 ], [ %3, %223 ]
  %240 = phi i64 [ %17, %230 ], [ %39, %223 ]
  %241 = phi i64 [ %236, %230 ], [ %229, %223 ]
  %242 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %243 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %242, 0
  %244 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %243, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %244, ptr %7, align 8
  %245 = load { i64, [24 x i8] }, ptr %7, align 8
  %246 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %238, 0
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %246, i64 %240, 1
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %241, 2
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, ptr %239, 3
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, { i64, [24 x i8] } %245, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %250

251:                                              ; preds = %5
  %252 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %252)
  %253 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %254 = call ptr %253()
  %255 = load i64, ptr %254, align 8
  %256 = mul i64 %255, 7730
  %257 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %256)
  br label %258

258:                                              ; preds = %216, %251
  %259 = phi i64 [ %0, %251 ], [ %0, %216 ]
  %260 = phi ptr [ %3, %251 ], [ %3, %216 ]
  %261 = phi i64 [ %17, %251 ], [ %69, %216 ]
  %262 = phi i64 [ %257, %251 ], [ %222, %216 ]
  %263 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %264 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %263, 0
  %265 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %264, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %265, ptr %6, align 8
  %266 = load { i64, [24 x i8] }, ptr %6, align 8
  %267 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %259, 0
  %268 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %267, i64 %261, 1
  %269 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %268, i64 %262, 2
  %270 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %269, ptr %260, 3
  %271 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %270, { i64, [24 x i8] } %266, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %271

272:                                              ; preds = %121
  call void @puts(ptr @assert_msg_17)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f5(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f5"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f5(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f5(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$360"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$360"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { {} } }, ptr %2, align 1
  %6 = extractvalue { i1, { {} } } %5, 1
  %7 = insertvalue { i1, { {} } } %5, { {} } %6, 1
  store { i1, { {} } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { {} } } %5, { {} } %6, 1
  store { i1, { {} } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$358"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$358"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { {}, {} } }, ptr %2, align 1
  %6 = extractvalue { i1, { {}, {} } } %5, 1
  %7 = insertvalue { i1, { {}, {} } } %5, { {}, {} } %6, 1
  store { i1, { {}, {} } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { {}, {} } } %5, { {}, {} } %6, 1
  store { i1, { {}, {} } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f6"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = add i64 %1, 1
  %16 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %17 = call ptr %16()
  %18 = icmp uge i64 %2, 0
  %19 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %18, label %20, label %217

20:                                               ; preds = %5
  %21 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %22 = extractvalue { { ptr, i32, i32, i32 } } %21, 0
  %23 = extractvalue { ptr, i32, i32, i32 } %22, 1
  %24 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %25 = sub i32 %24, %23
  %26 = icmp uge i32 %25, 1
  br i1 %26, label %27, label %196

27:                                               ; preds = %20
  %28 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %29 = load ptr, ptr %28, align 8
  %30 = zext i32 %23 to i64
  %31 = mul i64 %30, 32
  %32 = getelementptr inbounds i8, ptr %29, i64 %31
  %33 = add i32 %23, 1
  %34 = insertvalue { ptr, i32, i32, i32 } %22, i32 %33, 1
  %35 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %35, ptr %32, i64 32, i1 false)
  %36 = load i252, ptr %35, align 16
  call void @free(ptr %35)
  %37 = add i64 %1, 4
  %38 = icmp ult i252 %36, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %38, label %39, label %189

39:                                               ; preds = %27
  %40 = phi { ptr, i32, i32, i32 } [ %34, %27 ]
  %41 = extractvalue { ptr, i32, i32, i32 } %40, 1
  %42 = extractvalue { ptr, i32, i32, i32 } %40, 2
  %43 = sub i32 %42, %41
  %44 = icmp uge i32 %43, 1
  br i1 %44, label %45, label %178

45:                                               ; preds = %39
  %46 = extractvalue { ptr, i32, i32, i32 } %40, 0
  %47 = load ptr, ptr %46, align 8
  %48 = zext i32 %41 to i64
  %49 = mul i64 %48, 32
  %50 = getelementptr inbounds i8, ptr %47, i64 %49
  %51 = add i32 %41, 1
  %52 = insertvalue { ptr, i32, i32, i32 } %40, i32 %51, 1
  %53 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %53, ptr %50, i64 32, i1 false)
  %54 = load i252, ptr %53, align 16
  call void @free(ptr %53)
  %55 = icmp eq i252 %54, 0
  br i1 %55, label %56, label %63

56:                                               ; preds = %45
  %57 = phi i64 [ %19, %45 ]
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = load i64, ptr %59, align 8
  %61 = mul i64 %60, 3650
  %62 = call i64 @llvm.uadd.sat.i64(i64 %57, i64 %61)
  br label %70

63:                                               ; preds = %45
  %64 = phi i64 [ %19, %45 ]
  %65 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %66 = call ptr %65()
  %67 = load i64, ptr %66, align 8
  %68 = mul i64 %67, 3750
  %69 = call i64 @llvm.uadd.sat.i64(i64 %64, i64 %68)
  br label %70

70:                                               ; preds = %56, %63
  %71 = phi i64 [ %0, %63 ], [ %0, %56 ]
  %72 = phi ptr [ %3, %63 ], [ %3, %56 ]
  %73 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %63 ], [ { i1 true, [0 x i8] undef }, %56 ]
  %74 = phi i64 [ %37, %63 ], [ %37, %56 ]
  %75 = phi i252 [ %36, %63 ], [ %36, %56 ]
  %76 = phi { ptr, i32, i32, i32 } [ %52, %63 ], [ %52, %56 ]
  %77 = phi i64 [ %69, %63 ], [ %62, %56 ]
  %78 = extractvalue { ptr, i32, i32, i32 } %76, 1
  %79 = extractvalue { ptr, i32, i32, i32 } %76, 2
  %80 = sub i32 %79, %78
  %81 = icmp uge i32 %80, 1
  br i1 %81, label %82, label %100

82:                                               ; preds = %70
  %83 = extractvalue { ptr, i32, i32, i32 } %76, 0
  %84 = load ptr, ptr %83, align 8
  %85 = zext i32 %78 to i64
  %86 = mul i64 %85, 32
  %87 = getelementptr inbounds i8, ptr %84, i64 %86
  %88 = add i32 %78, 1
  %89 = insertvalue { ptr, i32, i32, i32 } %76, i32 %88, 1
  %90 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %90, ptr %87, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %89)
  call void @"drop$409"(ptr %90)
  %91 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %92 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %91, 0
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %14, align 8
  %94 = load { i64, [24 x i8] }, ptr %14, align 8
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %71, 0
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %74, 1
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %77, 2
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, ptr %72, 3
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %94, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %70
  %101 = phi { ptr, i32, i32, i32 } [ %76, %70 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %101)
  %102 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %103 = call ptr %102()
  %104 = add i64 %74, 1
  %105 = getelementptr inbounds i64, ptr %103, i32 1
  %106 = load i64, ptr %105, align 8
  %107 = mul i64 %106, 2
  %108 = load i64, ptr %103, align 8
  %109 = mul i64 %108, 70340
  %110 = add i64 %107, %109
  %111 = icmp uge i64 %77, %110
  %112 = call i64 @llvm.usub.sat.i64(i64 %77, i64 %110)
  br i1 %111, label %113, label %173

113:                                              ; preds = %100
  %114 = phi {} [ undef, %100 ]
  %115 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %104, i64 %112, i64 %71, ptr %72, {} %114)
  %116 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, 0
  %117 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, 1
  %118 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, 2
  %119 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, 3
  %120 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, 4
  store { i64, [24 x i8] } %120, ptr %9, align 8
  %121 = load i1, ptr %9, align 1
  switch i1 %121, label %122 [
    i1 false, label %124
    i1 true, label %135
  ]

122:                                              ; preds = %113
  br i1 false, label %123, label %238

123:                                              ; preds = %122
  unreachable

124:                                              ; preds = %113
  %125 = extractvalue { i1, [0 x i8] } %73, 0
  %126 = xor i1 %125, true
  %127 = insertvalue { i1, [0 x i8] } undef, i1 %126, 0
  %128 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %116, i64 %117, i64 %118, ptr %119, {} %114, i252 %75, { i1, [0 x i8] } %127)
  %129 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, 0
  %130 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, 1
  %131 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, 2
  %132 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, 3
  %133 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, 4
  store { i64, [24 x i8] } %133, ptr %11, align 8
  %134 = load i1, ptr %11, align 1
  switch i1 %134, label %145 [
    i1 false, label %147
    i1 true, label %163
  ]

135:                                              ; preds = %113
  %136 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %137 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %136, 1
  %138 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %137, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %138, ptr %10, align 8
  %139 = load { i64, [24 x i8] }, ptr %10, align 8
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %118, 0
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %140, i64 %116, 1
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, i64 %117, 2
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, ptr %119, 3
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, { i64, [24 x i8] } %139, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %144

145:                                              ; preds = %124
  br i1 false, label %146, label %239

146:                                              ; preds = %145
  unreachable

147:                                              ; preds = %124
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = call i64 @llvm.uadd.sat.i64(i64 %130, i64 0)
  %151 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %152 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %151, 0
  %153 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %151, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %152)
  %154 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %153, 0
  %155 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %154, 0
  %156 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %155, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %156, ptr %13, align 8
  %157 = load { i64, [24 x i8] }, ptr %13, align 8
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %131, 0
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %158, i64 %129, 1
  %160 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %159, i64 %150, 2
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %160, ptr %132, 3
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, { i64, [24 x i8] } %157, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %162

163:                                              ; preds = %124
  %164 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %165 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %164, 1
  %166 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %165, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %166, ptr %12, align 8
  %167 = load { i64, [24 x i8] }, ptr %12, align 8
  %168 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %131, 0
  %169 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %168, i64 %129, 1
  %170 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %169, i64 %130, 2
  %171 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %170, ptr %132, 3
  %172 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %171, { i64, [24 x i8] } %167, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %172

173:                                              ; preds = %100
  %174 = phi i64 [ %77, %100 ]
  %175 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %176 = call ptr %175()
  %177 = call i64 @llvm.uadd.sat.i64(i64 %174, i64 0)
  br label %224

178:                                              ; preds = %39
  %179 = phi { ptr, i32, i32, i32 } [ %40, %39 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %179)
  %180 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %181 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %180, 0
  %182 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %181, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %182, ptr %8, align 8
  %183 = load { i64, [24 x i8] }, ptr %8, align 8
  %184 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %185 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %184, i64 %37, 1
  %186 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %185, i64 %19, 2
  %187 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %186, ptr %3, 3
  %188 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %187, { i64, [24 x i8] } %183, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %188

189:                                              ; preds = %27
  %190 = phi { ptr, i32, i32, i32 } [ %34, %27 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %190)
  %191 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %192 = call ptr %191()
  %193 = load i64, ptr %192, align 8
  %194 = mul i64 %193, 6210
  %195 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %194)
  br label %203

196:                                              ; preds = %20
  %197 = phi { ptr, i32, i32, i32 } [ %22, %20 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %197)
  %198 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %199 = call ptr %198()
  %200 = load i64, ptr %199, align 8
  %201 = mul i64 %200, 7410
  %202 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %201)
  br label %203

203:                                              ; preds = %189, %196
  %204 = phi i64 [ %0, %196 ], [ %0, %189 ]
  %205 = phi ptr [ %3, %196 ], [ %3, %189 ]
  %206 = phi i64 [ %15, %196 ], [ %37, %189 ]
  %207 = phi i64 [ %202, %196 ], [ %195, %189 ]
  %208 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %209 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %208, 0
  %210 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %209, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %210, ptr %7, align 8
  %211 = load { i64, [24 x i8] }, ptr %7, align 8
  %212 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %204, 0
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %212, i64 %206, 1
  %214 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %213, i64 %207, 2
  %215 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %214, ptr %205, 3
  %216 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %215, { i64, [24 x i8] } %211, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %216

217:                                              ; preds = %5
  %218 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %218)
  %219 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %220 = call ptr %219()
  %221 = load i64, ptr %220, align 8
  %222 = mul i64 %221, 7610
  %223 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %222)
  br label %224

224:                                              ; preds = %173, %217
  %225 = phi i64 [ %0, %217 ], [ %71, %173 ]
  %226 = phi ptr [ %3, %217 ], [ %72, %173 ]
  %227 = phi i64 [ %15, %217 ], [ %104, %173 ]
  %228 = phi i64 [ %223, %217 ], [ %177, %173 ]
  %229 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %230 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %229, 0
  %231 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %230, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %231, ptr %6, align 8
  %232 = load { i64, [24 x i8] }, ptr %6, align 8
  %233 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %225, 0
  %234 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %233, i64 %227, 1
  %235 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %234, i64 %228, 2
  %236 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %235, ptr %226, 3
  %237 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %236, { i64, [24 x i8] } %232, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %237

238:                                              ; preds = %122
  call void @puts(ptr @assert_msg_18)
  call void @abort()
  unreachable

239:                                              ; preds = %145
  call void @puts(ptr @assert_msg_19)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f6(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f6"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f6(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f6(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f7"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = add i64 %1, 1
  %15 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %16 = call ptr %15()
  %17 = icmp uge i64 %2, 0
  %18 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %17, label %19, label %167

19:                                               ; preds = %5
  %20 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %21 = extractvalue { { ptr, i32, i32, i32 } } %20, 0
  %22 = extractvalue { ptr, i32, i32, i32 } %21, 1
  %23 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %24 = sub i32 %23, %22
  %25 = icmp uge i32 %24, 1
  br i1 %25, label %26, label %146

26:                                               ; preds = %19
  %27 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %28 = load ptr, ptr %27, align 8
  %29 = zext i32 %22 to i64
  %30 = mul i64 %29, 32
  %31 = getelementptr inbounds i8, ptr %28, i64 %30
  %32 = add i32 %22, 1
  %33 = insertvalue { ptr, i32, i32, i32 } %21, i32 %32, 1
  %34 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %34, ptr %31, i64 32, i1 false)
  %35 = load i252, ptr %34, align 16
  call void @free(ptr %34)
  %36 = add i64 %1, 4
  %37 = icmp ult i252 %35, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %37, label %38, label %139

38:                                               ; preds = %26
  %39 = phi { ptr, i32, i32, i32 } [ %33, %26 ]
  %40 = extractvalue { ptr, i32, i32, i32 } %39, 1
  %41 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %42 = sub i32 %41, %40
  %43 = icmp uge i32 %42, 1
  br i1 %43, label %44, label %62

44:                                               ; preds = %38
  %45 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %46 = load ptr, ptr %45, align 8
  %47 = zext i32 %40 to i64
  %48 = mul i64 %47, 32
  %49 = getelementptr inbounds i8, ptr %46, i64 %48
  %50 = add i32 %40, 1
  %51 = insertvalue { ptr, i32, i32, i32 } %39, i32 %50, 1
  %52 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %52, ptr %49, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %51)
  call void @"drop$409"(ptr %52)
  %53 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %54 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %53, 0
  %55 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %54, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %55, ptr %13, align 8
  %56 = load { i64, [24 x i8] }, ptr %13, align 8
  %57 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %58 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %57, i64 %36, 1
  %59 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %58, i64 %18, 2
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, ptr %3, 3
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, { i64, [24 x i8] } %56, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %61

62:                                               ; preds = %38
  %63 = phi { ptr, i32, i32, i32 } [ %39, %38 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %63)
  %64 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %65 = call ptr %64()
  %66 = add i64 %1, 5
  %67 = getelementptr inbounds i64, ptr %65, i32 1
  %68 = load i64, ptr %67, align 8
  %69 = mul i64 %68, 2
  %70 = load i64, ptr %65, align 8
  %71 = mul i64 %70, 65590
  %72 = add i64 %69, %71
  %73 = icmp uge i64 %18, %72
  %74 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %72)
  br i1 %73, label %75, label %132

75:                                               ; preds = %62
  %76 = phi {} [ undef, %62 ]
  %77 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %66, i64 %74, i64 %0, ptr %3, {} %76)
  %78 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 0
  %79 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 1
  %80 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 2
  %81 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 3
  %82 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 4
  store { i64, [24 x i8] } %82, ptr %8, align 8
  %83 = load i1, ptr %8, align 1
  switch i1 %83, label %84 [
    i1 false, label %86
    i1 true, label %94
  ]

84:                                               ; preds = %75
  br i1 false, label %85, label %188

85:                                               ; preds = %84
  unreachable

86:                                               ; preds = %75
  %87 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %78, i64 %79, i64 %80, ptr %81, {} %76, i252 %35, { i1, [0 x i8] } { i1 true, [0 x i8] undef })
  %88 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 0
  %89 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 1
  %90 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 2
  %91 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 3
  %92 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 4
  store { i64, [24 x i8] } %92, ptr %10, align 8
  %93 = load i1, ptr %10, align 1
  switch i1 %93, label %104 [
    i1 false, label %106
    i1 true, label %122
  ]

94:                                               ; preds = %75
  %95 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %96 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %95, 1
  %97 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %96, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %97, ptr %9, align 8
  %98 = load { i64, [24 x i8] }, ptr %9, align 8
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %80, 0
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %78, 1
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %79, 2
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, ptr %81, 3
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, { i64, [24 x i8] } %98, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %103

104:                                              ; preds = %86
  br i1 false, label %105, label %189

105:                                              ; preds = %104
  unreachable

106:                                              ; preds = %86
  %107 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %108 = call ptr %107()
  %109 = call i64 @llvm.uadd.sat.i64(i64 %89, i64 0)
  %110 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %111 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %110, 0
  %112 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %110, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %111)
  %113 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %112, 0
  %114 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %113, 0
  %115 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %114, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %115, ptr %12, align 8
  %116 = load { i64, [24 x i8] }, ptr %12, align 8
  %117 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %90, 0
  %118 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %117, i64 %88, 1
  %119 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %118, i64 %109, 2
  %120 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %119, ptr %91, 3
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %120, { i64, [24 x i8] } %116, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %121

122:                                              ; preds = %86
  %123 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %124 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %123, 1
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %11, align 8
  %126 = load { i64, [24 x i8] }, ptr %11, align 8
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %90, 0
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %88, 1
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %89, 2
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, ptr %91, 3
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %126, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %131

132:                                              ; preds = %62
  %133 = phi i64 [ %18, %62 ]
  %134 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %135 = call ptr %134()
  %136 = load i64, ptr %135, align 8
  %137 = mul i64 %136, 4650
  %138 = call i64 @llvm.uadd.sat.i64(i64 %133, i64 %137)
  br label %174

139:                                              ; preds = %26
  %140 = phi { ptr, i32, i32, i32 } [ %33, %26 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %140)
  %141 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %142 = call ptr %141()
  %143 = load i64, ptr %142, align 8
  %144 = mul i64 %143, 6220
  %145 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %144)
  br label %153

146:                                              ; preds = %19
  %147 = phi { ptr, i32, i32, i32 } [ %21, %19 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %147)
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = load i64, ptr %149, align 8
  %151 = mul i64 %150, 7420
  %152 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %151)
  br label %153

153:                                              ; preds = %139, %146
  %154 = phi i64 [ %0, %146 ], [ %0, %139 ]
  %155 = phi ptr [ %3, %146 ], [ %3, %139 ]
  %156 = phi i64 [ %14, %146 ], [ %36, %139 ]
  %157 = phi i64 [ %152, %146 ], [ %145, %139 ]
  %158 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %159 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %158, 0
  %160 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %159, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %160, ptr %7, align 8
  %161 = load { i64, [24 x i8] }, ptr %7, align 8
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %154, 0
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, i64 %156, 1
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %163, i64 %157, 2
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %164, ptr %155, 3
  %166 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %165, { i64, [24 x i8] } %161, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %166

167:                                              ; preds = %5
  %168 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %168)
  %169 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %170 = call ptr %169()
  %171 = load i64, ptr %170, align 8
  %172 = mul i64 %171, 7620
  %173 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %172)
  br label %174

174:                                              ; preds = %132, %167
  %175 = phi i64 [ %0, %167 ], [ %0, %132 ]
  %176 = phi ptr [ %3, %167 ], [ %3, %132 ]
  %177 = phi i64 [ %14, %167 ], [ %66, %132 ]
  %178 = phi i64 [ %173, %167 ], [ %138, %132 ]
  %179 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %180 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %179, 0
  %181 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %180, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %181, ptr %6, align 8
  %182 = load { i64, [24 x i8] }, ptr %6, align 8
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %175, 0
  %184 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %183, i64 %177, 1
  %185 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %184, i64 %178, 2
  %186 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %185, ptr %176, 3
  %187 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %186, { i64, [24 x i8] } %182, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %187

188:                                              ; preds = %84
  call void @puts(ptr @assert_msg_20)
  call void @abort()
  unreachable

189:                                              ; preds = %104
  call void @puts(ptr @assert_msg_21)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f7(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f7"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f7(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f7(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f8"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = add i64 %1, 1
  %15 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %16 = call ptr %15()
  %17 = icmp uge i64 %2, 0
  %18 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %17, label %19, label %167

19:                                               ; preds = %5
  %20 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %21 = extractvalue { { ptr, i32, i32, i32 } } %20, 0
  %22 = extractvalue { ptr, i32, i32, i32 } %21, 1
  %23 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %24 = sub i32 %23, %22
  %25 = icmp uge i32 %24, 1
  br i1 %25, label %26, label %146

26:                                               ; preds = %19
  %27 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %28 = load ptr, ptr %27, align 8
  %29 = zext i32 %22 to i64
  %30 = mul i64 %29, 32
  %31 = getelementptr inbounds i8, ptr %28, i64 %30
  %32 = add i32 %22, 1
  %33 = insertvalue { ptr, i32, i32, i32 } %21, i32 %32, 1
  %34 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %34, ptr %31, i64 32, i1 false)
  %35 = load i252, ptr %34, align 16
  call void @free(ptr %34)
  %36 = add i64 %1, 4
  %37 = icmp ult i252 %35, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %37, label %38, label %139

38:                                               ; preds = %26
  %39 = phi { ptr, i32, i32, i32 } [ %33, %26 ]
  %40 = extractvalue { ptr, i32, i32, i32 } %39, 1
  %41 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %42 = sub i32 %41, %40
  %43 = icmp uge i32 %42, 1
  br i1 %43, label %44, label %62

44:                                               ; preds = %38
  %45 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %46 = load ptr, ptr %45, align 8
  %47 = zext i32 %40 to i64
  %48 = mul i64 %47, 32
  %49 = getelementptr inbounds i8, ptr %46, i64 %48
  %50 = add i32 %40, 1
  %51 = insertvalue { ptr, i32, i32, i32 } %39, i32 %50, 1
  %52 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %52, ptr %49, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %51)
  call void @"drop$409"(ptr %52)
  %53 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %54 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %53, 0
  %55 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %54, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %55, ptr %13, align 8
  %56 = load { i64, [24 x i8] }, ptr %13, align 8
  %57 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %58 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %57, i64 %36, 1
  %59 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %58, i64 %18, 2
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, ptr %3, 3
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, { i64, [24 x i8] } %56, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %61

62:                                               ; preds = %38
  %63 = phi { ptr, i32, i32, i32 } [ %39, %38 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %63)
  %64 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %65 = call ptr %64()
  %66 = add i64 %1, 5
  %67 = getelementptr inbounds i64, ptr %65, i32 1
  %68 = load i64, ptr %67, align 8
  %69 = mul i64 %68, 2
  %70 = load i64, ptr %65, align 8
  %71 = mul i64 %70, 65590
  %72 = add i64 %69, %71
  %73 = icmp uge i64 %18, %72
  %74 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %72)
  br i1 %73, label %75, label %132

75:                                               ; preds = %62
  %76 = phi {} [ undef, %62 ]
  %77 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %66, i64 %74, i64 %0, ptr %3, {} %76)
  %78 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 0
  %79 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 1
  %80 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 2
  %81 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 3
  %82 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, 4
  store { i64, [24 x i8] } %82, ptr %8, align 8
  %83 = load i1, ptr %8, align 1
  switch i1 %83, label %84 [
    i1 false, label %86
    i1 true, label %94
  ]

84:                                               ; preds = %75
  br i1 false, label %85, label %188

85:                                               ; preds = %84
  unreachable

86:                                               ; preds = %75
  %87 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %78, i64 %79, i64 %80, ptr %81, {} %76, i252 %35, { i1, [0 x i8] } { i1 false, [0 x i8] undef })
  %88 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 0
  %89 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 1
  %90 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 2
  %91 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 3
  %92 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, 4
  store { i64, [24 x i8] } %92, ptr %10, align 8
  %93 = load i1, ptr %10, align 1
  switch i1 %93, label %104 [
    i1 false, label %106
    i1 true, label %122
  ]

94:                                               ; preds = %75
  %95 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %96 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %95, 1
  %97 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %96, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %97, ptr %9, align 8
  %98 = load { i64, [24 x i8] }, ptr %9, align 8
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %80, 0
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %78, 1
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %79, 2
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, ptr %81, 3
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, { i64, [24 x i8] } %98, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %103

104:                                              ; preds = %86
  br i1 false, label %105, label %189

105:                                              ; preds = %104
  unreachable

106:                                              ; preds = %86
  %107 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %108 = call ptr %107()
  %109 = call i64 @llvm.uadd.sat.i64(i64 %89, i64 0)
  %110 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %111 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %110, 0
  %112 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %110, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %111)
  %113 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %112, 0
  %114 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %113, 0
  %115 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %114, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %115, ptr %12, align 8
  %116 = load { i64, [24 x i8] }, ptr %12, align 8
  %117 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %90, 0
  %118 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %117, i64 %88, 1
  %119 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %118, i64 %109, 2
  %120 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %119, ptr %91, 3
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %120, { i64, [24 x i8] } %116, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %121

122:                                              ; preds = %86
  %123 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %124 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %123, 1
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %11, align 8
  %126 = load { i64, [24 x i8] }, ptr %11, align 8
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %90, 0
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %88, 1
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %89, 2
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, ptr %91, 3
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %126, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %131

132:                                              ; preds = %62
  %133 = phi i64 [ %18, %62 ]
  %134 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %135 = call ptr %134()
  %136 = load i64, ptr %135, align 8
  %137 = mul i64 %136, 4650
  %138 = call i64 @llvm.uadd.sat.i64(i64 %133, i64 %137)
  br label %174

139:                                              ; preds = %26
  %140 = phi { ptr, i32, i32, i32 } [ %33, %26 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %140)
  %141 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %142 = call ptr %141()
  %143 = load i64, ptr %142, align 8
  %144 = mul i64 %143, 6220
  %145 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %144)
  br label %153

146:                                              ; preds = %19
  %147 = phi { ptr, i32, i32, i32 } [ %21, %19 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %147)
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = load i64, ptr %149, align 8
  %151 = mul i64 %150, 7420
  %152 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %151)
  br label %153

153:                                              ; preds = %139, %146
  %154 = phi i64 [ %0, %146 ], [ %0, %139 ]
  %155 = phi ptr [ %3, %146 ], [ %3, %139 ]
  %156 = phi i64 [ %14, %146 ], [ %36, %139 ]
  %157 = phi i64 [ %152, %146 ], [ %145, %139 ]
  %158 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %159 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %158, 0
  %160 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %159, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %160, ptr %7, align 8
  %161 = load { i64, [24 x i8] }, ptr %7, align 8
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %154, 0
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, i64 %156, 1
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %163, i64 %157, 2
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %164, ptr %155, 3
  %166 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %165, { i64, [24 x i8] } %161, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %166

167:                                              ; preds = %5
  %168 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %168)
  %169 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %170 = call ptr %169()
  %171 = load i64, ptr %170, align 8
  %172 = mul i64 %171, 7620
  %173 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %172)
  br label %174

174:                                              ; preds = %132, %167
  %175 = phi i64 [ %0, %167 ], [ %0, %132 ]
  %176 = phi ptr [ %3, %167 ], [ %3, %132 ]
  %177 = phi i64 [ %14, %167 ], [ %66, %132 ]
  %178 = phi i64 [ %173, %167 ], [ %138, %132 ]
  %179 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %180 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %179, 0
  %181 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %180, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %181, ptr %6, align 8
  %182 = load { i64, [24 x i8] }, ptr %6, align 8
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %175, 0
  %184 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %183, i64 %177, 1
  %185 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %184, i64 %178, 2
  %186 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %185, ptr %176, 3
  %187 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %186, { i64, [24 x i8] } %182, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %187

188:                                              ; preds = %84
  call void @puts(ptr @assert_msg_22)
  call void @abort()
  unreachable

189:                                              ; preds = %104
  call void @puts(ptr @assert_msg_23)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f8(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f8"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f8(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f8(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$241"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$241"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$353"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$241"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$353"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$241"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$354"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$353"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$354"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$353"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$355"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$354"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$355"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$354"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$242"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$241"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$242"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$241"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$351"({ { { ptr, i32, i32, i32 } }, {}, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 0
  call void @"drop$242"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } @"dup$351"({ { { ptr, i32, i32, i32 } }, {}, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$242"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %6, {} %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %7, {} %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %9, {} %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %10, {} %11, 2
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } undef, { { { ptr, i32, i32, i32 } }, {}, {} } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %14, { { { ptr, i32, i32, i32 } }, {}, {} } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %15
}

define private void @"drop$352"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, 1
  call void @"drop$351"({ { { ptr, i32, i32, i32 } }, {}, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$352"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } @"dup$351"({ { { ptr, i32, i32, i32 } }, {}, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, { { { ptr, i32, i32, i32 } }, {}, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, { { { ptr, i32, i32, i32 } }, {}, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f9"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [56 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = icmp uge i64 %2, 0
  %21 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %20, label %22, label %197

22:                                               ; preds = %5
  %23 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %24 = extractvalue { { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  %28 = icmp uge i32 %27, 1
  br i1 %28, label %29, label %176

29:                                               ; preds = %22
  %30 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %31 = load ptr, ptr %30, align 8
  %32 = zext i32 %25 to i64
  %33 = mul i64 %32, 32
  %34 = getelementptr inbounds i8, ptr %31, i64 %33
  %35 = add i32 %25, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %24, i32 %35, 1
  %37 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %37, ptr %34, i64 32, i1 false)
  %38 = load i252, ptr %37, align 16
  call void @free(ptr %37)
  %39 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %36, 0
  %40 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f31"(i64 %17, i64 %21, { { ptr, i32, i32, i32 } } %39, { ptr, i32, i32, i32 } zeroinitializer, i252 %38)
  %41 = extractvalue { i64, i64, { i64, [56 x i8] } } %40, 0
  %42 = extractvalue { i64, i64, { i64, [56 x i8] } } %40, 1
  %43 = extractvalue { i64, i64, { i64, [56 x i8] } } %40, 2
  store { i64, [56 x i8] } %43, ptr %8, align 8
  %44 = load i1, ptr %8, align 1
  switch i1 %44, label %45 [
    i1 false, label %47
    i1 true, label %53
  ]

45:                                               ; preds = %29
  br i1 false, label %46, label %218

46:                                               ; preds = %45
  unreachable

47:                                               ; preds = %29
  %48 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %8, align 8
  %49 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %48, 1
  %50 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %49, 0
  %51 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %49, 1
  store { i64, [24 x i8] } %51, ptr %10, align 8
  %52 = load i1, ptr %10, align 1
  switch i1 %52, label %63 [
    i1 false, label %65
    i1 true, label %73
  ]

53:                                               ; preds = %29
  %54 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %55 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %54, 1
  %56 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %55, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %56, ptr %9, align 8
  %57 = load { i64, [24 x i8] }, ptr %9, align 8
  %58 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %59 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %58, i64 %41, 1
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, i64 %42, 2
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, ptr %3, 3
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, { i64, [24 x i8] } %57, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %62

63:                                               ; preds = %47
  br i1 false, label %64, label %219

64:                                               ; preds = %63
  unreachable

65:                                               ; preds = %47
  %66 = load { i1, { ptr, i32, i32, i32 } }, ptr %10, align 8
  %67 = extractvalue { i1, { ptr, i32, i32, i32 } } %66, 1
  %68 = extractvalue { { ptr, i32, i32, i32 } } %50, 0
  %69 = extractvalue { ptr, i32, i32, i32 } %68, 1
  %70 = extractvalue { ptr, i32, i32, i32 } %68, 2
  %71 = sub i32 %70, %69
  %72 = icmp uge i32 %71, 1
  br i1 %72, label %79, label %97

73:                                               ; preds = %47
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %50)
  %74 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %75 = call ptr %74()
  %76 = load i64, ptr %75, align 8
  %77 = mul i64 %76, 4040
  %78 = call i64 @llvm.uadd.sat.i64(i64 %42, i64 %77)
  br label %183

79:                                               ; preds = %65
  %80 = extractvalue { ptr, i32, i32, i32 } %68, 0
  %81 = load ptr, ptr %80, align 8
  %82 = zext i32 %69 to i64
  %83 = mul i64 %82, 32
  %84 = getelementptr inbounds i8, ptr %81, i64 %83
  %85 = add i32 %69, 1
  %86 = insertvalue { ptr, i32, i32, i32 } %68, i32 %85, 1
  %87 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %87, ptr %84, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %86)
  call void @"drop$409"(ptr %87)
  call void @"drop$241"({ ptr, i32, i32, i32 } %67)
  %88 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %89 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %88, 0
  %90 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %89, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %90, ptr %16, align 8
  %91 = load { i64, [24 x i8] }, ptr %16, align 8
  %92 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %92, i64 %41, 1
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %42, 2
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, ptr %3, 3
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, { i64, [24 x i8] } %91, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %96

97:                                               ; preds = %65
  %98 = phi { ptr, i32, i32, i32 } [ %68, %65 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %98)
  %99 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %100 = call ptr %99()
  %101 = add i64 %41, 1
  %102 = getelementptr inbounds i64, ptr %100, i32 1
  %103 = load i64, ptr %102, align 8
  %104 = load i64, ptr %100, align 8
  %105 = mul i64 %104, 43700
  %106 = add i64 %103, %105
  %107 = icmp uge i64 %42, %106
  %108 = call i64 @llvm.usub.sat.i64(i64 %42, i64 %106)
  br i1 %107, label %109, label %169

109:                                              ; preds = %97
  %110 = phi {} [ undef, %97 ]
  %111 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %101, i64 %108, i64 %0, ptr %3, {} %110)
  %112 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 0
  %113 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 1
  %114 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 2
  %115 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 3
  %116 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 4
  store { i64, [24 x i8] } %116, ptr %11, align 8
  %117 = load i1, ptr %11, align 1
  switch i1 %117, label %118 [
    i1 false, label %120
    i1 true, label %129
  ]

118:                                              ; preds = %109
  br i1 false, label %119, label %220

119:                                              ; preds = %118
  unreachable

120:                                              ; preds = %109
  %121 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %67, 0
  %122 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f32"(i64 %112, i64 %113, i64 %114, ptr %115, { { ptr, i32, i32, i32 } } %121, {} %110)
  %123 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 0
  %124 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 1
  %125 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 2
  %126 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 3
  %127 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 4
  store { i64, [24 x i8] } %127, ptr %13, align 8
  %128 = load i1, ptr %13, align 1
  switch i1 %128, label %139 [
    i1 false, label %141
    i1 true, label %159
  ]

129:                                              ; preds = %109
  %130 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %131 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %130, 1
  call void @"drop$241"({ ptr, i32, i32, i32 } %67)
  %132 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %131, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %132, ptr %12, align 8
  %133 = load { i64, [24 x i8] }, ptr %12, align 8
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %114, 0
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, i64 %112, 1
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %113, 2
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, ptr %115, 3
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, { i64, [24 x i8] } %133, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %138

139:                                              ; preds = %120
  br i1 false, label %140, label %221

140:                                              ; preds = %139
  unreachable

141:                                              ; preds = %120
  %142 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %13, align 8
  %143 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %142, 1
  call void @"drop$351"({ { { ptr, i32, i32, i32 } }, {}, {} } %143)
  %144 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %145 = call ptr %144()
  %146 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 0)
  %147 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %148 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 0
  %149 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %148)
  %150 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %149, 0
  %151 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %150, 0
  %152 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %151, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %152, ptr %15, align 8
  %153 = load { i64, [24 x i8] }, ptr %15, align 8
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %125, 0
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %154, i64 %123, 1
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %146, 2
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, ptr %126, 3
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %153, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %158

159:                                              ; preds = %120
  %160 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %161 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %160, 1
  %162 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %161, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %162, ptr %14, align 8
  %163 = load { i64, [24 x i8] }, ptr %14, align 8
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %125, 0
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %164, i64 %123, 1
  %166 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %165, i64 %124, 2
  %167 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %166, ptr %126, 3
  %168 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %167, { i64, [24 x i8] } %163, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %168

169:                                              ; preds = %97
  %170 = phi { ptr, i32, i32, i32 } [ %67, %97 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %170)
  %171 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %172 = call ptr %171()
  %173 = load i64, ptr %172, align 8
  %174 = mul i64 %173, 2390
  %175 = call i64 @llvm.uadd.sat.i64(i64 %42, i64 %174)
  br label %204

176:                                              ; preds = %22
  %177 = phi { ptr, i32, i32, i32 } [ %24, %22 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %177)
  %178 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %179 = call ptr %178()
  %180 = load i64, ptr %179, align 8
  %181 = mul i64 %180, 7410
  %182 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %181)
  br label %183

183:                                              ; preds = %73, %176
  %184 = phi i64 [ %0, %176 ], [ %0, %73 ]
  %185 = phi ptr [ %3, %176 ], [ %3, %73 ]
  %186 = phi i64 [ %17, %176 ], [ %41, %73 ]
  %187 = phi i64 [ %182, %176 ], [ %78, %73 ]
  %188 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %189 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %188, 0
  %190 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %189, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %190, ptr %7, align 8
  %191 = load { i64, [24 x i8] }, ptr %7, align 8
  %192 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %184, 0
  %193 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %192, i64 %186, 1
  %194 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %193, i64 %187, 2
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %194, ptr %185, 3
  %196 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, { i64, [24 x i8] } %191, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %196

197:                                              ; preds = %5
  %198 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %198)
  %199 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %200 = call ptr %199()
  %201 = load i64, ptr %200, align 8
  %202 = mul i64 %201, 7610
  %203 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %202)
  br label %204

204:                                              ; preds = %169, %197
  %205 = phi i64 [ %0, %197 ], [ %0, %169 ]
  %206 = phi ptr [ %3, %197 ], [ %3, %169 ]
  %207 = phi i64 [ %17, %197 ], [ %101, %169 ]
  %208 = phi i64 [ %203, %197 ], [ %175, %169 ]
  %209 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %210 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %209, 0
  %211 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %210, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %211, ptr %6, align 8
  %212 = load { i64, [24 x i8] }, ptr %6, align 8
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %205, 0
  %214 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %213, i64 %207, 1
  %215 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %214, i64 %208, 2
  %216 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %215, ptr %206, 3
  %217 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %216, { i64, [24 x i8] } %212, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %217

218:                                              ; preds = %45
  call void @puts(ptr @assert_msg_24)
  call void @abort()
  unreachable

219:                                              ; preds = %63
  call void @puts(ptr @assert_msg_25)
  call void @abort()
  unreachable

220:                                              ; preds = %118
  call void @puts(ptr @assert_msg_26)
  call void @abort()
  unreachable

221:                                              ; preds = %139
  call void @puts(ptr @assert_msg_27)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f9(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f9"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f9(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f9(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f10"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [56 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = icmp uge i64 %2, 0
  %21 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %20, label %22, label %197

22:                                               ; preds = %5
  %23 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %24 = extractvalue { { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  %28 = icmp uge i32 %27, 1
  br i1 %28, label %29, label %176

29:                                               ; preds = %22
  %30 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %31 = load ptr, ptr %30, align 8
  %32 = zext i32 %25 to i64
  %33 = mul i64 %32, 32
  %34 = getelementptr inbounds i8, ptr %31, i64 %33
  %35 = add i32 %25, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %24, i32 %35, 1
  %37 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %37, ptr %34, i64 32, i1 false)
  %38 = load i252, ptr %37, align 16
  call void @free(ptr %37)
  %39 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %36, 0
  %40 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f31"(i64 %17, i64 %21, { { ptr, i32, i32, i32 } } %39, { ptr, i32, i32, i32 } zeroinitializer, i252 %38)
  %41 = extractvalue { i64, i64, { i64, [56 x i8] } } %40, 0
  %42 = extractvalue { i64, i64, { i64, [56 x i8] } } %40, 1
  %43 = extractvalue { i64, i64, { i64, [56 x i8] } } %40, 2
  store { i64, [56 x i8] } %43, ptr %8, align 8
  %44 = load i1, ptr %8, align 1
  switch i1 %44, label %45 [
    i1 false, label %47
    i1 true, label %53
  ]

45:                                               ; preds = %29
  br i1 false, label %46, label %218

46:                                               ; preds = %45
  unreachable

47:                                               ; preds = %29
  %48 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %8, align 8
  %49 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %48, 1
  %50 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %49, 0
  %51 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %49, 1
  store { i64, [24 x i8] } %51, ptr %10, align 8
  %52 = load i1, ptr %10, align 1
  switch i1 %52, label %63 [
    i1 false, label %65
    i1 true, label %73
  ]

53:                                               ; preds = %29
  %54 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %55 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %54, 1
  %56 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %55, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %56, ptr %9, align 8
  %57 = load { i64, [24 x i8] }, ptr %9, align 8
  %58 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %59 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %58, i64 %41, 1
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, i64 %42, 2
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, ptr %3, 3
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, { i64, [24 x i8] } %57, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %62

63:                                               ; preds = %47
  br i1 false, label %64, label %219

64:                                               ; preds = %63
  unreachable

65:                                               ; preds = %47
  %66 = load { i1, { ptr, i32, i32, i32 } }, ptr %10, align 8
  %67 = extractvalue { i1, { ptr, i32, i32, i32 } } %66, 1
  %68 = extractvalue { { ptr, i32, i32, i32 } } %50, 0
  %69 = extractvalue { ptr, i32, i32, i32 } %68, 1
  %70 = extractvalue { ptr, i32, i32, i32 } %68, 2
  %71 = sub i32 %70, %69
  %72 = icmp uge i32 %71, 1
  br i1 %72, label %79, label %97

73:                                               ; preds = %47
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %50)
  %74 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %75 = call ptr %74()
  %76 = load i64, ptr %75, align 8
  %77 = mul i64 %76, 4040
  %78 = call i64 @llvm.uadd.sat.i64(i64 %42, i64 %77)
  br label %183

79:                                               ; preds = %65
  %80 = extractvalue { ptr, i32, i32, i32 } %68, 0
  %81 = load ptr, ptr %80, align 8
  %82 = zext i32 %69 to i64
  %83 = mul i64 %82, 32
  %84 = getelementptr inbounds i8, ptr %81, i64 %83
  %85 = add i32 %69, 1
  %86 = insertvalue { ptr, i32, i32, i32 } %68, i32 %85, 1
  %87 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %87, ptr %84, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %86)
  call void @"drop$409"(ptr %87)
  call void @"drop$241"({ ptr, i32, i32, i32 } %67)
  %88 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %89 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %88, 0
  %90 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %89, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %90, ptr %16, align 8
  %91 = load { i64, [24 x i8] }, ptr %16, align 8
  %92 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %92, i64 %41, 1
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %42, 2
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, ptr %3, 3
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, { i64, [24 x i8] } %91, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %96

97:                                               ; preds = %65
  %98 = phi { ptr, i32, i32, i32 } [ %68, %65 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %98)
  %99 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %100 = call ptr %99()
  %101 = add i64 %41, 1
  %102 = getelementptr inbounds i64, ptr %100, i32 1
  %103 = load i64, ptr %102, align 8
  %104 = load i64, ptr %100, align 8
  %105 = mul i64 %104, 43700
  %106 = add i64 %103, %105
  %107 = icmp uge i64 %42, %106
  %108 = call i64 @llvm.usub.sat.i64(i64 %42, i64 %106)
  br i1 %107, label %109, label %169

109:                                              ; preds = %97
  %110 = phi {} [ undef, %97 ]
  %111 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %101, i64 %108, i64 %0, ptr %3, {} %110)
  %112 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 0
  %113 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 1
  %114 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 2
  %115 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 3
  %116 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, 4
  store { i64, [24 x i8] } %116, ptr %11, align 8
  %117 = load i1, ptr %11, align 1
  switch i1 %117, label %118 [
    i1 false, label %120
    i1 true, label %129
  ]

118:                                              ; preds = %109
  br i1 false, label %119, label %220

119:                                              ; preds = %118
  unreachable

120:                                              ; preds = %109
  %121 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %67, 0
  %122 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f33"(i64 %112, i64 %113, i64 %114, ptr %115, { { ptr, i32, i32, i32 } } %121, {} %110)
  %123 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 0
  %124 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 1
  %125 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 2
  %126 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 3
  %127 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, 4
  store { i64, [24 x i8] } %127, ptr %13, align 8
  %128 = load i1, ptr %13, align 1
  switch i1 %128, label %139 [
    i1 false, label %141
    i1 true, label %159
  ]

129:                                              ; preds = %109
  %130 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %131 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %130, 1
  call void @"drop$241"({ ptr, i32, i32, i32 } %67)
  %132 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %131, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %132, ptr %12, align 8
  %133 = load { i64, [24 x i8] }, ptr %12, align 8
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %114, 0
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, i64 %112, 1
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %113, 2
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, ptr %115, 3
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, { i64, [24 x i8] } %133, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %138

139:                                              ; preds = %120
  br i1 false, label %140, label %221

140:                                              ; preds = %139
  unreachable

141:                                              ; preds = %120
  %142 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %13, align 8
  %143 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %142, 1
  call void @"drop$351"({ { { ptr, i32, i32, i32 } }, {}, {} } %143)
  %144 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %145 = call ptr %144()
  %146 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 0)
  %147 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %148 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 0
  %149 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %148)
  %150 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %149, 0
  %151 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %150, 0
  %152 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %151, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %152, ptr %15, align 8
  %153 = load { i64, [24 x i8] }, ptr %15, align 8
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %125, 0
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %154, i64 %123, 1
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %146, 2
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, ptr %126, 3
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %153, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %158

159:                                              ; preds = %120
  %160 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %161 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %160, 1
  %162 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %161, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %162, ptr %14, align 8
  %163 = load { i64, [24 x i8] }, ptr %14, align 8
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %125, 0
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %164, i64 %123, 1
  %166 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %165, i64 %124, 2
  %167 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %166, ptr %126, 3
  %168 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %167, { i64, [24 x i8] } %163, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %168

169:                                              ; preds = %97
  %170 = phi { ptr, i32, i32, i32 } [ %67, %97 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %170)
  %171 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %172 = call ptr %171()
  %173 = load i64, ptr %172, align 8
  %174 = mul i64 %173, 2390
  %175 = call i64 @llvm.uadd.sat.i64(i64 %42, i64 %174)
  br label %204

176:                                              ; preds = %22
  %177 = phi { ptr, i32, i32, i32 } [ %24, %22 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %177)
  %178 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %179 = call ptr %178()
  %180 = load i64, ptr %179, align 8
  %181 = mul i64 %180, 7410
  %182 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %181)
  br label %183

183:                                              ; preds = %73, %176
  %184 = phi i64 [ %0, %176 ], [ %0, %73 ]
  %185 = phi ptr [ %3, %176 ], [ %3, %73 ]
  %186 = phi i64 [ %17, %176 ], [ %41, %73 ]
  %187 = phi i64 [ %182, %176 ], [ %78, %73 ]
  %188 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %189 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %188, 0
  %190 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %189, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %190, ptr %7, align 8
  %191 = load { i64, [24 x i8] }, ptr %7, align 8
  %192 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %184, 0
  %193 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %192, i64 %186, 1
  %194 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %193, i64 %187, 2
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %194, ptr %185, 3
  %196 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, { i64, [24 x i8] } %191, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %196

197:                                              ; preds = %5
  %198 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %198)
  %199 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %200 = call ptr %199()
  %201 = load i64, ptr %200, align 8
  %202 = mul i64 %201, 7610
  %203 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %202)
  br label %204

204:                                              ; preds = %169, %197
  %205 = phi i64 [ %0, %197 ], [ %0, %169 ]
  %206 = phi ptr [ %3, %197 ], [ %3, %169 ]
  %207 = phi i64 [ %17, %197 ], [ %101, %169 ]
  %208 = phi i64 [ %203, %197 ], [ %175, %169 ]
  %209 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %210 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %209, 0
  %211 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %210, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %211, ptr %6, align 8
  %212 = load { i64, [24 x i8] }, ptr %6, align 8
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %205, 0
  %214 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %213, i64 %207, 1
  %215 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %214, i64 %208, 2
  %216 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %215, ptr %206, 3
  %217 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %216, { i64, [24 x i8] } %212, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %217

218:                                              ; preds = %45
  call void @puts(ptr @assert_msg_28)
  call void @abort()
  unreachable

219:                                              ; preds = %63
  call void @puts(ptr @assert_msg_29)
  call void @abort()
  unreachable

220:                                              ; preds = %118
  call void @puts(ptr @assert_msg_30)
  call void @abort()
  unreachable

221:                                              ; preds = %139
  call void @puts(ptr @assert_msg_31)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f10(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f10"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f10(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f10(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f11"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [56 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 230
  %22 = icmp uge i64 %2, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %2, i64 %21)
  br i1 %22, label %24, label %267

24:                                               ; preds = %5
  %25 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %246

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %41 = add i64 %1, 4
  %42 = icmp ult i252 %40, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %42, label %43, label %239

43:                                               ; preds = %31
  %44 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  %45 = extractvalue { ptr, i32, i32, i32 } %44, 1
  %46 = extractvalue { ptr, i32, i32, i32 } %44, 2
  %47 = sub i32 %46, %45
  %48 = icmp uge i32 %47, 1
  br i1 %48, label %49, label %218

49:                                               ; preds = %43
  %50 = extractvalue { ptr, i32, i32, i32 } %44, 0
  %51 = load ptr, ptr %50, align 8
  %52 = zext i32 %45 to i64
  %53 = mul i64 %52, 32
  %54 = getelementptr inbounds i8, ptr %51, i64 %53
  %55 = add i32 %45, 1
  %56 = insertvalue { ptr, i32, i32, i32 } %44, i32 %55, 1
  %57 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %57, ptr %54, i64 32, i1 false)
  %58 = load i252, ptr %57, align 16
  call void @free(ptr %57)
  %59 = add i64 %1, 7
  %60 = icmp ult i252 %58, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %60, label %61, label %211

61:                                               ; preds = %49
  %62 = phi { ptr, i32, i32, i32 } [ %56, %49 ]
  %63 = extractvalue { ptr, i32, i32, i32 } %62, 1
  %64 = extractvalue { ptr, i32, i32, i32 } %62, 2
  %65 = sub i32 %64, %63
  %66 = icmp uge i32 %65, 1
  br i1 %66, label %67, label %190

67:                                               ; preds = %61
  %68 = extractvalue { ptr, i32, i32, i32 } %62, 0
  %69 = load ptr, ptr %68, align 8
  %70 = zext i32 %63 to i64
  %71 = mul i64 %70, 32
  %72 = getelementptr inbounds i8, ptr %69, i64 %71
  %73 = add i32 %63, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %62, i32 %73, 1
  %75 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %75, ptr %72, i64 32, i1 false)
  %76 = load i252, ptr %75, align 16
  call void @free(ptr %75)
  %77 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %74, 0
  %78 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f31"(i64 %59, i64 %23, { { ptr, i32, i32, i32 } } %77, { ptr, i32, i32, i32 } zeroinitializer, i252 %76)
  %79 = extractvalue { i64, i64, { i64, [56 x i8] } } %78, 0
  %80 = extractvalue { i64, i64, { i64, [56 x i8] } } %78, 1
  %81 = extractvalue { i64, i64, { i64, [56 x i8] } } %78, 2
  store { i64, [56 x i8] } %81, ptr %10, align 8
  %82 = load i1, ptr %10, align 1
  switch i1 %82, label %83 [
    i1 false, label %85
    i1 true, label %91
  ]

83:                                               ; preds = %67
  br i1 false, label %84, label %288

84:                                               ; preds = %83
  unreachable

85:                                               ; preds = %67
  %86 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %10, align 8
  %87 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %86, 1
  %88 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %87, 0
  %89 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %87, 1
  store { i64, [24 x i8] } %89, ptr %12, align 8
  %90 = load i1, ptr %12, align 1
  switch i1 %90, label %101 [
    i1 false, label %103
    i1 true, label %111
  ]

91:                                               ; preds = %67
  %92 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %93 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %92, 1
  %94 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %93, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %94, ptr %11, align 8
  %95 = load { i64, [24 x i8] }, ptr %11, align 8
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %79, 1
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, i64 %80, 2
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, ptr %3, 3
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, { i64, [24 x i8] } %95, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %100

101:                                              ; preds = %85
  br i1 false, label %102, label %289

102:                                              ; preds = %101
  unreachable

103:                                              ; preds = %85
  %104 = load { i1, { ptr, i32, i32, i32 } }, ptr %12, align 8
  %105 = extractvalue { i1, { ptr, i32, i32, i32 } } %104, 1
  %106 = extractvalue { { ptr, i32, i32, i32 } } %88, 0
  %107 = extractvalue { ptr, i32, i32, i32 } %106, 1
  %108 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %109 = sub i32 %108, %107
  %110 = icmp uge i32 %109, 1
  br i1 %110, label %117, label %135

111:                                              ; preds = %85
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %88)
  %112 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %113 = call ptr %112()
  %114 = load i64, ptr %113, align 8
  %115 = mul i64 %114, 1470
  %116 = call i64 @llvm.uadd.sat.i64(i64 %80, i64 %115)
  br label %197

117:                                              ; preds = %103
  %118 = extractvalue { ptr, i32, i32, i32 } %106, 0
  %119 = load ptr, ptr %118, align 8
  %120 = zext i32 %107 to i64
  %121 = mul i64 %120, 32
  %122 = getelementptr inbounds i8, ptr %119, i64 %121
  %123 = add i32 %107, 1
  %124 = insertvalue { ptr, i32, i32, i32 } %106, i32 %123, 1
  %125 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %125, ptr %122, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %124)
  call void @"drop$409"(ptr %125)
  call void @"drop$241"({ ptr, i32, i32, i32 } %105)
  %126 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %127 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %126, 0
  %128 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %127, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %128, ptr %16, align 8
  %129 = load { i64, [24 x i8] }, ptr %16, align 8
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %79, 1
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %80, 2
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %132, ptr %3, 3
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %133, { i64, [24 x i8] } %129, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %134

135:                                              ; preds = %103
  %136 = phi { ptr, i32, i32, i32 } [ %106, %103 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %136)
  %137 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %138 = call ptr %137()
  %139 = add i64 %79, 1
  %140 = getelementptr inbounds i64, ptr %138, i32 1
  %141 = load i64, ptr %140, align 8
  %142 = load i64, ptr %138, align 8
  %143 = mul i64 %142, 147870
  %144 = add i64 %141, %143
  %145 = icmp uge i64 %80, %144
  %146 = call i64 @llvm.usub.sat.i64(i64 %80, i64 %144)
  br i1 %145, label %147, label %185

147:                                              ; preds = %135
  %148 = phi {} [ undef, %135 ]
  %149 = insertvalue { {} } undef, {} %148, 0
  %150 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %139, i64 %146, i64 %0, ptr %3, { {} } %149, i252 %40, i252 %58, { ptr, i32, i32, i32 } %105)
  %151 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, 0
  %152 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, 1
  %153 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, 2
  %154 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, 3
  %155 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, 4
  store { i64, [24 x i8] } %155, ptr %13, align 8
  %156 = load i1, ptr %13, align 1
  switch i1 %156, label %157 [
    i1 false, label %159
    i1 true, label %175
  ]

157:                                              ; preds = %147
  br i1 false, label %158, label %290

158:                                              ; preds = %157
  unreachable

159:                                              ; preds = %147
  %160 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %161 = call ptr %160()
  %162 = call i64 @llvm.uadd.sat.i64(i64 %152, i64 0)
  %163 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %164 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %163, 0
  %165 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %163, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %164)
  %166 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %165, 0
  %167 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %166, 0
  %168 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %167, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %168, ptr %15, align 8
  %169 = load { i64, [24 x i8] }, ptr %15, align 8
  %170 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %153, 0
  %171 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %170, i64 %151, 1
  %172 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %171, i64 %162, 2
  %173 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %172, ptr %154, 3
  %174 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %173, { i64, [24 x i8] } %169, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %174

175:                                              ; preds = %147
  %176 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %177 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %176, 1
  %178 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %177, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %178, ptr %14, align 8
  %179 = load { i64, [24 x i8] }, ptr %14, align 8
  %180 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %153, 0
  %181 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %180, i64 %151, 1
  %182 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %181, i64 %152, 2
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, ptr %154, 3
  %184 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %183, { i64, [24 x i8] } %179, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %184

185:                                              ; preds = %135
  %186 = phi { ptr, i32, i32, i32 } [ %105, %135 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %186)
  %187 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %188 = call ptr %187()
  %189 = call i64 @llvm.uadd.sat.i64(i64 %80, i64 0)
  br label %274

190:                                              ; preds = %61
  %191 = phi { ptr, i32, i32, i32 } [ %62, %61 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %191)
  %192 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %193 = call ptr %192()
  %194 = load i64, ptr %193, align 8
  %195 = mul i64 %194, 4840
  %196 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %195)
  br label %197

197:                                              ; preds = %111, %190
  %198 = phi i64 [ %0, %190 ], [ %0, %111 ]
  %199 = phi ptr [ %3, %190 ], [ %3, %111 ]
  %200 = phi i64 [ %59, %190 ], [ %79, %111 ]
  %201 = phi i64 [ %196, %190 ], [ %116, %111 ]
  %202 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f20"()
  %203 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %202, 0
  %204 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %203, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %204, ptr %9, align 8
  %205 = load { i64, [24 x i8] }, ptr %9, align 8
  %206 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %198, 0
  %207 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %206, i64 %200, 1
  %208 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %207, i64 %201, 2
  %209 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %208, ptr %199, 3
  %210 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %209, { i64, [24 x i8] } %205, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %210

211:                                              ; preds = %49
  %212 = phi { ptr, i32, i32, i32 } [ %56, %49 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %212)
  %213 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %214 = call ptr %213()
  %215 = load i64, ptr %214, align 8
  %216 = mul i64 %215, 5040
  %217 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %216)
  br label %225

218:                                              ; preds = %43
  %219 = phi { ptr, i32, i32, i32 } [ %44, %43 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %219)
  %220 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %221 = call ptr %220()
  %222 = load i64, ptr %221, align 8
  %223 = mul i64 %222, 6240
  %224 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %223)
  br label %225

225:                                              ; preds = %211, %218
  %226 = phi i64 [ %0, %218 ], [ %0, %211 ]
  %227 = phi ptr [ %3, %218 ], [ %3, %211 ]
  %228 = phi i64 [ %41, %218 ], [ %59, %211 ]
  %229 = phi i64 [ %224, %218 ], [ %217, %211 ]
  %230 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %231 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %230, 0
  %232 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %231, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %232, ptr %8, align 8
  %233 = load { i64, [24 x i8] }, ptr %8, align 8
  %234 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %226, 0
  %235 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %234, i64 %228, 1
  %236 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %235, i64 %229, 2
  %237 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %236, ptr %227, 3
  %238 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %237, { i64, [24 x i8] } %233, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %238

239:                                              ; preds = %31
  %240 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %240)
  %241 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %242 = call ptr %241()
  %243 = load i64, ptr %242, align 8
  %244 = mul i64 %243, 6440
  %245 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %244)
  br label %253

246:                                              ; preds = %24
  %247 = phi { ptr, i32, i32, i32 } [ %26, %24 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %247)
  %248 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %249 = call ptr %248()
  %250 = load i64, ptr %249, align 8
  %251 = mul i64 %250, 7640
  %252 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %251)
  br label %253

253:                                              ; preds = %239, %246
  %254 = phi i64 [ %0, %246 ], [ %0, %239 ]
  %255 = phi ptr [ %3, %246 ], [ %3, %239 ]
  %256 = phi i64 [ %17, %246 ], [ %41, %239 ]
  %257 = phi i64 [ %252, %246 ], [ %245, %239 ]
  %258 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %259 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %258, 0
  %260 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %259, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %260, ptr %7, align 8
  %261 = load { i64, [24 x i8] }, ptr %7, align 8
  %262 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %254, 0
  %263 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %262, i64 %256, 1
  %264 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %263, i64 %257, 2
  %265 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %264, ptr %255, 3
  %266 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %265, { i64, [24 x i8] } %261, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %266

267:                                              ; preds = %5
  %268 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %268)
  %269 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %270 = call ptr %269()
  %271 = load i64, ptr %270, align 8
  %272 = mul i64 %271, 7610
  %273 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %272)
  br label %274

274:                                              ; preds = %185, %267
  %275 = phi i64 [ %0, %267 ], [ %0, %185 ]
  %276 = phi ptr [ %3, %267 ], [ %3, %185 ]
  %277 = phi i64 [ %17, %267 ], [ %139, %185 ]
  %278 = phi i64 [ %273, %267 ], [ %189, %185 ]
  %279 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %280 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %279, 0
  %281 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %280, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %281, ptr %6, align 8
  %282 = load { i64, [24 x i8] }, ptr %6, align 8
  %283 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %275, 0
  %284 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %283, i64 %277, 1
  %285 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %284, i64 %278, 2
  %286 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %285, ptr %276, 3
  %287 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %286, { i64, [24 x i8] } %282, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %287

288:                                              ; preds = %83
  call void @puts(ptr @assert_msg_32)
  call void @abort()
  unreachable

289:                                              ; preds = %101
  call void @puts(ptr @assert_msg_33)
  call void @abort()
  unreachable

290:                                              ; preds = %157
  call void @puts(ptr @assert_msg_34)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f11(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f11"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f11(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f11(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 7733229381460288120802334208475838166080759535023995805565484692595)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f12() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f12"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f12(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f12()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$343"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$343"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 40)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 40, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$130"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$130"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$131"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$130"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$131"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$130"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$228"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$131"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$228"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$131"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$229"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$228"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$229"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$228"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, 0
  call void @"drop$229"({ { { ptr, i32, i32, i32 } } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } @"dup$231"({ { { { ptr, i32, i32, i32 } } }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$229"({ { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, { { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %6, {} %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } undef, { { { { ptr, i32, i32, i32 } } }, {} } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %11, { { { { ptr, i32, i32, i32 } } }, {} } %10, 1
  ret { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %12
}

define private void @"drop$341"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %2)
  %3 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } @"dup$341"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } @"dup$231"({ { { { ptr, i32, i32, i32 } } }, {} } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, { { { { ptr, i32, i32, i32 } } }, {} } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } undef, { { { { ptr, i32, i32, i32 } } }, {} } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } undef, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %17, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$342"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$341"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$342"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } @"dup$341"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$220"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$220"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, 0
  call void @"drop$220"({ { { ptr, i32, i32, i32 } } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } @"dup$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$220"({ { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, { { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6, { { {} } } %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %7, { { {} } } %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %11, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %10, 1
  ret { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %12
}

define private void @"drop$316"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %0, 0
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } @"dup$316"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } @"dup$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %0, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %0, 1
  %9 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %6, { i32, i32, i32, i32 } %8, 1
  %10 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %7, { i32, i32, i32, i32 } %8, 1
  %11 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } undef, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %9, 0
  %12 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %11, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %10, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %12
}

define private void @"drop$339"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %5, 1
  call void @"drop$316"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [40 x i8] }, { i64, [40 x i8] } } @"dup$339"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } @"dup$316"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %10, ptr %2, align 8
  %11 = load { i64, [40 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %12, ptr %2, align 8
  %13 = load { i64, [40 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %11, 0
  %15 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %14, { i64, [40 x i8] } %13, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [40 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [40 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %23, 0
  %27 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %26, { i64, [40 x i8] } %25, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f13"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8) {
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca { i1, [47 x i8] }, i64 1, align 16
  %14 = alloca i64, i64 1, align 8
  %15 = alloca i252, i64 1, align 16
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca i252, i64 1, align 16
  %20 = alloca i252, i64 1, align 16
  %21 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i32, [24 x i8] }, i64 1, align 4
  %24 = alloca { i64, [24 x i8] }, i64 1, align 8
  %25 = alloca { i32, [20 x i8] }, i64 1, align 4
  %26 = alloca i256, i64 1, align 16
  %27 = alloca i256, i64 1, align 16
  %28 = alloca i256, i64 1, align 16
  %29 = alloca { i32, [4 x i8] }, i64 1, align 4
  %30 = alloca { i32, [4 x i8] }, i64 1, align 4
  %31 = alloca { i32, [4 x i8] }, i64 1, align 4
  %32 = alloca { i32, [4 x i8] }, i64 1, align 4
  %33 = alloca { i32, [4 x i8] }, i64 1, align 4
  %34 = alloca { i64, [48 x i8] }, i64 1, align 8
  %35 = alloca { i64, [24 x i8] }, i64 1, align 8
  %36 = alloca { i64, [40 x i8] }, i64 1, align 8
  %37 = alloca { i64, [24 x i8] }, i64 1, align 8
  %38 = alloca { i64, [24 x i8] }, i64 1, align 8
  %39 = alloca { i64, [24 x i8] }, i64 1, align 8
  %40 = add i64 %3, 3
  %41 = zext i252 %7 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %10, align 16
  store i256 %41, ptr %11, align 16
  %42 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %42(ptr %12, ptr %10, ptr %11)
  %43 = load i256, ptr %12, align 16
  %44 = trunc i256 %43 to i252
  %45 = add i64 %0, 3
  %46 = sub i252 %44, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %47 = icmp ult i252 %44, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %48 = select i1 %47, i252 %44, i252 %46
  %49 = load ptr, ptr %5, align 8
  store i64 %1, ptr %14, align 8
  store i252 %48, ptr %15, align 16
  %50 = getelementptr inbounds ptr, ptr %5, i32 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %13, ptr %49, ptr %14, i32 0, ptr %15)
  %52 = load { i1, [47 x i8] }, ptr %13, align 1
  %53 = extractvalue { i1, [47 x i8] } %52, 0
  %54 = getelementptr inbounds i8, ptr %13, i32 16
  %55 = load i252, ptr %54, align 16
  %56 = getelementptr inbounds i8, ptr %13, i32 8
  %57 = load { ptr, i32, i32, i32 }, ptr %56, align 8
  %58 = load i64, ptr %14, align 8
  br i1 %53, label %298, label %59

59:                                               ; preds = %9
  %60 = phi i252 [ %55, %9 ]
  %61 = icmp eq i252 %60, 0
  br i1 %61, label %62, label %76

62:                                               ; preds = %59
  %63 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f36"()
  %64 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %63, 0
  %65 = extractvalue { {}, { ptr, i32, i32, i32 } } %64, 1
  %66 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %65, 1
  %67 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %66, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %67, ptr %39, align 8
  %68 = load { i64, [24 x i8] }, ptr %39, align 8
  %69 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %45, 0
  %70 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %69, i64 %58, 1
  %71 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %2, 2
  %72 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %71, i64 %40, 3
  %73 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %72, i64 %4, 4
  %74 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %73, ptr %5, 5
  %75 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %74, { i64, [24 x i8] } %68, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %75

76:                                               ; preds = %59
  %77 = phi { i128, i128 } [ %8, %59 ]
  %78 = extractvalue { i128, i128 } %77, 0
  %79 = zext i128 %78 to i252
  %80 = extractvalue { i128, i128 } %77, 1
  %81 = zext i128 %80 to i252
  %82 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %82, align 4
  %83 = getelementptr inbounds i8, ptr %82, i32 4
  store i32 0, ptr %83, align 4
  %84 = getelementptr inbounds i8, ptr %82, i32 16
  %85 = call ptr @realloc(ptr null, i64 8)
  store ptr %84, ptr %85, align 8
  %86 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %85, 0
  %87 = insertvalue { ptr, i32, i32, i32 } %86, i32 8, 3
  %88 = load ptr, ptr %85, align 8
  store i252 %79, ptr %88, align 16
  %89 = insertvalue { ptr, i32, i32, i32 } %87, i32 1, 2
  %90 = getelementptr inbounds i8, ptr %88, i32 -12
  store i32 1, ptr %90, align 4
  %91 = load ptr, ptr %85, align 8
  %92 = getelementptr inbounds i8, ptr %91, i32 32
  store i252 %81, ptr %92, align 16
  %93 = insertvalue { ptr, i32, i32, i32 } %89, i32 2, 2
  %94 = getelementptr inbounds i8, ptr %91, i32 -12
  store i32 2, ptr %94, align 4
  %95 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %93)
  %96 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 0
  %97 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %96)
  %98 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %97, 0
  %99 = load ptr, ptr %5, align 8
  store i64 %58, ptr %18, align 8
  store i252 %7, ptr %19, align 16
  store i252 198245171877110614431632758327373800976566065571148526819123645061251396147, ptr %20, align 16
  store { { ptr, i32, i32, i32 } } %98, ptr %21, align 8
  %100 = getelementptr inbounds ptr, ptr %5, i32 7
  %101 = load ptr, ptr %100, align 8
  call void %101(ptr %17, ptr %99, ptr %18, ptr %19, ptr %20, ptr %21)
  %102 = load { i1, [31 x i8] }, ptr %17, align 1
  %103 = extractvalue { i1, [31 x i8] } %102, 0
  %104 = getelementptr inbounds i8, ptr %17, i32 8
  %105 = load { { ptr, i32, i32, i32 } }, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %17, i32 8
  %107 = load { ptr, i32, i32, i32 }, ptr %106, align 8
  %108 = load i64, ptr %18, align 8
  br i1 %103, label %284, label %109

109:                                              ; preds = %76
  %110 = phi i64 [ %45, %76 ]
  %111 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f37"(i64 %110, { { ptr, i32, i32, i32 } } %105)
  %112 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %111, 0
  %113 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %111, 1
  %114 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %111, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %113)
  store { i32, [24 x i8] } %114, ptr %23, align 4
  %115 = load i1, ptr %23, align 1
  switch i1 %115, label %116 [
    i1 false, label %118
    i1 true, label %122
  ]

116:                                              ; preds = %109
  br i1 false, label %117, label %312

117:                                              ; preds = %116
  unreachable

118:                                              ; preds = %109
  %119 = load { i1, { i32, [20 x i8] } }, ptr %23, align 4
  %120 = extractvalue { i1, { i32, [20 x i8] } } %119, 1
  store { i32, [20 x i8] } %120, ptr %25, align 4
  %121 = load i1, ptr %25, align 1
  switch i1 %121, label %136 [
    i1 false, label %138
    i1 true, label %179
  ]

122:                                              ; preds = %109
  %123 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f41"()
  %124 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %123, 0
  %125 = extractvalue { {}, { ptr, i32, i32, i32 } } %124, 1
  %126 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %125, 1
  %127 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %126, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %127, ptr %24, align 8
  %128 = load { i64, [24 x i8] }, ptr %24, align 8
  %129 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %112, 0
  %130 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %108, 1
  %131 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %2, 2
  %132 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %40, 3
  %133 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %132, i64 %4, 4
  %134 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, ptr %5, 5
  %135 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %134, { i64, [24 x i8] } %128, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %135

136:                                              ; preds = %118
  br i1 false, label %137, label %313

137:                                              ; preds = %136
  unreachable

138:                                              ; preds = %118
  %139 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %25, align 4
  %140 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %139, 1
  %141 = extractvalue { i32, i32, i32, i32, i32 } %140, 0
  %142 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %141, 1
  store { i3, i32 } %142, ptr %29, align 4
  %143 = load { i32, [4 x i8] }, ptr %29, align 4
  %144 = extractvalue { i32, i32, i32, i32, i32 } %140, 1
  %145 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %144, 1
  store { i3, i32 } %145, ptr %30, align 4
  %146 = load { i32, [4 x i8] }, ptr %30, align 4
  %147 = extractvalue { i32, i32, i32, i32, i32 } %140, 2
  %148 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %147, 1
  store { i3, i32 } %148, ptr %31, align 4
  %149 = load { i32, [4 x i8] }, ptr %31, align 4
  %150 = extractvalue { i32, i32, i32, i32, i32 } %140, 3
  %151 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %150, 1
  store { i3, i32 } %151, ptr %32, align 4
  %152 = load { i32, [4 x i8] }, ptr %32, align 4
  %153 = extractvalue { i32, i32, i32, i32, i32 } %140, 4
  %154 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %153, 1
  store { i3, i32 } %154, ptr %33, align 4
  %155 = load { i32, [4 x i8] }, ptr %33, align 4
  %156 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } undef, { i32, [4 x i8] } %143, 0
  %157 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %156, { i32, [4 x i8] } %146, 1
  %158 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %157, { i32, [4 x i8] } %149, 2
  %159 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %158, { i32, [4 x i8] } %152, 3
  %160 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %159, { i32, [4 x i8] } %155, 4
  %161 = call ptr @realloc(ptr null, i64 40)
  store { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %160, ptr %161, align 4
  %162 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 5 }, ptr %162, align 4
  %163 = getelementptr inbounds i8, ptr %162, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr %163, ptr %161, i64 40, i1 false)
  call void @free(ptr %161)
  %164 = call ptr @realloc(ptr null, i64 8)
  store ptr %163, ptr %164, align 8
  %165 = insertvalue { ptr, i32, i32, i32 } undef, ptr %164, 0
  %166 = insertvalue { ptr, i32, i32, i32 } %165, i32 0, 1
  %167 = insertvalue { ptr, i32, i32, i32 } %166, i32 5, 2
  %168 = insertvalue { ptr, i32, i32, i32 } %167, i32 5, 3
  %169 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %168, 0
  %170 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %169, 0
  %171 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %170, 0
  %172 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %171, {} undef, 1
  %173 = call fastcc { i64, i64, i64, { i64, [48 x i8] } } @"impl$f38"(i64 %112, i64 %108, i64 %4, { { { { ptr, i32, i32, i32 } } }, {} } %172, { ptr, i32, i32, i32 } zeroinitializer)
  %174 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %173, 0
  %175 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %173, 1
  %176 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %173, 2
  %177 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %173, 3
  store { i64, [48 x i8] } %177, ptr %34, align 8
  %178 = load i1, ptr %34, align 1
  switch i1 %178, label %208 [
    i1 false, label %210
    i1 true, label %231
  ]

179:                                              ; preds = %118
  %180 = load { i1, i32 }, ptr %25, align 4
  %181 = extractvalue { i1, i32 } %180, 1
  %182 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %183 = call ptr %182()
  %184 = call i64 @llvm.uadd.sat.i64(i64 %108, i64 0)
  %185 = add i64 %3, 6
  %186 = zext i32 %181 to i256
  store i256 119674880063757522161687995182389208939526319504019663621515716359683735285, ptr %26, align 16
  store i256 %186, ptr %27, align 16
  %187 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %187(ptr %28, ptr %26, ptr %27)
  %188 = load i256, ptr %28, align 16
  %189 = trunc i256 %188 to i252
  %190 = add i64 %112, 3
  %191 = sub i252 %189, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %192 = icmp ult i252 %189, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %193 = select i1 %192, i252 %189, i252 %191
  %194 = insertvalue { i252 } undef, i252 %193, 0
  %195 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %190, i64 %184, i64 %2, ptr %5, { i252 } %194)
  %196 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, 0
  %197 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, 1
  %198 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, 2
  %199 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, 3
  %200 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, 4
  %201 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %196, 0
  %202 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %201, i64 %197, 1
  %203 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %202, i64 %198, 2
  %204 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %203, i64 %185, 3
  %205 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %204, i64 %4, 4
  %206 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %205, ptr %199, 5
  %207 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %206, { i64, [24 x i8] } %200, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %207

208:                                              ; preds = %138
  br i1 false, label %209, label %314

209:                                              ; preds = %208
  unreachable

210:                                              ; preds = %138
  %211 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %34, align 8
  %212 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %211, 1
  %213 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %212, 0
  %214 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %212, 1
  call void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %213)
  %215 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %214)
  %216 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 0
  %217 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %216)
  %218 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %217, 0
  %219 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %218, 0
  %220 = insertvalue { { {} } } undef, { {} } %6, 0
  %221 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %219, 0
  %222 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %221, { { {} } } %220, 1
  %223 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f39"(i64 %174, i64 %175, i64 %2, i64 %40, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %222, { i32, i32, i32, i32 } zeroinitializer, {} undef)
  %224 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %223, 0
  %225 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %223, 1
  %226 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %223, 2
  %227 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %223, 3
  %228 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %223, 4
  %229 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %223, 5
  store { i64, [40 x i8] } %229, ptr %36, align 8
  %230 = load i1, ptr %36, align 1
  switch i1 %230, label %243 [
    i1 false, label %245
    i1 true, label %272
  ]

231:                                              ; preds = %138
  %232 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %34, align 8
  %233 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %232, 1
  %234 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %233, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %234, ptr %35, align 8
  %235 = load { i64, [24 x i8] }, ptr %35, align 8
  %236 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %174, 0
  %237 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %236, i64 %175, 1
  %238 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %237, i64 %2, 2
  %239 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %238, i64 %40, 3
  %240 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %239, i64 %176, 4
  %241 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %240, ptr %5, 5
  %242 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %241, { i64, [24 x i8] } %235, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %242

243:                                              ; preds = %210
  br i1 false, label %244, label %315

244:                                              ; preds = %243
  unreachable

245:                                              ; preds = %210
  %246 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } }, ptr %36, align 8
  %247 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %246, 1
  %248 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %249 = call ptr %248()
  %250 = getelementptr inbounds i64, ptr %249, i32 1
  %251 = load i64, ptr %250, align 8
  %252 = getelementptr inbounds i64, ptr %249, i32 2
  %253 = load i64, ptr %252, align 8
  %254 = mul i64 %253, 4
  %255 = add i64 %251, %254
  %256 = load i64, ptr %249, align 8
  %257 = mul i64 %256, 12270
  %258 = add i64 %255, %257
  %259 = call i64 @llvm.uadd.sat.i64(i64 %225, i64 %258)
  %260 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %247, 0
  %261 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %247, 1
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %260)
  %262 = insertvalue { { i32, i32, i32, i32 } } undef, { i32, i32, i32, i32 } %261, 0
  %263 = insertvalue { i1, { { i32, i32, i32, i32 } } } { i1 false, { { i32, i32, i32, i32 } } undef }, { { i32, i32, i32, i32 } } %262, 1
  store { i1, { { i32, i32, i32, i32 } } } %263, ptr %38, align 4
  %264 = load { i64, [24 x i8] }, ptr %38, align 8
  %265 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %224, 0
  %266 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %265, i64 %259, 1
  %267 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %266, i64 %226, 2
  %268 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %267, i64 %227, 3
  %269 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %268, i64 %176, 4
  %270 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, ptr %228, 5
  %271 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %270, { i64, [24 x i8] } %264, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %271

272:                                              ; preds = %210
  %273 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %36, align 8
  %274 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %273, 1
  %275 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %274, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %275, ptr %37, align 8
  %276 = load { i64, [24 x i8] }, ptr %37, align 8
  %277 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %224, 0
  %278 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %277, i64 %225, 1
  %279 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %278, i64 %226, 2
  %280 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %279, i64 %227, 3
  %281 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %280, i64 %176, 4
  %282 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %281, ptr %228, 5
  %283 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %282, { i64, [24 x i8] } %276, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %283

284:                                              ; preds = %76
  %285 = phi {} [ undef, %76 ]
  %286 = phi { ptr, i32, i32, i32 } [ %107, %76 ]
  %287 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %285, 0
  %288 = insertvalue { {}, { ptr, i32, i32, i32 } } %287, { ptr, i32, i32, i32 } %286, 1
  %289 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %288, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %289, ptr %22, align 8
  %290 = load { i64, [24 x i8] }, ptr %22, align 8
  %291 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %45, 0
  %292 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %291, i64 %108, 1
  %293 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %292, i64 %2, 2
  %294 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %293, i64 %40, 3
  %295 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %294, i64 %4, 4
  %296 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %295, ptr %5, 5
  %297 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %296, { i64, [24 x i8] } %290, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %297

298:                                              ; preds = %9
  %299 = phi {} [ undef, %9 ]
  %300 = phi { ptr, i32, i32, i32 } [ %57, %9 ]
  %301 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %299, 0
  %302 = insertvalue { {}, { ptr, i32, i32, i32 } } %301, { ptr, i32, i32, i32 } %300, 1
  %303 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %302, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %303, ptr %16, align 8
  %304 = load { i64, [24 x i8] }, ptr %16, align 8
  %305 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %45, 0
  %306 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, i64 %58, 1
  %307 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %306, i64 %2, 2
  %308 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %307, i64 %40, 3
  %309 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %308, i64 %4, 4
  %310 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %309, ptr %5, 5
  %311 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %310, { i64, [24 x i8] } %304, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %311

312:                                              ; preds = %116
  call void @puts(ptr @assert_msg_35)
  call void @abort()
  unreachable

313:                                              ; preds = %136
  call void @puts(ptr @assert_msg_36)
  call void @abort()
  unreachable

314:                                              ; preds = %208
  call void @puts(ptr @assert_msg_37)
  call void @abort()
  unreachable

315:                                              ; preds = %243
  call void @puts(ptr @assert_msg_38)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f13(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8) {
  %10 = call fastcc { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f13"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8)
  %11 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 2
  %14 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 3
  %15 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 4
  %16 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 5
  %17 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 6
  %18 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %11, 0
  %19 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %12, 1
  %20 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, i64 %13, 2
  %21 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, i64 %14, 3
  %22 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21, i64 %15, 4
  %23 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %22, ptr %16, 5
  %24 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %17, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %24
}

define void @_mlir_ciface_f13(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { {} } %7, i252 %8, { i128, i128 } %9) {
  %11 = call { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f13(i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { {} } %7, i252 %8, { i128, i128 } %9)
  store { i64, i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 485748461484230571791265682659113160264223489397539653310998840191492914)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f14() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f14"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f14(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f14()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 485748461484230571791265682659113160264223489397539653310998840191492913)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f15() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f15(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f15()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 375233589013918064796019)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f16() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f16(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f16()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$330"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$330"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$331"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$330"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$331"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$330"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$332"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$331"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$332"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$331"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f17"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [56 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %19

19:                                               ; preds = %145, %5
  %20 = phi i64 [ %76, %145 ], [ %0, %5 ]
  %21 = phi i64 [ %105, %145 ], [ %1, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %85, %145 ], [ %2, %5 ]
  %23 = phi { ptr, i32, i32, i32 } [ %154, %145 ], [ %3, %5 ]
  %24 = phi i252 [ %161, %145 ], [ %4, %5 ]
  %25 = add i64 %20, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 5140
  %30 = icmp uge i64 %21, %29
  %31 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %29)
  br i1 %30, label %32, label %215

32:                                               ; preds = %19
  %33 = phi i252 [ %24, %19 ]
  %34 = icmp eq i252 %33, 0
  br i1 %34, label %35, label %57

35:                                               ; preds = %32
  %36 = phi i64 [ %31, %32 ]
  %37 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %38 = call ptr %37()
  %39 = load i64, ptr %38, align 8
  %40 = mul i64 %39, 6040
  %41 = call i64 @llvm.uadd.sat.i64(i64 %36, i64 %40)
  %42 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %23, 1
  store { i1, { ptr, i32, i32, i32 } } %42, ptr %17, align 8
  %43 = load { i64, [24 x i8] }, ptr %17, align 8
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %22, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %43, 1
  %46 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %45, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, ptr %18, align 8
  %47 = load { i64, [56 x i8] }, ptr %18, align 8
  %48 = extractvalue { ptr, ptr, i64 } %9, 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp eq i64 %49, 0
  %51 = sub i64 %49, 1
  %52 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %51, ptr %52, align 8
  br i1 %50, label %53, label %172

53:                                               ; preds = %35
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, i64 %41, 1
  %56 = insertvalue { i64, i64, { i64, [56 x i8] } } %55, { i64, [56 x i8] } %47, 2
  ret { i64, i64, { i64, [56 x i8] } } %56

57:                                               ; preds = %32
  %58 = phi { { ptr, i32, i32, i32 } } [ %22, %32 ]
  %59 = extractvalue { { ptr, i32, i32, i32 } } %58, 0
  %60 = extractvalue { ptr, i32, i32, i32 } %59, 1
  %61 = extractvalue { ptr, i32, i32, i32 } %59, 2
  %62 = sub i32 %61, %60
  %63 = icmp uge i32 %62, 1
  br i1 %63, label %64, label %189

64:                                               ; preds = %57
  %65 = extractvalue { ptr, i32, i32, i32 } %59, 0
  %66 = load ptr, ptr %65, align 8
  %67 = zext i32 %60 to i64
  %68 = mul i64 %67, 32
  %69 = getelementptr inbounds i8, ptr %66, i64 %68
  %70 = add i32 %60, 1
  %71 = insertvalue { ptr, i32, i32, i32 } %59, i32 %70, 1
  %72 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %72, ptr %69, i64 32, i1 false)
  %73 = load i252, ptr %72, align 16
  call void @free(ptr %72)
  %74 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %71, 0
  %75 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f42"(i64 %25, i64 %31, { { ptr, i32, i32, i32 } } %74, { ptr, i32, i32, i32 } zeroinitializer, i252 %73)
  %76 = extractvalue { i64, i64, { i64, [56 x i8] } } %75, 0
  %77 = extractvalue { i64, i64, { i64, [56 x i8] } } %75, 1
  %78 = extractvalue { i64, i64, { i64, [56 x i8] } } %75, 2
  store { i64, [56 x i8] } %78, ptr %14, align 8
  %79 = load i1, ptr %14, align 1
  switch i1 %79, label %80 [
    i1 false, label %82
    i1 true, label %88
  ]

80:                                               ; preds = %64
  br i1 false, label %81, label %230

81:                                               ; preds = %80
  unreachable

82:                                               ; preds = %64
  %83 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %14, align 8
  %84 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %83, 1
  %85 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %84, 0
  %86 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %84, 1
  store { i64, [24 x i8] } %86, ptr %16, align 8
  %87 = load i1, ptr %16, align 1
  switch i1 %87, label %98 [
    i1 false, label %100
    i1 true, label %166
  ]

88:                                               ; preds = %64
  %89 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %90 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %89, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %23)
  %91 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %90, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %91, ptr %15, align 8
  %92 = load { i64, [56 x i8] }, ptr %15, align 8
  %93 = extractvalue { ptr, ptr, i64 } %9, 1
  %94 = load i64, ptr %93, align 8
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %94, 1
  %97 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %96, ptr %97, align 8
  br i1 %95, label %185, label %172

98:                                               ; preds = %82
  br i1 false, label %99, label %231

99:                                               ; preds = %98
  unreachable

100:                                              ; preds = %82
  %101 = load { i1, { ptr, i32, i32, i32 } }, ptr %16, align 8
  %102 = extractvalue { i1, { ptr, i32, i32, i32 } } %101, 1
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %77, i64 0)
  %106 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %107 = icmp eq i32 %106, 0
  br i1 %107, label %108, label %122

108:                                              ; preds = %100
  %109 = shl i32 %106, 1
  %110 = call i32 @llvm.umin.i32(i32 %109, i32 1024)
  %111 = add i32 %110, %106
  %112 = call i32 @llvm.umax.i32(i32 %111, i32 8)
  %113 = zext i32 %112 to i64
  %114 = mul i64 %113, 24
  %115 = add i64 %114, 8
  %116 = call ptr @realloc(ptr null, i64 %115)
  store i32 1, ptr %116, align 4
  %117 = getelementptr inbounds i8, ptr %116, i32 4
  store i32 0, ptr %117, align 4
  %118 = getelementptr inbounds i8, ptr %116, i32 8
  %119 = call ptr @realloc(ptr null, i64 8)
  store ptr %118, ptr %119, align 8
  %120 = insertvalue { ptr, i32, i32, i32 } %23, ptr %119, 0
  %121 = insertvalue { ptr, i32, i32, i32 } %120, i32 %112, 3
  br label %143

122:                                              ; preds = %100
  %123 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %124 = icmp ult i32 %123, %106
  br i1 %124, label %125, label %126

125:                                              ; preds = %122
  br label %140

126:                                              ; preds = %122
  %127 = shl i32 %106, 1
  %128 = call i32 @llvm.umin.i32(i32 %127, i32 1024)
  %129 = add i32 %128, %106
  %130 = call i32 @llvm.umax.i32(i32 %129, i32 8)
  %131 = zext i32 %130 to i64
  %132 = mul i64 %131, 24
  %133 = add i64 %132, 8
  %134 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr inbounds i8, ptr %135, i32 -8
  %137 = call ptr @realloc(ptr %136, i64 %133)
  %138 = getelementptr inbounds i8, ptr %137, i32 8
  store ptr %138, ptr %134, align 8
  %139 = insertvalue { ptr, i32, i32, i32 } %23, i32 %130, 3
  br label %140

140:                                              ; preds = %125, %126
  %141 = phi { ptr, i32, i32, i32 } [ %139, %126 ], [ %23, %125 ]
  br label %142

142:                                              ; preds = %140
  br label %143

143:                                              ; preds = %108, %142
  %144 = phi { ptr, i32, i32, i32 } [ %141, %142 ], [ %121, %108 ]
  br label %145

145:                                              ; preds = %143
  %146 = extractvalue { ptr, i32, i32, i32 } %144, 0
  %147 = load ptr, ptr %146, align 8
  %148 = extractvalue { ptr, i32, i32, i32 } %144, 2
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 24
  %151 = getelementptr inbounds i8, ptr %147, i64 %150
  store { ptr, i32, i32, i32 } %102, ptr %151, align 8
  %152 = extractvalue { ptr, i32, i32, i32 } %144, 2
  %153 = add i32 %152, 1
  %154 = insertvalue { ptr, i32, i32, i32 } %144, i32 %153, 2
  %155 = getelementptr inbounds i8, ptr %147, i32 -4
  store i32 %153, ptr %155, align 4
  %156 = zext i252 %33 to i256
  %157 = sub i256 %156, 1
  %158 = add i256 %156, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %159 = icmp ult i256 %156, 1
  %160 = select i1 %159, i256 %158, i256 %157
  %161 = trunc i256 %160 to i252
  %162 = extractvalue { ptr, ptr, i64 } %9, 1
  %163 = load i64, ptr %162, align 8
  %164 = add i64 %163, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br label %19

166:                                              ; preds = %82
  call void @"drop$212"({ ptr, i32, i32, i32 } %23)
  %167 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %168 = call ptr %167()
  %169 = load i64, ptr %168, align 8
  %170 = mul i64 %169, 1970
  %171 = call i64 @llvm.uadd.sat.i64(i64 %77, i64 %170)
  br label %197

172:                                              ; preds = %172, %35, %197, %88, %215
  %173 = phi i64 [ %25, %215 ], [ %198, %197 ], [ %173, %172 ], [ %76, %88 ], [ %25, %35 ]
  %174 = phi i64 [ %21, %215 ], [ %199, %197 ], [ %174, %172 ], [ %77, %88 ], [ %41, %35 ]
  %175 = phi { i64, [56 x i8] } [ %220, %215 ], [ %205, %197 ], [ %175, %172 ], [ %92, %88 ], [ %47, %35 ]
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %172

181:                                              ; preds = %172
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %173, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %174, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184

185:                                              ; preds = %88
  %186 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %76, 0
  %187 = insertvalue { i64, i64, { i64, [56 x i8] } } %186, i64 %77, 1
  %188 = insertvalue { i64, i64, { i64, [56 x i8] } } %187, { i64, [56 x i8] } %92, 2
  ret { i64, i64, { i64, [56 x i8] } } %188

189:                                              ; preds = %57
  %190 = phi { ptr, i32, i32, i32 } [ %23, %57 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %190)
  %191 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %192 = call ptr %191()
  %193 = load i64, ptr %192, align 8
  %194 = mul i64 %193, 5340
  %195 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %194)
  %196 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %59, 0
  br label %197

197:                                              ; preds = %166, %189
  %198 = phi i64 [ %25, %189 ], [ %76, %166 ]
  %199 = phi i64 [ %195, %189 ], [ %171, %166 ]
  %200 = phi { { ptr, i32, i32, i32 } } [ %196, %189 ], [ %85, %166 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %201 = load { i64, [24 x i8] }, ptr %12, align 8
  %202 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %200, 0
  %203 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %202, { i64, [24 x i8] } %201, 1
  %204 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %203, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %204, ptr %13, align 8
  %205 = load { i64, [56 x i8] }, ptr %13, align 8
  %206 = extractvalue { ptr, ptr, i64 } %9, 1
  %207 = load i64, ptr %206, align 8
  %208 = icmp eq i64 %207, 0
  %209 = sub i64 %207, 1
  %210 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %209, ptr %210, align 8
  br i1 %208, label %211, label %172

211:                                              ; preds = %197
  %212 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %198, 0
  %213 = insertvalue { i64, i64, { i64, [56 x i8] } } %212, i64 %199, 1
  %214 = insertvalue { i64, i64, { i64, [56 x i8] } } %213, { i64, [56 x i8] } %205, 2
  ret { i64, i64, { i64, [56 x i8] } } %214

215:                                              ; preds = %19
  %216 = phi { ptr, i32, i32, i32 } [ %23, %19 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %216)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %22)
  %217 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %218 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %217, 0
  %219 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %218, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %219, ptr %11, align 8
  %220 = load { i64, [56 x i8] }, ptr %11, align 8
  %221 = extractvalue { ptr, ptr, i64 } %9, 1
  %222 = load i64, ptr %221, align 8
  %223 = icmp eq i64 %222, 0
  %224 = sub i64 %222, 1
  %225 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %224, ptr %225, align 8
  br i1 %223, label %226, label %172

226:                                              ; preds = %215
  %227 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %228 = insertvalue { i64, i64, { i64, [56 x i8] } } %227, i64 %21, 1
  %229 = insertvalue { i64, i64, { i64, [56 x i8] } } %228, { i64, [56 x i8] } %220, 2
  ret { i64, i64, { i64, [56 x i8] } } %229

230:                                              ; preds = %80
  call void @puts(ptr @assert_msg_39)
  call void @abort()
  unreachable

231:                                              ; preds = %98
  call void @puts(ptr @assert_msg_40)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f17(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f17"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f17(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f17(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$321"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$212"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$321"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %0, 0
  call void @"drop$321"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } @"dup$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$321"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %6, { { {} }, i32 } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %7, { { {} }, i32 } %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } %11, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } %12
}

define private void @"drop$324"({ { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %2)
  %3 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$324"({ { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } @"dup$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %17, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$325"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$324"({ { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$325"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$324"({ { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } @"dup$326"({ { {} }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, { {} } %2, 0
  %4 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } undef, { {} } %2, 0
  %5 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = insertvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { {} }, { { ptr, i32, i32, i32 } } } %9, 0
  %12 = insertvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %11, { { {} }, { { ptr, i32, i32, i32 } } } %10, 1
  ret { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %12
}

define private void @"drop$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 0
  call void @"drop$321"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 1
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } @"dup$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$321"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 1
  %9 = call { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } @"dup$326"({ { {} }, { { ptr, i32, i32, i32 } } } %8)
  %10 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %9, 0
  %11 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %6, { { {} }, { { ptr, i32, i32, i32 } } } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %7, { { {} }, { { ptr, i32, i32, i32 } } } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %14, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %15
}

define private void @"drop$328"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %2)
  %3 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } @"dup$328"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } @"dup$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %17, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$329"({ i64, [72 x i8] } %0) {
  %2 = alloca { i64, [72 x i8] }, i64 1, align 8
  store { i64, [72 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$328"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [72 x i8] }, { i64, [72 x i8] } } @"dup$329"({ i64, [72 x i8] } %0) {
  %2 = alloca { i64, [72 x i8] }, i64 1, align 8
  store { i64, [72 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } @"dup$328"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [72 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [72 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } undef, { i64, [72 x i8] } %11, 0
  %15 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } %14, { i64, [72 x i8] } %13, 1
  ret { { i64, [72 x i8] }, { i64, [72 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [72 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [72 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } undef, { i64, [72 x i8] } %23, 0
  %27 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } %26, { i64, [72 x i8] } %25, 1
  ret { { i64, [72 x i8] }, { i64, [72 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f18"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca { i1, [47 x i8] }, i64 1, align 16
  %14 = alloca i64, i64 1, align 8
  %15 = alloca i252, i64 1, align 16
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca i252, i64 1, align 16
  %20 = alloca i252, i64 1, align 16
  %21 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i32, [24 x i8] }, i64 1, align 4
  %24 = alloca { i64, [24 x i8] }, i64 1, align 8
  %25 = alloca { i32, [20 x i8] }, i64 1, align 4
  %26 = alloca { i64, [56 x i8] }, i64 1, align 8
  %27 = alloca { i64, [24 x i8] }, i64 1, align 8
  %28 = alloca { i64, [24 x i8] }, i64 1, align 8
  %29 = alloca { i32, [4 x i8] }, i64 1, align 4
  %30 = alloca { i32, [4 x i8] }, i64 1, align 4
  %31 = alloca { i32, [4 x i8] }, i64 1, align 4
  %32 = alloca { i32, [4 x i8] }, i64 1, align 4
  %33 = alloca { i32, [4 x i8] }, i64 1, align 4
  %34 = alloca { i64, [48 x i8] }, i64 1, align 8
  %35 = alloca { i64, [24 x i8] }, i64 1, align 8
  %36 = alloca { i64, [72 x i8] }, i64 1, align 8
  %37 = alloca { i64, [24 x i8] }, i64 1, align 8
  %38 = alloca { i64, [24 x i8] }, i64 1, align 8
  %39 = alloca { i64, [24 x i8] }, i64 1, align 8
  %40 = add i64 %2, 3
  %41 = zext i252 %6 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %10, align 16
  store i256 %41, ptr %11, align 16
  %42 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %42(ptr %12, ptr %10, ptr %11)
  %43 = load i256, ptr %12, align 16
  %44 = trunc i256 %43 to i252
  %45 = add i64 %0, 3
  %46 = sub i252 %44, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %47 = icmp ult i252 %44, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %48 = select i1 %47, i252 %44, i252 %46
  %49 = load ptr, ptr %4, align 8
  store i64 %1, ptr %14, align 8
  store i252 %48, ptr %15, align 16
  %50 = getelementptr inbounds ptr, ptr %4, i32 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %13, ptr %49, ptr %14, i32 0, ptr %15)
  %52 = load { i1, [47 x i8] }, ptr %13, align 1
  %53 = extractvalue { i1, [47 x i8] } %52, 0
  %54 = getelementptr inbounds i8, ptr %13, i32 16
  %55 = load i252, ptr %54, align 16
  %56 = getelementptr inbounds i8, ptr %13, i32 8
  %57 = load { ptr, i32, i32, i32 }, ptr %56, align 8
  %58 = load i64, ptr %14, align 8
  br i1 %53, label %305, label %59

59:                                               ; preds = %9
  %60 = phi i252 [ %55, %9 ]
  %61 = icmp eq i252 %60, 0
  br i1 %61, label %62, label %76

62:                                               ; preds = %59
  %63 = phi { ptr, i32, i32, i32 } [ %8, %59 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %63)
  %64 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f36"()
  %65 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %64, 0
  %66 = extractvalue { {}, { ptr, i32, i32, i32 } } %65, 1
  %67 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %66, 1
  %68 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %67, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %68, ptr %39, align 8
  %69 = load { i64, [24 x i8] }, ptr %39, align 8
  %70 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %45, 0
  %71 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %58, 1
  %72 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %71, i64 %40, 2
  %73 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %72, i64 %3, 3
  %74 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %73, ptr %4, 4
  %75 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %74, { i64, [24 x i8] } %69, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %75

76:                                               ; preds = %59
  %77 = phi { i128, i128 } [ %7, %59 ]
  %78 = extractvalue { i128, i128 } %77, 0
  %79 = zext i128 %78 to i252
  %80 = extractvalue { i128, i128 } %77, 1
  %81 = zext i128 %80 to i252
  %82 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %82, align 4
  %83 = getelementptr inbounds i8, ptr %82, i32 4
  store i32 0, ptr %83, align 4
  %84 = getelementptr inbounds i8, ptr %82, i32 16
  %85 = call ptr @realloc(ptr null, i64 8)
  store ptr %84, ptr %85, align 8
  %86 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %85, 0
  %87 = insertvalue { ptr, i32, i32, i32 } %86, i32 8, 3
  %88 = load ptr, ptr %85, align 8
  store i252 %79, ptr %88, align 16
  %89 = insertvalue { ptr, i32, i32, i32 } %87, i32 1, 2
  %90 = getelementptr inbounds i8, ptr %88, i32 -12
  store i32 1, ptr %90, align 4
  %91 = load ptr, ptr %85, align 8
  %92 = getelementptr inbounds i8, ptr %91, i32 32
  store i252 %81, ptr %92, align 16
  %93 = insertvalue { ptr, i32, i32, i32 } %89, i32 2, 2
  %94 = getelementptr inbounds i8, ptr %91, i32 -12
  store i32 2, ptr %94, align 4
  %95 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %93)
  %96 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 0
  %97 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %96)
  %98 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %97, 0
  %99 = load ptr, ptr %4, align 8
  store i64 %58, ptr %18, align 8
  store i252 %6, ptr %19, align 16
  store i252 198245171877110614431632758327373800976566065571148526819123645061251396147, ptr %20, align 16
  store { { ptr, i32, i32, i32 } } %98, ptr %21, align 8
  %100 = getelementptr inbounds ptr, ptr %4, i32 7
  %101 = load ptr, ptr %100, align 8
  call void %101(ptr %17, ptr %99, ptr %18, ptr %19, ptr %20, ptr %21)
  %102 = load { i1, [31 x i8] }, ptr %17, align 1
  %103 = extractvalue { i1, [31 x i8] } %102, 0
  %104 = getelementptr inbounds i8, ptr %17, i32 8
  %105 = load { { ptr, i32, i32, i32 } }, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %17, i32 8
  %107 = load { ptr, i32, i32, i32 }, ptr %106, align 8
  %108 = load i64, ptr %18, align 8
  br i1 %103, label %294, label %109

109:                                              ; preds = %76
  %110 = phi i64 [ %45, %76 ]
  %111 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f37"(i64 %110, { { ptr, i32, i32, i32 } } %105)
  %112 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %111, 0
  %113 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %111, 1
  %114 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %111, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %113)
  store { i32, [24 x i8] } %114, ptr %23, align 4
  %115 = load i1, ptr %23, align 1
  switch i1 %115, label %116 [
    i1 false, label %118
    i1 true, label %122
  ]

116:                                              ; preds = %109
  br i1 false, label %117, label %316

117:                                              ; preds = %116
  unreachable

118:                                              ; preds = %109
  %119 = load { i1, { i32, [20 x i8] } }, ptr %23, align 4
  %120 = extractvalue { i1, { i32, [20 x i8] } } %119, 1
  store { i32, [20 x i8] } %120, ptr %25, align 4
  %121 = load i1, ptr %25, align 1
  switch i1 %121, label %135 [
    i1 false, label %137
    i1 true, label %178
  ]

122:                                              ; preds = %109
  call void @"drop$212"({ ptr, i32, i32, i32 } %8)
  %123 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f41"()
  %124 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %123, 0
  %125 = extractvalue { {}, { ptr, i32, i32, i32 } } %124, 1
  %126 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %125, 1
  %127 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %126, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %127, ptr %24, align 8
  %128 = load { i64, [24 x i8] }, ptr %24, align 8
  %129 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %112, 0
  %130 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %108, 1
  %131 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %40, 2
  %132 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %3, 3
  %133 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %132, ptr %4, 4
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, { i64, [24 x i8] } %128, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %134

135:                                              ; preds = %118
  br i1 false, label %136, label %317

136:                                              ; preds = %135
  unreachable

137:                                              ; preds = %118
  %138 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %25, align 4
  %139 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %138, 1
  %140 = extractvalue { i32, i32, i32, i32, i32 } %139, 0
  %141 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %140, 1
  store { i3, i32 } %141, ptr %29, align 4
  %142 = load { i32, [4 x i8] }, ptr %29, align 4
  %143 = extractvalue { i32, i32, i32, i32, i32 } %139, 1
  %144 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %143, 1
  store { i3, i32 } %144, ptr %30, align 4
  %145 = load { i32, [4 x i8] }, ptr %30, align 4
  %146 = extractvalue { i32, i32, i32, i32, i32 } %139, 2
  %147 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %146, 1
  store { i3, i32 } %147, ptr %31, align 4
  %148 = load { i32, [4 x i8] }, ptr %31, align 4
  %149 = extractvalue { i32, i32, i32, i32, i32 } %139, 3
  %150 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %149, 1
  store { i3, i32 } %150, ptr %32, align 4
  %151 = load { i32, [4 x i8] }, ptr %32, align 4
  %152 = extractvalue { i32, i32, i32, i32, i32 } %139, 4
  %153 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %152, 1
  store { i3, i32 } %153, ptr %33, align 4
  %154 = load { i32, [4 x i8] }, ptr %33, align 4
  %155 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } undef, { i32, [4 x i8] } %142, 0
  %156 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %155, { i32, [4 x i8] } %145, 1
  %157 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %156, { i32, [4 x i8] } %148, 2
  %158 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %157, { i32, [4 x i8] } %151, 3
  %159 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %158, { i32, [4 x i8] } %154, 4
  %160 = call ptr @realloc(ptr null, i64 40)
  store { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %159, ptr %160, align 4
  %161 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 5 }, ptr %161, align 4
  %162 = getelementptr inbounds i8, ptr %161, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr %162, ptr %160, i64 40, i1 false)
  call void @free(ptr %160)
  %163 = call ptr @realloc(ptr null, i64 8)
  store ptr %162, ptr %163, align 8
  %164 = insertvalue { ptr, i32, i32, i32 } undef, ptr %163, 0
  %165 = insertvalue { ptr, i32, i32, i32 } %164, i32 0, 1
  %166 = insertvalue { ptr, i32, i32, i32 } %165, i32 5, 2
  %167 = insertvalue { ptr, i32, i32, i32 } %166, i32 5, 3
  %168 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %167, 0
  %169 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %168, 0
  %170 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %169, 0
  %171 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %170, {} undef, 1
  %172 = call fastcc { i64, i64, i64, { i64, [48 x i8] } } @"impl$f38"(i64 %112, i64 %108, i64 %3, { { { { ptr, i32, i32, i32 } } }, {} } %171, { ptr, i32, i32, i32 } zeroinitializer)
  %173 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %172, 0
  %174 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %172, 1
  %175 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %172, 2
  %176 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %172, 3
  store { i64, [48 x i8] } %176, ptr %34, align 8
  %177 = load i1, ptr %34, align 1
  switch i1 %177, label %194 [
    i1 false, label %196
    i1 true, label %221
  ]

178:                                              ; preds = %118
  %179 = load { i1, i32 }, ptr %25, align 4
  %180 = extractvalue { i1, i32 } %179, 1
  %181 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %8, 0
  %182 = insertvalue { { {} }, i32 } undef, { {} } %5, 0
  %183 = insertvalue { { {} }, i32 } %182, i32 %180, 1
  %184 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } undef, { { ptr, i32, i32, i32 } } %181, 0
  %185 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %184, { { {} }, i32 } %183, 1
  %186 = call fastcc { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } @"impl$f44"(i64 %112, i64 %108, i64 %40, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %185, { ptr, i32, i32, i32 } zeroinitializer)
  %187 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %186, 0
  %188 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %186, 1
  %189 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %186, 2
  %190 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %186, 3
  %191 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %186, 4
  %192 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %186, 5
  store { i64, [56 x i8] } %192, ptr %26, align 8
  %193 = load i1, ptr %26, align 1
  switch i1 %193, label %262 [
    i1 false, label %264
    i1 true, label %283
  ]

194:                                              ; preds = %137
  br i1 false, label %195, label %318

195:                                              ; preds = %194
  unreachable

196:                                              ; preds = %137
  %197 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %34, align 8
  %198 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %197, 1
  %199 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %198, 0
  %200 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %198, 1
  call void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %199)
  %201 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %200)
  %202 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, 0
  %203 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %202)
  %204 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %203, 0
  %205 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %204)
  %206 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %205, 0
  %207 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %205, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %206)
  %208 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %8, 0
  %209 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } undef, { {} } %5, 0
  %210 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %209, { { ptr, i32, i32, i32 } } %207, 1
  %211 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %208, 0
  %212 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %211, { { {} }, { { ptr, i32, i32, i32 } } } %210, 1
  %213 = call fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f43"(i64 %173, i64 %174, i64 %40, i64 %175, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %212, { ptr, i32, i32, i32 } zeroinitializer)
  %214 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %213, 0
  %215 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %213, 1
  %216 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %213, 2
  %217 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %213, 3
  %218 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %213, 4
  %219 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %213, 5
  store { i64, [72 x i8] } %219, ptr %36, align 8
  %220 = load i1, ptr %36, align 1
  switch i1 %220, label %232 [
    i1 false, label %234
    i1 true, label %251
  ]

221:                                              ; preds = %137
  %222 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %34, align 8
  %223 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %222, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %8)
  %224 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %223, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %224, ptr %35, align 8
  %225 = load { i64, [24 x i8] }, ptr %35, align 8
  %226 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %173, 0
  %227 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %226, i64 %174, 1
  %228 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %227, i64 %40, 2
  %229 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %228, i64 %175, 3
  %230 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %229, ptr %4, 4
  %231 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %230, { i64, [24 x i8] } %225, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %231

232:                                              ; preds = %196
  br i1 false, label %233, label %319

233:                                              ; preds = %232
  unreachable

234:                                              ; preds = %196
  %235 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %36, align 8
  %236 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %235, 1
  %237 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %238 = call ptr %237()
  %239 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 0)
  %240 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %236, 0
  %241 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %236, 1
  call void @"drop$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %240)
  %242 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %241, 0
  %243 = insertvalue { i1, { { ptr, i32, i32, i32 } } } { i1 false, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %242, 1
  store { i1, { { ptr, i32, i32, i32 } } } %243, ptr %38, align 8
  %244 = load { i64, [24 x i8] }, ptr %38, align 8
  %245 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %214, 0
  %246 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %245, i64 %239, 1
  %247 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %246, i64 %216, 2
  %248 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %217, 3
  %249 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %248, ptr %218, 4
  %250 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %249, { i64, [24 x i8] } %244, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %250

251:                                              ; preds = %196
  %252 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %36, align 8
  %253 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %252, 1
  %254 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %253, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %254, ptr %37, align 8
  %255 = load { i64, [24 x i8] }, ptr %37, align 8
  %256 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %214, 0
  %257 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %256, i64 %215, 1
  %258 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %257, i64 %216, 2
  %259 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %258, i64 %217, 3
  %260 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %259, ptr %218, 4
  %261 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %260, { i64, [24 x i8] } %255, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %261

262:                                              ; preds = %178
  br i1 false, label %263, label %320

263:                                              ; preds = %262
  unreachable

264:                                              ; preds = %178
  %265 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %26, align 8
  %266 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %265, 1
  %267 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %268 = call ptr %267()
  %269 = load i64, ptr %268, align 8
  %270 = mul i64 %269, 5470
  %271 = call i64 @llvm.uadd.sat.i64(i64 %188, i64 %270)
  %272 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %266, 0
  %273 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %266, 1
  call void @"drop$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %272)
  %274 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %273, 0
  %275 = insertvalue { i1, { { ptr, i32, i32, i32 } } } { i1 false, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %274, 1
  store { i1, { { ptr, i32, i32, i32 } } } %275, ptr %28, align 8
  %276 = load { i64, [24 x i8] }, ptr %28, align 8
  %277 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %187, 0
  %278 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %277, i64 %271, 1
  %279 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %278, i64 %189, 2
  %280 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %279, i64 %190, 3
  %281 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %280, ptr %191, 4
  %282 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %281, { i64, [24 x i8] } %276, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %282

283:                                              ; preds = %178
  %284 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %26, align 8
  %285 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %284, 1
  %286 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %285, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %286, ptr %27, align 8
  %287 = load { i64, [24 x i8] }, ptr %27, align 8
  %288 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %187, 0
  %289 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %288, i64 %188, 1
  %290 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %289, i64 %189, 2
  %291 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %290, i64 %190, 3
  %292 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %291, ptr %191, 4
  %293 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %292, { i64, [24 x i8] } %287, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %293

294:                                              ; preds = %76
  %295 = phi { ptr, i32, i32, i32 } [ %8, %76 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %295)
  %296 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %107, 1
  %297 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %296, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %297, ptr %22, align 8
  %298 = load { i64, [24 x i8] }, ptr %22, align 8
  %299 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %45, 0
  %300 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %299, i64 %108, 1
  %301 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %300, i64 %40, 2
  %302 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %301, i64 %3, 3
  %303 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %302, ptr %4, 4
  %304 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %303, { i64, [24 x i8] } %298, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %304

305:                                              ; preds = %9
  %306 = phi { ptr, i32, i32, i32 } [ %8, %9 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %306)
  %307 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %57, 1
  %308 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %307, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %308, ptr %16, align 8
  %309 = load { i64, [24 x i8] }, ptr %16, align 8
  %310 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %45, 0
  %311 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %310, i64 %58, 1
  %312 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %311, i64 %40, 2
  %313 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %312, i64 %3, 3
  %314 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %313, ptr %4, 4
  %315 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %314, { i64, [24 x i8] } %309, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %315

316:                                              ; preds = %116
  call void @puts(ptr @assert_msg_41)
  call void @abort()
  unreachable

317:                                              ; preds = %135
  call void @puts(ptr @assert_msg_42)
  call void @abort()
  unreachable

318:                                              ; preds = %194
  call void @puts(ptr @assert_msg_43)
  call void @abort()
  unreachable

319:                                              ; preds = %232
  call void @puts(ptr @assert_msg_44)
  call void @abort()
  unreachable

320:                                              ; preds = %262
  call void @puts(ptr @assert_msg_45)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f18(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f18"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8)
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 2
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 3
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 4
  %16 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, 5
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %11, 0
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %12, 1
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %13, 2
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, i64 %14, 3
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, ptr %15, 4
  %22 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21, { i64, [24 x i8] } %16, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %22
}

define void @_mlir_ciface_f18(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f18(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %12

12:                                               ; preds = %83, %4
  %13 = phi i64 [ %17, %83 ], [ %0, %4 ]
  %14 = phi i64 [ %42, %83 ], [ %1, %4 ]
  %15 = phi { { ptr, i32, i32, i32 } } [ %94, %83 ], [ %2, %4 ]
  %16 = phi { ptr, i32, i32, i32 } [ %92, %83 ], [ %3, %4 ]
  %17 = add i64 %13, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 1570
  %22 = icmp uge i64 %14, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %14, i64 %21)
  br i1 %22, label %24, label %132

24:                                               ; preds = %12
  %25 = phi { { ptr, i32, i32, i32 } } [ %15, %12 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %112

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 0)
  %43 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %44 = extractvalue { ptr, i32, i32, i32 } %16, 3
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %60

46:                                               ; preds = %31
  %47 = shl i32 %44, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %44
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = call ptr @realloc(ptr null, i64 %53)
  store i32 1, ptr %54, align 4
  %55 = getelementptr inbounds i8, ptr %54, i32 4
  store i32 0, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %54, i32 16
  %57 = call ptr @realloc(ptr null, i64 8)
  store ptr %56, ptr %57, align 8
  %58 = insertvalue { ptr, i32, i32, i32 } %16, ptr %57, 0
  %59 = insertvalue { ptr, i32, i32, i32 } %58, i32 %50, 3
  br label %81

60:                                               ; preds = %31
  %61 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %62 = icmp ult i32 %61, %44
  br i1 %62, label %63, label %64

63:                                               ; preds = %60
  br label %78

64:                                               ; preds = %60
  %65 = shl i32 %44, 1
  %66 = call i32 @llvm.umin.i32(i32 %65, i32 1024)
  %67 = add i32 %66, %44
  %68 = call i32 @llvm.umax.i32(i32 %67, i32 8)
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = add i64 %70, 16
  %72 = extractvalue { ptr, i32, i32, i32 } %16, 0
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %73, i32 -16
  %75 = call ptr @realloc(ptr %74, i64 %71)
  %76 = getelementptr inbounds i8, ptr %75, i32 16
  store ptr %76, ptr %72, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } %16, i32 %68, 3
  br label %78

78:                                               ; preds = %63, %64
  %79 = phi { ptr, i32, i32, i32 } [ %77, %64 ], [ %16, %63 ]
  br label %80

80:                                               ; preds = %78
  br label %81

81:                                               ; preds = %46, %80
  %82 = phi { ptr, i32, i32, i32 } [ %79, %80 ], [ %59, %46 ]
  br label %83

83:                                               ; preds = %81
  %84 = extractvalue { ptr, i32, i32, i32 } %82, 0
  %85 = load ptr, ptr %84, align 8
  %86 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %87 = zext i32 %86 to i64
  %88 = mul i64 %87, 32
  %89 = getelementptr inbounds i8, ptr %85, i64 %88
  store i252 %43, ptr %89, align 16
  %90 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %91 = add i32 %90, 1
  %92 = insertvalue { ptr, i32, i32, i32 } %82, i32 %91, 2
  %93 = getelementptr inbounds i8, ptr %85, i32 -12
  store i32 %91, ptr %93, align 4
  %94 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %38, 0
  %95 = extractvalue { ptr, ptr, i64 } %8, 1
  %96 = load i64, ptr %95, align 8
  %97 = add i64 %96, 1
  %98 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %97, ptr %98, align 8
  br label %12

99:                                               ; preds = %99, %112, %132
  %100 = phi i64 [ %17, %132 ], [ %17, %112 ], [ %100, %99 ]
  %101 = phi i64 [ %14, %132 ], [ %118, %112 ], [ %101, %99 ]
  %102 = phi { i64, [24 x i8] } [ %137, %132 ], [ %122, %112 ], [ %102, %99 ]
  %103 = extractvalue { ptr, ptr, i64 } %8, 1
  %104 = load i64, ptr %103, align 8
  %105 = icmp eq i64 %104, 0
  %106 = sub i64 %104, 1
  %107 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %106, ptr %107, align 8
  br i1 %105, label %108, label %99

108:                                              ; preds = %99
  %109 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %100, 0
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } %109, i64 %101, 1
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, { i64, [24 x i8] } %102, 2
  ret { i64, i64, { i64, [24 x i8] } } %111

112:                                              ; preds = %24
  %113 = phi { ptr, i32, i32, i32 } [ %26, %24 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %113)
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = load i64, ptr %115, align 8
  %117 = mul i64 %116, 2270
  %118 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %117)
  %119 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %16, 0
  %120 = insertvalue { { ptr, i32, i32, i32 }, {} } %119, {} undef, 1
  %121 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %120, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %121, ptr %11, align 8
  %122 = load { i64, [24 x i8] }, ptr %11, align 8
  %123 = extractvalue { ptr, ptr, i64 } %8, 1
  %124 = load i64, ptr %123, align 8
  %125 = icmp eq i64 %124, 0
  %126 = sub i64 %124, 1
  %127 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %126, ptr %127, align 8
  br i1 %125, label %128, label %99

128:                                              ; preds = %112
  %129 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %130 = insertvalue { i64, i64, { i64, [24 x i8] } } %129, i64 %118, 1
  %131 = insertvalue { i64, i64, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %122, 2
  ret { i64, i64, { i64, [24 x i8] } } %131

132:                                              ; preds = %12
  %133 = phi { ptr, i32, i32, i32 } [ %16, %12 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %133)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %15)
  %134 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %135 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %134, 0
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %10, align 8
  %137 = load { i64, [24 x i8] }, ptr %10, align 8
  %138 = extractvalue { ptr, ptr, i64 } %8, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %143, label %99

143:                                              ; preds = %132
  %144 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } %144, i64 %14, 1
  %146 = insertvalue { i64, i64, { i64, [24 x i8] } } %145, { i64, [24 x i8] } %137, 2
  ret { i64, i64, { i64, [24 x i8] } } %146
}

define private { i64, i64, { i64, [24 x i8] } } @f19(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f19(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f19(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f20"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 485748461484230571791265682659113160264223489397539653310998840191492915)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f20() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f20"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f20(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f20()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f21"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca { i1, [47 x i8] }, i64 1, align 16
  %15 = alloca i64, i64 1, align 8
  %16 = alloca i252, i64 1, align 16
  %17 = alloca { i64, [40 x i8] }, i64 1, align 8
  %18 = alloca { i1, [31 x i8] }, i64 1, align 8
  %19 = alloca i64, i64 1, align 8
  %20 = alloca i252, i64 1, align 16
  %21 = alloca i252, i64 1, align 16
  %22 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %23 = alloca { i64, [40 x i8] }, i64 1, align 8
  %24 = alloca { i32, [24 x i8] }, i64 1, align 4
  %25 = alloca { i64, [40 x i8] }, i64 1, align 8
  %26 = alloca { i32, [20 x i8] }, i64 1, align 4
  %27 = alloca i256, i64 1, align 16
  %28 = alloca i256, i64 1, align 16
  %29 = alloca i256, i64 1, align 16
  %30 = alloca { i64, [24 x i8] }, i64 1, align 8
  %31 = alloca { i64, [40 x i8] }, i64 1, align 8
  %32 = alloca { i64, [56 x i8] }, i64 1, align 8
  %33 = alloca { i64, [40 x i8] }, i64 1, align 8
  %34 = alloca { i64, [40 x i8] }, i64 1, align 8
  %35 = alloca { i32, [4 x i8] }, i64 1, align 4
  %36 = alloca { i32, [4 x i8] }, i64 1, align 4
  %37 = alloca { i32, [4 x i8] }, i64 1, align 4
  %38 = alloca { i32, [4 x i8] }, i64 1, align 4
  %39 = alloca { i32, [4 x i8] }, i64 1, align 4
  %40 = alloca { i64, [48 x i8] }, i64 1, align 8
  %41 = alloca { i64, [40 x i8] }, i64 1, align 8
  %42 = alloca { i64, [40 x i8] }, i64 1, align 8
  %43 = alloca { i64, [40 x i8] }, i64 1, align 8
  %44 = alloca { i64, [72 x i8] }, i64 1, align 8
  %45 = alloca { i64, [40 x i8] }, i64 1, align 8
  %46 = alloca { i64, [40 x i8] }, i64 1, align 8
  %47 = alloca { i64, [40 x i8] }, i64 1, align 8
  %48 = add i64 %3, 3
  %49 = zext i252 %7 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %11, align 16
  store i256 %49, ptr %12, align 16
  %50 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %50(ptr %13, ptr %11, ptr %12)
  %51 = load i256, ptr %13, align 16
  %52 = trunc i256 %51 to i252
  %53 = add i64 %0, 3
  %54 = sub i252 %52, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %55 = icmp ult i252 %52, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %56 = select i1 %55, i252 %52, i252 %54
  %57 = load ptr, ptr %5, align 8
  store i64 %1, ptr %15, align 8
  store i252 %56, ptr %16, align 16
  %58 = getelementptr inbounds ptr, ptr %5, i32 8
  %59 = load ptr, ptr %58, align 8
  call void %59(ptr %14, ptr %57, ptr %15, i32 0, ptr %16)
  %60 = load { i1, [47 x i8] }, ptr %14, align 1
  %61 = extractvalue { i1, [47 x i8] } %60, 0
  %62 = getelementptr inbounds i8, ptr %14, i32 16
  %63 = load i252, ptr %62, align 16
  %64 = getelementptr inbounds i8, ptr %14, i32 8
  %65 = load { ptr, i32, i32, i32 }, ptr %64, align 8
  %66 = load i64, ptr %15, align 8
  br i1 %61, label %401, label %67

67:                                               ; preds = %10
  %68 = phi i252 [ %63, %10 ]
  %69 = icmp eq i252 %68, 0
  br i1 %69, label %70, label %85

70:                                               ; preds = %67
  %71 = phi { ptr, i32, i32, i32 } [ %9, %67 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %71)
  %72 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f36"()
  %73 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %72, 0
  %74 = extractvalue { {}, { ptr, i32, i32, i32 } } %73, 1
  %75 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %74, 1
  %76 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %75, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %76, ptr %47, align 8
  %77 = load { i64, [40 x i8] }, ptr %47, align 8
  %78 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %53, 0
  %79 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %78, i64 %66, 1
  %80 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %79, i64 %2, 2
  %81 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %80, i64 %48, 3
  %82 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %81, i64 %4, 4
  %83 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %82, ptr %5, 5
  %84 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %83, { i64, [40 x i8] } %77, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %84

85:                                               ; preds = %67
  %86 = phi { i128, i128 } [ %8, %67 ]
  %87 = extractvalue { i128, i128 } %86, 0
  %88 = zext i128 %87 to i252
  %89 = extractvalue { i128, i128 } %86, 1
  %90 = zext i128 %89 to i252
  %91 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %91, align 4
  %92 = getelementptr inbounds i8, ptr %91, i32 4
  store i32 0, ptr %92, align 4
  %93 = getelementptr inbounds i8, ptr %91, i32 16
  %94 = call ptr @realloc(ptr null, i64 8)
  store ptr %93, ptr %94, align 8
  %95 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %94, 0
  %96 = insertvalue { ptr, i32, i32, i32 } %95, i32 8, 3
  %97 = load ptr, ptr %94, align 8
  store i252 %88, ptr %97, align 16
  %98 = insertvalue { ptr, i32, i32, i32 } %96, i32 1, 2
  %99 = getelementptr inbounds i8, ptr %97, i32 -12
  store i32 1, ptr %99, align 4
  %100 = load ptr, ptr %94, align 8
  %101 = getelementptr inbounds i8, ptr %100, i32 32
  store i252 %90, ptr %101, align 16
  %102 = insertvalue { ptr, i32, i32, i32 } %98, i32 2, 2
  %103 = getelementptr inbounds i8, ptr %100, i32 -12
  store i32 2, ptr %103, align 4
  %104 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %102)
  %105 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %104, 0
  %106 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %104, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %105)
  %107 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %106, 0
  %108 = load ptr, ptr %5, align 8
  store i64 %66, ptr %19, align 8
  store i252 %7, ptr %20, align 16
  store i252 198245171877110614431632758327373800976566065571148526819123645061251396147, ptr %21, align 16
  store { { ptr, i32, i32, i32 } } %107, ptr %22, align 8
  %109 = getelementptr inbounds ptr, ptr %5, i32 7
  %110 = load ptr, ptr %109, align 8
  call void %110(ptr %18, ptr %108, ptr %19, ptr %20, ptr %21, ptr %22)
  %111 = load { i1, [31 x i8] }, ptr %18, align 1
  %112 = extractvalue { i1, [31 x i8] } %111, 0
  %113 = getelementptr inbounds i8, ptr %18, i32 8
  %114 = load { { ptr, i32, i32, i32 } }, ptr %113, align 8
  %115 = getelementptr inbounds i8, ptr %18, i32 8
  %116 = load { ptr, i32, i32, i32 }, ptr %115, align 8
  %117 = load i64, ptr %19, align 8
  br i1 %112, label %389, label %118

118:                                              ; preds = %85
  %119 = phi i64 [ %53, %85 ]
  %120 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f37"(i64 %119, { { ptr, i32, i32, i32 } } %114)
  %121 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %120, 0
  %122 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %120, 1
  %123 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %120, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %122)
  store { i32, [24 x i8] } %123, ptr %24, align 4
  %124 = load i1, ptr %24, align 1
  switch i1 %124, label %125 [
    i1 false, label %127
    i1 true, label %131
  ]

125:                                              ; preds = %118
  br i1 false, label %126, label %413

126:                                              ; preds = %125
  unreachable

127:                                              ; preds = %118
  %128 = load { i1, { i32, [20 x i8] } }, ptr %24, align 4
  %129 = extractvalue { i1, { i32, [20 x i8] } } %128, 1
  store { i32, [20 x i8] } %129, ptr %26, align 4
  %130 = load i1, ptr %26, align 1
  switch i1 %130, label %145 [
    i1 false, label %147
    i1 true, label %188
  ]

131:                                              ; preds = %118
  call void @"drop$212"({ ptr, i32, i32, i32 } %9)
  %132 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f41"()
  %133 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %132, 0
  %134 = extractvalue { {}, { ptr, i32, i32, i32 } } %133, 1
  %135 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %134, 1
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %25, align 8
  %137 = load { i64, [40 x i8] }, ptr %25, align 8
  %138 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %121, 0
  %139 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %138, i64 %117, 1
  %140 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %139, i64 %2, 2
  %141 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %140, i64 %48, 3
  %142 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %141, i64 %4, 4
  %143 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %142, ptr %5, 5
  %144 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %143, { i64, [40 x i8] } %137, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %144

145:                                              ; preds = %127
  br i1 false, label %146, label %414

146:                                              ; preds = %145
  unreachable

147:                                              ; preds = %127
  %148 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %26, align 4
  %149 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %148, 1
  %150 = extractvalue { i32, i32, i32, i32, i32 } %149, 0
  %151 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %150, 1
  store { i3, i32 } %151, ptr %35, align 4
  %152 = load { i32, [4 x i8] }, ptr %35, align 4
  %153 = extractvalue { i32, i32, i32, i32, i32 } %149, 1
  %154 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %153, 1
  store { i3, i32 } %154, ptr %36, align 4
  %155 = load { i32, [4 x i8] }, ptr %36, align 4
  %156 = extractvalue { i32, i32, i32, i32, i32 } %149, 2
  %157 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %156, 1
  store { i3, i32 } %157, ptr %37, align 4
  %158 = load { i32, [4 x i8] }, ptr %37, align 4
  %159 = extractvalue { i32, i32, i32, i32, i32 } %149, 3
  %160 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %159, 1
  store { i3, i32 } %160, ptr %38, align 4
  %161 = load { i32, [4 x i8] }, ptr %38, align 4
  %162 = extractvalue { i32, i32, i32, i32, i32 } %149, 4
  %163 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %162, 1
  store { i3, i32 } %163, ptr %39, align 4
  %164 = load { i32, [4 x i8] }, ptr %39, align 4
  %165 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } undef, { i32, [4 x i8] } %152, 0
  %166 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %165, { i32, [4 x i8] } %155, 1
  %167 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %166, { i32, [4 x i8] } %158, 2
  %168 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %167, { i32, [4 x i8] } %161, 3
  %169 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %168, { i32, [4 x i8] } %164, 4
  %170 = call ptr @realloc(ptr null, i64 40)
  store { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %169, ptr %170, align 4
  %171 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 5 }, ptr %171, align 4
  %172 = getelementptr inbounds i8, ptr %171, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr %172, ptr %170, i64 40, i1 false)
  call void @free(ptr %170)
  %173 = call ptr @realloc(ptr null, i64 8)
  store ptr %172, ptr %173, align 8
  %174 = insertvalue { ptr, i32, i32, i32 } undef, ptr %173, 0
  %175 = insertvalue { ptr, i32, i32, i32 } %174, i32 0, 1
  %176 = insertvalue { ptr, i32, i32, i32 } %175, i32 5, 2
  %177 = insertvalue { ptr, i32, i32, i32 } %176, i32 5, 3
  %178 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %177, 0
  %179 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %178, 0
  %180 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %179, 0
  %181 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %180, {} undef, 1
  %182 = call fastcc { i64, i64, i64, { i64, [48 x i8] } } @"impl$f38"(i64 %121, i64 %117, i64 %4, { { { { ptr, i32, i32, i32 } } }, {} } %181, { ptr, i32, i32, i32 } zeroinitializer)
  %183 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %182, 0
  %184 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %182, 1
  %185 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %182, 2
  %186 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %182, 3
  store { i64, [48 x i8] } %186, ptr %40, align 8
  %187 = load i1, ptr %40, align 1
  switch i1 %187, label %208 [
    i1 false, label %210
    i1 true, label %234
  ]

188:                                              ; preds = %127
  %189 = load { i1, i32 }, ptr %26, align 4
  %190 = extractvalue { i1, i32 } %189, 1
  %191 = add i64 %3, 6
  %192 = zext i32 %190 to i256
  store i256 119674880063757522161687995182389208939526319504019663621515716359683735285, ptr %27, align 16
  store i256 %192, ptr %28, align 16
  %193 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %193(ptr %29, ptr %27, ptr %28)
  %194 = load i256, ptr %29, align 16
  %195 = trunc i256 %194 to i252
  %196 = add i64 %121, 3
  %197 = sub i252 %195, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %198 = icmp ult i252 %195, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %199 = select i1 %198, i252 %195, i252 %197
  %200 = insertvalue { i252 } undef, i252 %199, 0
  %201 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %196, i64 %117, i64 %2, ptr %5, { i252 } %200)
  %202 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, 0
  %203 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, 1
  %204 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, 2
  %205 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, 3
  %206 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, 4
  store { i64, [24 x i8] } %206, ptr %30, align 8
  %207 = load i1, ptr %30, align 1
  switch i1 %207, label %324 [
    i1 false, label %326
    i1 true, label %342
  ]

208:                                              ; preds = %147
  br i1 false, label %209, label %415

209:                                              ; preds = %208
  unreachable

210:                                              ; preds = %147
  %211 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %40, align 8
  %212 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %211, 1
  %213 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %212, 0
  %214 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %212, 1
  call void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %213)
  %215 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %214)
  %216 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 0
  %217 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %216)
  %218 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %217, 0
  %219 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %218)
  %220 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %219, 0
  %221 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %219, 1
  %222 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %221, 0
  %223 = insertvalue { { {} } } undef, { {} } %6, 0
  %224 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %222, 0
  %225 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %224, { { {} } } %223, 1
  %226 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f39"(i64 %183, i64 %184, i64 %2, i64 %48, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %225, { i32, i32, i32, i32 } zeroinitializer, {} undef)
  %227 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %226, 0
  %228 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %226, 1
  %229 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %226, 2
  %230 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %226, 3
  %231 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %226, 4
  %232 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %226, 5
  store { i64, [40 x i8] } %232, ptr %42, align 8
  %233 = load i1, ptr %42, align 1
  switch i1 %233, label %246 [
    i1 false, label %248
    i1 true, label %267
  ]

234:                                              ; preds = %147
  %235 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %40, align 8
  %236 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %235, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %9)
  %237 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %236, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %237, ptr %41, align 8
  %238 = load { i64, [40 x i8] }, ptr %41, align 8
  %239 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %183, 0
  %240 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %239, i64 %184, 1
  %241 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %240, i64 %2, 2
  %242 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %241, i64 %48, 3
  %243 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %242, i64 %185, 4
  %244 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %243, ptr %5, 5
  %245 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %244, { i64, [40 x i8] } %238, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %245

246:                                              ; preds = %210
  br i1 false, label %247, label %416

247:                                              ; preds = %246
  unreachable

248:                                              ; preds = %210
  %249 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } }, ptr %42, align 8
  %250 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %249, 1
  %251 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %220)
  %252 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %251, 0
  %253 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %251, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %252)
  %254 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %9, 0
  %255 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } undef, { {} } %6, 0
  %256 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %255, { { ptr, i32, i32, i32 } } %253, 1
  %257 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %254, 0
  %258 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %257, { { {} }, { { ptr, i32, i32, i32 } } } %256, 1
  %259 = call fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f43"(i64 %227, i64 %228, i64 %230, i64 %185, ptr %231, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %258, { ptr, i32, i32, i32 } zeroinitializer)
  %260 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %259, 0
  %261 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %259, 1
  %262 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %259, 2
  %263 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %259, 3
  %264 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %259, 4
  %265 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %259, 5
  store { i64, [72 x i8] } %265, ptr %44, align 8
  %266 = load i1, ptr %44, align 1
  switch i1 %266, label %279 [
    i1 false, label %281
    i1 true, label %312
  ]

267:                                              ; preds = %210
  %268 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %42, align 8
  %269 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %268, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %220)
  call void @"drop$212"({ ptr, i32, i32, i32 } %9)
  %270 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %269, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %270, ptr %43, align 8
  %271 = load { i64, [40 x i8] }, ptr %43, align 8
  %272 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %227, 0
  %273 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %272, i64 %228, 1
  %274 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %273, i64 %229, 2
  %275 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %274, i64 %230, 3
  %276 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %275, i64 %185, 4
  %277 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %276, ptr %231, 5
  %278 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %277, { i64, [40 x i8] } %271, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %278

279:                                              ; preds = %248
  br i1 false, label %280, label %417

280:                                              ; preds = %279
  unreachable

281:                                              ; preds = %248
  %282 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %44, align 8
  %283 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %282, 1
  %284 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %285 = call ptr %284()
  %286 = getelementptr inbounds i64, ptr %285, i32 1
  %287 = load i64, ptr %286, align 8
  %288 = getelementptr inbounds i64, ptr %285, i32 2
  %289 = load i64, ptr %288, align 8
  %290 = mul i64 %289, 4
  %291 = add i64 %287, %290
  %292 = load i64, ptr %285, align 8
  %293 = mul i64 %292, 11710
  %294 = add i64 %291, %293
  %295 = call i64 @llvm.uadd.sat.i64(i64 %261, i64 %294)
  %296 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %250, 0
  %297 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %250, 1
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %296)
  %298 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %283, 0
  %299 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %283, 1
  call void @"drop$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %298)
  %300 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { i32, i32, i32, i32 } %297, 0
  %301 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %300, { ptr, i32, i32, i32 } %299, 1
  %302 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %301, 0
  %303 = insertvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } { i1 false, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %302, 1
  store { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %303, ptr %46, align 8
  %304 = load { i64, [40 x i8] }, ptr %46, align 8
  %305 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %260, 0
  %306 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %305, i64 %295, 1
  %307 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %306, i64 %229, 2
  %308 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %307, i64 %262, 3
  %309 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %308, i64 %263, 4
  %310 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %309, ptr %264, 5
  %311 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %310, { i64, [40 x i8] } %304, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %311

312:                                              ; preds = %248
  %313 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %44, align 8
  %314 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %313, 1
  call void @"drop$316"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %250)
  %315 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %314, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %315, ptr %45, align 8
  %316 = load { i64, [40 x i8] }, ptr %45, align 8
  %317 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %260, 0
  %318 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %317, i64 %261, 1
  %319 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %318, i64 %229, 2
  %320 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %319, i64 %262, 3
  %321 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %320, i64 %263, 4
  %322 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %321, ptr %264, 5
  %323 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %322, { i64, [40 x i8] } %316, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %323

324:                                              ; preds = %188
  br i1 false, label %325, label %418

325:                                              ; preds = %324
  unreachable

326:                                              ; preds = %188
  %327 = load { i1, { { i32, i32, i32, i32 } } }, ptr %30, align 4
  %328 = extractvalue { i1, { { i32, i32, i32, i32 } } } %327, 1
  %329 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %9, 0
  %330 = insertvalue { { {} }, i32 } undef, { {} } %6, 0
  %331 = insertvalue { { {} }, i32 } %330, i32 %190, 1
  %332 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } undef, { { ptr, i32, i32, i32 } } %329, 0
  %333 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %332, { { {} }, i32 } %331, 1
  %334 = call fastcc { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } @"impl$f44"(i64 %202, i64 %203, i64 %191, i64 %4, ptr %205, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %333, { ptr, i32, i32, i32 } zeroinitializer)
  %335 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %334, 0
  %336 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %334, 1
  %337 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %334, 2
  %338 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %334, 3
  %339 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %334, 4
  %340 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %334, 5
  store { i64, [56 x i8] } %340, ptr %32, align 8
  %341 = load i1, ptr %32, align 1
  switch i1 %341, label %354 [
    i1 false, label %356
    i1 true, label %377
  ]

342:                                              ; preds = %188
  %343 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %30, align 8
  %344 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %343, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %9)
  %345 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %344, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %345, ptr %31, align 8
  %346 = load { i64, [40 x i8] }, ptr %31, align 8
  %347 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %202, 0
  %348 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %347, i64 %203, 1
  %349 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %348, i64 %204, 2
  %350 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %349, i64 %191, 3
  %351 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %350, i64 %4, 4
  %352 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %351, ptr %205, 5
  %353 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %352, { i64, [40 x i8] } %346, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %353

354:                                              ; preds = %326
  br i1 false, label %355, label %419

355:                                              ; preds = %354
  unreachable

356:                                              ; preds = %326
  %357 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %32, align 8
  %358 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %357, 1
  %359 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %360 = call ptr %359()
  %361 = call i64 @llvm.uadd.sat.i64(i64 %336, i64 0)
  %362 = extractvalue { { i32, i32, i32, i32 } } %328, 0
  %363 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %358, 0
  %364 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %358, 1
  call void @"drop$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %363)
  %365 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { i32, i32, i32, i32 } %362, 0
  %366 = insertvalue { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %365, { ptr, i32, i32, i32 } %364, 1
  %367 = insertvalue { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %366, 0
  %368 = insertvalue { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } { i1 false, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef }, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %367, 1
  store { i1, { { { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %368, ptr %34, align 8
  %369 = load { i64, [40 x i8] }, ptr %34, align 8
  %370 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %335, 0
  %371 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %370, i64 %361, 1
  %372 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %371, i64 %204, 2
  %373 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %372, i64 %337, 3
  %374 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %373, i64 %338, 4
  %375 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %374, ptr %339, 5
  %376 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %375, { i64, [40 x i8] } %369, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %376

377:                                              ; preds = %326
  %378 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %32, align 8
  %379 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %378, 1
  %380 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %379, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %380, ptr %33, align 8
  %381 = load { i64, [40 x i8] }, ptr %33, align 8
  %382 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %335, 0
  %383 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %382, i64 %336, 1
  %384 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %383, i64 %204, 2
  %385 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %384, i64 %337, 3
  %386 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %385, i64 %338, 4
  %387 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %386, ptr %339, 5
  %388 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %387, { i64, [40 x i8] } %381, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %388

389:                                              ; preds = %85
  %390 = phi { ptr, i32, i32, i32 } [ %9, %85 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %390)
  %391 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %116, 1
  %392 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %391, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %392, ptr %23, align 8
  %393 = load { i64, [40 x i8] }, ptr %23, align 8
  %394 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %53, 0
  %395 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %394, i64 %117, 1
  %396 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %395, i64 %2, 2
  %397 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %396, i64 %48, 3
  %398 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %397, i64 %4, 4
  %399 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %398, ptr %5, 5
  %400 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %399, { i64, [40 x i8] } %393, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %400

401:                                              ; preds = %10
  %402 = phi { ptr, i32, i32, i32 } [ %9, %10 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %402)
  %403 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %65, 1
  %404 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %403, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %404, ptr %17, align 8
  %405 = load { i64, [40 x i8] }, ptr %17, align 8
  %406 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %53, 0
  %407 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %406, i64 %66, 1
  %408 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %407, i64 %2, 2
  %409 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %408, i64 %48, 3
  %410 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %409, i64 %4, 4
  %411 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %410, ptr %5, 5
  %412 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %411, { i64, [40 x i8] } %405, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %412

413:                                              ; preds = %125
  call void @puts(ptr @assert_msg_46)
  call void @abort()
  unreachable

414:                                              ; preds = %145
  call void @puts(ptr @assert_msg_47)
  call void @abort()
  unreachable

415:                                              ; preds = %208
  call void @puts(ptr @assert_msg_48)
  call void @abort()
  unreachable

416:                                              ; preds = %246
  call void @puts(ptr @assert_msg_49)
  call void @abort()
  unreachable

417:                                              ; preds = %279
  call void @puts(ptr @assert_msg_50)
  call void @abort()
  unreachable

418:                                              ; preds = %324
  call void @puts(ptr @assert_msg_51)
  call void @abort()
  unreachable

419:                                              ; preds = %354
  call void @puts(ptr @assert_msg_52)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f21(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call fastcc { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f21"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9)
  %12 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 0
  %13 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 1
  %14 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 2
  %15 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 3
  %16 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 4
  %17 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 5
  %18 = extractvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, 6
  %19 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %12, 0
  %20 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %19, i64 %13, 1
  %21 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %20, i64 %14, 2
  %22 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %21, i64 %15, 3
  %23 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %22, i64 %16, 4
  %24 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %23, ptr %17, 5
  %25 = insertvalue { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %24, { i64, [40 x i8] } %18, 6
  ret { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %25
}

define void @_mlir_ciface_f21(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { {} } %7, i252 %8, { i128, i128 } %9, { ptr, i32, i32, i32 } %10) {
  %12 = call { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f21(i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, ptr %6, { {} } %7, i252 %8, { i128, i128 } %9, { ptr, i32, i32, i32 } %10)
  store { i64, i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %12, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f22"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [8 x i8] }, i64 1, align 4
  %4 = alloca { i32, [8 x i8] }, i64 1, align 4
  %5 = alloca { i32, [4 x i8] }, i64 1, align 4
  %6 = alloca { i32, [8 x i8] }, i64 1, align 4
  %7 = alloca { i32, [4 x i8] }, i64 1, align 4
  %8 = alloca { i32, [8 x i8] }, i64 1, align 4
  %9 = alloca { i32, [4 x i8] }, i64 1, align 4
  %10 = alloca { i32, [8 x i8] }, i64 1, align 4
  %11 = alloca { i32, [4 x i8] }, i64 1, align 4
  %12 = alloca { i32, [8 x i8] }, i64 1, align 4
  %13 = alloca { i32, [4 x i8] }, i64 1, align 4
  %14 = alloca { i32, [8 x i8] }, i64 1, align 4
  %15 = alloca { i32, [4 x i8] }, i64 1, align 4
  %16 = alloca { i32, [8 x i8] }, i64 1, align 4
  %17 = alloca { i32, [4 x i8] }, i64 1, align 4
  %18 = alloca { i32, [8 x i8] }, i64 1, align 4
  %19 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %20 = extractvalue { ptr, i32, i32, i32 } %19, 1
  %21 = extractvalue { ptr, i32, i32, i32 } %19, 2
  %22 = sub i32 %21, %20
  %23 = icmp uge i32 %22, 1
  br i1 %23, label %24, label %295

24:                                               ; preds = %2
  %25 = extractvalue { ptr, i32, i32, i32 } %19, 0
  %26 = load ptr, ptr %25, align 8
  %27 = zext i32 %20 to i64
  %28 = mul i64 %27, 32
  %29 = getelementptr inbounds i8, ptr %26, i64 %28
  %30 = add i32 %20, 1
  %31 = insertvalue { ptr, i32, i32, i32 } %19, i32 %30, 1
  %32 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %32, ptr %29, i64 32, i1 false)
  %33 = load i252, ptr %32, align 16
  call void @free(ptr %32)
  %34 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$27"({ ptr, i32, i32, i32 } %31)
  %35 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %34, 1
  %37 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %36, 0
  %38 = icmp eq i252 %33, 0
  br i1 %38, label %39, label %47

39:                                               ; preds = %24
  %40 = phi { ptr, i32, i32, i32 } [ %35, %24 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %40)
  store { i3, [0 x i8] } { i3 0, [0 x i8] undef }, ptr %17, align 1
  %41 = load { i32, [4 x i8] }, ptr %17, align 4
  %42 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %41, 1
  store { i1, { i32, [4 x i8] } } %42, ptr %18, align 4
  %43 = load { i32, [8 x i8] }, ptr %18, align 4
  %44 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %0, 0
  %45 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %44, { { ptr, i32, i32, i32 } } %37, 1
  %46 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %45, { i32, [8 x i8] } %43, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %46

47:                                               ; preds = %24
  %48 = phi i252 [ %33, %24 ]
  %49 = zext i252 %48 to i256
  %50 = sub i256 %49, 1
  %51 = add i256 %49, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %52 = icmp ult i256 %49, 1
  %53 = select i1 %52, i256 %51, i256 %50
  %54 = trunc i256 %53 to i252
  %55 = icmp eq i252 %54, 0
  br i1 %55, label %56, label %87

56:                                               ; preds = %47
  %57 = phi { { ptr, i32, i32, i32 } } [ %37, %47 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %57)
  %58 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %59 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %60 = sub i32 %59, %58
  %61 = icmp uge i32 %60, 1
  br i1 %61, label %62, label %295

62:                                               ; preds = %56
  %63 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %64 = load ptr, ptr %63, align 8
  %65 = zext i32 %58 to i64
  %66 = mul i64 %65, 32
  %67 = getelementptr inbounds i8, ptr %64, i64 %66
  %68 = add i32 %58, 1
  %69 = insertvalue { ptr, i32, i32, i32 } %35, i32 %68, 1
  %70 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %70, ptr %67, i64 32, i1 false)
  %71 = load i252, ptr %70, align 16
  call void @free(ptr %70)
  %72 = icmp ult i252 %71, 4294967296
  %73 = add i64 %0, 2
  %74 = add i64 %0, 3
  %75 = select i1 %72, i64 %73, i64 %74
  %76 = trunc i252 %71 to i32
  br i1 %72, label %77, label %295

77:                                               ; preds = %62
  %78 = phi { ptr, i32, i32, i32 } [ %69, %62 ]
  %79 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %78, 0
  %80 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %76, 1
  store { i3, i32 } %80, ptr %15, align 4
  %81 = load { i32, [4 x i8] }, ptr %15, align 4
  %82 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %81, 1
  store { i1, { i32, [4 x i8] } } %82, ptr %16, align 4
  %83 = load { i32, [8 x i8] }, ptr %16, align 4
  %84 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %75, 0
  %85 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %84, { { ptr, i32, i32, i32 } } %79, 1
  %86 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %85, { i32, [8 x i8] } %83, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %86

87:                                               ; preds = %47
  %88 = phi i252 [ %48, %47 ]
  %89 = zext i252 %88 to i256
  %90 = sub i256 %89, 2
  %91 = add i256 %89, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %92 = icmp ult i256 %89, 2
  %93 = select i1 %92, i256 %91, i256 %90
  %94 = trunc i256 %93 to i252
  %95 = icmp eq i252 %94, 0
  br i1 %95, label %96, label %127

96:                                               ; preds = %87
  %97 = phi { { ptr, i32, i32, i32 } } [ %37, %87 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %97)
  %98 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %99 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %100 = sub i32 %99, %98
  %101 = icmp uge i32 %100, 1
  br i1 %101, label %102, label %295

102:                                              ; preds = %96
  %103 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %104 = load ptr, ptr %103, align 8
  %105 = zext i32 %98 to i64
  %106 = mul i64 %105, 32
  %107 = getelementptr inbounds i8, ptr %104, i64 %106
  %108 = add i32 %98, 1
  %109 = insertvalue { ptr, i32, i32, i32 } %35, i32 %108, 1
  %110 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %110, ptr %107, i64 32, i1 false)
  %111 = load i252, ptr %110, align 16
  call void @free(ptr %110)
  %112 = icmp ult i252 %111, 4294967296
  %113 = add i64 %0, 2
  %114 = add i64 %0, 3
  %115 = select i1 %112, i64 %113, i64 %114
  %116 = trunc i252 %111 to i32
  br i1 %112, label %117, label %295

117:                                              ; preds = %102
  %118 = phi { ptr, i32, i32, i32 } [ %109, %102 ]
  %119 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %118, 0
  %120 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %116, 1
  store { i3, i32 } %120, ptr %13, align 4
  %121 = load { i32, [4 x i8] }, ptr %13, align 4
  %122 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %121, 1
  store { i1, { i32, [4 x i8] } } %122, ptr %14, align 4
  %123 = load { i32, [8 x i8] }, ptr %14, align 4
  %124 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %115, 0
  %125 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %124, { { ptr, i32, i32, i32 } } %119, 1
  %126 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %125, { i32, [8 x i8] } %123, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %126

127:                                              ; preds = %87
  %128 = phi i252 [ %88, %87 ]
  %129 = zext i252 %128 to i256
  %130 = sub i256 %129, 3
  %131 = add i256 %129, 3618502788666131213697322783095070105623107215331596699973092056135872020478
  %132 = icmp ult i256 %129, 3
  %133 = select i1 %132, i256 %131, i256 %130
  %134 = trunc i256 %133 to i252
  %135 = icmp eq i252 %134, 0
  br i1 %135, label %136, label %167

136:                                              ; preds = %127
  %137 = phi { { ptr, i32, i32, i32 } } [ %37, %127 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %137)
  %138 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %139 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %140 = sub i32 %139, %138
  %141 = icmp uge i32 %140, 1
  br i1 %141, label %142, label %295

142:                                              ; preds = %136
  %143 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %144 = load ptr, ptr %143, align 8
  %145 = zext i32 %138 to i64
  %146 = mul i64 %145, 32
  %147 = getelementptr inbounds i8, ptr %144, i64 %146
  %148 = add i32 %138, 1
  %149 = insertvalue { ptr, i32, i32, i32 } %35, i32 %148, 1
  %150 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %150, ptr %147, i64 32, i1 false)
  %151 = load i252, ptr %150, align 16
  call void @free(ptr %150)
  %152 = icmp ult i252 %151, 4294967296
  %153 = add i64 %0, 2
  %154 = add i64 %0, 3
  %155 = select i1 %152, i64 %153, i64 %154
  %156 = trunc i252 %151 to i32
  br i1 %152, label %157, label %295

157:                                              ; preds = %142
  %158 = phi { ptr, i32, i32, i32 } [ %149, %142 ]
  %159 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %158, 0
  %160 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %156, 1
  store { i3, i32 } %160, ptr %11, align 4
  %161 = load { i32, [4 x i8] }, ptr %11, align 4
  %162 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %161, 1
  store { i1, { i32, [4 x i8] } } %162, ptr %12, align 4
  %163 = load { i32, [8 x i8] }, ptr %12, align 4
  %164 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %155, 0
  %165 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %164, { { ptr, i32, i32, i32 } } %159, 1
  %166 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %165, { i32, [8 x i8] } %163, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %166

167:                                              ; preds = %127
  %168 = phi i252 [ %128, %127 ]
  %169 = zext i252 %168 to i256
  %170 = sub i256 %169, 4
  %171 = add i256 %169, 3618502788666131213697322783095070105623107215331596699973092056135872020477
  %172 = icmp ult i256 %169, 4
  %173 = select i1 %172, i256 %171, i256 %170
  %174 = trunc i256 %173 to i252
  %175 = icmp eq i252 %174, 0
  br i1 %175, label %176, label %207

176:                                              ; preds = %167
  %177 = phi { { ptr, i32, i32, i32 } } [ %37, %167 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %177)
  %178 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %179 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %180 = sub i32 %179, %178
  %181 = icmp uge i32 %180, 1
  br i1 %181, label %182, label %295

182:                                              ; preds = %176
  %183 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %184 = load ptr, ptr %183, align 8
  %185 = zext i32 %178 to i64
  %186 = mul i64 %185, 32
  %187 = getelementptr inbounds i8, ptr %184, i64 %186
  %188 = add i32 %178, 1
  %189 = insertvalue { ptr, i32, i32, i32 } %35, i32 %188, 1
  %190 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %190, ptr %187, i64 32, i1 false)
  %191 = load i252, ptr %190, align 16
  call void @free(ptr %190)
  %192 = icmp ult i252 %191, 4294967296
  %193 = add i64 %0, 2
  %194 = add i64 %0, 3
  %195 = select i1 %192, i64 %193, i64 %194
  %196 = trunc i252 %191 to i32
  br i1 %192, label %197, label %295

197:                                              ; preds = %182
  %198 = phi { ptr, i32, i32, i32 } [ %189, %182 ]
  %199 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %198, 0
  %200 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %196, 1
  store { i3, i32 } %200, ptr %9, align 4
  %201 = load { i32, [4 x i8] }, ptr %9, align 4
  %202 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %201, 1
  store { i1, { i32, [4 x i8] } } %202, ptr %10, align 4
  %203 = load { i32, [8 x i8] }, ptr %10, align 4
  %204 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %195, 0
  %205 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %204, { { ptr, i32, i32, i32 } } %199, 1
  %206 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %205, { i32, [8 x i8] } %203, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %206

207:                                              ; preds = %167
  %208 = phi i252 [ %168, %167 ]
  %209 = zext i252 %208 to i256
  %210 = sub i256 %209, 5
  %211 = add i256 %209, 3618502788666131213697322783095070105623107215331596699973092056135872020476
  %212 = icmp ult i256 %209, 5
  %213 = select i1 %212, i256 %211, i256 %210
  %214 = trunc i256 %213 to i252
  %215 = icmp eq i252 %214, 0
  br i1 %215, label %216, label %247

216:                                              ; preds = %207
  %217 = phi { { ptr, i32, i32, i32 } } [ %37, %207 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %217)
  %218 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %219 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %220 = sub i32 %219, %218
  %221 = icmp uge i32 %220, 1
  br i1 %221, label %222, label %295

222:                                              ; preds = %216
  %223 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %224 = load ptr, ptr %223, align 8
  %225 = zext i32 %218 to i64
  %226 = mul i64 %225, 32
  %227 = getelementptr inbounds i8, ptr %224, i64 %226
  %228 = add i32 %218, 1
  %229 = insertvalue { ptr, i32, i32, i32 } %35, i32 %228, 1
  %230 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %230, ptr %227, i64 32, i1 false)
  %231 = load i252, ptr %230, align 16
  call void @free(ptr %230)
  %232 = icmp ult i252 %231, 4294967296
  %233 = add i64 %0, 2
  %234 = add i64 %0, 3
  %235 = select i1 %232, i64 %233, i64 %234
  %236 = trunc i252 %231 to i32
  br i1 %232, label %237, label %295

237:                                              ; preds = %222
  %238 = phi { ptr, i32, i32, i32 } [ %229, %222 ]
  %239 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %238, 0
  %240 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %236, 1
  store { i3, i32 } %240, ptr %7, align 4
  %241 = load { i32, [4 x i8] }, ptr %7, align 4
  %242 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %241, 1
  store { i1, { i32, [4 x i8] } } %242, ptr %8, align 4
  %243 = load { i32, [8 x i8] }, ptr %8, align 4
  %244 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %235, 0
  %245 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %244, { { ptr, i32, i32, i32 } } %239, 1
  %246 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %245, { i32, [8 x i8] } %243, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %246

247:                                              ; preds = %207
  %248 = phi i252 [ %208, %207 ]
  %249 = phi i252 [ 6, %207 ]
  %250 = zext i252 %248 to i256
  %251 = zext i252 %249 to i256
  %252 = sub i256 %250, %251
  %253 = add i256 %252, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %254 = icmp ult i256 %250, %251
  %255 = select i1 %254, i256 %253, i256 %252
  %256 = trunc i256 %255 to i252
  %257 = icmp eq i252 %256, 0
  br i1 %257, label %258, label %289

258:                                              ; preds = %247
  %259 = phi { { ptr, i32, i32, i32 } } [ %37, %247 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %259)
  %260 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %261 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %262 = sub i32 %261, %260
  %263 = icmp uge i32 %262, 1
  br i1 %263, label %264, label %295

264:                                              ; preds = %258
  %265 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %266 = load ptr, ptr %265, align 8
  %267 = zext i32 %260 to i64
  %268 = mul i64 %267, 32
  %269 = getelementptr inbounds i8, ptr %266, i64 %268
  %270 = add i32 %260, 1
  %271 = insertvalue { ptr, i32, i32, i32 } %35, i32 %270, 1
  %272 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %272, ptr %269, i64 32, i1 false)
  %273 = load i252, ptr %272, align 16
  call void @free(ptr %272)
  %274 = icmp ult i252 %273, 4294967296
  %275 = add i64 %0, 2
  %276 = add i64 %0, 3
  %277 = select i1 %274, i64 %275, i64 %276
  %278 = trunc i252 %273 to i32
  br i1 %274, label %279, label %295

279:                                              ; preds = %264
  %280 = phi { ptr, i32, i32, i32 } [ %271, %264 ]
  %281 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %280, 0
  %282 = insertvalue { i3, i32 } { i3 -2, i32 undef }, i32 %278, 1
  store { i3, i32 } %282, ptr %5, align 4
  %283 = load { i32, [4 x i8] }, ptr %5, align 4
  %284 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %283, 1
  store { i1, { i32, [4 x i8] } } %284, ptr %6, align 4
  %285 = load { i32, [8 x i8] }, ptr %6, align 4
  %286 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %277, 0
  %287 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %286, { { ptr, i32, i32, i32 } } %281, 1
  %288 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %287, { i32, [8 x i8] } %285, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %288

289:                                              ; preds = %247
  %290 = phi { ptr, i32, i32, i32 } [ %35, %247 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %290)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %291 = load { i32, [8 x i8] }, ptr %4, align 4
  %292 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %0, 0
  %293 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %292, { { ptr, i32, i32, i32 } } %37, 1
  %294 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %293, { i32, [8 x i8] } %291, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %294

295:                                              ; preds = %62, %56, %102, %96, %142, %136, %182, %176, %222, %216, %264, %258, %2
  %296 = phi i64 [ %277, %264 ], [ %0, %258 ], [ %235, %222 ], [ %0, %216 ], [ %195, %182 ], [ %0, %176 ], [ %155, %142 ], [ %0, %136 ], [ %115, %102 ], [ %0, %96 ], [ %75, %62 ], [ %0, %56 ], [ %0, %2 ]
  %297 = phi { ptr, i32, i32, i32 } [ %271, %264 ], [ %35, %258 ], [ %229, %222 ], [ %35, %216 ], [ %189, %182 ], [ %35, %176 ], [ %149, %142 ], [ %35, %136 ], [ %109, %102 ], [ %35, %96 ], [ %69, %62 ], [ %35, %56 ], [ %19, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %298 = load { i32, [8 x i8] }, ptr %3, align 4
  %299 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %297, 0
  %300 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %296, 0
  %301 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %300, { { ptr, i32, i32, i32 } } %299, 1
  %302 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %301, { i32, [8 x i8] } %298, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %302
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @f22(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f22"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %8, { i32, [8 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %9
}

define void @_mlir_ciface_f22(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @f22(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$306"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$40"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$306"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$40"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$307"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$306"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$307"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$306"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$308"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$307"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$308"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$307"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f23"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [80 x i8] }, i64 1, align 16
  %5 = alloca { i128, [128 x i8] }, i64 1, align 16
  %6 = alloca { i64, [56 x i8] }, i64 1, align 8
  %7 = alloca { i128, [128 x i8] }, i64 1, align 16
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [128 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [128 x i8] }, i64 1, align 16
  %13 = extractvalue { { ptr, i32, i32, i32 } } %2, 0
  %14 = extractvalue { ptr, i32, i32, i32 } %13, 1
  %15 = extractvalue { ptr, i32, i32, i32 } %13, 2
  %16 = sub i32 %15, %14
  %17 = icmp uge i32 %16, 1
  br i1 %17, label %18, label %146

18:                                               ; preds = %3
  %19 = extractvalue { ptr, i32, i32, i32 } %13, 0
  %20 = load ptr, ptr %19, align 8
  %21 = zext i32 %14 to i64
  %22 = mul i64 %21, 32
  %23 = getelementptr inbounds i8, ptr %20, i64 %22
  %24 = add i32 %14, 1
  %25 = insertvalue { ptr, i32, i32, i32 } %13, i32 %24, 1
  %26 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %26, ptr %23, i64 32, i1 false)
  %27 = load i252, ptr %26, align 16
  call void @free(ptr %26)
  %28 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %25, 0
  %29 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f45"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %28, { ptr, i32, i32, i32 } zeroinitializer, i252 %27)
  %30 = extractvalue { i64, i64, { i64, [56 x i8] } } %29, 0
  %31 = extractvalue { i64, i64, { i64, [56 x i8] } } %29, 1
  %32 = extractvalue { i64, i64, { i64, [56 x i8] } } %29, 2
  store { i64, [56 x i8] } %32, ptr %6, align 8
  %33 = load i1, ptr %6, align 1
  switch i1 %33, label %34 [
    i1 false, label %36
    i1 true, label %43
  ]

34:                                               ; preds = %18
  br i1 false, label %35, label %166

35:                                               ; preds = %34
  unreachable

36:                                               ; preds = %18
  %37 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %6, align 8
  %38 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %37, 1
  %39 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %38, 0
  %40 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %38, 1
  %41 = extractvalue { { ptr, i32, i32, i32 } } %39, 0
  store { i64, [24 x i8] } %40, ptr %8, align 8
  %42 = load i1, ptr %8, align 1
  switch i1 %42, label %51 [
    i1 false, label %53
    i1 true, label %60
  ]

43:                                               ; preds = %18
  %44 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %45 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %44, 1
  %46 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %45, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %46, ptr %7, align 8
  %47 = load { i128, [128 x i8] }, ptr %7, align 16
  %48 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %30, 0
  %49 = insertvalue { i64, i64, { i128, [128 x i8] } } %48, i64 %31, 1
  %50 = insertvalue { i64, i64, { i128, [128 x i8] } } %49, { i128, [128 x i8] } %47, 2
  ret { i64, i64, { i128, [128 x i8] } } %50

51:                                               ; preds = %36
  br i1 false, label %52, label %167

52:                                               ; preds = %51
  unreachable

53:                                               ; preds = %36
  %54 = load { i1, { ptr, i32, i32, i32 } }, ptr %8, align 8
  %55 = extractvalue { i1, { ptr, i32, i32, i32 } } %54, 1
  %56 = extractvalue { ptr, i32, i32, i32 } %41, 1
  %57 = extractvalue { ptr, i32, i32, i32 } %41, 2
  %58 = sub i32 %57, %56
  %59 = icmp uge i32 %58, 1
  br i1 %59, label %66, label %126

60:                                               ; preds = %36
  %61 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %62 = call ptr %61()
  %63 = load i64, ptr %62, align 8
  %64 = mul i64 %63, 1910
  %65 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %64)
  br label %153

66:                                               ; preds = %53
  %67 = extractvalue { ptr, i32, i32, i32 } %41, 0
  %68 = load ptr, ptr %67, align 8
  %69 = zext i32 %56 to i64
  %70 = mul i64 %69, 32
  %71 = getelementptr inbounds i8, ptr %68, i64 %70
  %72 = add i32 %56, 1
  %73 = insertvalue { ptr, i32, i32, i32 } %41, i32 %72, 1
  %74 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %74, ptr %71, i64 32, i1 false)
  %75 = extractvalue { ptr, i32, i32, i32 } %41, 2
  %76 = sub i32 %75, %72
  %77 = icmp uge i32 %76, 1
  br i1 %77, label %78, label %119

78:                                               ; preds = %66
  %79 = extractvalue { ptr, i32, i32, i32 } %41, 0
  %80 = load ptr, ptr %79, align 8
  %81 = zext i32 %72 to i64
  %82 = mul i64 %81, 32
  %83 = getelementptr inbounds i8, ptr %80, i64 %82
  %84 = add i32 %56, 2
  %85 = insertvalue { ptr, i32, i32, i32 } %73, i32 %84, 1
  %86 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %86, ptr %83, i64 32, i1 false)
  %87 = load i252, ptr %86, align 16
  call void @free(ptr %86)
  %88 = icmp ult i252 %87, 4294967296
  %89 = add i64 %30, 2
  %90 = add i64 %30, 3
  %91 = select i1 %88, i64 %89, i64 %90
  %92 = trunc i252 %87 to i32
  br i1 %88, label %93, label %114

93:                                               ; preds = %78
  %94 = phi i64 [ %31, %78 ]
  %95 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %96 = call ptr %95()
  %97 = load i64, ptr %96, align 8
  %98 = mul i64 %97, 1170
  %99 = call i64 @llvm.uadd.sat.i64(i64 %94, i64 %98)
  %100 = load i252, ptr %74, align 16
  call void @free(ptr %74)
  %101 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %85, 0
  %102 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %55, 0
  %103 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %102, i252 %100, 1
  %104 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %103, i32 %92, 2
  %105 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } { i1 false, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %104, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %105, ptr %11, align 16
  %106 = load { i128, [80 x i8] }, ptr %11, align 16
  %107 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %101, 0
  %108 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %107, { i128, [80 x i8] } %106, 1
  %109 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %108, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %109, ptr %12, align 16
  %110 = load { i128, [128 x i8] }, ptr %12, align 16
  %111 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %91, 0
  %112 = insertvalue { i64, i64, { i128, [128 x i8] } } %111, i64 %99, 1
  %113 = insertvalue { i64, i64, { i128, [128 x i8] } } %112, { i128, [128 x i8] } %110, 2
  ret { i64, i64, { i128, [128 x i8] } } %113

114:                                              ; preds = %78
  %115 = phi ptr [ %74, %78 ]
  call void @"drop$409"(ptr %115)
  call void @"drop$40"({ ptr, i32, i32, i32 } %55)
  %116 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %117 = call ptr %116()
  %118 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 0)
  br label %133

119:                                              ; preds = %66
  %120 = phi ptr [ %74, %66 ]
  call void @"drop$409"(ptr %120)
  call void @"drop$40"({ ptr, i32, i32, i32 } %55)
  %121 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %122 = call ptr %121()
  %123 = load i64, ptr %122, align 8
  %124 = mul i64 %123, 1210
  %125 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %124)
  br label %133

126:                                              ; preds = %53
  %127 = phi { ptr, i32, i32, i32 } [ %55, %53 ]
  call void @"drop$40"({ ptr, i32, i32, i32 } %127)
  %128 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %129 = call ptr %128()
  %130 = load i64, ptr %129, align 8
  %131 = mul i64 %130, 1710
  %132 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %131)
  br label %133

133:                                              ; preds = %114, %119, %126
  %134 = phi i64 [ %30, %126 ], [ %30, %119 ], [ %91, %114 ]
  %135 = phi i64 [ %132, %126 ], [ %125, %119 ], [ %118, %114 ]
  %136 = phi { ptr, i32, i32, i32 } [ %41, %126 ], [ %73, %119 ], [ %85, %114 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %137 = load { i128, [80 x i8] }, ptr %9, align 16
  %138 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %136, 0
  %139 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %138, 0
  %140 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %139, { i128, [80 x i8] } %137, 1
  %141 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %140, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %141, ptr %10, align 16
  %142 = load { i128, [128 x i8] }, ptr %10, align 16
  %143 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %134, 0
  %144 = insertvalue { i64, i64, { i128, [128 x i8] } } %143, i64 %135, 1
  %145 = insertvalue { i64, i64, { i128, [128 x i8] } } %144, { i128, [128 x i8] } %142, 2
  ret { i64, i64, { i128, [128 x i8] } } %145

146:                                              ; preds = %3
  %147 = phi i64 [ %1, %3 ]
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = load i64, ptr %149, align 8
  %151 = mul i64 %150, 5280
  %152 = call i64 @llvm.uadd.sat.i64(i64 %147, i64 %151)
  br label %153

153:                                              ; preds = %60, %146
  %154 = phi i64 [ %0, %146 ], [ %30, %60 ]
  %155 = phi i64 [ %152, %146 ], [ %65, %60 ]
  %156 = phi { ptr, i32, i32, i32 } [ %13, %146 ], [ %41, %60 ]
  %157 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %156, 0
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %158 = load { i128, [80 x i8] }, ptr %4, align 16
  %159 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %157, 0
  %160 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %159, { i128, [80 x i8] } %158, 1
  %161 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %160, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %161, ptr %5, align 16
  %162 = load { i128, [128 x i8] }, ptr %5, align 16
  %163 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %154, 0
  %164 = insertvalue { i64, i64, { i128, [128 x i8] } } %163, i64 %155, 1
  %165 = insertvalue { i64, i64, { i128, [128 x i8] } } %164, { i128, [128 x i8] } %162, 2
  ret { i64, i64, { i128, [128 x i8] } } %165

166:                                              ; preds = %34
  call void @puts(ptr @assert_msg_53)
  call void @abort()
  unreachable

167:                                              ; preds = %51
  call void @puts(ptr @assert_msg_54)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [128 x i8] } } @f23(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f23"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [128 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [128 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [128 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [128 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [128 x i8] } } %9, { i128, [128 x i8] } %7, 2
  ret { i64, i64, { i128, [128 x i8] } } %10
}

define void @_mlir_ciface_f23(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [128 x i8] } } @f23(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [128 x i8] } } %5, ptr %0, align 16
  ret void
}

define private void @"drop$303"({ i128, [160 x i8] } %0) {
  %2 = alloca { i128, [160 x i8] }, i64 1, align 16
  store { i128, [160 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i128, [144 x i8] } }, ptr %2, align 16
  %6 = extractvalue { i1, { i128, [144 x i8] } } %5, 1
  call void @"drop$103"({ i128, [144 x i8] } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [160 x i8] }, { i128, [160 x i8] } } @"dup$303"({ i128, [160 x i8] } %0) {
  %2 = alloca { i128, [160 x i8] }, i64 1, align 16
  store { i128, [160 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i128, [144 x i8] } }, ptr %2, align 16
  %6 = extractvalue { i1, { i128, [144 x i8] } } %5, 1
  %7 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$103"({ i128, [144 x i8] } %6)
  %8 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %7, 0
  %9 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %7, 1
  %10 = insertvalue { i1, { i128, [144 x i8] } } %5, { i128, [144 x i8] } %8, 1
  store { i1, { i128, [144 x i8] } } %10, ptr %2, align 16
  %11 = load { i128, [160 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { i128, [144 x i8] } } %5, { i128, [144 x i8] } %9, 1
  store { i1, { i128, [144 x i8] } } %12, ptr %2, align 16
  %13 = load { i128, [160 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } undef, { i128, [160 x i8] } %11, 0
  %15 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %14, { i128, [160 x i8] } %13, 1
  ret { { i128, [160 x i8] }, { i128, [160 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [160 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [160 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } undef, { i128, [160 x i8] } %20, 0
  %24 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %23, { i128, [160 x i8] } %22, 1
  ret { { i128, [160 x i8] }, { i128, [160 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$304"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 1
  call void @"drop$303"({ i128, [160 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } @"dup$304"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 1
  %9 = call { { i128, [160 x i8] }, { i128, [160 x i8] } } @"dup$303"({ i128, [160 x i8] } %8)
  %10 = extractvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %9, 0
  %11 = extractvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %6, { i128, [160 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %7, { i128, [160 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %15
}

define private void @"drop$305"({ i128, [208 x i8] } %0) {
  %2 = alloca { i128, [208 x i8] }, i64 1, align 16
  store { i128, [208 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, 1
  call void @"drop$304"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [208 x i8] }, { i128, [208 x i8] } } @"dup$305"({ i128, [208 x i8] } %0) {
  %2 = alloca { i128, [208 x i8] }, i64 1, align 16
  store { i128, [208 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } @"dup$304"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [208 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [208 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } undef, { i128, [208 x i8] } %11, 0
  %15 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } %14, { i128, [208 x i8] } %13, 1
  ret { { i128, [208 x i8] }, { i128, [208 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [208 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [208 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } undef, { i128, [208 x i8] } %23, 0
  %27 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } %26, { i128, [208 x i8] } %25, 1
  ret { { i128, [208 x i8] }, { i128, [208 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f24"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i128, [208 x i8] }, i64 1, align 16
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i128, [160 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %19

19:                                               ; preds = %129, %5
  %20 = phi i64 [ %60, %129 ], [ %0, %5 ]
  %21 = phi i64 [ %89, %129 ], [ %1, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %69, %129 ], [ %2, %5 ]
  %23 = phi { ptr, i32, i32, i32 } [ %138, %129 ], [ %3, %5 ]
  %24 = phi i252 [ %145, %129 ], [ %4, %5 ]
  %25 = add i64 %20, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 28110
  %30 = icmp uge i64 %21, %29
  %31 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %29)
  br i1 %30, label %32, label %187

32:                                               ; preds = %19
  %33 = phi i252 [ %24, %19 ]
  %34 = icmp eq i252 %33, 0
  br i1 %34, label %35, label %57

35:                                               ; preds = %32
  %36 = phi i64 [ %31, %32 ]
  %37 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %38 = call ptr %37()
  %39 = load i64, ptr %38, align 8
  %40 = mul i64 %39, 29010
  %41 = call i64 @llvm.uadd.sat.i64(i64 %36, i64 %40)
  %42 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %23, 1
  store { i1, { ptr, i32, i32, i32 } } %42, ptr %17, align 8
  %43 = load { i64, [24 x i8] }, ptr %17, align 8
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %22, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %43, 1
  %46 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %45, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, ptr %18, align 8
  %47 = load { i64, [56 x i8] }, ptr %18, align 8
  %48 = extractvalue { ptr, ptr, i64 } %9, 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp eq i64 %49, 0
  %51 = sub i64 %49, 1
  %52 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %51, ptr %52, align 8
  br i1 %50, label %53, label %166

53:                                               ; preds = %35
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, i64 %41, 1
  %56 = insertvalue { i64, i64, { i64, [56 x i8] } } %55, { i64, [56 x i8] } %47, 2
  ret { i64, i64, { i64, [56 x i8] } } %56

57:                                               ; preds = %32
  %58 = phi i64 [ %25, %32 ]
  %59 = call fastcc { i64, i64, { i128, [208 x i8] } } @"impl$f46"(i64 %58, i64 %31, { { ptr, i32, i32, i32 } } %22)
  %60 = extractvalue { i64, i64, { i128, [208 x i8] } } %59, 0
  %61 = extractvalue { i64, i64, { i128, [208 x i8] } } %59, 1
  %62 = extractvalue { i64, i64, { i128, [208 x i8] } } %59, 2
  store { i128, [208 x i8] } %62, ptr %12, align 16
  %63 = load i1, ptr %12, align 1
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %72
  ]

64:                                               ; preds = %57
  br i1 false, label %65, label %202

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %57
  %67 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } }, ptr %12, align 16
  %68 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %67, 1
  %69 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %68, 1
  store { i128, [160 x i8] } %70, ptr %14, align 16
  %71 = load i1, ptr %14, align 1
  switch i1 %71, label %82 [
    i1 false, label %84
    i1 true, label %150
  ]

72:                                               ; preds = %57
  %73 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %74 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %73, 1
  call void @"drop$106"({ ptr, i32, i32, i32 } %23)
  %75 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %74, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %75, ptr %13, align 8
  %76 = load { i64, [56 x i8] }, ptr %13, align 8
  %77 = extractvalue { ptr, ptr, i64 } %9, 1
  %78 = load i64, ptr %77, align 8
  %79 = icmp eq i64 %78, 0
  %80 = sub i64 %78, 1
  %81 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %80, ptr %81, align 8
  br i1 %79, label %183, label %166

82:                                               ; preds = %66
  br i1 false, label %83, label %203

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %66
  %85 = load { i1, { i128, [144 x i8] } }, ptr %14, align 16
  %86 = extractvalue { i1, { i128, [144 x i8] } } %85, 1
  %87 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %88 = call ptr %87()
  %89 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 0)
  %90 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %91 = icmp eq i32 %90, 0
  br i1 %91, label %92, label %106

92:                                               ; preds = %84
  %93 = shl i32 %90, 1
  %94 = call i32 @llvm.umin.i32(i32 %93, i32 1024)
  %95 = add i32 %94, %90
  %96 = call i32 @llvm.umax.i32(i32 %95, i32 8)
  %97 = zext i32 %96 to i64
  %98 = mul i64 %97, 160
  %99 = add i64 %98, 16
  %100 = call ptr @realloc(ptr null, i64 %99)
  store i32 1, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %100, i32 4
  store i32 0, ptr %101, align 4
  %102 = getelementptr inbounds i8, ptr %100, i32 16
  %103 = call ptr @realloc(ptr null, i64 8)
  store ptr %102, ptr %103, align 8
  %104 = insertvalue { ptr, i32, i32, i32 } %23, ptr %103, 0
  %105 = insertvalue { ptr, i32, i32, i32 } %104, i32 %96, 3
  br label %127

106:                                              ; preds = %84
  %107 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %108 = icmp ult i32 %107, %90
  br i1 %108, label %109, label %110

109:                                              ; preds = %106
  br label %124

110:                                              ; preds = %106
  %111 = shl i32 %90, 1
  %112 = call i32 @llvm.umin.i32(i32 %111, i32 1024)
  %113 = add i32 %112, %90
  %114 = call i32 @llvm.umax.i32(i32 %113, i32 8)
  %115 = zext i32 %114 to i64
  %116 = mul i64 %115, 160
  %117 = add i64 %116, 16
  %118 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %119 = load ptr, ptr %118, align 8
  %120 = getelementptr inbounds i8, ptr %119, i32 -16
  %121 = call ptr @realloc(ptr %120, i64 %117)
  %122 = getelementptr inbounds i8, ptr %121, i32 16
  store ptr %122, ptr %118, align 8
  %123 = insertvalue { ptr, i32, i32, i32 } %23, i32 %114, 3
  br label %124

124:                                              ; preds = %109, %110
  %125 = phi { ptr, i32, i32, i32 } [ %123, %110 ], [ %23, %109 ]
  br label %126

126:                                              ; preds = %124
  br label %127

127:                                              ; preds = %92, %126
  %128 = phi { ptr, i32, i32, i32 } [ %125, %126 ], [ %105, %92 ]
  br label %129

129:                                              ; preds = %127
  %130 = extractvalue { ptr, i32, i32, i32 } %128, 0
  %131 = load ptr, ptr %130, align 8
  %132 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %133 = zext i32 %132 to i64
  %134 = mul i64 %133, 160
  %135 = getelementptr inbounds i8, ptr %131, i64 %134
  store { i128, [144 x i8] } %86, ptr %135, align 16
  %136 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %137 = add i32 %136, 1
  %138 = insertvalue { ptr, i32, i32, i32 } %128, i32 %137, 2
  %139 = getelementptr inbounds i8, ptr %131, i32 -12
  store i32 %137, ptr %139, align 4
  %140 = zext i252 %33 to i256
  %141 = sub i256 %140, 1
  %142 = add i256 %140, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %143 = icmp ult i256 %140, 1
  %144 = select i1 %143, i256 %142, i256 %141
  %145 = trunc i256 %144 to i252
  %146 = extractvalue { ptr, ptr, i64 } %9, 1
  %147 = load i64, ptr %146, align 8
  %148 = add i64 %147, 1
  %149 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %148, ptr %149, align 8
  br label %19

150:                                              ; preds = %66
  call void @"drop$106"({ ptr, i32, i32, i32 } %23)
  %151 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %152 = call ptr %151()
  %153 = load i64, ptr %152, align 8
  %154 = mul i64 %153, 3470
  %155 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 %154)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %15, align 1
  %156 = load { i64, [24 x i8] }, ptr %15, align 8
  %157 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %69, 0
  %158 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %156, 1
  %159 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %158, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %159, ptr %16, align 8
  %160 = load { i64, [56 x i8] }, ptr %16, align 8
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %179, label %166

166:                                              ; preds = %166, %35, %150, %72, %187
  %167 = phi i64 [ %25, %187 ], [ %167, %166 ], [ %60, %150 ], [ %60, %72 ], [ %25, %35 ]
  %168 = phi i64 [ %21, %187 ], [ %168, %166 ], [ %155, %150 ], [ %61, %72 ], [ %41, %35 ]
  %169 = phi { i64, [56 x i8] } [ %192, %187 ], [ %169, %166 ], [ %160, %150 ], [ %76, %72 ], [ %47, %35 ]
  %170 = extractvalue { ptr, ptr, i64 } %9, 1
  %171 = load i64, ptr %170, align 8
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %171, 1
  %174 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %173, ptr %174, align 8
  br i1 %172, label %175, label %166

175:                                              ; preds = %166
  %176 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %177 = insertvalue { i64, i64, { i64, [56 x i8] } } %176, i64 %168, 1
  %178 = insertvalue { i64, i64, { i64, [56 x i8] } } %177, { i64, [56 x i8] } %169, 2
  ret { i64, i64, { i64, [56 x i8] } } %178

179:                                              ; preds = %150
  %180 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %181 = insertvalue { i64, i64, { i64, [56 x i8] } } %180, i64 %155, 1
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } %181, { i64, [56 x i8] } %160, 2
  ret { i64, i64, { i64, [56 x i8] } } %182

183:                                              ; preds = %72
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %185 = insertvalue { i64, i64, { i64, [56 x i8] } } %184, i64 %61, 1
  %186 = insertvalue { i64, i64, { i64, [56 x i8] } } %185, { i64, [56 x i8] } %76, 2
  ret { i64, i64, { i64, [56 x i8] } } %186

187:                                              ; preds = %19
  %188 = phi { ptr, i32, i32, i32 } [ %23, %19 ]
  call void @"drop$106"({ ptr, i32, i32, i32 } %188)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %22)
  %189 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %190 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %189, 0
  %191 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %190, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %191, ptr %11, align 8
  %192 = load { i64, [56 x i8] }, ptr %11, align 8
  %193 = extractvalue { ptr, ptr, i64 } %9, 1
  %194 = load i64, ptr %193, align 8
  %195 = icmp eq i64 %194, 0
  %196 = sub i64 %194, 1
  %197 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %196, ptr %197, align 8
  br i1 %195, label %198, label %166

198:                                              ; preds = %187
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %200 = insertvalue { i64, i64, { i64, [56 x i8] } } %199, i64 %21, 1
  %201 = insertvalue { i64, i64, { i64, [56 x i8] } } %200, { i64, [56 x i8] } %192, 2
  ret { i64, i64, { i64, [56 x i8] } } %201

202:                                              ; preds = %64
  call void @puts(ptr @assert_msg_55)
  call void @abort()
  unreachable

203:                                              ; preds = %82
  call void @puts(ptr @assert_msg_56)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f24(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f24"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f24(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f24(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$298"({ { { ptr, i32, i32, i32 } }, i252 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } @"dup$298"({ { { ptr, i32, i32, i32 } }, i252 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } %6, i252 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } %7, i252 %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } undef, { { { ptr, i32, i32, i32 } }, i252 } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } %11, { { { ptr, i32, i32, i32 } }, i252 } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } %12
}

define private void @"drop$299"({ i128, [64 x i8] } %0) {
  %2 = alloca { i128, [64 x i8] }, i64 1, align 16
  store { i128, [64 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %5, 1
  call void @"drop$298"({ { { ptr, i32, i32, i32 } }, i252 } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [64 x i8] }, { i128, [64 x i8] } } @"dup$299"({ i128, [64 x i8] } %0) {
  %2 = alloca { i128, [64 x i8] }, i64 1, align 16
  store { i128, [64 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } @"dup$298"({ { { ptr, i32, i32, i32 } }, i252 } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, i252 }, { { { ptr, i32, i32, i32 } }, i252 } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %5, { { { ptr, i32, i32, i32 } }, i252 } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, i252 } } %10, ptr %2, align 16
  %11 = load { i128, [64 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %5, { { { ptr, i32, i32, i32 } }, i252 } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, i252 } } %12, ptr %2, align 16
  %13 = load { i128, [64 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } undef, { i128, [64 x i8] } %11, 0
  %15 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } %14, { i128, [64 x i8] } %13, 1
  ret { { i128, [64 x i8] }, { i128, [64 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [64 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [64 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } undef, { i128, [64 x i8] } %23, 0
  %27 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } %26, { i128, [64 x i8] } %25, 1
  ret { { i128, [64 x i8] }, { i128, [64 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$290"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$290"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i32, {} } }, ptr %2, align 4
  %6 = extractvalue { i1, { i32, {} } } %5, 1
  %7 = insertvalue { i1, { i32, {} } } %5, { i32, {} } %6, 1
  store { i1, { i32, {} } } %7, ptr %2, align 4
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { i32, {} } } %5, { i32, {} } %6, 1
  store { i1, { i32, {} } } %9, ptr %2, align 4
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$268"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$26"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$268"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$286"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  call void @"drop$268"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$286"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$268"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %6, i32 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %7, i32 %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } undef, { { { ptr, i32, i32, i32 } }, i32 } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %11, { { { ptr, i32, i32, i32 } }, i32 } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %12
}

define private void @"drop$287"({ { { { ptr, i32, i32, i32 } }, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %0, 0
  call void @"drop$286"({ { { ptr, i32, i32, i32 } }, i32 } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } @"dup$287"({ { { { ptr, i32, i32, i32 } }, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$286"({ { { ptr, i32, i32, i32 } }, i32 } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %0, { { { ptr, i32, i32, i32 } }, i32 } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, i32 } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %6, {} %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } }, i32 }, {} } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %11, { { { { ptr, i32, i32, i32 } }, i32 }, {} } %10, 1
  ret { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %12
}

define private void @"drop$288"({ i64, [32 x i8] } %0) {
  %2 = alloca { i64, [32 x i8] }, i64 1, align 8
  store { i64, [32 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %5, 1
  call void @"drop$287"({ { { { ptr, i32, i32, i32 } }, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [32 x i8] }, { i64, [32 x i8] } } @"dup$288"({ i64, [32 x i8] } %0) {
  %2 = alloca { i64, [32 x i8] }, i64 1, align 8
  store { i64, [32 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } @"dup$287"({ { { { ptr, i32, i32, i32 } }, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [32 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [32 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } undef, { i64, [32 x i8] } %11, 0
  %15 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } %14, { i64, [32 x i8] } %13, 1
  ret { { i64, [32 x i8] }, { i64, [32 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [32 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [32 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } undef, { i64, [32 x i8] } %23, 0
  %27 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } %26, { i64, [32 x i8] } %25, 1
  ret { { i64, [32 x i8] }, { i64, [32 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 2
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  ret void
}

define private { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } @"dup$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 0
  %3 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, { i3, [0 x i8] } %2, 0
  %4 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } undef, { i3, [0 x i8] } %2, 0
  %5 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 1
  %6 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %3, i32 %5, 1
  %7 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %4, i32 %5, 1
  %8 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 2
  %9 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 1
  %12 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %6, { { ptr, i32, i32, i32 }, i252, i32 } %10, 2
  %13 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %7, { { ptr, i32, i32, i32 }, i252, i32 } %11, 2
  %14 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 3
  %15 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %12, { i32, i32, i32, i32 } %14, 3
  %16 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %13, { i32, i32, i32, i32 } %14, 3
  %17 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } undef, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %15, 0
  %18 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %17, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %16, 1
  ret { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %18
}

define private void @"drop$285"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0) {
  call void @"drop$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0)
  ret void
}

define private { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } @"dup$285"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0) {
  %2 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } @"dup$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0)
  %3 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %2, 0
  %4 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %2, 1
  %5 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } undef, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %3, 0
  %6 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %4, 1
  ret { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %6
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f25"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, ptr %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i32, i32, i32, i32 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i32, [4 x i8] }, i64 1, align 4
  %14 = alloca { i128, [64 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i32, [4 x i8] }, i64 1, align 4
  %17 = alloca i256, i64 1, align 16
  %18 = alloca i256, i64 1, align 16
  %19 = alloca i256, i64 1, align 16
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i1, [47 x i8] }, i64 1, align 16
  %23 = alloca i64, i64 1, align 8
  %24 = alloca i252, i64 1, align 16
  %25 = alloca { i64, [24 x i8] }, i64 1, align 8
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = alloca { i64, [24 x i8] }, i64 1, align 8
  %28 = alloca { i64, [24 x i8] }, i64 1, align 8
  %29 = alloca { i32, [4 x i8] }, i64 1, align 4
  %30 = alloca { i64, [24 x i8] }, i64 1, align 8
  %31 = alloca { i64, [24 x i8] }, i64 1, align 8
  %32 = alloca { i32, [4 x i8] }, i64 1, align 4
  %33 = alloca { i64, [32 x i8] }, i64 1, align 8
  %34 = alloca { i64, [24 x i8] }, i64 1, align 8
  %35 = alloca { i64, [24 x i8] }, i64 1, align 8
  %36 = alloca { i64, [24 x i8] }, i64 1, align 8
  %37 = alloca { i64, [24 x i8] }, i64 1, align 8
  %38 = load { i32, [4 x i8] }, ptr %6, align 4
  %39 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f47"(i64 %0, i64 %1, i64 %2, ptr %4, { {} } %5)
  %40 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %39, 0
  %41 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %39, 1
  %42 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %39, 2
  %43 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %39, 3
  %44 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %39, 4
  store { i64, [24 x i8] } %44, ptr %11, align 8
  %45 = load i1, ptr %11, align 1
  switch i1 %45, label %46 [
    i1 false, label %48
    i1 true, label %63
  ]

46:                                               ; preds = %10
  br i1 false, label %47, label %441

47:                                               ; preds = %46
  unreachable

48:                                               ; preds = %10
  store { i32, [4 x i8] } %38, ptr %13, align 4
  %49 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f48"(ptr %13, { ptr, i32, i32, i32 } zeroinitializer)
  %50 = extractvalue { { ptr, i32, i32, i32 } } %49, 0
  %51 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %52 = call ptr %51()
  %53 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %50)
  %54 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %53, 0
  %55 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %53, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %54)
  %56 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %55, 0
  %57 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %40, i64 %41, i64 %3, ptr %52, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %56)
  %58 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %57, 0
  %59 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %57, 1
  %60 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %57, 2
  %61 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %57, 3
  store { i128, [64 x i8] } %61, ptr %14, align 16
  %62 = load i1, ptr %14, align 1
  switch i1 %62, label %74 [
    i1 false, label %76
    i1 true, label %82
  ]

63:                                               ; preds = %10
  %64 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %65 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %64, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %7)
  call void @"drop$106"({ ptr, i32, i32, i32 } %9)
  %66 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %65, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %66, ptr %12, align 8
  %67 = load { i64, [24 x i8] }, ptr %12, align 8
  %68 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %40, 0
  %69 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %68, i64 %41, 1
  %70 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %69, i64 %42, 2
  %71 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %3, 3
  %72 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %71, ptr %43, 4
  %73 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %72, { i64, [24 x i8] } %67, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %73

74:                                               ; preds = %48
  br i1 false, label %75, label %442

75:                                               ; preds = %74
  unreachable

76:                                               ; preds = %48
  %77 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %14, align 16
  %78 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %77, 1
  %79 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %78, 0
  %80 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %78, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %79)
  store { i32, [4 x i8] } %38, ptr %16, align 4
  %81 = load i3, ptr %16, align 1
  switch i3 %81, label %93 [
    i3 0, label %95
    i3 1, label %101
    i3 2, label %105
    i3 3, label %109
    i3 -4, label %113
    i3 -3, label %117
    i3 -2, label %123
  ]

82:                                               ; preds = %48
  %83 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %84 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %83, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %7)
  call void @"drop$106"({ ptr, i32, i32, i32 } %9)
  %85 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %84, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %85, ptr %15, align 8
  %86 = load { i64, [24 x i8] }, ptr %15, align 8
  %87 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %58, 0
  %88 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %87, i64 %59, 1
  %89 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %88, i64 %42, 2
  %90 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %89, i64 %60, 3
  %91 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %90, ptr %43, 4
  %92 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %91, { i64, [24 x i8] } %86, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %92

93:                                               ; preds = %76
  br i1 false, label %94, label %443

94:                                               ; preds = %93
  unreachable

95:                                               ; preds = %76
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = load i64, ptr %97, align 8
  %99 = mul i64 %98, 100
  %100 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 %99)
  br label %129

101:                                              ; preds = %76
  %102 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %103 = call ptr %102()
  %104 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  br label %129

105:                                              ; preds = %76
  %106 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %107 = call ptr %106()
  %108 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  br label %129

109:                                              ; preds = %76
  %110 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %111 = call ptr %110()
  %112 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  br label %129

113:                                              ; preds = %76
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  br label %129

117:                                              ; preds = %76
  %118 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %119 = call ptr %118()
  %120 = load i64, ptr %119, align 8
  %121 = mul i64 %120, 100
  %122 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 %121)
  br label %129

123:                                              ; preds = %76
  %124 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %125 = call ptr %124()
  %126 = load i64, ptr %125, align 8
  %127 = mul i64 %126, 200
  %128 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 %127)
  br label %129

129:                                              ; preds = %95, %101, %105, %109, %113, %117, %123
  %130 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %7, %123 ], [ %7, %117 ], [ %7, %113 ], [ %7, %109 ], [ %7, %105 ], [ %7, %101 ], [ %7, %95 ]
  %131 = phi { i32, i32, i32, i32 } [ %8, %123 ], [ %8, %117 ], [ %8, %113 ], [ %8, %109 ], [ %8, %105 ], [ %8, %101 ], [ %8, %95 ]
  %132 = phi { ptr, i32, i32, i32 } [ %9, %123 ], [ %9, %117 ], [ %9, %113 ], [ %9, %109 ], [ %9, %105 ], [ %9, %101 ], [ %9, %95 ]
  %133 = phi i252 [ %80, %123 ], [ %80, %117 ], [ %80, %113 ], [ %80, %109 ], [ %80, %105 ], [ %80, %101 ], [ %80, %95 ]
  %134 = phi i64 [ %60, %123 ], [ %60, %117 ], [ %60, %113 ], [ %60, %109 ], [ %60, %105 ], [ %60, %101 ], [ %60, %95 ]
  %135 = phi i64 [ %42, %123 ], [ %42, %117 ], [ %42, %113 ], [ %42, %109 ], [ %42, %105 ], [ %42, %101 ], [ %42, %95 ]
  %136 = phi ptr [ %43, %123 ], [ %43, %117 ], [ %43, %113 ], [ %43, %109 ], [ %43, %105 ], [ %43, %101 ], [ %43, %95 ]
  %137 = phi { i32, [4 x i8] } [ %38, %123 ], [ %38, %117 ], [ %38, %113 ], [ %38, %109 ], [ %38, %105 ], [ %38, %101 ], [ %38, %95 ]
  %138 = phi i64 [ %58, %123 ], [ %58, %117 ], [ %58, %113 ], [ %58, %109 ], [ %58, %105 ], [ %58, %101 ], [ %58, %95 ]
  %139 = phi i64 [ %128, %123 ], [ %122, %117 ], [ %116, %113 ], [ %112, %109 ], [ %108, %105 ], [ %104, %101 ], [ %100, %95 ]
  %140 = phi i252 [ 119674880063757522161687995182389208939526319504019663621515716359683735285, %123 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %117 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %113 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %109 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %105 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %101 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %95 ]
  %141 = add i64 %135, 3
  %142 = zext i252 %140 to i256
  %143 = zext i252 %133 to i256
  store i256 %142, ptr %17, align 16
  store i256 %143, ptr %18, align 16
  %144 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %144(ptr %19, ptr %17, ptr %18)
  %145 = load i256, ptr %19, align 16
  %146 = trunc i256 %145 to i252
  %147 = add i64 %138, 3
  %148 = sub i252 %146, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %149 = icmp ult i252 %146, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %150 = select i1 %149, i252 %146, i252 %148
  %151 = insertvalue { i252 } undef, i252 %150, 0
  %152 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f50"(i64 %147, i64 %139, ptr %136, { i252 } %151, { i32, i32, i32, i32 } %131)
  %153 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %152, 0
  %154 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %152, 1
  %155 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %152, 2
  %156 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %152, 3
  store { i64, [24 x i8] } %156, ptr %20, align 8
  %157 = load i1, ptr %20, align 1
  switch i1 %157, label %158 [
    i1 false, label %160
    i1 true, label %171
  ]

158:                                              ; preds = %129
  br i1 false, label %159, label %444

159:                                              ; preds = %158
  unreachable

160:                                              ; preds = %129
  %161 = load ptr, ptr %155, align 8
  store i64 %154, ptr %23, align 8
  store i252 814182874304483309791743286124228493744277863724345952005546811777229850325, ptr %24, align 16
  %162 = getelementptr inbounds ptr, ptr %155, i32 8
  %163 = load ptr, ptr %162, align 8
  call void %163(ptr %22, ptr %161, ptr %23, i32 0, ptr %24)
  %164 = load { i1, [47 x i8] }, ptr %22, align 1
  %165 = extractvalue { i1, [47 x i8] } %164, 0
  %166 = getelementptr inbounds i8, ptr %22, i32 16
  %167 = load i252, ptr %166, align 16
  %168 = getelementptr inbounds i8, ptr %22, i32 8
  %169 = load { ptr, i32, i32, i32 }, ptr %168, align 8
  %170 = load i64, ptr %23, align 8
  br i1 %165, label %430, label %182

171:                                              ; preds = %129
  %172 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %20, align 8
  %173 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %172, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %130)
  call void @"drop$106"({ ptr, i32, i32, i32 } %132)
  %174 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %173, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %174, ptr %21, align 8
  %175 = load { i64, [24 x i8] }, ptr %21, align 8
  %176 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %153, 0
  %177 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %176, i64 %154, 1
  %178 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %177, i64 %141, 2
  %179 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %178, i64 %134, 3
  %180 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %179, ptr %155, 4
  %181 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %180, { i64, [24 x i8] } %175, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %181

182:                                              ; preds = %160
  %183 = phi i64 [ %153, %160 ]
  %184 = phi i252 [ %167, %160 ]
  %185 = add i64 %183, 3
  %186 = icmp ult i252 %184, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %186, label %187, label %416

187:                                              ; preds = %182
  %188 = phi i252 [ %184, %182 ]
  %189 = insertvalue { i252 } undef, i252 %188, 0
  %190 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f51"(i64 %185, i64 %170, ptr %155, { i252 } %189, { ptr, i32, i32, i32 } %132)
  %191 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %190, 0
  %192 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %190, 1
  %193 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %190, 2
  %194 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %190, 3
  store { i64, [24 x i8] } %194, ptr %27, align 8
  %195 = load i1, ptr %27, align 1
  switch i1 %195, label %196 [
    i1 false, label %198
    i1 true, label %203
  ]

196:                                              ; preds = %187
  br i1 false, label %197, label %445

197:                                              ; preds = %196
  unreachable

198:                                              ; preds = %187
  %199 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %27, align 8
  %200 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %199, 1
  %201 = extractvalue { { ptr, i32, i32, i32 } } %200, 0
  store { i32, [4 x i8] } %137, ptr %29, align 4
  %202 = load i3, ptr %29, align 1
  switch i3 %202, label %214 [
    i3 0, label %216
    i3 1, label %222
    i3 2, label %226
    i3 3, label %230
    i3 -4, label %234
    i3 -3, label %238
    i3 -2, label %244
  ]

203:                                              ; preds = %187
  %204 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %27, align 8
  %205 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %204, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %130)
  %206 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %205, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %206, ptr %28, align 8
  %207 = load { i64, [24 x i8] }, ptr %28, align 8
  %208 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %191, 0
  %209 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %208, i64 %192, 1
  %210 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %209, i64 %141, 2
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %210, i64 %134, 3
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %211, ptr %193, 4
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %212, { i64, [24 x i8] } %207, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213

214:                                              ; preds = %198
  br i1 false, label %215, label %446

215:                                              ; preds = %214
  unreachable

216:                                              ; preds = %198
  %217 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %218 = call ptr %217()
  %219 = load i64, ptr %218, align 8
  %220 = mul i64 %219, 100
  %221 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 %220)
  br label %250

222:                                              ; preds = %198
  %223 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %224 = call ptr %223()
  %225 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 0)
  br label %250

226:                                              ; preds = %198
  %227 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %228 = call ptr %227()
  %229 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 0)
  br label %250

230:                                              ; preds = %198
  %231 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %232 = call ptr %231()
  %233 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 0)
  br label %250

234:                                              ; preds = %198
  %235 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %236 = call ptr %235()
  %237 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 0)
  br label %250

238:                                              ; preds = %198
  %239 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %240 = call ptr %239()
  %241 = load i64, ptr %240, align 8
  %242 = mul i64 %241, 100
  %243 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 %242)
  br label %250

244:                                              ; preds = %198
  %245 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %246 = call ptr %245()
  %247 = load i64, ptr %246, align 8
  %248 = mul i64 %247, 200
  %249 = call i64 @llvm.uadd.sat.i64(i64 %192, i64 %248)
  br label %250

250:                                              ; preds = %216, %222, %226, %230, %234, %238, %244
  %251 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %130, %244 ], [ %130, %238 ], [ %130, %234 ], [ %130, %230 ], [ %130, %226 ], [ %130, %222 ], [ %130, %216 ]
  %252 = phi { i32, i32, i32, i32 } [ %131, %244 ], [ %131, %238 ], [ %131, %234 ], [ %131, %230 ], [ %131, %226 ], [ %131, %222 ], [ %131, %216 ]
  %253 = phi i252 [ %133, %244 ], [ %133, %238 ], [ %133, %234 ], [ %133, %230 ], [ %133, %226 ], [ %133, %222 ], [ %133, %216 ]
  %254 = phi { ptr, i32, i32, i32 } [ %201, %244 ], [ %201, %238 ], [ %201, %234 ], [ %201, %230 ], [ %201, %226 ], [ %201, %222 ], [ %201, %216 ]
  %255 = phi i252 [ 422073521398876225481035229297186717153911541103484599068011287805644405767, %244 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %238 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %234 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %230 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %226 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %222 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %216 ]
  %256 = phi i64 [ %141, %244 ], [ %141, %238 ], [ %141, %234 ], [ %141, %230 ], [ %141, %226 ], [ %141, %222 ], [ %141, %216 ]
  %257 = phi i64 [ %134, %244 ], [ %134, %238 ], [ %134, %234 ], [ %134, %230 ], [ %134, %226 ], [ %134, %222 ], [ %134, %216 ]
  %258 = phi { i32, [4 x i8] } [ %137, %244 ], [ %137, %238 ], [ %137, %234 ], [ %137, %230 ], [ %137, %226 ], [ %137, %222 ], [ %137, %216 ]
  %259 = phi i64 [ %191, %244 ], [ %191, %238 ], [ %191, %234 ], [ %191, %230 ], [ %191, %226 ], [ %191, %222 ], [ %191, %216 ]
  %260 = phi ptr [ %193, %244 ], [ %193, %238 ], [ %193, %234 ], [ %193, %230 ], [ %193, %226 ], [ %193, %222 ], [ %193, %216 ]
  %261 = phi i64 [ %249, %244 ], [ %243, %238 ], [ %237, %234 ], [ %233, %230 ], [ %229, %226 ], [ %225, %222 ], [ %221, %216 ]
  %262 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %254)
  %263 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %262, 0
  %264 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %262, 1
  %265 = extractvalue { ptr, i32, i32, i32 } %264, 1
  %266 = extractvalue { ptr, i32, i32, i32 } %264, 2
  %267 = sub i32 %266, %265
  call void @"drop$27"({ ptr, i32, i32, i32 } %264)
  %268 = insertvalue { i252 } undef, i252 %255, 0
  %269 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f52"(i64 %259, i64 %261, i64 %256, i64 %257, ptr %260, i252 %253, i32 %267, { i252 } %268)
  %270 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, 0
  %271 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, 1
  %272 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, 2
  %273 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, 3
  %274 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, 4
  %275 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %269, 5
  store { i64, [24 x i8] } %275, ptr %30, align 8
  %276 = load i1, ptr %30, align 1
  switch i1 %276, label %277 [
    i1 false, label %279
    i1 true, label %282
  ]

277:                                              ; preds = %250
  br i1 false, label %278, label %447

278:                                              ; preds = %277
  unreachable

279:                                              ; preds = %250
  %280 = insertvalue { i252 } undef, i252 %255, 0
  store { i32, [4 x i8] } %258, ptr %32, align 4
  %281 = load i3, ptr %32, align 1
  switch i3 %281, label %293 [
    i3 0, label %295
    i3 1, label %301
    i3 2, label %307
    i3 3, label %313
    i3 -4, label %319
    i3 -3, label %325
    i3 -2, label %331
  ]

282:                                              ; preds = %250
  %283 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %30, align 8
  %284 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %283, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %263)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %251)
  %285 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %284, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %285, ptr %31, align 8
  %286 = load { i64, [24 x i8] }, ptr %31, align 8
  %287 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %270, 0
  %288 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %287, i64 %271, 1
  %289 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %288, i64 %272, 2
  %290 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %289, i64 %273, 3
  %291 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %290, ptr %274, 4
  %292 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %291, { i64, [24 x i8] } %286, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %292

293:                                              ; preds = %279
  br i1 false, label %294, label %448

294:                                              ; preds = %293
  unreachable

295:                                              ; preds = %279
  %296 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %297 = call ptr %296()
  %298 = load i64, ptr %297, align 8
  %299 = mul i64 %298, 100
  %300 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 %299)
  br label %339

301:                                              ; preds = %279
  %302 = load { i3, i32 }, ptr %32, align 4
  %303 = extractvalue { i3, i32 } %302, 1
  %304 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %305 = call ptr %304()
  %306 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 0)
  br label %339

307:                                              ; preds = %279
  %308 = load { i3, i32 }, ptr %32, align 4
  %309 = extractvalue { i3, i32 } %308, 1
  %310 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %311 = call ptr %310()
  %312 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 0)
  br label %339

313:                                              ; preds = %279
  %314 = load { i3, i32 }, ptr %32, align 4
  %315 = extractvalue { i3, i32 } %314, 1
  %316 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %317 = call ptr %316()
  %318 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 0)
  br label %339

319:                                              ; preds = %279
  %320 = load { i3, i32 }, ptr %32, align 4
  %321 = extractvalue { i3, i32 } %320, 1
  %322 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %323 = call ptr %322()
  %324 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 0)
  br label %339

325:                                              ; preds = %279
  %326 = load { i3, i32 }, ptr %32, align 4
  %327 = extractvalue { i3, i32 } %326, 1
  %328 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %329 = call ptr %328()
  %330 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 0)
  br label %339

331:                                              ; preds = %279
  %332 = load { i3, i32 }, ptr %32, align 4
  %333 = extractvalue { i3, i32 } %332, 1
  %334 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %335 = call ptr %334()
  %336 = load i64, ptr %335, align 8
  %337 = mul i64 %336, 100
  %338 = call i64 @llvm.uadd.sat.i64(i64 %271, i64 %337)
  br label %339

339:                                              ; preds = %295, %301, %307, %313, %319, %325, %331
  %340 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %251, %331 ], [ %251, %325 ], [ %251, %319 ], [ %251, %313 ], [ %251, %307 ], [ %251, %301 ], [ %251, %295 ]
  %341 = phi { i32, i32, i32, i32 } [ %252, %331 ], [ %252, %325 ], [ %252, %319 ], [ %252, %313 ], [ %252, %307 ], [ %252, %301 ], [ %252, %295 ]
  %342 = phi i32 [ %333, %331 ], [ %327, %325 ], [ %321, %319 ], [ %315, %313 ], [ %309, %307 ], [ %303, %301 ], [ 0, %295 ]
  %343 = phi { i3, [0 x i8] } [ { i3 -2, [0 x i8] undef }, %331 ], [ { i3 -3, [0 x i8] undef }, %325 ], [ { i3 -4, [0 x i8] undef }, %319 ], [ { i3 3, [0 x i8] undef }, %313 ], [ { i3 2, [0 x i8] undef }, %307 ], [ { i3 1, [0 x i8] undef }, %301 ], [ { i3 0, [0 x i8] undef }, %295 ]
  %344 = phi i252 [ %253, %331 ], [ %253, %325 ], [ %253, %319 ], [ %253, %313 ], [ %253, %307 ], [ %253, %301 ], [ %253, %295 ]
  %345 = phi { ptr, i32, i32, i32 } [ %263, %331 ], [ %263, %325 ], [ %263, %319 ], [ %263, %313 ], [ %263, %307 ], [ %263, %301 ], [ %263, %295 ]
  %346 = phi i64 [ %270, %331 ], [ %270, %325 ], [ %270, %319 ], [ %270, %313 ], [ %270, %307 ], [ %270, %301 ], [ %270, %295 ]
  %347 = phi i64 [ %272, %331 ], [ %272, %325 ], [ %272, %319 ], [ %272, %313 ], [ %272, %307 ], [ %272, %301 ], [ %272, %295 ]
  %348 = phi i64 [ %273, %331 ], [ %273, %325 ], [ %273, %319 ], [ %273, %313 ], [ %273, %307 ], [ %273, %301 ], [ %273, %295 ]
  %349 = phi ptr [ %274, %331 ], [ %274, %325 ], [ %274, %319 ], [ %274, %313 ], [ %274, %307 ], [ %274, %301 ], [ %274, %295 ]
  %350 = phi { i252 } [ %280, %331 ], [ %280, %325 ], [ %280, %319 ], [ %280, %313 ], [ %280, %307 ], [ %280, %301 ], [ %280, %295 ]
  %351 = phi i64 [ %338, %331 ], [ %330, %325 ], [ %324, %319 ], [ %318, %313 ], [ %312, %307 ], [ %306, %301 ], [ %300, %295 ]
  %352 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %345, 0
  %353 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %352, 0
  %354 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %353, i32 0, 1
  %355 = call fastcc { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } @"impl$f53"(i64 %346, i64 %351, i64 %347, i64 %348, ptr %349, { { { ptr, i32, i32, i32 } }, i32 } %354, i252 %344, i32 %342, { i252 } %350, { i3, [0 x i8] } %343)
  %356 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %355, 0
  %357 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %355, 1
  %358 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %355, 2
  %359 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %355, 3
  %360 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %355, 4
  %361 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %355, 5
  store { i64, [32 x i8] } %361, ptr %33, align 8
  %362 = load i1, ptr %33, align 1
  switch i1 %362, label %363 [
    i1 false, label %365
    i1 true, label %381
  ]

363:                                              ; preds = %339
  br i1 false, label %364, label %449

364:                                              ; preds = %363
  unreachable

365:                                              ; preds = %339
  %366 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } }, ptr %33, align 8
  %367 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %366, 1
  call void @"drop$287"({ { { { ptr, i32, i32, i32 } }, i32 }, {} } %367)
  %368 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } undef, { i3, [0 x i8] } %343, 0
  %369 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %368, i32 %342, 1
  %370 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %369, { { ptr, i32, i32, i32 }, i252, i32 } %340, 2
  %371 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %370, { i32, i32, i32, i32 } %341, 3
  %372 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } @"dup$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %371)
  %373 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %372, 0
  %374 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %372, 1
  call void @"drop$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %373)
  %375 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f54"(i64 %356, i64 %357, ptr %360, i252 453315402536231072555619669907522599583709578777227265110163302022970973962, i252 %344, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %374)
  %376 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %375, 0
  %377 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %375, 1
  %378 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %375, 2
  %379 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %375, 3
  store { i64, [24 x i8] } %379, ptr %35, align 8
  %380 = load i1, ptr %35, align 1
  switch i1 %380, label %392 [
    i1 false, label %394
    i1 true, label %405
  ]

381:                                              ; preds = %339
  %382 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %33, align 8
  %383 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %382, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %340)
  %384 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %383, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %384, ptr %34, align 8
  %385 = load { i64, [24 x i8] }, ptr %34, align 8
  %386 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %356, 0
  %387 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %386, i64 %357, 1
  %388 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %387, i64 %358, 2
  %389 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %388, i64 %359, 3
  %390 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %389, ptr %360, 4
  %391 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %390, { i64, [24 x i8] } %385, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %391

392:                                              ; preds = %365
  br i1 false, label %393, label %450

393:                                              ; preds = %392
  unreachable

394:                                              ; preds = %365
  %395 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %396 = call ptr %395()
  %397 = call i64 @llvm.uadd.sat.i64(i64 %377, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %37, align 1
  %398 = load { i64, [24 x i8] }, ptr %37, align 8
  %399 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %376, 0
  %400 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %399, i64 %397, 1
  %401 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %400, i64 %358, 2
  %402 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %401, i64 %359, 3
  %403 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %402, ptr %378, 4
  %404 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %403, { i64, [24 x i8] } %398, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %404

405:                                              ; preds = %365
  %406 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %35, align 8
  %407 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %406, 1
  %408 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %407, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %408, ptr %36, align 8
  %409 = load { i64, [24 x i8] }, ptr %36, align 8
  %410 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %376, 0
  %411 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %410, i64 %377, 1
  %412 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %411, i64 %358, 2
  %413 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %412, i64 %359, 3
  %414 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %413, ptr %378, 4
  %415 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %414, { i64, [24 x i8] } %409, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %415

416:                                              ; preds = %182
  %417 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %130, %182 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %417)
  call void @"drop$106"({ ptr, i32, i32, i32 } %132)
  %418 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"()
  %419 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %418, 0
  %420 = extractvalue { {}, { ptr, i32, i32, i32 } } %419, 1
  %421 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %420, 1
  %422 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %421, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %422, ptr %26, align 8
  %423 = load { i64, [24 x i8] }, ptr %26, align 8
  %424 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %185, 0
  %425 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %424, i64 %170, 1
  %426 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %425, i64 %141, 2
  %427 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %426, i64 %134, 3
  %428 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %427, ptr %155, 4
  %429 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %428, { i64, [24 x i8] } %423, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %429

430:                                              ; preds = %160
  %431 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %130, %160 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %431)
  call void @"drop$106"({ ptr, i32, i32, i32 } %132)
  %432 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %169, 1
  %433 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %432, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %433, ptr %25, align 8
  %434 = load { i64, [24 x i8] }, ptr %25, align 8
  %435 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %153, 0
  %436 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %435, i64 %170, 1
  %437 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %436, i64 %141, 2
  %438 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %437, i64 %134, 3
  %439 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %438, ptr %155, 4
  %440 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %439, { i64, [24 x i8] } %434, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %440

441:                                              ; preds = %46
  call void @puts(ptr @assert_msg_57)
  call void @abort()
  unreachable

442:                                              ; preds = %74
  call void @puts(ptr @assert_msg_58)
  call void @abort()
  unreachable

443:                                              ; preds = %93
  call void @puts(ptr @assert_msg_59)
  call void @abort()
  unreachable

444:                                              ; preds = %158
  call void @puts(ptr @assert_msg_60)
  call void @abort()
  unreachable

445:                                              ; preds = %196
  call void @puts(ptr @assert_msg_61)
  call void @abort()
  unreachable

446:                                              ; preds = %214
  call void @puts(ptr @assert_msg_62)
  call void @abort()
  unreachable

447:                                              ; preds = %277
  call void @puts(ptr @assert_msg_63)
  call void @abort()
  unreachable

448:                                              ; preds = %293
  call void @puts(ptr @assert_msg_64)
  call void @abort()
  unreachable

449:                                              ; preds = %363
  call void @puts(ptr @assert_msg_65)
  call void @abort()
  unreachable

450:                                              ; preds = %392
  call void @puts(ptr @assert_msg_66)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f25(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, ptr %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i32, i32, i32, i32 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f25"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, ptr %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i32, i32, i32, i32 } %8, { ptr, i32, i32, i32 } %9)
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 0
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 1
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 2
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 3
  %16 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 4
  %17 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 5
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %12, 0
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %13, 1
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, i64 %14, 2
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, i64 %15, 3
  %22 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21, ptr %16, 4
  %23 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %22, { i64, [24 x i8] } %17, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %23
}

define void @_mlir_ciface_f25(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, ptr %7, { { ptr, i32, i32, i32 }, i252, i32 } %8, { i32, i32, i32, i32 } %9, { ptr, i32, i32, i32 } %10) {
  %12 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f25(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, ptr %7, { { ptr, i32, i32, i32 }, i252, i32 } %8, { i32, i32, i32, i32 } %9, { ptr, i32, i32, i32 } %10)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f26"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 485748461484230571791265682659113160264223489397539653310998840191492916)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f26() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f26"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f26(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f26()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$279"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, 1
  call void @"drop$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$279"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, 1
  %7 = call { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6)
  %8 = extractvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %8, 1
  store { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %10, ptr %2, align 16
  %11 = load { i128, [144 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  store { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %12, ptr %2, align 16
  %13 = load { i128, [144 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %11, 0
  %15 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %14, { i128, [144 x i8] } %13, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [144 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [144 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %20, 0
  %24 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %23, { i128, [144 x i8] } %22, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$280"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  call void @"drop$279"({ i128, [144 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$280"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  %9 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$279"({ i128, [144 x i8] } %8)
  %10 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 0
  %11 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6, { i128, [144 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %7, { i128, [144 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %15
}

define private void @"drop$281"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  call void @"drop$280"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [192 x i8] }, { i128, [192 x i8] } } @"dup$281"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$280"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [192 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [192 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %11, 0
  %15 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %14, { i128, [192 x i8] } %13, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [192 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [192 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %23, 0
  %27 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %26, { i128, [192 x i8] } %25, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f27"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i128, [192 x i8] }, i64 1, align 16
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i128, [144 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %19

19:                                               ; preds = %129, %5
  %20 = phi i64 [ %60, %129 ], [ %0, %5 ]
  %21 = phi i64 [ %89, %129 ], [ %1, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %69, %129 ], [ %2, %5 ]
  %23 = phi { ptr, i32, i32, i32 } [ %138, %129 ], [ %3, %5 ]
  %24 = phi i252 [ %145, %129 ], [ %4, %5 ]
  %25 = add i64 %20, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 26490
  %30 = icmp uge i64 %21, %29
  %31 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %29)
  br i1 %30, label %32, label %187

32:                                               ; preds = %19
  %33 = phi i252 [ %24, %19 ]
  %34 = icmp eq i252 %33, 0
  br i1 %34, label %35, label %57

35:                                               ; preds = %32
  %36 = phi i64 [ %31, %32 ]
  %37 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %38 = call ptr %37()
  %39 = load i64, ptr %38, align 8
  %40 = mul i64 %39, 27390
  %41 = call i64 @llvm.uadd.sat.i64(i64 %36, i64 %40)
  %42 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %23, 1
  store { i1, { ptr, i32, i32, i32 } } %42, ptr %17, align 8
  %43 = load { i64, [24 x i8] }, ptr %17, align 8
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %22, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %43, 1
  %46 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %45, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, ptr %18, align 8
  %47 = load { i64, [56 x i8] }, ptr %18, align 8
  %48 = extractvalue { ptr, ptr, i64 } %9, 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp eq i64 %49, 0
  %51 = sub i64 %49, 1
  %52 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %51, ptr %52, align 8
  br i1 %50, label %53, label %166

53:                                               ; preds = %35
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, i64 %41, 1
  %56 = insertvalue { i64, i64, { i64, [56 x i8] } } %55, { i64, [56 x i8] } %47, 2
  ret { i64, i64, { i64, [56 x i8] } } %56

57:                                               ; preds = %32
  %58 = phi i64 [ %25, %32 ]
  %59 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f56"(i64 %58, i64 %31, { { ptr, i32, i32, i32 } } %22)
  %60 = extractvalue { i64, i64, { i128, [192 x i8] } } %59, 0
  %61 = extractvalue { i64, i64, { i128, [192 x i8] } } %59, 1
  %62 = extractvalue { i64, i64, { i128, [192 x i8] } } %59, 2
  store { i128, [192 x i8] } %62, ptr %12, align 16
  %63 = load i1, ptr %12, align 1
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %72
  ]

64:                                               ; preds = %57
  br i1 false, label %65, label %202

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %57
  %67 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %12, align 16
  %68 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %67, 1
  %69 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %68, 1
  store { i128, [144 x i8] } %70, ptr %14, align 16
  %71 = load i1, ptr %14, align 1
  switch i1 %71, label %82 [
    i1 false, label %84
    i1 true, label %150
  ]

72:                                               ; preds = %57
  %73 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %74 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %73, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %23)
  %75 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %74, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %75, ptr %13, align 8
  %76 = load { i64, [56 x i8] }, ptr %13, align 8
  %77 = extractvalue { ptr, ptr, i64 } %9, 1
  %78 = load i64, ptr %77, align 8
  %79 = icmp eq i64 %78, 0
  %80 = sub i64 %78, 1
  %81 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %80, ptr %81, align 8
  br i1 %79, label %183, label %166

82:                                               ; preds = %66
  br i1 false, label %83, label %203

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %66
  %85 = load { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %14, align 16
  %86 = extractvalue { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %85, 1
  %87 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %88 = call ptr %87()
  %89 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 0)
  %90 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %91 = icmp eq i32 %90, 0
  br i1 %91, label %92, label %106

92:                                               ; preds = %84
  %93 = shl i32 %90, 1
  %94 = call i32 @llvm.umin.i32(i32 %93, i32 1024)
  %95 = add i32 %94, %90
  %96 = call i32 @llvm.umax.i32(i32 %95, i32 8)
  %97 = zext i32 %96 to i64
  %98 = mul i64 %97, 144
  %99 = add i64 %98, 16
  %100 = call ptr @realloc(ptr null, i64 %99)
  store i32 1, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %100, i32 4
  store i32 0, ptr %101, align 4
  %102 = getelementptr inbounds i8, ptr %100, i32 16
  %103 = call ptr @realloc(ptr null, i64 8)
  store ptr %102, ptr %103, align 8
  %104 = insertvalue { ptr, i32, i32, i32 } %23, ptr %103, 0
  %105 = insertvalue { ptr, i32, i32, i32 } %104, i32 %96, 3
  br label %127

106:                                              ; preds = %84
  %107 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %108 = icmp ult i32 %107, %90
  br i1 %108, label %109, label %110

109:                                              ; preds = %106
  br label %124

110:                                              ; preds = %106
  %111 = shl i32 %90, 1
  %112 = call i32 @llvm.umin.i32(i32 %111, i32 1024)
  %113 = add i32 %112, %90
  %114 = call i32 @llvm.umax.i32(i32 %113, i32 8)
  %115 = zext i32 %114 to i64
  %116 = mul i64 %115, 144
  %117 = add i64 %116, 16
  %118 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %119 = load ptr, ptr %118, align 8
  %120 = getelementptr inbounds i8, ptr %119, i32 -16
  %121 = call ptr @realloc(ptr %120, i64 %117)
  %122 = getelementptr inbounds i8, ptr %121, i32 16
  store ptr %122, ptr %118, align 8
  %123 = insertvalue { ptr, i32, i32, i32 } %23, i32 %114, 3
  br label %124

124:                                              ; preds = %109, %110
  %125 = phi { ptr, i32, i32, i32 } [ %123, %110 ], [ %23, %109 ]
  br label %126

126:                                              ; preds = %124
  br label %127

127:                                              ; preds = %92, %126
  %128 = phi { ptr, i32, i32, i32 } [ %125, %126 ], [ %105, %92 ]
  br label %129

129:                                              ; preds = %127
  %130 = extractvalue { ptr, i32, i32, i32 } %128, 0
  %131 = load ptr, ptr %130, align 8
  %132 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %133 = zext i32 %132 to i64
  %134 = mul i64 %133, 144
  %135 = getelementptr inbounds i8, ptr %131, i64 %134
  store { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, ptr %135, align 16
  %136 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %137 = add i32 %136, 1
  %138 = insertvalue { ptr, i32, i32, i32 } %128, i32 %137, 2
  %139 = getelementptr inbounds i8, ptr %131, i32 -12
  store i32 %137, ptr %139, align 4
  %140 = zext i252 %33 to i256
  %141 = sub i256 %140, 1
  %142 = add i256 %140, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %143 = icmp ult i256 %140, 1
  %144 = select i1 %143, i256 %142, i256 %141
  %145 = trunc i256 %144 to i252
  %146 = extractvalue { ptr, ptr, i64 } %9, 1
  %147 = load i64, ptr %146, align 8
  %148 = add i64 %147, 1
  %149 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %148, ptr %149, align 8
  br label %19

150:                                              ; preds = %66
  call void @"drop$189"({ ptr, i32, i32, i32 } %23)
  %151 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %152 = call ptr %151()
  %153 = load i64, ptr %152, align 8
  %154 = mul i64 %153, 3470
  %155 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 %154)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %15, align 1
  %156 = load { i64, [24 x i8] }, ptr %15, align 8
  %157 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %69, 0
  %158 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %156, 1
  %159 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %158, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %159, ptr %16, align 8
  %160 = load { i64, [56 x i8] }, ptr %16, align 8
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %179, label %166

166:                                              ; preds = %166, %35, %150, %72, %187
  %167 = phi i64 [ %25, %187 ], [ %167, %166 ], [ %60, %150 ], [ %60, %72 ], [ %25, %35 ]
  %168 = phi i64 [ %21, %187 ], [ %168, %166 ], [ %155, %150 ], [ %61, %72 ], [ %41, %35 ]
  %169 = phi { i64, [56 x i8] } [ %192, %187 ], [ %169, %166 ], [ %160, %150 ], [ %76, %72 ], [ %47, %35 ]
  %170 = extractvalue { ptr, ptr, i64 } %9, 1
  %171 = load i64, ptr %170, align 8
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %171, 1
  %174 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %173, ptr %174, align 8
  br i1 %172, label %175, label %166

175:                                              ; preds = %166
  %176 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %177 = insertvalue { i64, i64, { i64, [56 x i8] } } %176, i64 %168, 1
  %178 = insertvalue { i64, i64, { i64, [56 x i8] } } %177, { i64, [56 x i8] } %169, 2
  ret { i64, i64, { i64, [56 x i8] } } %178

179:                                              ; preds = %150
  %180 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %181 = insertvalue { i64, i64, { i64, [56 x i8] } } %180, i64 %155, 1
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } %181, { i64, [56 x i8] } %160, 2
  ret { i64, i64, { i64, [56 x i8] } } %182

183:                                              ; preds = %72
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %185 = insertvalue { i64, i64, { i64, [56 x i8] } } %184, i64 %61, 1
  %186 = insertvalue { i64, i64, { i64, [56 x i8] } } %185, { i64, [56 x i8] } %76, 2
  ret { i64, i64, { i64, [56 x i8] } } %186

187:                                              ; preds = %19
  %188 = phi { ptr, i32, i32, i32 } [ %23, %19 ]
  call void @"drop$189"({ ptr, i32, i32, i32 } %188)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %22)
  %189 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %190 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %189, 0
  %191 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %190, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %191, ptr %11, align 8
  %192 = load { i64, [56 x i8] }, ptr %11, align 8
  %193 = extractvalue { ptr, ptr, i64 } %9, 1
  %194 = load i64, ptr %193, align 8
  %195 = icmp eq i64 %194, 0
  %196 = sub i64 %194, 1
  %197 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %196, ptr %197, align 8
  br i1 %195, label %198, label %166

198:                                              ; preds = %187
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %200 = insertvalue { i64, i64, { i64, [56 x i8] } } %199, i64 %21, 1
  %201 = insertvalue { i64, i64, { i64, [56 x i8] } } %200, { i64, [56 x i8] } %192, 2
  ret { i64, i64, { i64, [56 x i8] } } %201

202:                                              ; preds = %64
  call void @puts(ptr @assert_msg_67)
  call void @abort()
  unreachable

203:                                              ; preds = %82
  call void @puts(ptr @assert_msg_68)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f27(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f27"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f27(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f27(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$182"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$182"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$273"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$189"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$273"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$189"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$274"({ { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$273"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 2
  call void @"drop$182"({ ptr, i32, i32, i32 } %3)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 3
  call void @"drop$106"({ ptr, i32, i32, i32 } %4)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } @"dup$274"({ { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$273"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %6, { {} } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %7, { {} } %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 2
  %12 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$182"({ ptr, i32, i32, i32 } %11)
  %13 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, 0
  %14 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, 1
  %15 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %9, { ptr, i32, i32, i32 } %13, 2
  %16 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %10, { ptr, i32, i32, i32 } %14, 2
  %17 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 3
  %18 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %17)
  %19 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 0
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 1
  %21 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %15, { ptr, i32, i32, i32 } %19, 3
  %22 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %16, { ptr, i32, i32, i32 } %20, 3
  %23 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 4
  %24 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %21, {} %23, 4
  %25 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %22, {} %23, 4
  %26 = insertvalue { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } undef, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %24, 0
  %27 = insertvalue { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %26, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %25, 1
  ret { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %27
}

define private void @"drop$275"({ i64, [72 x i8] } %0) {
  %2 = alloca { i64, [72 x i8] }, i64 1, align 8
  store { i64, [72 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$274"({ { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [72 x i8] }, { i64, [72 x i8] } } @"dup$275"({ i64, [72 x i8] } %0) {
  %2 = alloca { i64, [72 x i8] }, i64 1, align 8
  store { i64, [72 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } @"dup$274"({ { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [72 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [72 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } undef, { i64, [72 x i8] } %11, 0
  %15 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } %14, { i64, [72 x i8] } %13, 1
  ret { { i64, [72 x i8] }, { i64, [72 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [72 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [72 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } undef, { i64, [72 x i8] } %23, 0
  %27 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } %26, { i64, [72 x i8] } %25, 1
  ret { { i64, [72 x i8] }, { i64, [72 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$269"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$182"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$269"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$182"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$270"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$268"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$269"({ { ptr, i32, i32, i32 } } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$270"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$268"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  %9 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$269"({ { ptr, i32, i32, i32 } } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, { { ptr, i32, i32, i32 } } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7, { { ptr, i32, i32, i32 } } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %15
}

define private void @"drop$271"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %0, 0
  call void @"drop$270"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } @"dup$271"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$270"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %0, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %6, {} %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } undef, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %11, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %10, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %12
}

define private void @"drop$272"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %5, 1
  call void @"drop$271"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$272"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } @"dup$271"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f28"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { ptr, i32, i32, i32 } %6) {
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [72 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i1, [47 x i8] }, i64 1, align 16
  %13 = alloca i64, i64 1, align 8
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [48 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f47"(i64 %0, i64 %1, i64 %2, ptr %4, { {} } %5)
  %23 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %22, 0
  %24 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %22, 1
  %25 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %22, 2
  %26 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %22, 3
  %27 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %22, 4
  store { i64, [24 x i8] } %27, ptr %8, align 8
  %28 = load i1, ptr %8, align 1
  switch i1 %28, label %29 [
    i1 false, label %31
    i1 true, label %41
  ]

29:                                               ; preds = %7
  br i1 false, label %30, label %176

30:                                               ; preds = %29
  unreachable

31:                                               ; preds = %7
  %32 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %6, 0
  %33 = call fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f57"(i64 %23, i64 %24, i64 %25, i64 %3, ptr %26, { { ptr, i32, i32, i32 } } %32, { {} } %5, { ptr, i32, i32, i32 } zeroinitializer, { ptr, i32, i32, i32 } zeroinitializer)
  %34 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %33, 0
  %35 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %33, 1
  %36 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %33, 2
  %37 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %33, 3
  %38 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %33, 4
  %39 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %33, 5
  store { i64, [72 x i8] } %39, ptr %10, align 8
  %40 = load i1, ptr %10, align 1
  switch i1 %40, label %52 [
    i1 false, label %54
    i1 true, label %70
  ]

41:                                               ; preds = %7
  %42 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %43 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %42, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %6)
  %44 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %43, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %44, ptr %9, align 8
  %45 = load { i64, [24 x i8] }, ptr %9, align 8
  %46 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %47 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %46, i64 %24, 1
  %48 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %47, i64 %25, 2
  %49 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %48, i64 %3, 3
  %50 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %49, ptr %26, 4
  %51 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %50, { i64, [24 x i8] } %45, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %51

52:                                               ; preds = %31
  br i1 false, label %53, label %177

53:                                               ; preds = %52
  unreachable

54:                                               ; preds = %31
  %55 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } }, ptr %10, align 8
  %56 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %55, 1
  %57 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %56, 0
  %58 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %56, 2
  %59 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %56, 3
  call void @"drop$273"({ { ptr, i32, i32, i32 } } %57)
  %60 = load ptr, ptr %38, align 8
  store i64 %35, ptr %13, align 8
  store i252 814182874304483309791743286124228493744277863724345952005546811777229850325, ptr %14, align 16
  %61 = getelementptr inbounds ptr, ptr %38, i32 8
  %62 = load ptr, ptr %61, align 8
  call void %62(ptr %12, ptr %60, ptr %13, i32 0, ptr %14)
  %63 = load { i1, [47 x i8] }, ptr %12, align 1
  %64 = extractvalue { i1, [47 x i8] } %63, 0
  %65 = getelementptr inbounds i8, ptr %12, i32 16
  %66 = load i252, ptr %65, align 16
  %67 = getelementptr inbounds i8, ptr %12, i32 8
  %68 = load { ptr, i32, i32, i32 }, ptr %67, align 8
  %69 = load i64, ptr %13, align 8
  br i1 %64, label %165, label %81

70:                                               ; preds = %31
  %71 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %72 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %71, 1
  %73 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %72, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %73, ptr %11, align 8
  %74 = load { i64, [24 x i8] }, ptr %11, align 8
  %75 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %34, 0
  %76 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %75, i64 %35, 1
  %77 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %76, i64 %36, 2
  %78 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %77, i64 %37, 3
  %79 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %78, ptr %38, 4
  %80 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %79, { i64, [24 x i8] } %74, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %80

81:                                               ; preds = %54
  %82 = phi i64 [ %34, %54 ]
  %83 = phi i252 [ %66, %54 ]
  %84 = add i64 %82, 3
  %85 = icmp ult i252 %83, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %85, label %86, label %151

86:                                               ; preds = %81
  %87 = phi i252 [ %83, %81 ]
  %88 = insertvalue { i252 } undef, i252 %87, 0
  %89 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f51"(i64 %84, i64 %69, ptr %38, { i252 } %88, { ptr, i32, i32, i32 } %59)
  %90 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %89, 0
  %91 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %89, 1
  %92 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %89, 2
  %93 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %89, 3
  store { i64, [24 x i8] } %93, ptr %17, align 8
  %94 = load i1, ptr %17, align 1
  switch i1 %94, label %95 [
    i1 false, label %97
    i1 true, label %113
  ]

95:                                               ; preds = %86
  br i1 false, label %96, label %178

96:                                               ; preds = %95
  unreachable

97:                                               ; preds = %86
  %98 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %99 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %98, 1
  %100 = extractvalue { { ptr, i32, i32, i32 } } %99, 0
  %101 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %100, 0
  %102 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 0
  %103 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %101, 0
  %104 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %103, { { ptr, i32, i32, i32 } } %102, 1
  %105 = call fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f58"(i64 %90, i64 %91, i64 %36, i64 %37, ptr %92, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %104)
  %106 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, 0
  %107 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, 1
  %108 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, 2
  %109 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, 3
  %110 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, 4
  %111 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, 5
  store { i64, [48 x i8] } %111, ptr %19, align 8
  %112 = load i1, ptr %19, align 1
  switch i1 %112, label %124 [
    i1 false, label %126
    i1 true, label %140
  ]

113:                                              ; preds = %86
  %114 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %115 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %114, 1
  call void @"drop$182"({ ptr, i32, i32, i32 } %58)
  %116 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %115, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %116, ptr %18, align 8
  %117 = load { i64, [24 x i8] }, ptr %18, align 8
  %118 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %90, 0
  %119 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %118, i64 %91, 1
  %120 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %119, i64 %36, 2
  %121 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %120, i64 %37, 3
  %122 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %121, ptr %92, 4
  %123 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %122, { i64, [24 x i8] } %117, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %123

124:                                              ; preds = %97
  br i1 false, label %125, label %179

125:                                              ; preds = %124
  unreachable

126:                                              ; preds = %97
  %127 = load { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } }, ptr %19, align 8
  %128 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %127, 1
  %129 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %130 = call ptr %129()
  %131 = call i64 @llvm.uadd.sat.i64(i64 %107, i64 0)
  %132 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %128, 0
  call void @"drop$270"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %132)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %21, align 1
  %133 = load { i64, [24 x i8] }, ptr %21, align 8
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %106, 0
  %135 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %134, i64 %131, 1
  %136 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %108, 2
  %137 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %109, 3
  %138 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %137, ptr %110, 4
  %139 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %138, { i64, [24 x i8] } %133, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %139

140:                                              ; preds = %97
  %141 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %142 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %141, 1
  %143 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %142, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %143, ptr %20, align 8
  %144 = load { i64, [24 x i8] }, ptr %20, align 8
  %145 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %106, 0
  %146 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %145, i64 %107, 1
  %147 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %146, i64 %108, 2
  %148 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %147, i64 %109, 3
  %149 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %148, ptr %110, 4
  %150 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %149, { i64, [24 x i8] } %144, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %150

151:                                              ; preds = %81
  %152 = phi { ptr, i32, i32, i32 } [ %58, %81 ]
  call void @"drop$182"({ ptr, i32, i32, i32 } %152)
  call void @"drop$106"({ ptr, i32, i32, i32 } %59)
  %153 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"()
  %154 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %153, 0
  %155 = extractvalue { {}, { ptr, i32, i32, i32 } } %154, 1
  %156 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %155, 1
  %157 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %156, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %157, ptr %16, align 8
  %158 = load { i64, [24 x i8] }, ptr %16, align 8
  %159 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %84, 0
  %160 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %159, i64 %69, 1
  %161 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %160, i64 %36, 2
  %162 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %161, i64 %37, 3
  %163 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %162, ptr %38, 4
  %164 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %163, { i64, [24 x i8] } %158, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %164

165:                                              ; preds = %54
  %166 = phi { ptr, i32, i32, i32 } [ %58, %54 ]
  call void @"drop$182"({ ptr, i32, i32, i32 } %166)
  call void @"drop$106"({ ptr, i32, i32, i32 } %59)
  %167 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 1
  %168 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %167, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %168, ptr %15, align 8
  %169 = load { i64, [24 x i8] }, ptr %15, align 8
  %170 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %34, 0
  %171 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %170, i64 %69, 1
  %172 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %171, i64 %36, 2
  %173 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %172, i64 %37, 3
  %174 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %173, ptr %38, 4
  %175 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %174, { i64, [24 x i8] } %169, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %175

176:                                              ; preds = %29
  call void @puts(ptr @assert_msg_69)
  call void @abort()
  unreachable

177:                                              ; preds = %52
  call void @puts(ptr @assert_msg_70)
  call void @abort()
  unreachable

178:                                              ; preds = %95
  call void @puts(ptr @assert_msg_71)
  call void @abort()
  unreachable

179:                                              ; preds = %124
  call void @puts(ptr @assert_msg_72)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f28(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f28"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { ptr, i32, i32, i32 } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, { i64, [24 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20
}

define void @_mlir_ciface_f28(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, { ptr, i32, i32, i32 } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f28(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, { ptr, i32, i32, i32 } %7)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, ptr %0, align 8
  ret void
}

define private void @"drop$258"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$258"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 48)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 48, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$259"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$259"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$260"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$259"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$260"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$259"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$261"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$260"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$261"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$260"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$262"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 3
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 7
  call void @"drop$261"({ { ptr, i32, i32, i32 } } %3)
  %4 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 9
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %4)
  %5 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 12
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %5)
  ret void
}

define private { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } @"dup$262"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, i252 %2, 0
  %4 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } undef, i252 %2, 0
  %5 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %3, i252 %5, 1
  %7 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %4, i252 %5, 1
  %8 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 2
  %9 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %6, i128 %8, 2
  %10 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %7, i128 %8, 2
  %11 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 3
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %9, { { ptr, i32, i32, i32 } } %13, 3
  %16 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %10, { { ptr, i32, i32, i32 } } %14, 3
  %17 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 4
  %18 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %15, i252 %17, 4
  %19 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %16, i252 %17, 4
  %20 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 5
  %21 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %18, i252 %20, 5
  %22 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %19, i252 %20, 5
  %23 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 6
  %24 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %21, i252 %23, 6
  %25 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %22, i252 %23, 6
  %26 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 7
  %27 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$261"({ { ptr, i32, i32, i32 } } %26)
  %28 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %27, 0
  %29 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %27, 1
  %30 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %24, { { ptr, i32, i32, i32 } } %28, 7
  %31 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %25, { { ptr, i32, i32, i32 } } %29, 7
  %32 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 8
  %33 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %30, i128 %32, 8
  %34 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %31, i128 %32, 8
  %35 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 9
  %36 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %35)
  %37 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %36, 0
  %38 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %36, 1
  %39 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %33, { { ptr, i32, i32, i32 } } %37, 9
  %40 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %34, { { ptr, i32, i32, i32 } } %38, 9
  %41 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 10
  %42 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %39, i32 %41, 10
  %43 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %40, i32 %41, 10
  %44 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 11
  %45 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %42, i32 %44, 11
  %46 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %43, i32 %44, 11
  %47 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 12
  %48 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %47)
  %49 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %48, 0
  %50 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %48, 1
  %51 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %45, { { ptr, i32, i32, i32 } } %49, 12
  %52 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %46, { { ptr, i32, i32, i32 } } %50, 12
  %53 = insertvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } undef, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %51, 0
  %54 = insertvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %53, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %52, 1
  ret { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %54
}

define private void @"drop$257"(ptr %0) {
  %2 = load { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, ptr %0, align 16
  call void @"drop$262"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$257"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 320)
  %3 = load { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, ptr %0, align 16
  %4 = call { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } @"dup$262"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %3)
  %5 = extractvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %4, 0
  %6 = extractvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %4, 1
  store { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %5, ptr %0, align 16
  store { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$266"({ ptr, ptr, i252, i252, i252 } %0) {
  %2 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 0
  call void @"drop$258"(ptr %2)
  %3 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 1
  call void @"drop$257"(ptr %3)
  ret void
}

define private { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } @"dup$266"({ ptr, ptr, i252, i252, i252 } %0) {
  %2 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 0
  %3 = call { ptr, ptr } @"dup$258"(ptr %2)
  %4 = extractvalue { ptr, ptr } %3, 0
  %5 = extractvalue { ptr, ptr } %3, 1
  %6 = insertvalue { ptr, ptr, i252, i252, i252 } %0, ptr %4, 0
  %7 = insertvalue { ptr, ptr, i252, i252, i252 } undef, ptr %5, 0
  %8 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 1
  %9 = call { ptr, ptr } @"dup$257"(ptr %8)
  %10 = extractvalue { ptr, ptr } %9, 0
  %11 = extractvalue { ptr, ptr } %9, 1
  %12 = insertvalue { ptr, ptr, i252, i252, i252 } %6, ptr %10, 1
  %13 = insertvalue { ptr, ptr, i252, i252, i252 } %7, ptr %11, 1
  %14 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 2
  %15 = insertvalue { ptr, ptr, i252, i252, i252 } %12, i252 %14, 2
  %16 = insertvalue { ptr, ptr, i252, i252, i252 } %13, i252 %14, 2
  %17 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 3
  %18 = insertvalue { ptr, ptr, i252, i252, i252 } %15, i252 %17, 3
  %19 = insertvalue { ptr, ptr, i252, i252, i252 } %16, i252 %17, 3
  %20 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 4
  %21 = insertvalue { ptr, ptr, i252, i252, i252 } %18, i252 %20, 4
  %22 = insertvalue { ptr, ptr, i252, i252, i252 } %19, i252 %20, 4
  %23 = insertvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } undef, { ptr, ptr, i252, i252, i252 } %21, 0
  %24 = insertvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %23, { ptr, ptr, i252, i252, i252 } %22, 1
  ret { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %24
}

define private void @"drop$267"(ptr %0) {
  %2 = load { ptr, ptr, i252, i252, i252 }, ptr %0, align 16
  call void @"drop$266"({ ptr, ptr, i252, i252, i252 } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$267"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 112)
  %3 = load { ptr, ptr, i252, i252, i252 }, ptr %0, align 16
  %4 = call { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } @"dup$266"({ ptr, ptr, i252, i252, i252 } %3)
  %5 = extractvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %4, 0
  %6 = extractvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %4, 1
  store { ptr, ptr, i252, i252, i252 } %5, ptr %0, align 16
  store { ptr, ptr, i252, i252, i252 } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$253"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 0
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } @"dup$253"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6, {} %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %11, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %10, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %12
}

define private void @"drop$254"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, 1
  call void @"drop$253"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$254"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } @"dup$253"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %10, ptr %2, align 16
  %11 = load { i128, [80 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %12, ptr %2, align 16
  %13 = load { i128, [80 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %11, 0
  %15 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %14, { i128, [80 x i8] } %13, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [80 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [80 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %23, 0
  %27 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %26, { i128, [80 x i8] } %25, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %0)
  ret void
}

define private { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  %2 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %0)
  %3 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, 0
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, 1
  %5 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %3, 0
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %5, { { ptr, i32, i32, i32 }, i252, i32 } %4, 1
  ret { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4) {
  %6 = alloca { i1, [31 x i8] }, i64 1, align 8
  %7 = alloca i64, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca { i1, [47 x i8] }, i64 1, align 16
  %13 = alloca i64, i64 1, align 8
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i128, [80 x i8] }, i64 1, align 16
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = load ptr, ptr %3, align 8
  store i64 %1, ptr %7, align 8
  %21 = getelementptr inbounds ptr, ptr %3, i32 3
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %6, ptr %20, ptr %7)
  %23 = load { i1, [31 x i8] }, ptr %6, align 1
  %24 = extractvalue { i1, [31 x i8] } %23, 0
  %25 = getelementptr inbounds i8, ptr %6, i32 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr inbounds i8, ptr %6, i32 8
  %28 = load { ptr, i32, i32, i32 }, ptr %27, align 8
  %29 = load i64, ptr %7, align 8
  br i1 %24, label %140, label %30

30:                                               ; preds = %5
  %31 = phi ptr [ %26, %5 ]
  %32 = load { ptr, ptr, i252, i252, i252 }, ptr %31, align 16
  call void @free(ptr %31)
  %33 = extractvalue { ptr, ptr, i252, i252, i252 } %32, 0
  %34 = extractvalue { ptr, ptr, i252, i252, i252 } %32, 1
  %35 = extractvalue { ptr, ptr, i252, i252, i252 } %32, 2
  call void @"drop$258"(ptr %33)
  call void @"drop$257"(ptr %34)
  %36 = add i64 %2, 3
  %37 = zext i252 %35 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %9, align 16
  store i256 %37, ptr %10, align 16
  %38 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %38(ptr %11, ptr %9, ptr %10)
  %39 = load i256, ptr %11, align 16
  %40 = trunc i256 %39 to i252
  %41 = add i64 %0, 3
  %42 = sub i252 %40, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %43 = icmp ult i252 %40, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %44 = select i1 %43, i252 %40, i252 %42
  %45 = load ptr, ptr %3, align 8
  store i64 %29, ptr %13, align 8
  store i252 %44, ptr %14, align 16
  %46 = getelementptr inbounds ptr, ptr %3, i32 8
  %47 = load ptr, ptr %46, align 8
  call void %47(ptr %12, ptr %45, ptr %13, i32 0, ptr %14)
  %48 = load { i1, [47 x i8] }, ptr %12, align 1
  %49 = extractvalue { i1, [47 x i8] } %48, 0
  %50 = getelementptr inbounds i8, ptr %12, i32 16
  %51 = load i252, ptr %50, align 16
  %52 = getelementptr inbounds i8, ptr %12, i32 8
  %53 = load { ptr, i32, i32, i32 }, ptr %52, align 8
  %54 = load i64, ptr %13, align 8
  br i1 %49, label %128, label %55

55:                                               ; preds = %30
  %56 = phi i252 [ %51, %30 ]
  %57 = icmp eq i252 %56, 0
  br i1 %57, label %58, label %63

58:                                               ; preds = %55
  %59 = phi i64 [ %54, %55 ]
  %60 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %61 = call ptr %60()
  %62 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  br label %70

63:                                               ; preds = %55
  %64 = phi i64 [ %54, %55 ]
  %65 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %66 = call ptr %65()
  %67 = load i64, ptr %66, align 8
  %68 = mul i64 %67, 100
  %69 = call i64 @llvm.uadd.sat.i64(i64 %64, i64 %68)
  br label %70

70:                                               ; preds = %58, %63
  %71 = phi i64 [ %36, %63 ], [ %36, %58 ]
  %72 = phi ptr [ %3, %63 ], [ %3, %58 ]
  %73 = phi i64 [ %41, %63 ], [ %41, %58 ]
  %74 = phi i64 [ %69, %63 ], [ %62, %58 ]
  %75 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %63 ], [ { i1 true, [0 x i8] undef }, %58 ]
  %76 = extractvalue { i1, [0 x i8] } %75, 0
  %77 = xor i1 %76, true
  switch i1 %77, label %78 [
    i1 false, label %80
    i1 true, label %115
  ]

78:                                               ; preds = %70
  br i1 false, label %79, label %152

79:                                               ; preds = %78
  unreachable

80:                                               ; preds = %70
  %81 = call fastcc { i64, { i128, [80 x i8] } } @"impl$f59"(i64 %73, { { ptr, i32, i32, i32 }, i252, i32 } zeroinitializer, i252 25210060730641651003830129888238850617644299624277362, i32 22)
  %82 = extractvalue { i64, { i128, [80 x i8] } } %81, 0
  %83 = extractvalue { i64, { i128, [80 x i8] } } %81, 1
  store { i128, [80 x i8] } %83, ptr %17, align 16
  %84 = load i1, ptr %17, align 1
  switch i1 %84, label %85 [
    i1 false, label %87
    i1 true, label %105
  ]

85:                                               ; preds = %80
  br i1 false, label %86, label %153

86:                                               ; preds = %85
  unreachable

87:                                               ; preds = %80
  %88 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %17, align 16
  %89 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %88, 1
  %90 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %89, 0
  %91 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %90)
  %92 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %91, 0
  %93 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %91, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %92)
  %94 = call fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f60"(i64 %82, i64 %74, { { ptr, i32, i32, i32 }, i252, i32 } %93)
  %95 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %94, 0
  %96 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %94, 1
  %97 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %94, 2
  %98 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %97, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %98, ptr %19, align 8
  %99 = load { i64, [24 x i8] }, ptr %19, align 8
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %95, 0
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %96, 1
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, i64 %71, 2
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, ptr %72, 3
  %104 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %103, { i64, [24 x i8] } %99, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %104

105:                                              ; preds = %80
  %106 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %107 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %106, 1
  %108 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %107, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %108, ptr %18, align 8
  %109 = load { i64, [24 x i8] }, ptr %18, align 8
  %110 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %110, i64 %74, 1
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, i64 %71, 2
  %113 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %112, ptr %72, 3
  %114 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %113, { i64, [24 x i8] } %109, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %114

115:                                              ; preds = %70
  %116 = phi i64 [ %74, %70 ]
  %117 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %118 = call ptr %117()
  %119 = load i64, ptr %118, align 8
  %120 = mul i64 %119, 17910
  %121 = call i64 @llvm.uadd.sat.i64(i64 %116, i64 %120)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %16, align 1
  %122 = load { i64, [24 x i8] }, ptr %16, align 8
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %73, 0
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, i64 %121, 1
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, i64 %71, 2
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %125, ptr %72, 3
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, { i64, [24 x i8] } %122, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %127

128:                                              ; preds = %30
  %129 = phi {} [ undef, %30 ]
  %130 = phi { ptr, i32, i32, i32 } [ %53, %30 ]
  %131 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %129, 0
  %132 = insertvalue { {}, { ptr, i32, i32, i32 } } %131, { ptr, i32, i32, i32 } %130, 1
  %133 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %132, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %133, ptr %15, align 8
  %134 = load { i64, [24 x i8] }, ptr %15, align 8
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %41, 0
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %54, 1
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %36, 2
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, ptr %3, 3
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, { i64, [24 x i8] } %134, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %139

140:                                              ; preds = %5
  %141 = phi {} [ undef, %5 ]
  %142 = phi { ptr, i32, i32, i32 } [ %28, %5 ]
  %143 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %141, 0
  %144 = insertvalue { {}, { ptr, i32, i32, i32 } } %143, { ptr, i32, i32, i32 } %142, 1
  %145 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %144, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %145, ptr %8, align 8
  %146 = load { i64, [24 x i8] }, ptr %8, align 8
  %147 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %148 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, i64 %29, 1
  %149 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %148, i64 %2, 2
  %150 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, ptr %3, 3
  %151 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, { i64, [24 x i8] } %146, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %151

152:                                              ; preds = %78
  call void @puts(ptr @assert_msg_73)
  call void @abort()
  unreachable

153:                                              ; preds = %85
  call void @puts(ptr @assert_msg_74)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f29(i64 %0, i64 %1, i64 %2, ptr %3, {} %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f29(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, {} %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f29(i64 %1, i64 %2, i64 %3, ptr %4, {} %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5, { i1, [0 x i8] } %6) {
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca i252, i64 1, align 16
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i128, [32 x i8] }, i64 1, align 16
  %17 = alloca { i128, [32 x i8] }, i64 1, align 16
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i128, [32 x i8] }, i64 1, align 16
  %22 = alloca { i128, [32 x i8] }, i64 1, align 16
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca { i64, [24 x i8] }, i64 1, align 8
  %25 = add i64 %2, 3
  %26 = zext i252 %5 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %8, align 16
  store i256 %26, ptr %9, align 16
  %27 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %27(ptr %10, ptr %8, ptr %9)
  %28 = load i256, ptr %10, align 16
  %29 = trunc i256 %28 to i252
  %30 = add i64 %0, 3
  %31 = sub i252 %29, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %32 = icmp ult i252 %29, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %33 = select i1 %32, i252 %29, i252 %31
  %34 = extractvalue { i1, [0 x i8] } %6, 0
  %35 = zext i1 %34 to i252
  %36 = load ptr, ptr %3, align 8
  store i64 %1, ptr %12, align 8
  store i252 %33, ptr %13, align 16
  store i252 %35, ptr %14, align 16
  %37 = getelementptr inbounds ptr, ptr %3, i32 9
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %11, ptr %36, ptr %12, i32 0, ptr %13, ptr %14)
  %39 = load { i1, [31 x i8] }, ptr %11, align 1
  %40 = extractvalue { i1, [31 x i8] } %39, 0
  %41 = getelementptr inbounds i8, ptr %11, i32 8
  %42 = load { ptr, i32, i32, i32 }, ptr %41, align 8
  %43 = load i64, ptr %12, align 8
  br i1 %40, label %114, label %44

44:                                               ; preds = %7
  %45 = phi { i1, [0 x i8] } [ %6, %7 ]
  %46 = extractvalue { i1, [0 x i8] } %45, 0
  switch i1 %46, label %47 [
    i1 false, label %49
    i1 true, label %75
  ]

47:                                               ; preds = %44
  br i1 false, label %48, label %126

48:                                               ; preds = %47
  unreachable

49:                                               ; preds = %44
  %50 = phi i252 [ %5, %44 ]
  %51 = insertvalue { i252 } undef, i252 %50, 0
  %52 = insertvalue { i1, { i252 } } { i1 true, { i252 } undef }, { i252 } %51, 1
  store { i1, { i252 } } %52, ptr %21, align 16
  %53 = load { i128, [32 x i8] }, ptr %21, align 16
  store { i128, [32 x i8] } %53, ptr %22, align 16
  %54 = call fastcc { i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %43, ptr %3, { {} } undef, ptr %22)
  %55 = extractvalue { i64, ptr, { i64, [24 x i8] } } %54, 0
  %56 = extractvalue { i64, ptr, { i64, [24 x i8] } } %54, 1
  %57 = extractvalue { i64, ptr, { i64, [24 x i8] } } %54, 2
  store { i64, [24 x i8] } %57, ptr %23, align 8
  %58 = load i1, ptr %23, align 1
  switch i1 %58, label %59 [
    i1 false, label %61
    i1 true, label %65
  ]

59:                                               ; preds = %49
  br i1 false, label %60, label %127

60:                                               ; preds = %59
  unreachable

61:                                               ; preds = %49
  %62 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %63 = call ptr %62()
  %64 = call i64 @llvm.uadd.sat.i64(i64 %55, i64 0)
  br label %103

65:                                               ; preds = %49
  %66 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %23, align 8
  %67 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %66, 1
  %68 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %67, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %68, ptr %24, align 8
  %69 = load { i64, [24 x i8] }, ptr %24, align 8
  %70 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %30, 0
  %71 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %55, 1
  %72 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %71, i64 %25, 2
  %73 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %72, ptr %56, 3
  %74 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, { i64, [24 x i8] } %69, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %74

75:                                               ; preds = %44
  %76 = phi i252 [ %5, %44 ]
  %77 = insertvalue { i252 } undef, i252 %76, 0
  %78 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %77, 1
  store { i1, { i252 } } %78, ptr %16, align 16
  %79 = load { i128, [32 x i8] }, ptr %16, align 16
  store { i128, [32 x i8] } %79, ptr %17, align 16
  %80 = call fastcc { i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %43, ptr %3, { {} } undef, ptr %17)
  %81 = extractvalue { i64, ptr, { i64, [24 x i8] } } %80, 0
  %82 = extractvalue { i64, ptr, { i64, [24 x i8] } } %80, 1
  %83 = extractvalue { i64, ptr, { i64, [24 x i8] } } %80, 2
  store { i64, [24 x i8] } %83, ptr %18, align 8
  %84 = load i1, ptr %18, align 1
  switch i1 %84, label %85 [
    i1 false, label %87
    i1 true, label %93
  ]

85:                                               ; preds = %75
  br i1 false, label %86, label %128

86:                                               ; preds = %85
  unreachable

87:                                               ; preds = %75
  %88 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %89 = call ptr %88()
  %90 = load i64, ptr %89, align 8
  %91 = mul i64 %90, 100
  %92 = call i64 @llvm.uadd.sat.i64(i64 %81, i64 %91)
  br label %103

93:                                               ; preds = %75
  %94 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %95 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %94, 1
  %96 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %95, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %96, ptr %19, align 8
  %97 = load { i64, [24 x i8] }, ptr %19, align 8
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %30, 0
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, i64 %81, 1
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %25, 2
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, ptr %82, 3
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, { i64, [24 x i8] } %97, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %102

103:                                              ; preds = %61, %87
  %104 = phi i64 [ %25, %87 ], [ %25, %61 ]
  %105 = phi i64 [ %30, %87 ], [ %30, %61 ]
  %106 = phi i64 [ %92, %87 ], [ %64, %61 ]
  %107 = phi ptr [ %82, %87 ], [ %56, %61 ]
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %20, align 1
  %108 = load { i64, [24 x i8] }, ptr %20, align 8
  %109 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %105, 0
  %110 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, i64 %106, 1
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %110, i64 %104, 2
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, ptr %107, 3
  %113 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %112, { i64, [24 x i8] } %108, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %113

114:                                              ; preds = %7
  %115 = phi {} [ undef, %7 ]
  %116 = phi { ptr, i32, i32, i32 } [ %42, %7 ]
  %117 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %115, 0
  %118 = insertvalue { {}, { ptr, i32, i32, i32 } } %117, { ptr, i32, i32, i32 } %116, 1
  %119 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %118, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %119, ptr %15, align 8
  %120 = load { i64, [24 x i8] }, ptr %15, align 8
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %30, 0
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, i64 %43, 1
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, i64 %25, 2
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, ptr %3, 3
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, { i64, [24 x i8] } %120, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %125

126:                                              ; preds = %47
  call void @puts(ptr @assert_msg_75)
  call void @abort()
  unreachable

127:                                              ; preds = %59
  call void @puts(ptr @assert_msg_76)
  call void @abort()
  unreachable

128:                                              ; preds = %85
  call void @puts(ptr @assert_msg_77)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f30(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5, { i1, [0 x i8] } %6) {
  %8 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5, { i1, [0 x i8] } %6)
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 4
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %9, 0
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 1
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %11, 2
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, ptr %12, 3
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, { i64, [24 x i8] } %13, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %18
}

define void @_mlir_ciface_f30(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6, { i1, [0 x i8] } %7) {
  %9 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f30(i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6, { i1, [0 x i8] } %7)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f31"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %117, %5
  %17 = phi i64 [ %71, %117 ], [ %0, %5 ]
  %18 = phi i64 [ %77, %117 ], [ %1, %5 ]
  %19 = phi { { ptr, i32, i32, i32 } } [ %134, %117 ], [ %2, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %126, %117 ], [ %3, %5 ]
  %21 = phi i252 [ %133, %117 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 2680
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %185

29:                                               ; preds = %16
  %30 = phi i252 [ %21, %16 ]
  %31 = icmp eq i252 %30, 0
  br i1 %31, label %32, label %54

32:                                               ; preds = %29
  %33 = phi i64 [ %28, %29 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = load i64, ptr %35, align 8
  %37 = mul i64 %36, 3580
  %38 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %37)
  %39 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %20, 1
  store { i1, { ptr, i32, i32, i32 } } %39, ptr %14, align 8
  %40 = load { i64, [24 x i8] }, ptr %14, align 8
  %41 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %19, 0
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %41, { i64, [24 x i8] } %40, 1
  %43 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %43, ptr %15, align 8
  %44 = load { i64, [56 x i8] }, ptr %15, align 8
  %45 = extractvalue { ptr, ptr, i64 } %9, 1
  %46 = load i64, ptr %45, align 8
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %46, 1
  %49 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %48, ptr %49, align 8
  br i1 %47, label %50, label %139

50:                                               ; preds = %32
  %51 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } %51, i64 %38, 1
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, { i64, [56 x i8] } %44, 2
  ret { i64, i64, { i64, [56 x i8] } } %53

54:                                               ; preds = %29
  %55 = phi { { ptr, i32, i32, i32 } } [ %19, %29 ]
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %159

61:                                               ; preds = %54
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %71 = add i64 %17, 4
  %72 = icmp ult i252 %70, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %72, label %73, label %152

73:                                               ; preds = %61
  %74 = phi i64 [ %28, %61 ]
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %74, i64 0)
  %78 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %94

80:                                               ; preds = %73
  %81 = shl i32 %78, 1
  %82 = call i32 @llvm.umin.i32(i32 %81, i32 1024)
  %83 = add i32 %82, %78
  %84 = call i32 @llvm.umax.i32(i32 %83, i32 8)
  %85 = zext i32 %84 to i64
  %86 = mul i64 %85, 32
  %87 = add i64 %86, 16
  %88 = call ptr @realloc(ptr null, i64 %87)
  store i32 1, ptr %88, align 4
  %89 = getelementptr inbounds i8, ptr %88, i32 4
  store i32 0, ptr %89, align 4
  %90 = getelementptr inbounds i8, ptr %88, i32 16
  %91 = call ptr @realloc(ptr null, i64 8)
  store ptr %90, ptr %91, align 8
  %92 = insertvalue { ptr, i32, i32, i32 } %20, ptr %91, 0
  %93 = insertvalue { ptr, i32, i32, i32 } %92, i32 %84, 3
  br label %115

94:                                               ; preds = %73
  %95 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %96 = icmp ult i32 %95, %78
  br i1 %96, label %97, label %98

97:                                               ; preds = %94
  br label %112

98:                                               ; preds = %94
  %99 = shl i32 %78, 1
  %100 = call i32 @llvm.umin.i32(i32 %99, i32 1024)
  %101 = add i32 %100, %78
  %102 = call i32 @llvm.umax.i32(i32 %101, i32 8)
  %103 = zext i32 %102 to i64
  %104 = mul i64 %103, 32
  %105 = add i64 %104, 16
  %106 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr inbounds i8, ptr %107, i32 -16
  %109 = call ptr @realloc(ptr %108, i64 %105)
  %110 = getelementptr inbounds i8, ptr %109, i32 16
  store ptr %110, ptr %106, align 8
  %111 = insertvalue { ptr, i32, i32, i32 } %20, i32 %102, 3
  br label %112

112:                                              ; preds = %97, %98
  %113 = phi { ptr, i32, i32, i32 } [ %111, %98 ], [ %20, %97 ]
  br label %114

114:                                              ; preds = %112
  br label %115

115:                                              ; preds = %80, %114
  %116 = phi { ptr, i32, i32, i32 } [ %113, %114 ], [ %93, %80 ]
  br label %117

117:                                              ; preds = %115
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %119 = load ptr, ptr %118, align 8
  %120 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %121 = zext i32 %120 to i64
  %122 = mul i64 %121, 32
  %123 = getelementptr inbounds i8, ptr %119, i64 %122
  store i252 %70, ptr %123, align 16
  %124 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %125 = add i32 %124, 1
  %126 = insertvalue { ptr, i32, i32, i32 } %116, i32 %125, 2
  %127 = getelementptr inbounds i8, ptr %119, i32 -12
  store i32 %125, ptr %127, align 4
  %128 = zext i252 %30 to i256
  %129 = sub i256 %128, 1
  %130 = add i256 %128, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %131 = icmp ult i256 %128, 1
  %132 = select i1 %131, i256 %130, i256 %129
  %133 = trunc i256 %132 to i252
  %134 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %135 = extractvalue { ptr, ptr, i64 } %9, 1
  %136 = load i64, ptr %135, align 8
  %137 = add i64 %136, 1
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %137, ptr %138, align 8
  br label %16

139:                                              ; preds = %139, %32, %166, %185
  %140 = phi i64 [ %22, %185 ], [ %167, %166 ], [ %140, %139 ], [ %22, %32 ]
  %141 = phi i64 [ %18, %185 ], [ %168, %166 ], [ %141, %139 ], [ %38, %32 ]
  %142 = phi { i64, [56 x i8] } [ %190, %185 ], [ %175, %166 ], [ %142, %139 ], [ %44, %32 ]
  %143 = extractvalue { ptr, ptr, i64 } %9, 1
  %144 = load i64, ptr %143, align 8
  %145 = icmp eq i64 %144, 0
  %146 = sub i64 %144, 1
  %147 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %146, ptr %147, align 8
  br i1 %145, label %148, label %139

148:                                              ; preds = %139
  %149 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %140, 0
  %150 = insertvalue { i64, i64, { i64, [56 x i8] } } %149, i64 %141, 1
  %151 = insertvalue { i64, i64, { i64, [56 x i8] } } %150, { i64, [56 x i8] } %142, 2
  ret { i64, i64, { i64, [56 x i8] } } %151

152:                                              ; preds = %61
  %153 = phi { ptr, i32, i32, i32 } [ %20, %61 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %153)
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = load i64, ptr %155, align 8
  %157 = mul i64 %156, 1670
  %158 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %157)
  br label %166

159:                                              ; preds = %54
  %160 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %160)
  %161 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %162 = call ptr %161()
  %163 = load i64, ptr %162, align 8
  %164 = mul i64 %163, 2880
  %165 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %164)
  br label %166

166:                                              ; preds = %152, %159
  %167 = phi i64 [ %22, %159 ], [ %71, %152 ]
  %168 = phi i64 [ %165, %159 ], [ %158, %152 ]
  %169 = phi { ptr, i32, i32, i32 } [ %56, %159 ], [ %68, %152 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %170 = load { i64, [24 x i8] }, ptr %12, align 8
  %171 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %169, 0
  %172 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %171, 0
  %173 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %172, { i64, [24 x i8] } %170, 1
  %174 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %173, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %174, ptr %13, align 8
  %175 = load { i64, [56 x i8] }, ptr %13, align 8
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %139

181:                                              ; preds = %166
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %168, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184

185:                                              ; preds = %16
  %186 = phi { ptr, i32, i32, i32 } [ %20, %16 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %186)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %19)
  %187 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %188 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %187, 0
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %11, align 8
  %190 = load { i64, [56 x i8] }, ptr %11, align 8
  %191 = extractvalue { ptr, ptr, i64 } %9, 1
  %192 = load i64, ptr %191, align 8
  %193 = icmp eq i64 %192, 0
  %194 = sub i64 %192, 1
  %195 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %194, ptr %195, align 8
  br i1 %193, label %196, label %139

196:                                              ; preds = %185
  %197 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %198 = insertvalue { i64, i64, { i64, [56 x i8] } } %197, i64 %18, 1
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } %198, { i64, [56 x i8] } %190, 2
  ret { i64, i64, { i64, [56 x i8] } } %199
}

define private { i64, i64, { i64, [56 x i8] } } @f31(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f31"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f31(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f31(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$246"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$246"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f32"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %59, %6
  %17 = phi i64 [ %51, %59 ], [ %0, %6 ]
  %18 = phi i64 [ %64, %59 ], [ %1, %6 ]
  %19 = phi i64 [ %53, %59 ], [ %2, %6 ]
  %20 = phi ptr [ %54, %59 ], [ %3, %6 ]
  %21 = phi { { ptr, i32, i32, i32 } } [ %66, %59 ], [ %4, %6 ]
  %22 = phi {} [ %65, %59 ], [ %5, %6 ]
  %23 = add i64 %17, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = getelementptr inbounds i64, ptr %25, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %25, align 8
  %29 = mul i64 %28, 29790
  %30 = add i64 %27, %29
  %31 = icmp uge i64 %18, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %30)
  br i1 %31, label %33, label %131

33:                                               ; preds = %16
  %34 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  %35 = extractvalue { { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %104

40:                                               ; preds = %33
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %23, i64 %32, i64 %19, ptr %20, {} %22, i252 %49, { i1, [0 x i8] } { i1 true, [0 x i8] undef })
  %51 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 0
  %52 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 1
  %53 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 2
  %54 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 3
  %55 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 4
  store { i64, [24 x i8] } %55, ptr %14, align 8
  %56 = load i1, ptr %14, align 1
  switch i1 %56, label %57 [
    i1 false, label %59
    i1 true, label %71
  ]

57:                                               ; preds = %40
  br i1 false, label %58, label %148

58:                                               ; preds = %57
  unreachable

59:                                               ; preds = %40
  %60 = load { i1, { {}, {} } }, ptr %14, align 1
  %61 = extractvalue { i1, { {}, {} } } %60, 1
  %62 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %63 = call ptr %62()
  %64 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 0)
  %65 = extractvalue { {}, {} } %61, 0
  %66 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %47, 0
  %67 = extractvalue { ptr, ptr, i64 } %10, 1
  %68 = load i64, ptr %67, align 8
  %69 = add i64 %68, 1
  %70 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %69, ptr %70, align 8
  br label %16

71:                                               ; preds = %40
  %72 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %73 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %72, 1
  call void @"drop$241"({ ptr, i32, i32, i32 } %47)
  %74 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %73, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %74, ptr %15, align 8
  %75 = load { i64, [24 x i8] }, ptr %15, align 8
  %76 = extractvalue { ptr, ptr, i64 } %10, 1
  %77 = load i64, ptr %76, align 8
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %77, 1
  %80 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %79, ptr %80, align 8
  br i1 %78, label %98, label %81

81:                                               ; preds = %81, %71, %104, %131
  %82 = phi i64 [ %23, %131 ], [ %23, %104 ], [ %82, %81 ], [ %51, %71 ]
  %83 = phi i64 [ %18, %131 ], [ %113, %104 ], [ %83, %81 ], [ %52, %71 ]
  %84 = phi i64 [ %19, %131 ], [ %19, %104 ], [ %84, %81 ], [ %53, %71 ]
  %85 = phi ptr [ %20, %131 ], [ %20, %104 ], [ %85, %81 ], [ %54, %71 ]
  %86 = phi { i64, [24 x i8] } [ %136, %131 ], [ %119, %104 ], [ %86, %81 ], [ %75, %71 ]
  %87 = extractvalue { ptr, ptr, i64 } %10, 1
  %88 = load i64, ptr %87, align 8
  %89 = icmp eq i64 %88, 0
  %90 = sub i64 %88, 1
  %91 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %90, ptr %91, align 8
  br i1 %89, label %92, label %81

92:                                               ; preds = %81
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %83, 1
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %84, 2
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, ptr %85, 3
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %86, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %97

98:                                               ; preds = %71
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %51, 0
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %52, 1
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %53, 2
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, ptr %54, 3
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, { i64, [24 x i8] } %75, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %103

104:                                              ; preds = %33
  %105 = phi i64 [ %32, %33 ]
  %106 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %107 = call ptr %106()
  %108 = getelementptr inbounds i64, ptr %107, i32 1
  %109 = load i64, ptr %108, align 8
  %110 = load i64, ptr %107, align 8
  %111 = mul i64 %110, 29990
  %112 = add i64 %109, %111
  %113 = call i64 @llvm.uadd.sat.i64(i64 %105, i64 %112)
  %114 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %35, 0
  %115 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } undef, { { ptr, i32, i32, i32 } } %114, 0
  %116 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %115, {} %22, 1
  %117 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %116, {} undef, 2
  %118 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, {}, {} } undef }, { { { ptr, i32, i32, i32 } }, {}, {} } %117, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %118, ptr %13, align 8
  %119 = load { i64, [24 x i8] }, ptr %13, align 8
  %120 = extractvalue { ptr, ptr, i64 } %10, 1
  %121 = load i64, ptr %120, align 8
  %122 = icmp eq i64 %121, 0
  %123 = sub i64 %121, 1
  %124 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %123, ptr %124, align 8
  br i1 %122, label %125, label %81

125:                                              ; preds = %104
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, i64 %113, 1
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %19, 2
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, ptr %20, 3
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, { i64, [24 x i8] } %119, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %130

131:                                              ; preds = %16
  %132 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  call void @"drop$242"({ { ptr, i32, i32, i32 } } %132)
  %133 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %134 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %133, 0
  %135 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %134, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %135, ptr %12, align 8
  %136 = load { i64, [24 x i8] }, ptr %12, align 8
  %137 = extractvalue { ptr, ptr, i64 } %10, 1
  %138 = load i64, ptr %137, align 8
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %138, 1
  %141 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %140, ptr %141, align 8
  br i1 %139, label %142, label %81

142:                                              ; preds = %131
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, i64 %18, 1
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, i64 %19, 2
  %146 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %145, ptr %20, 3
  %147 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %146, { i64, [24 x i8] } %136, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %147

148:                                              ; preds = %57
  call void @puts(ptr @assert_msg_78)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f32(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f32"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f32(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f32(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f33"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %59, %6
  %17 = phi i64 [ %51, %59 ], [ %0, %6 ]
  %18 = phi i64 [ %64, %59 ], [ %1, %6 ]
  %19 = phi i64 [ %53, %59 ], [ %2, %6 ]
  %20 = phi ptr [ %54, %59 ], [ %3, %6 ]
  %21 = phi { { ptr, i32, i32, i32 } } [ %66, %59 ], [ %4, %6 ]
  %22 = phi {} [ %65, %59 ], [ %5, %6 ]
  %23 = add i64 %17, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = getelementptr inbounds i64, ptr %25, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %25, align 8
  %29 = mul i64 %28, 29790
  %30 = add i64 %27, %29
  %31 = icmp uge i64 %18, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %30)
  br i1 %31, label %33, label %131

33:                                               ; preds = %16
  %34 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  %35 = extractvalue { { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %104

40:                                               ; preds = %33
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %23, i64 %32, i64 %19, ptr %20, {} %22, i252 %49, { i1, [0 x i8] } { i1 false, [0 x i8] undef })
  %51 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 0
  %52 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 1
  %53 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 2
  %54 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 3
  %55 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 4
  store { i64, [24 x i8] } %55, ptr %14, align 8
  %56 = load i1, ptr %14, align 1
  switch i1 %56, label %57 [
    i1 false, label %59
    i1 true, label %71
  ]

57:                                               ; preds = %40
  br i1 false, label %58, label %148

58:                                               ; preds = %57
  unreachable

59:                                               ; preds = %40
  %60 = load { i1, { {}, {} } }, ptr %14, align 1
  %61 = extractvalue { i1, { {}, {} } } %60, 1
  %62 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %63 = call ptr %62()
  %64 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 0)
  %65 = extractvalue { {}, {} } %61, 0
  %66 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %47, 0
  %67 = extractvalue { ptr, ptr, i64 } %10, 1
  %68 = load i64, ptr %67, align 8
  %69 = add i64 %68, 1
  %70 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %69, ptr %70, align 8
  br label %16

71:                                               ; preds = %40
  %72 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %73 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %72, 1
  call void @"drop$241"({ ptr, i32, i32, i32 } %47)
  %74 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %73, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %74, ptr %15, align 8
  %75 = load { i64, [24 x i8] }, ptr %15, align 8
  %76 = extractvalue { ptr, ptr, i64 } %10, 1
  %77 = load i64, ptr %76, align 8
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %77, 1
  %80 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %79, ptr %80, align 8
  br i1 %78, label %98, label %81

81:                                               ; preds = %81, %71, %104, %131
  %82 = phi i64 [ %23, %131 ], [ %23, %104 ], [ %82, %81 ], [ %51, %71 ]
  %83 = phi i64 [ %18, %131 ], [ %113, %104 ], [ %83, %81 ], [ %52, %71 ]
  %84 = phi i64 [ %19, %131 ], [ %19, %104 ], [ %84, %81 ], [ %53, %71 ]
  %85 = phi ptr [ %20, %131 ], [ %20, %104 ], [ %85, %81 ], [ %54, %71 ]
  %86 = phi { i64, [24 x i8] } [ %136, %131 ], [ %119, %104 ], [ %86, %81 ], [ %75, %71 ]
  %87 = extractvalue { ptr, ptr, i64 } %10, 1
  %88 = load i64, ptr %87, align 8
  %89 = icmp eq i64 %88, 0
  %90 = sub i64 %88, 1
  %91 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %90, ptr %91, align 8
  br i1 %89, label %92, label %81

92:                                               ; preds = %81
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %83, 1
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %84, 2
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, ptr %85, 3
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %86, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %97

98:                                               ; preds = %71
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %51, 0
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %52, 1
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %53, 2
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, ptr %54, 3
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, { i64, [24 x i8] } %75, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %103

104:                                              ; preds = %33
  %105 = phi i64 [ %32, %33 ]
  %106 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %107 = call ptr %106()
  %108 = getelementptr inbounds i64, ptr %107, i32 1
  %109 = load i64, ptr %108, align 8
  %110 = load i64, ptr %107, align 8
  %111 = mul i64 %110, 29990
  %112 = add i64 %109, %111
  %113 = call i64 @llvm.uadd.sat.i64(i64 %105, i64 %112)
  %114 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %35, 0
  %115 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } undef, { { ptr, i32, i32, i32 } } %114, 0
  %116 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %115, {} %22, 1
  %117 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %116, {} undef, 2
  %118 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, {}, {} } undef }, { { { ptr, i32, i32, i32 } }, {}, {} } %117, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %118, ptr %13, align 8
  %119 = load { i64, [24 x i8] }, ptr %13, align 8
  %120 = extractvalue { ptr, ptr, i64 } %10, 1
  %121 = load i64, ptr %120, align 8
  %122 = icmp eq i64 %121, 0
  %123 = sub i64 %121, 1
  %124 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %123, ptr %124, align 8
  br i1 %122, label %125, label %81

125:                                              ; preds = %104
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, i64 %113, 1
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %19, 2
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, ptr %20, 3
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, { i64, [24 x i8] } %119, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %130

131:                                              ; preds = %16
  %132 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  call void @"drop$242"({ { ptr, i32, i32, i32 } } %132)
  %133 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %134 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %133, 0
  %135 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %134, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %135, ptr %12, align 8
  %136 = load { i64, [24 x i8] }, ptr %12, align 8
  %137 = extractvalue { ptr, ptr, i64 } %10, 1
  %138 = load i64, ptr %137, align 8
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %138, 1
  %141 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %140, ptr %141, align 8
  br i1 %139, label %142, label %81

142:                                              ; preds = %131
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, i64 %18, 1
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, i64 %19, 2
  %146 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %145, ptr %20, 3
  %147 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %146, { i64, [24 x i8] } %136, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %147

148:                                              ; preds = %57
  call void @puts(ptr @assert_msg_79)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f33(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f33"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f33(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f33(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 0
  call void @"drop$242"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } @"dup$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$242"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %6, { {} } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %7, { {} } %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %9, {} %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %10, {} %11, 2
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } undef, { { { ptr, i32, i32, i32 } }, { {} }, {} } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %14, { { { ptr, i32, i32, i32 } }, { {} }, {} } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %15
}

define private void @"drop$244"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, 1
  call void @"drop$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$244"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } @"dup$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, { { { ptr, i32, i32, i32 } }, { {} }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, { { { ptr, i32, i32, i32 } }, { {} }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, i252 %6, { ptr, i32, i32, i32 } %7) {
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i1, [31 x i8] }, i64 1, align 8
  %14 = alloca i64, i64 1, align 8
  %15 = alloca i252, i64 1, align 16
  %16 = alloca i252, i64 1, align 16
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f30"(i64 %0, i64 %1, i64 %2, ptr %3, {} undef, i252 %5, { i1, [0 x i8] } { i1 true, [0 x i8] undef })
  %24 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 0
  %25 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 1
  %26 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 2
  %27 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 3
  %28 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 4
  store { i64, [24 x i8] } %28, ptr %9, align 8
  %29 = load i1, ptr %9, align 1
  switch i1 %29, label %30 [
    i1 false, label %32
    i1 true, label %41
  ]

30:                                               ; preds = %8
  br i1 false, label %31, label %133

31:                                               ; preds = %30
  unreachable

32:                                               ; preds = %8
  %33 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %7, 0
  %34 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f62"(i64 %24, i64 %25, i64 %26, ptr %27, { { ptr, i32, i32, i32 } } %33, { {} } %4)
  %35 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 0
  %36 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 1
  %37 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 2
  %38 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 3
  %39 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 4
  store { i64, [24 x i8] } %39, ptr %11, align 8
  %40 = load i1, ptr %11, align 1
  switch i1 %40, label %51 [
    i1 false, label %53
    i1 true, label %64
  ]

41:                                               ; preds = %8
  %42 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %43 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %42, 1
  call void @"drop$241"({ ptr, i32, i32, i32 } %7)
  %44 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %43, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %44, ptr %10, align 8
  %45 = load { i64, [24 x i8] }, ptr %10, align 8
  %46 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %24, 0
  %47 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %46, i64 %25, 1
  %48 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %47, i64 %26, 2
  %49 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %48, ptr %27, 3
  %50 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %49, { i64, [24 x i8] } %45, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %50

51:                                               ; preds = %32
  br i1 false, label %52, label %134

52:                                               ; preds = %51
  unreachable

53:                                               ; preds = %32
  %54 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } }, ptr %11, align 8
  %55 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %54, 1
  %56 = load ptr, ptr %38, align 8
  store i64 %36, ptr %14, align 8
  store i252 814182874304483309791743286124228493744277863724345952005546811777229850325, ptr %15, align 16
  store i252 %6, ptr %16, align 16
  %57 = getelementptr inbounds ptr, ptr %38, i32 9
  %58 = load ptr, ptr %57, align 8
  call void %58(ptr %13, ptr %56, ptr %14, i32 0, ptr %15, ptr %16)
  %59 = load { i1, [31 x i8] }, ptr %13, align 1
  %60 = extractvalue { i1, [31 x i8] } %59, 0
  %61 = getelementptr inbounds i8, ptr %13, i32 8
  %62 = load { ptr, i32, i32, i32 }, ptr %61, align 8
  %63 = load i64, ptr %14, align 8
  br i1 %60, label %123, label %74

64:                                               ; preds = %32
  %65 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %66 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %65, 1
  %67 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %66, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %67, ptr %12, align 8
  %68 = load { i64, [24 x i8] }, ptr %12, align 8
  %69 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %35, 0
  %70 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %69, i64 %36, 1
  %71 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %37, 2
  %72 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %71, ptr %38, 3
  %73 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %72, { i64, [24 x i8] } %68, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %73

74:                                               ; preds = %53
  %75 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f63"(i64 %35, i64 %63, ptr %38, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 563027124402777014625093953982261603, i32 15 }, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 1367508244613640598782226851263609, i32 14 })
  %76 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 0
  %77 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 1
  %78 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 2
  %79 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 3
  store { i64, [24 x i8] } %79, ptr %18, align 8
  %80 = load i1, ptr %18, align 1
  switch i1 %80, label %81 [
    i1 false, label %83
    i1 true, label %90
  ]

81:                                               ; preds = %74
  br i1 false, label %82, label %135

82:                                               ; preds = %81
  unreachable

83:                                               ; preds = %74
  %84 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f64"(i64 %76, i64 %77, ptr %78, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 563027124402777014625093953982261603, i32 15 }, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 22942981201663884872471587768649531551604, i32 17 })
  %85 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 0
  %86 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 1
  %87 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 2
  %88 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 3
  store { i64, [24 x i8] } %88, ptr %20, align 8
  %89 = load i1, ptr %20, align 1
  switch i1 %89, label %100 [
    i1 false, label %102
    i1 true, label %113
  ]

90:                                               ; preds = %74
  %91 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %92 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %91, 1
  call void @"drop$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %55)
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %19, align 8
  %94 = load { i64, [24 x i8] }, ptr %19, align 8
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %76, 0
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %77, 1
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %37, 2
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, ptr %78, 3
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %94, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %83
  br i1 false, label %101, label %136

101:                                              ; preds = %100
  unreachable

102:                                              ; preds = %83
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %86, i64 0)
  %106 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %55, 0
  call void @"drop$242"({ { ptr, i32, i32, i32 } } %106)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %22, align 1
  %107 = load { i64, [24 x i8] }, ptr %22, align 8
  %108 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %85, 0
  %109 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %108, i64 %105, 1
  %110 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, i64 %37, 2
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %110, ptr %87, 3
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %107, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %112

113:                                              ; preds = %83
  %114 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %20, align 8
  %115 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %114, 1
  call void @"drop$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %55)
  %116 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %115, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %116, ptr %21, align 8
  %117 = load { i64, [24 x i8] }, ptr %21, align 8
  %118 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %85, 0
  %119 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %118, i64 %86, 1
  %120 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %119, i64 %37, 2
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %120, ptr %87, 3
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, { i64, [24 x i8] } %117, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %122

123:                                              ; preds = %53
  %124 = phi { { { ptr, i32, i32, i32 } }, { {} }, {} } [ %55, %53 ]
  call void @"drop$243"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %124)
  %125 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 1
  %126 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %125, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %126, ptr %17, align 8
  %127 = load { i64, [24 x i8] }, ptr %17, align 8
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %35, 0
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %63, 1
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %37, 2
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, ptr %38, 3
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, { i64, [24 x i8] } %127, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %132

133:                                              ; preds = %30
  call void @puts(ptr @assert_msg_80)
  call void @abort()
  unreachable

134:                                              ; preds = %51
  call void @puts(ptr @assert_msg_81)
  call void @abort()
  unreachable

135:                                              ; preds = %81
  call void @puts(ptr @assert_msg_82)
  call void @abort()
  unreachable

136:                                              ; preds = %100
  call void @puts(ptr @assert_msg_83)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f34(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, i252 %6, { ptr, i32, i32, i32 } %7) {
  %9 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, i252 %6, { ptr, i32, i32, i32 } %7)
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 4
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %10, 0
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %11, 1
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %12, 2
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %13, 3
  %19 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %14, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f34(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, i252 %7, { ptr, i32, i32, i32 } %8) {
  %10 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f34(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, i252 %7, { ptr, i32, i32, i32 } %8)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %10, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 %0) {
  %2 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %2, align 4
  %3 = getelementptr inbounds i8, ptr %2, i32 4
  store i32 0, ptr %3, align 4
  %4 = getelementptr inbounds i8, ptr %2, i32 16
  %5 = call ptr @realloc(ptr null, i64 8)
  store ptr %4, ptr %5, align 8
  %6 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %5, 0
  %7 = insertvalue { ptr, i32, i32, i32 } %6, i32 8, 3
  %8 = load ptr, ptr %5, align 8
  store i252 %0, ptr %8, align 16
  %9 = insertvalue { ptr, i32, i32, i32 } %7, i32 1, 2
  %10 = getelementptr inbounds i8, ptr %8, i32 -12
  store i32 1, ptr %10, align 4
  %11 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %9, 1
  %12 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %11, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %12
}

define private { {}, { ptr, i32, i32, i32 } } @f35(i252 %0) {
  %2 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 %0)
  %3 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %2, 0
  ret { {}, { ptr, i32, i32, i32 } } %3
}

define void @_mlir_ciface_f35(ptr %0, i252 %1) {
  %3 = call { {}, { ptr, i32, i32, i32 } } @f35(i252 %1)
  store { {}, { ptr, i32, i32, i32 } } %3, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f36"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 117999861104695822858408463129383551244204096177556094315754355)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f36() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f36"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f36(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f36()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f37"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [24 x i8] }, i64 1, align 4
  %4 = alloca { i32, [24 x i8] }, i64 1, align 4
  %5 = alloca { i32, [20 x i8] }, i64 1, align 4
  %6 = alloca { i32, [24 x i8] }, i64 1, align 4
  %7 = alloca { i32, [20 x i8] }, i64 1, align 4
  %8 = alloca { i32, [24 x i8] }, i64 1, align 4
  %9 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %10 = extractvalue { ptr, i32, i32, i32 } %9, 1
  %11 = extractvalue { ptr, i32, i32, i32 } %9, 2
  %12 = sub i32 %11, %10
  %13 = icmp uge i32 %12, 1
  br i1 %13, label %14, label %194

14:                                               ; preds = %2
  %15 = extractvalue { ptr, i32, i32, i32 } %9, 0
  %16 = load ptr, ptr %15, align 8
  %17 = zext i32 %10 to i64
  %18 = mul i64 %17, 32
  %19 = getelementptr inbounds i8, ptr %16, i64 %18
  %20 = add i32 %10, 1
  %21 = insertvalue { ptr, i32, i32, i32 } %9, i32 %20, 1
  %22 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %22, ptr %19, i64 32, i1 false)
  %23 = load i252, ptr %22, align 16
  call void @free(ptr %22)
  %24 = icmp eq i252 %23, 0
  br i1 %24, label %25, label %145

25:                                               ; preds = %14
  %26 = phi { ptr, i32, i32, i32 } [ %21, %14 ]
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %194

31:                                               ; preds = %25
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %41 = icmp ult i252 %40, 4294967296
  %42 = add i64 %0, 2
  %43 = add i64 %0, 3
  %44 = select i1 %41, i64 %42, i64 %43
  %45 = trunc i252 %40 to i32
  br i1 %41, label %46, label %194

46:                                               ; preds = %31
  %47 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %52, label %194

52:                                               ; preds = %46
  %53 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %54 = load ptr, ptr %53, align 8
  %55 = zext i32 %48 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %54, i64 %56
  %58 = add i32 %48, 1
  %59 = insertvalue { ptr, i32, i32, i32 } %47, i32 %58, 1
  %60 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %60, ptr %57, i64 32, i1 false)
  %61 = load i252, ptr %60, align 16
  call void @free(ptr %60)
  %62 = icmp ult i252 %61, 4294967296
  %63 = add i64 %44, 2
  %64 = add i64 %44, 3
  %65 = select i1 %62, i64 %63, i64 %64
  %66 = trunc i252 %61 to i32
  br i1 %62, label %67, label %194

67:                                               ; preds = %52
  %68 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  %69 = extractvalue { ptr, i32, i32, i32 } %68, 1
  %70 = extractvalue { ptr, i32, i32, i32 } %68, 2
  %71 = sub i32 %70, %69
  %72 = icmp uge i32 %71, 1
  br i1 %72, label %73, label %194

73:                                               ; preds = %67
  %74 = extractvalue { ptr, i32, i32, i32 } %68, 0
  %75 = load ptr, ptr %74, align 8
  %76 = zext i32 %69 to i64
  %77 = mul i64 %76, 32
  %78 = getelementptr inbounds i8, ptr %75, i64 %77
  %79 = add i32 %69, 1
  %80 = insertvalue { ptr, i32, i32, i32 } %68, i32 %79, 1
  %81 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %81, ptr %78, i64 32, i1 false)
  %82 = load i252, ptr %81, align 16
  call void @free(ptr %81)
  %83 = icmp ult i252 %82, 4294967296
  %84 = add i64 %65, 2
  %85 = add i64 %65, 3
  %86 = select i1 %83, i64 %84, i64 %85
  %87 = trunc i252 %82 to i32
  br i1 %83, label %88, label %194

88:                                               ; preds = %73
  %89 = phi { ptr, i32, i32, i32 } [ %80, %73 ]
  %90 = extractvalue { ptr, i32, i32, i32 } %89, 1
  %91 = extractvalue { ptr, i32, i32, i32 } %89, 2
  %92 = sub i32 %91, %90
  %93 = icmp uge i32 %92, 1
  br i1 %93, label %94, label %194

94:                                               ; preds = %88
  %95 = extractvalue { ptr, i32, i32, i32 } %89, 0
  %96 = load ptr, ptr %95, align 8
  %97 = zext i32 %90 to i64
  %98 = mul i64 %97, 32
  %99 = getelementptr inbounds i8, ptr %96, i64 %98
  %100 = add i32 %90, 1
  %101 = insertvalue { ptr, i32, i32, i32 } %89, i32 %100, 1
  %102 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %102, ptr %99, i64 32, i1 false)
  %103 = load i252, ptr %102, align 16
  call void @free(ptr %102)
  %104 = icmp ult i252 %103, 4294967296
  %105 = add i64 %86, 2
  %106 = add i64 %86, 3
  %107 = select i1 %104, i64 %105, i64 %106
  %108 = trunc i252 %103 to i32
  br i1 %104, label %109, label %194

109:                                              ; preds = %94
  %110 = phi { ptr, i32, i32, i32 } [ %101, %94 ]
  %111 = extractvalue { ptr, i32, i32, i32 } %110, 1
  %112 = extractvalue { ptr, i32, i32, i32 } %110, 2
  %113 = sub i32 %112, %111
  %114 = icmp uge i32 %113, 1
  br i1 %114, label %115, label %194

115:                                              ; preds = %109
  %116 = extractvalue { ptr, i32, i32, i32 } %110, 0
  %117 = load ptr, ptr %116, align 8
  %118 = zext i32 %111 to i64
  %119 = mul i64 %118, 32
  %120 = getelementptr inbounds i8, ptr %117, i64 %119
  %121 = add i32 %111, 1
  %122 = insertvalue { ptr, i32, i32, i32 } %110, i32 %121, 1
  %123 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %123, ptr %120, i64 32, i1 false)
  %124 = load i252, ptr %123, align 16
  call void @free(ptr %123)
  %125 = icmp ult i252 %124, 4294967296
  %126 = add i64 %107, 2
  %127 = add i64 %107, 3
  %128 = select i1 %125, i64 %126, i64 %127
  %129 = trunc i252 %124 to i32
  br i1 %125, label %130, label %194

130:                                              ; preds = %115
  %131 = phi { ptr, i32, i32, i32 } [ %122, %115 ]
  %132 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %131, 0
  %133 = insertvalue { i32, i32, i32, i32, i32 } undef, i32 %45, 0
  %134 = insertvalue { i32, i32, i32, i32, i32 } %133, i32 %66, 1
  %135 = insertvalue { i32, i32, i32, i32, i32 } %134, i32 %87, 2
  %136 = insertvalue { i32, i32, i32, i32, i32 } %135, i32 %108, 3
  %137 = insertvalue { i32, i32, i32, i32, i32 } %136, i32 %129, 4
  %138 = insertvalue { i1, { i32, i32, i32, i32, i32 } } { i1 false, { i32, i32, i32, i32, i32 } undef }, { i32, i32, i32, i32, i32 } %137, 1
  store { i1, { i32, i32, i32, i32, i32 } } %138, ptr %7, align 4
  %139 = load { i32, [20 x i8] }, ptr %7, align 4
  %140 = insertvalue { i1, { i32, [20 x i8] } } { i1 false, { i32, [20 x i8] } undef }, { i32, [20 x i8] } %139, 1
  store { i1, { i32, [20 x i8] } } %140, ptr %8, align 4
  %141 = load { i32, [24 x i8] }, ptr %8, align 4
  %142 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %128, 0
  %143 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %142, { { ptr, i32, i32, i32 } } %132, 1
  %144 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %143, { i32, [24 x i8] } %141, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %144

145:                                              ; preds = %14
  %146 = phi i252 [ %23, %14 ]
  %147 = phi i252 [ 1, %14 ]
  %148 = zext i252 %146 to i256
  %149 = zext i252 %147 to i256
  %150 = sub i256 %148, %149
  %151 = add i256 %150, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %152 = icmp ult i256 %148, %149
  %153 = select i1 %152, i256 %151, i256 %150
  %154 = trunc i256 %153 to i252
  %155 = icmp eq i252 %154, 0
  br i1 %155, label %156, label %187

156:                                              ; preds = %145
  %157 = phi { ptr, i32, i32, i32 } [ %21, %145 ]
  %158 = extractvalue { ptr, i32, i32, i32 } %157, 1
  %159 = extractvalue { ptr, i32, i32, i32 } %157, 2
  %160 = sub i32 %159, %158
  %161 = icmp uge i32 %160, 1
  br i1 %161, label %162, label %194

162:                                              ; preds = %156
  %163 = extractvalue { ptr, i32, i32, i32 } %157, 0
  %164 = load ptr, ptr %163, align 8
  %165 = zext i32 %158 to i64
  %166 = mul i64 %165, 32
  %167 = getelementptr inbounds i8, ptr %164, i64 %166
  %168 = add i32 %158, 1
  %169 = insertvalue { ptr, i32, i32, i32 } %157, i32 %168, 1
  %170 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %170, ptr %167, i64 32, i1 false)
  %171 = load i252, ptr %170, align 16
  call void @free(ptr %170)
  %172 = icmp ult i252 %171, 4294967296
  %173 = add i64 %0, 2
  %174 = add i64 %0, 3
  %175 = select i1 %172, i64 %173, i64 %174
  %176 = trunc i252 %171 to i32
  br i1 %172, label %177, label %194

177:                                              ; preds = %162
  %178 = phi { ptr, i32, i32, i32 } [ %169, %162 ]
  %179 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %178, 0
  %180 = insertvalue { i1, i32 } { i1 true, i32 undef }, i32 %176, 1
  store { i1, i32 } %180, ptr %5, align 4
  %181 = load { i32, [20 x i8] }, ptr %5, align 4
  %182 = insertvalue { i1, { i32, [20 x i8] } } { i1 false, { i32, [20 x i8] } undef }, { i32, [20 x i8] } %181, 1
  store { i1, { i32, [20 x i8] } } %182, ptr %6, align 4
  %183 = load { i32, [24 x i8] }, ptr %6, align 4
  %184 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %175, 0
  %185 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %184, { { ptr, i32, i32, i32 } } %179, 1
  %186 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %185, { i32, [24 x i8] } %183, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %186

187:                                              ; preds = %145
  %188 = phi { ptr, i32, i32, i32 } [ %21, %145 ]
  %189 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %188, 0
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %190 = load { i32, [24 x i8] }, ptr %4, align 4
  %191 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %0, 0
  %192 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %191, { { ptr, i32, i32, i32 } } %189, 1
  %193 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %192, { i32, [24 x i8] } %190, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %193

194:                                              ; preds = %115, %109, %94, %88, %73, %67, %52, %46, %31, %25, %162, %156, %2
  %195 = phi i64 [ %175, %162 ], [ %0, %156 ], [ %128, %115 ], [ %107, %109 ], [ %107, %94 ], [ %86, %88 ], [ %86, %73 ], [ %65, %67 ], [ %65, %52 ], [ %44, %46 ], [ %44, %31 ], [ %0, %25 ], [ %0, %2 ]
  %196 = phi { ptr, i32, i32, i32 } [ %169, %162 ], [ %157, %156 ], [ %122, %115 ], [ %110, %109 ], [ %101, %94 ], [ %89, %88 ], [ %80, %73 ], [ %68, %67 ], [ %59, %52 ], [ %47, %46 ], [ %38, %31 ], [ %26, %25 ], [ %9, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %197 = load { i32, [24 x i8] }, ptr %3, align 4
  %198 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %196, 0
  %199 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %195, 0
  %200 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %199, { { ptr, i32, i32, i32 } } %198, 1
  %201 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %200, { i32, [24 x i8] } %197, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %201
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @f37(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f37"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %8, { i32, [24 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %9
}

define void @_mlir_ciface_f37(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @f37(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$232"({ { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %0, 0
  call void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %2)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } @"dup$232"({ { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } @"dup$231"({ { { { ptr, i32, i32, i32 } } }, {} } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %0, { { { { ptr, i32, i32, i32 } } }, {} } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, {} } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %0, 1
  %9 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %6, { i128, [32 x i8] } %8, 1
  %10 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %7, { i128, [32 x i8] } %8, 1
  %11 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } undef, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %9, 0
  %12 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %11, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %10, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %12
}

define private void @"drop$233"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %5, 1
  call void @"drop$232"({ { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$233"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } @"dup$232"({ { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %5, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [80 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %5, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [80 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %11, 0
  %15 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %14, { i128, [80 x i8] } %13, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [80 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [80 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %23, 0
  %27 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %26, { i128, [80 x i8] } %25, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, { i64, [48 x i8] } } @"impl$f38"(i64 %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3, { ptr, i32, i32, i32 } %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [48 x i8] }, i64 1, align 8
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i64, [48 x i8] }, i64 1, align 8
  %14 = alloca { i128, [32 x i8] }, i64 1, align 16
  %15 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %102, %5
  %17 = phi i64 [ %32, %102 ], [ %0, %5 ]
  %18 = phi i64 [ %62, %102 ], [ %1, %5 ]
  %19 = phi i64 [ %34, %102 ], [ %2, %5 ]
  %20 = phi { { { { ptr, i32, i32, i32 } } }, {} } [ %42, %102 ], [ %3, %5 ]
  %21 = phi { ptr, i32, i32, i32 } [ %111, %102 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 10340
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %158

29:                                               ; preds = %16
  %30 = phi i64 [ %22, %16 ]
  %31 = call fastcc { i64, i64, i64, { i128, [80 x i8] } } @"impl$f65"(i64 %30, i64 %28, i64 %19, { { { { ptr, i32, i32, i32 } } }, {} } %20)
  %32 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %31, 0
  %33 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %31, 1
  %34 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %31, 2
  %35 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %31, 3
  store { i128, [80 x i8] } %35, ptr %12, align 16
  %36 = load i1, ptr %12, align 1
  switch i1 %36, label %37 [
    i1 false, label %39
    i1 true, label %45
  ]

37:                                               ; preds = %29
  br i1 false, label %38, label %174

38:                                               ; preds = %37
  unreachable

39:                                               ; preds = %29
  %40 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } }, ptr %12, align 16
  %41 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %40, 1
  %42 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %41, 0
  %43 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %41, 1
  store { i128, [32 x i8] } %43, ptr %14, align 16
  %44 = load i1, ptr %14, align 1
  switch i1 %44, label %55 [
    i1 false, label %57
    i1 true, label %117
  ]

45:                                               ; preds = %29
  %46 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %47 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %46, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %21)
  %48 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %47, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %48, ptr %13, align 8
  %49 = load { i64, [48 x i8] }, ptr %13, align 8
  %50 = extractvalue { ptr, ptr, i64 } %9, 1
  %51 = load i64, ptr %50, align 8
  %52 = icmp eq i64 %51, 0
  %53 = sub i64 %51, 1
  %54 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %53, ptr %54, align 8
  br i1 %52, label %153, label %133

55:                                               ; preds = %39
  br i1 false, label %56, label %175

56:                                               ; preds = %55
  unreachable

57:                                               ; preds = %39
  %58 = load { i1, i252 }, ptr %14, align 16
  %59 = extractvalue { i1, i252 } %58, 1
  %60 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %61 = call ptr %60()
  %62 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 0)
  %63 = extractvalue { ptr, i32, i32, i32 } %21, 3
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %65, label %79

65:                                               ; preds = %57
  %66 = shl i32 %63, 1
  %67 = call i32 @llvm.umin.i32(i32 %66, i32 1024)
  %68 = add i32 %67, %63
  %69 = call i32 @llvm.umax.i32(i32 %68, i32 8)
  %70 = zext i32 %69 to i64
  %71 = mul i64 %70, 32
  %72 = add i64 %71, 16
  %73 = call ptr @realloc(ptr null, i64 %72)
  store i32 1, ptr %73, align 4
  %74 = getelementptr inbounds i8, ptr %73, i32 4
  store i32 0, ptr %74, align 4
  %75 = getelementptr inbounds i8, ptr %73, i32 16
  %76 = call ptr @realloc(ptr null, i64 8)
  store ptr %75, ptr %76, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } %21, ptr %76, 0
  %78 = insertvalue { ptr, i32, i32, i32 } %77, i32 %69, 3
  br label %100

79:                                               ; preds = %57
  %80 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %81 = icmp ult i32 %80, %63
  br i1 %81, label %82, label %83

82:                                               ; preds = %79
  br label %97

83:                                               ; preds = %79
  %84 = shl i32 %63, 1
  %85 = call i32 @llvm.umin.i32(i32 %84, i32 1024)
  %86 = add i32 %85, %63
  %87 = call i32 @llvm.umax.i32(i32 %86, i32 8)
  %88 = zext i32 %87 to i64
  %89 = mul i64 %88, 32
  %90 = add i64 %89, 16
  %91 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %92 = load ptr, ptr %91, align 8
  %93 = getelementptr inbounds i8, ptr %92, i32 -16
  %94 = call ptr @realloc(ptr %93, i64 %90)
  %95 = getelementptr inbounds i8, ptr %94, i32 16
  store ptr %95, ptr %91, align 8
  %96 = insertvalue { ptr, i32, i32, i32 } %21, i32 %87, 3
  br label %97

97:                                               ; preds = %82, %83
  %98 = phi { ptr, i32, i32, i32 } [ %96, %83 ], [ %21, %82 ]
  br label %99

99:                                               ; preds = %97
  br label %100

100:                                              ; preds = %65, %99
  %101 = phi { ptr, i32, i32, i32 } [ %98, %99 ], [ %78, %65 ]
  br label %102

102:                                              ; preds = %100
  %103 = extractvalue { ptr, i32, i32, i32 } %101, 0
  %104 = load ptr, ptr %103, align 8
  %105 = extractvalue { ptr, i32, i32, i32 } %101, 2
  %106 = zext i32 %105 to i64
  %107 = mul i64 %106, 32
  %108 = getelementptr inbounds i8, ptr %104, i64 %107
  store i252 %59, ptr %108, align 16
  %109 = extractvalue { ptr, i32, i32, i32 } %101, 2
  %110 = add i32 %109, 1
  %111 = insertvalue { ptr, i32, i32, i32 } %101, i32 %110, 2
  %112 = getelementptr inbounds i8, ptr %104, i32 -12
  store i32 %110, ptr %112, align 4
  %113 = extractvalue { ptr, ptr, i64 } %9, 1
  %114 = load i64, ptr %113, align 8
  %115 = add i64 %114, 1
  %116 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %115, ptr %116, align 8
  br label %16

117:                                              ; preds = %39
  %118 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %119 = call ptr %118()
  %120 = load i64, ptr %119, align 8
  %121 = mul i64 %120, 2370
  %122 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %121)
  %123 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } undef, { { { { ptr, i32, i32, i32 } } }, {} } %42, 0
  %124 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %123, { ptr, i32, i32, i32 } %21, 1
  %125 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %124, {} undef, 2
  %126 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } undef }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %125, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %126, ptr %15, align 8
  %127 = load { i64, [48 x i8] }, ptr %15, align 8
  %128 = extractvalue { ptr, ptr, i64 } %9, 1
  %129 = load i64, ptr %128, align 8
  %130 = icmp eq i64 %129, 0
  %131 = sub i64 %129, 1
  %132 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %131, ptr %132, align 8
  br i1 %130, label %148, label %133

133:                                              ; preds = %133, %117, %45, %158
  %134 = phi i64 [ %22, %158 ], [ %134, %133 ], [ %32, %117 ], [ %32, %45 ]
  %135 = phi i64 [ %18, %158 ], [ %135, %133 ], [ %122, %117 ], [ %33, %45 ]
  %136 = phi i64 [ %19, %158 ], [ %136, %133 ], [ %34, %117 ], [ %34, %45 ]
  %137 = phi { i64, [48 x i8] } [ %163, %158 ], [ %137, %133 ], [ %127, %117 ], [ %49, %45 ]
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %143, label %133

143:                                              ; preds = %133
  %144 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } undef, i64 %134, 0
  %145 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %144, i64 %135, 1
  %146 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %145, i64 %136, 2
  %147 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %146, { i64, [48 x i8] } %137, 3
  ret { i64, i64, i64, { i64, [48 x i8] } } %147

148:                                              ; preds = %117
  %149 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } undef, i64 %32, 0
  %150 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %149, i64 %122, 1
  %151 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %150, i64 %34, 2
  %152 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %151, { i64, [48 x i8] } %127, 3
  ret { i64, i64, i64, { i64, [48 x i8] } } %152

153:                                              ; preds = %45
  %154 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } undef, i64 %32, 0
  %155 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %154, i64 %33, 1
  %156 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %155, i64 %34, 2
  %157 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %156, { i64, [48 x i8] } %49, 3
  ret { i64, i64, i64, { i64, [48 x i8] } } %157

158:                                              ; preds = %16
  %159 = phi { ptr, i32, i32, i32 } [ %21, %16 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %159)
  call void @"drop$231"({ { { { ptr, i32, i32, i32 } } }, {} } %20)
  %160 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %161 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %160, 0
  %162 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %161, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %162, ptr %11, align 8
  %163 = load { i64, [48 x i8] }, ptr %11, align 8
  %164 = extractvalue { ptr, ptr, i64 } %9, 1
  %165 = load i64, ptr %164, align 8
  %166 = icmp eq i64 %165, 0
  %167 = sub i64 %165, 1
  %168 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %167, ptr %168, align 8
  br i1 %166, label %169, label %133

169:                                              ; preds = %158
  %170 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } undef, i64 %22, 0
  %171 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %170, i64 %18, 1
  %172 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %171, i64 %19, 2
  %173 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %172, { i64, [48 x i8] } %163, 3
  ret { i64, i64, i64, { i64, [48 x i8] } } %173

174:                                              ; preds = %37
  call void @puts(ptr @assert_msg_84)
  call void @abort()
  unreachable

175:                                              ; preds = %55
  call void @puts(ptr @assert_msg_85)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, { i64, [48 x i8] } } @f38(i64 %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call fastcc { i64, i64, i64, { i64, [48 x i8] } } @"impl$f38"(i64 %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3, { ptr, i32, i32, i32 } %4)
  %7 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, { i64, [48 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %12, i64 %9, 2
  %14 = insertvalue { i64, i64, i64, { i64, [48 x i8] } } %13, { i64, [48 x i8] } %10, 3
  ret { i64, i64, i64, { i64, [48 x i8] } } %14
}

define void @_mlir_ciface_f38(ptr %0, i64 %1, i64 %2, i64 %3, { { { { ptr, i32, i32, i32 } } }, {} } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call { i64, i64, i64, { i64, [48 x i8] } } @f38(i64 %1, i64 %2, i64 %3, { { { { ptr, i32, i32, i32 } } }, {} } %4, { ptr, i32, i32, i32 } %5)
  store { i64, i64, i64, { i64, [48 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$225"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %0, 0
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } @"dup$225"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } @"dup$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %0, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %0, 1
  %9 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %6, { i32, [16 x i8] } %8, 1
  %10 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %7, { i32, [16 x i8] } %8, 1
  %11 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } undef, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %9, 0
  %12 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %11, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %10, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %12
}

define private void @"drop$226"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %5, 1
  call void @"drop$225"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$226"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } @"dup$225"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f39"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, { i32, i32, i32, i32 } %6, {} %7) {
  %9 = alloca i64, i64 1, align 8
  %10 = insertvalue { ptr, ptr, i64 } undef, ptr %9, 0
  %11 = insertvalue { ptr, ptr, i64 } %10, ptr %9, 1
  %12 = insertvalue { ptr, ptr, i64 } %11, i64 0, 2
  %13 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 0, ptr %13, align 8
  %14 = alloca { i64, [40 x i8] }, i64 1, align 8
  %15 = alloca { i64, [48 x i8] }, i64 1, align 8
  %16 = alloca { i64, [40 x i8] }, i64 1, align 8
  %17 = alloca { i32, [16 x i8] }, i64 1, align 4
  %18 = alloca { i64, [40 x i8] }, i64 1, align 8
  %19 = alloca { i64, [40 x i8] }, i64 1, align 8
  br label %20

20:                                               ; preds = %126, %8
  %21 = phi i64 [ %122, %126 ], [ %0, %8 ]
  %22 = phi i64 [ %130, %126 ], [ %1, %8 ]
  %23 = phi i64 [ %47, %126 ], [ %2, %8 ]
  %24 = phi i64 [ %48, %126 ], [ %3, %8 ]
  %25 = phi ptr [ %49, %126 ], [ %4, %8 ]
  %26 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %57, %126 ], [ %5, %8 ]
  %27 = phi { i32, i32, i32, i32 } [ %134, %126 ], [ %6, %8 ]
  %28 = add i64 %21, 1
  %29 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %30 = call ptr %29()
  %31 = getelementptr inbounds i64, ptr %30, i32 1
  %32 = load i64, ptr %31, align 8
  %33 = getelementptr inbounds i64, ptr %30, i32 2
  %34 = load i64, ptr %33, align 8
  %35 = mul i64 %34, 4
  %36 = add i64 %32, %35
  %37 = load i64, ptr %30, align 8
  %38 = mul i64 %37, 31250
  %39 = add i64 %36, %38
  %40 = icmp uge i64 %22, %39
  %41 = call i64 @llvm.usub.sat.i64(i64 %22, i64 %39)
  br i1 %40, label %42, label %222

42:                                               ; preds = %20
  %43 = phi i64 [ %28, %20 ]
  %44 = call fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f66"(i64 %43, i64 %41, i64 %23, i64 %24, ptr %25, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %26)
  %45 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %44, 0
  %46 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %44, 1
  %47 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %44, 2
  %48 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %44, 3
  %49 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %44, 4
  %50 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %44, 5
  store { i64, [48 x i8] } %50, ptr %15, align 8
  %51 = load i1, ptr %15, align 1
  switch i1 %51, label %52 [
    i1 false, label %54
    i1 true, label %60
  ]

52:                                               ; preds = %42
  br i1 false, label %53, label %240

53:                                               ; preds = %52
  unreachable

54:                                               ; preds = %42
  %55 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } }, ptr %15, align 8
  %56 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %55, 1
  %57 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %56, 0
  %58 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %56, 1
  store { i32, [16 x i8] } %58, ptr %17, align 4
  %59 = load i1, ptr %17, align 1
  switch i1 %59, label %70 [
    i1 false, label %72
    i1 true, label %87
  ]

60:                                               ; preds = %42
  %61 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %62 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %61, 1
  %63 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %62, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %63, ptr %16, align 8
  %64 = load { i64, [40 x i8] }, ptr %16, align 8
  %65 = extractvalue { ptr, ptr, i64 } %12, 1
  %66 = load i64, ptr %65, align 8
  %67 = icmp eq i64 %66, 0
  %68 = sub i64 %66, 1
  %69 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %68, ptr %69, align 8
  br i1 %67, label %215, label %139

70:                                               ; preds = %54
  br i1 false, label %71, label %241

71:                                               ; preds = %70
  unreachable

72:                                               ; preds = %54
  %73 = load { i1, { i32, i32, i32, i32 } }, ptr %17, align 4
  %74 = extractvalue { i1, { i32, i32, i32, i32 } } %73, 1
  %75 = extractvalue { i32, i32, i32, i32 } %27, 0
  %76 = extractvalue { i32, i32, i32, i32 } %27, 1
  %77 = extractvalue { i32, i32, i32, i32 } %27, 2
  %78 = extractvalue { i32, i32, i32, i32 } %27, 3
  %79 = extractvalue { i32, i32, i32, i32 } %74, 0
  %80 = extractvalue { i32, i32, i32, i32 } %74, 1
  %81 = extractvalue { i32, i32, i32, i32 } %74, 2
  %82 = extractvalue { i32, i32, i32, i32 } %74, 3
  %83 = add i64 %45, 1
  %84 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %75, i32 %79)
  %85 = extractvalue { i32, i1 } %84, 0
  %86 = extractvalue { i32, i1 } %84, 1
  br i1 %86, label %179, label %102

87:                                               ; preds = %54
  %88 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %89 = call ptr %88()
  %90 = load i64, ptr %89, align 8
  %91 = mul i64 %90, 5550
  %92 = call i64 @llvm.uadd.sat.i64(i64 %46, i64 %91)
  %93 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %57, 0
  %94 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %93, { i32, i32, i32, i32 } %27, 1
  %95 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } undef }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } %94, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, i32, i32, i32 } } } %95, ptr %18, align 8
  %96 = load { i64, [40 x i8] }, ptr %18, align 8
  %97 = extractvalue { ptr, ptr, i64 } %12, 1
  %98 = load i64, ptr %97, align 8
  %99 = icmp eq i64 %98, 0
  %100 = sub i64 %98, 1
  %101 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %100, ptr %101, align 8
  br i1 %99, label %208, label %139

102:                                              ; preds = %72
  %103 = phi i64 [ %83, %72 ]
  %104 = phi i32 [ %76, %72 ]
  %105 = phi i32 [ %80, %72 ]
  %106 = add i64 %103, 1
  %107 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %104, i32 %105)
  %108 = extractvalue { i32, i1 } %107, 0
  %109 = extractvalue { i32, i1 } %107, 1
  br i1 %109, label %172, label %110

110:                                              ; preds = %102
  %111 = phi i64 [ %106, %102 ]
  %112 = phi i32 [ %77, %102 ]
  %113 = phi i32 [ %81, %102 ]
  %114 = add i64 %111, 1
  %115 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %112, i32 %113)
  %116 = extractvalue { i32, i1 } %115, 0
  %117 = extractvalue { i32, i1 } %115, 1
  br i1 %117, label %165, label %118

118:                                              ; preds = %110
  %119 = phi i64 [ %114, %110 ]
  %120 = phi i32 [ %78, %110 ]
  %121 = phi i32 [ %82, %110 ]
  %122 = add i64 %119, 1
  %123 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %120, i32 %121)
  %124 = extractvalue { i32, i1 } %123, 0
  %125 = extractvalue { i32, i1 } %123, 1
  br i1 %125, label %158, label %126

126:                                              ; preds = %118
  %127 = phi i64 [ %46, %118 ]
  %128 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %129 = call ptr %128()
  %130 = call i64 @llvm.uadd.sat.i64(i64 %127, i64 0)
  %131 = insertvalue { i32, i32, i32, i32 } undef, i32 %85, 0
  %132 = insertvalue { i32, i32, i32, i32 } %131, i32 %108, 1
  %133 = insertvalue { i32, i32, i32, i32 } %132, i32 %116, 2
  %134 = insertvalue { i32, i32, i32, i32 } %133, i32 %124, 3
  %135 = extractvalue { ptr, ptr, i64 } %12, 1
  %136 = load i64, ptr %135, align 8
  %137 = add i64 %136, 1
  %138 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %137, ptr %138, align 8
  br label %20

139:                                              ; preds = %139, %186, %87, %60, %222
  %140 = phi i64 [ %28, %222 ], [ %190, %186 ], [ %140, %139 ], [ %45, %87 ], [ %45, %60 ]
  %141 = phi i64 [ %22, %222 ], [ %191, %186 ], [ %141, %139 ], [ %92, %87 ], [ %46, %60 ]
  %142 = phi i64 [ %23, %222 ], [ %187, %186 ], [ %142, %139 ], [ %47, %87 ], [ %47, %60 ]
  %143 = phi i64 [ %24, %222 ], [ %188, %186 ], [ %143, %139 ], [ %48, %87 ], [ %48, %60 ]
  %144 = phi ptr [ %25, %222 ], [ %189, %186 ], [ %144, %139 ], [ %49, %87 ], [ %49, %60 ]
  %145 = phi { i64, [40 x i8] } [ %227, %222 ], [ %195, %186 ], [ %145, %139 ], [ %96, %87 ], [ %64, %60 ]
  %146 = extractvalue { ptr, ptr, i64 } %12, 1
  %147 = load i64, ptr %146, align 8
  %148 = icmp eq i64 %147, 0
  %149 = sub i64 %147, 1
  %150 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %149, ptr %150, align 8
  br i1 %148, label %151, label %139

151:                                              ; preds = %139
  %152 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %140, 0
  %153 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %152, i64 %141, 1
  %154 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %153, i64 %142, 2
  %155 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %154, i64 %143, 3
  %156 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %155, ptr %144, 4
  %157 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %156, { i64, [40 x i8] } %145, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %157

158:                                              ; preds = %118
  %159 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %57, %118 ]
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %159)
  %160 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %161 = call ptr %160()
  %162 = load i64, ptr %161, align 8
  %163 = mul i64 %162, 2370
  %164 = call i64 @llvm.uadd.sat.i64(i64 %46, i64 %163)
  br label %186

165:                                              ; preds = %110
  %166 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %57, %110 ]
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %166)
  %167 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %168 = call ptr %167()
  %169 = load i64, ptr %168, align 8
  %170 = mul i64 %169, 2710
  %171 = call i64 @llvm.uadd.sat.i64(i64 %46, i64 %170)
  br label %186

172:                                              ; preds = %102
  %173 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %57, %102 ]
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %173)
  %174 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %175 = call ptr %174()
  %176 = load i64, ptr %175, align 8
  %177 = mul i64 %176, 3150
  %178 = call i64 @llvm.uadd.sat.i64(i64 %46, i64 %177)
  br label %186

179:                                              ; preds = %72
  %180 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %57, %72 ]
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %180)
  %181 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %182 = call ptr %181()
  %183 = load i64, ptr %182, align 8
  %184 = mul i64 %183, 3690
  %185 = call i64 @llvm.uadd.sat.i64(i64 %46, i64 %184)
  br label %186

186:                                              ; preds = %179, %172, %165, %158
  %187 = phi i64 [ %47, %179 ], [ %47, %172 ], [ %47, %165 ], [ %47, %158 ]
  %188 = phi i64 [ %48, %179 ], [ %48, %172 ], [ %48, %165 ], [ %48, %158 ]
  %189 = phi ptr [ %49, %179 ], [ %49, %172 ], [ %49, %165 ], [ %49, %158 ]
  %190 = phi i64 [ %83, %179 ], [ %106, %172 ], [ %114, %165 ], [ %122, %158 ]
  %191 = phi i64 [ %185, %179 ], [ %178, %172 ], [ %171, %165 ], [ %164, %158 ]
  %192 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"()
  %193 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %192, 0
  %194 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %193, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %194, ptr %19, align 8
  %195 = load { i64, [40 x i8] }, ptr %19, align 8
  %196 = extractvalue { ptr, ptr, i64 } %12, 1
  %197 = load i64, ptr %196, align 8
  %198 = icmp eq i64 %197, 0
  %199 = sub i64 %197, 1
  %200 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %199, ptr %200, align 8
  br i1 %198, label %201, label %139

201:                                              ; preds = %186
  %202 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %190, 0
  %203 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %202, i64 %191, 1
  %204 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %203, i64 %187, 2
  %205 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %204, i64 %188, 3
  %206 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %205, ptr %189, 4
  %207 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %206, { i64, [40 x i8] } %195, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %207

208:                                              ; preds = %87
  %209 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %45, 0
  %210 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %209, i64 %92, 1
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %210, i64 %47, 2
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %211, i64 %48, 3
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %212, ptr %49, 4
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %213, { i64, [40 x i8] } %96, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %214

215:                                              ; preds = %60
  %216 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %45, 0
  %217 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %216, i64 %46, 1
  %218 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %217, i64 %47, 2
  %219 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %218, i64 %48, 3
  %220 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %219, ptr %49, 4
  %221 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %220, { i64, [40 x i8] } %64, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %221

222:                                              ; preds = %20
  %223 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %26, %20 ]
  call void @"drop$224"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %223)
  %224 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %225 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %224, 0
  %226 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %225, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %226, ptr %14, align 8
  %227 = load { i64, [40 x i8] }, ptr %14, align 8
  %228 = extractvalue { ptr, ptr, i64 } %12, 1
  %229 = load i64, ptr %228, align 8
  %230 = icmp eq i64 %229, 0
  %231 = sub i64 %229, 1
  %232 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %231, ptr %232, align 8
  br i1 %230, label %233, label %139

233:                                              ; preds = %222
  %234 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %28, 0
  %235 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %234, i64 %22, 1
  %236 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %235, i64 %23, 2
  %237 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %236, i64 %24, 3
  %238 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %237, ptr %25, 4
  %239 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %238, { i64, [40 x i8] } %227, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %239

240:                                              ; preds = %52
  call void @puts(ptr @assert_msg_86)
  call void @abort()
  unreachable

241:                                              ; preds = %70
  call void @puts(ptr @assert_msg_87)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f39(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, { i32, i32, i32, i32 } %6, {} %7) {
  %9 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f39"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, { i32, i32, i32, i32 } %6, {} %7)
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %9, 4
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %9, 5
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %10, 0
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %16, i64 %11, 1
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %17, i64 %12, 2
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %18, i64 %13, 3
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %19, ptr %14, 4
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %20, { i64, [40 x i8] } %15, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %21
}

define void @_mlir_ciface_f39(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6, { i32, i32, i32, i32 } %7, {} %8) {
  %10 = call { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f39(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6, { i32, i32, i32, i32 } %7, {} %8)
  store { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4) {
  %6 = alloca { i1, [47 x i8] }, i64 1, align 16
  %7 = alloca i64, i64 1, align 8
  %8 = alloca i252, i64 1, align 16
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = extractvalue { i252 } %4, 0
  %14 = load ptr, ptr %3, align 8
  store i64 %1, ptr %7, align 8
  store i252 %13, ptr %8, align 16
  %15 = getelementptr inbounds ptr, ptr %3, i32 8
  %16 = load ptr, ptr %15, align 8
  call void %16(ptr %6, ptr %14, ptr %7, i32 0, ptr %8)
  %17 = load { i1, [47 x i8] }, ptr %6, align 1
  %18 = extractvalue { i1, [47 x i8] } %17, 0
  %19 = getelementptr inbounds i8, ptr %6, i32 16
  %20 = load i252, ptr %19, align 16
  %21 = getelementptr inbounds i8, ptr %6, i32 8
  %22 = load { ptr, i32, i32, i32 }, ptr %21, align 8
  %23 = load i64, ptr %7, align 8
  br i1 %18, label %147, label %24

24:                                               ; preds = %5
  %25 = phi i64 [ %0, %5 ]
  %26 = phi i252 [ %20, %5 ]
  %27 = trunc i252 %26 to i128
  %28 = lshr i252 %26, 128
  %29 = trunc i252 %28 to i128
  %30 = icmp ne i128 %29, 0
  %31 = add i64 %25, 3
  %32 = add i64 %25, 1
  %33 = select i1 %30, i64 %31, i64 %32
  br i1 %30, label %137, label %34

34:                                               ; preds = %24
  %35 = phi i128 [ %27, %24 ]
  %36 = add i64 %2, 5
  %37 = and i128 %35, 4294967295
  %38 = icmp ult i128 %37, 4294967296
  %39 = add i64 %33, 1
  %40 = trunc i128 %37 to i32
  br i1 %38, label %41, label %112

41:                                               ; preds = %34
  %42 = phi i128 [ %35, %34 ]
  %43 = udiv i128 %42, 4294967296
  %44 = add i64 %2, 10
  %45 = and i128 %43, 4294967295
  %46 = icmp ult i128 %45, 4294967296
  %47 = add i64 %33, 6
  %48 = trunc i128 %45 to i32
  br i1 %46, label %49, label %101

49:                                               ; preds = %41
  %50 = phi i128 [ %42, %41 ]
  %51 = udiv i128 %50, 18446744073709551616
  %52 = add i64 %2, 15
  %53 = and i128 %51, 4294967295
  %54 = icmp ult i128 %53, 4294967296
  %55 = add i64 %33, 11
  %56 = trunc i128 %53 to i32
  br i1 %54, label %57, label %91

57:                                               ; preds = %49
  %58 = phi i64 [ %55, %49 ]
  %59 = phi i128 [ %50, %49 ]
  %60 = phi i128 [ 79228162514264337593543950336, %49 ]
  %61 = udiv i128 %59, %60
  %62 = add i64 %2, 20
  %63 = and i128 %61, 4294967295
  %64 = icmp ult i128 %63, 4294967296
  %65 = add i64 %58, 5
  %66 = trunc i128 %63 to i32
  br i1 %64, label %67, label %86

67:                                               ; preds = %57
  %68 = phi i64 [ %23, %57 ]
  %69 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %70 = call ptr %69()
  %71 = load i64, ptr %70, align 8
  %72 = mul i64 %71, 1190
  %73 = call i64 @llvm.uadd.sat.i64(i64 %68, i64 %72)
  %74 = insertvalue { i32, i32, i32, i32 } undef, i32 %40, 0
  %75 = insertvalue { i32, i32, i32, i32 } %74, i32 %48, 1
  %76 = insertvalue { i32, i32, i32, i32 } %75, i32 %56, 2
  %77 = insertvalue { i32, i32, i32, i32 } %76, i32 %66, 3
  %78 = insertvalue { { i32, i32, i32, i32 } } undef, { i32, i32, i32, i32 } %77, 0
  %79 = insertvalue { i1, { { i32, i32, i32, i32 } } } { i1 false, { { i32, i32, i32, i32 } } undef }, { { i32, i32, i32, i32 } } %78, 1
  store { i1, { { i32, i32, i32, i32 } } } %79, ptr %12, align 4
  %80 = load { i64, [24 x i8] }, ptr %12, align 8
  %81 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %65, 0
  %82 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %81, i64 %73, 1
  %83 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %82, i64 %62, 2
  %84 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %83, ptr %3, 3
  %85 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %84, { i64, [24 x i8] } %80, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %85

86:                                               ; preds = %57
  %87 = phi i64 [ %23, %57 ]
  %88 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %89 = call ptr %88()
  %90 = call i64 @llvm.uadd.sat.i64(i64 %87, i64 0)
  br label %123

91:                                               ; preds = %49
  %92 = phi i64 [ %23, %49 ]
  %93 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %94 = call ptr %93()
  %95 = getelementptr inbounds i64, ptr %94, i32 2
  %96 = load i64, ptr %95, align 8
  %97 = load i64, ptr %94, align 8
  %98 = mul i64 %97, 1490
  %99 = add i64 %96, %98
  %100 = call i64 @llvm.uadd.sat.i64(i64 %92, i64 %99)
  br label %123

101:                                              ; preds = %41
  %102 = phi i64 [ %23, %41 ]
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = getelementptr inbounds i64, ptr %104, i32 2
  %106 = load i64, ptr %105, align 8
  %107 = mul i64 %106, 2
  %108 = load i64, ptr %104, align 8
  %109 = mul i64 %108, 3530
  %110 = add i64 %107, %109
  %111 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 %110)
  br label %123

112:                                              ; preds = %34
  %113 = phi i64 [ %23, %34 ]
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = getelementptr inbounds i64, ptr %115, i32 2
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 3
  %119 = load i64, ptr %115, align 8
  %120 = mul i64 %119, 5760
  %121 = add i64 %118, %120
  %122 = call i64 @llvm.uadd.sat.i64(i64 %113, i64 %121)
  br label %123

123:                                              ; preds = %86, %91, %101, %112
  %124 = phi ptr [ %3, %112 ], [ %3, %101 ], [ %3, %91 ], [ %3, %86 ]
  %125 = phi i64 [ %39, %112 ], [ %47, %101 ], [ %55, %91 ], [ %65, %86 ]
  %126 = phi i64 [ %122, %112 ], [ %111, %101 ], [ %100, %91 ], [ %90, %86 ]
  %127 = phi i64 [ %36, %112 ], [ %44, %101 ], [ %52, %91 ], [ %62, %86 ]
  %128 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f68"()
  %129 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %128, 0
  %130 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %129, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %130, ptr %11, align 8
  %131 = load { i64, [24 x i8] }, ptr %11, align 8
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %125, 0
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %132, i64 %126, 1
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %133, i64 %127, 2
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, ptr %124, 3
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %135, { i64, [24 x i8] } %131, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %136

137:                                              ; preds = %24
  %138 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f69"()
  %139 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %138, 0
  %140 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %139, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %140, ptr %10, align 8
  %141 = load { i64, [24 x i8] }, ptr %10, align 8
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %33, 0
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, i64 %23, 1
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, i64 %2, 2
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, ptr %3, 3
  %146 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %145, { i64, [24 x i8] } %141, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %146

147:                                              ; preds = %5
  %148 = phi {} [ undef, %5 ]
  %149 = phi { ptr, i32, i32, i32 } [ %22, %5 ]
  %150 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %148, 0
  %151 = insertvalue { {}, { ptr, i32, i32, i32 } } %150, { ptr, i32, i32, i32 } %149, 1
  %152 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %151, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %152, ptr %9, align 8
  %153 = load { i64, [24 x i8] }, ptr %9, align 8
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %154, i64 %23, 1
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %2, 2
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, ptr %3, 3
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %153, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %158
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f40(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f40(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { i252 } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f40(i64 %1, i64 %2, i64 %3, ptr %4, { i252 } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f41"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 7891998437966260601762371672023996916393715052535837300)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f41() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f41"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f41(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f41()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f42"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %113, %5
  %17 = phi i64 [ %22, %113 ], [ %0, %5 ]
  %18 = phi i64 [ %72, %113 ], [ %1, %5 ]
  %19 = phi { { ptr, i32, i32, i32 } } [ %130, %113 ], [ %2, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %122, %113 ], [ %3, %5 ]
  %21 = phi i252 [ %129, %113 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 1770
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %170

29:                                               ; preds = %16
  %30 = phi i252 [ %21, %16 ]
  %31 = icmp eq i252 %30, 0
  br i1 %31, label %32, label %54

32:                                               ; preds = %29
  %33 = phi i64 [ %28, %29 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = load i64, ptr %35, align 8
  %37 = mul i64 %36, 2670
  %38 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %37)
  %39 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %20, 1
  store { i1, { ptr, i32, i32, i32 } } %39, ptr %14, align 8
  %40 = load { i64, [24 x i8] }, ptr %14, align 8
  %41 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %19, 0
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %41, { i64, [24 x i8] } %40, 1
  %43 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %43, ptr %15, align 8
  %44 = load { i64, [56 x i8] }, ptr %15, align 8
  %45 = extractvalue { ptr, ptr, i64 } %9, 1
  %46 = load i64, ptr %45, align 8
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %46, 1
  %49 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %48, ptr %49, align 8
  br i1 %47, label %50, label %135

50:                                               ; preds = %32
  %51 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } %51, i64 %38, 1
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, { i64, [56 x i8] } %44, 2
  ret { i64, i64, { i64, [56 x i8] } } %53

54:                                               ; preds = %29
  %55 = phi { { ptr, i32, i32, i32 } } [ %19, %29 ]
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %148

61:                                               ; preds = %54
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %71 = call ptr %70()
  %72 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 0)
  %73 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %74 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %76, label %90

76:                                               ; preds = %61
  %77 = shl i32 %74, 1
  %78 = call i32 @llvm.umin.i32(i32 %77, i32 1024)
  %79 = add i32 %78, %74
  %80 = call i32 @llvm.umax.i32(i32 %79, i32 8)
  %81 = zext i32 %80 to i64
  %82 = mul i64 %81, 32
  %83 = add i64 %82, 16
  %84 = call ptr @realloc(ptr null, i64 %83)
  store i32 1, ptr %84, align 4
  %85 = getelementptr inbounds i8, ptr %84, i32 4
  store i32 0, ptr %85, align 4
  %86 = getelementptr inbounds i8, ptr %84, i32 16
  %87 = call ptr @realloc(ptr null, i64 8)
  store ptr %86, ptr %87, align 8
  %88 = insertvalue { ptr, i32, i32, i32 } %20, ptr %87, 0
  %89 = insertvalue { ptr, i32, i32, i32 } %88, i32 %80, 3
  br label %111

90:                                               ; preds = %61
  %91 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %92 = icmp ult i32 %91, %74
  br i1 %92, label %93, label %94

93:                                               ; preds = %90
  br label %108

94:                                               ; preds = %90
  %95 = shl i32 %74, 1
  %96 = call i32 @llvm.umin.i32(i32 %95, i32 1024)
  %97 = add i32 %96, %74
  %98 = call i32 @llvm.umax.i32(i32 %97, i32 8)
  %99 = zext i32 %98 to i64
  %100 = mul i64 %99, 32
  %101 = add i64 %100, 16
  %102 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %103 = load ptr, ptr %102, align 8
  %104 = getelementptr inbounds i8, ptr %103, i32 -16
  %105 = call ptr @realloc(ptr %104, i64 %101)
  %106 = getelementptr inbounds i8, ptr %105, i32 16
  store ptr %106, ptr %102, align 8
  %107 = insertvalue { ptr, i32, i32, i32 } %20, i32 %98, 3
  br label %108

108:                                              ; preds = %93, %94
  %109 = phi { ptr, i32, i32, i32 } [ %107, %94 ], [ %20, %93 ]
  br label %110

110:                                              ; preds = %108
  br label %111

111:                                              ; preds = %76, %110
  %112 = phi { ptr, i32, i32, i32 } [ %109, %110 ], [ %89, %76 ]
  br label %113

113:                                              ; preds = %111
  %114 = extractvalue { ptr, i32, i32, i32 } %112, 0
  %115 = load ptr, ptr %114, align 8
  %116 = extractvalue { ptr, i32, i32, i32 } %112, 2
  %117 = zext i32 %116 to i64
  %118 = mul i64 %117, 32
  %119 = getelementptr inbounds i8, ptr %115, i64 %118
  store i252 %73, ptr %119, align 16
  %120 = extractvalue { ptr, i32, i32, i32 } %112, 2
  %121 = add i32 %120, 1
  %122 = insertvalue { ptr, i32, i32, i32 } %112, i32 %121, 2
  %123 = getelementptr inbounds i8, ptr %115, i32 -12
  store i32 %121, ptr %123, align 4
  %124 = zext i252 %30 to i256
  %125 = sub i256 %124, 1
  %126 = add i256 %124, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %127 = icmp ult i256 %124, 1
  %128 = select i1 %127, i256 %126, i256 %125
  %129 = trunc i256 %128 to i252
  %130 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %131 = extractvalue { ptr, ptr, i64 } %9, 1
  %132 = load i64, ptr %131, align 8
  %133 = add i64 %132, 1
  %134 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %133, ptr %134, align 8
  br label %16

135:                                              ; preds = %135, %32, %148, %170
  %136 = phi i64 [ %22, %170 ], [ %22, %148 ], [ %136, %135 ], [ %22, %32 ]
  %137 = phi i64 [ %18, %170 ], [ %154, %148 ], [ %137, %135 ], [ %38, %32 ]
  %138 = phi { i64, [56 x i8] } [ %175, %170 ], [ %160, %148 ], [ %138, %135 ], [ %44, %32 ]
  %139 = extractvalue { ptr, ptr, i64 } %9, 1
  %140 = load i64, ptr %139, align 8
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %140, 1
  %143 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %142, ptr %143, align 8
  br i1 %141, label %144, label %135

144:                                              ; preds = %135
  %145 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %136, 0
  %146 = insertvalue { i64, i64, { i64, [56 x i8] } } %145, i64 %137, 1
  %147 = insertvalue { i64, i64, { i64, [56 x i8] } } %146, { i64, [56 x i8] } %138, 2
  ret { i64, i64, { i64, [56 x i8] } } %147

148:                                              ; preds = %54
  %149 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %149)
  %150 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %151 = call ptr %150()
  %152 = load i64, ptr %151, align 8
  %153 = mul i64 %152, 2370
  %154 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %153)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %155 = load { i64, [24 x i8] }, ptr %12, align 8
  %156 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %56, 0
  %157 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %156, 0
  %158 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %155, 1
  %159 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %158, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %159, ptr %13, align 8
  %160 = load { i64, [56 x i8] }, ptr %13, align 8
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %166, label %135

166:                                              ; preds = %148
  %167 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %168 = insertvalue { i64, i64, { i64, [56 x i8] } } %167, i64 %154, 1
  %169 = insertvalue { i64, i64, { i64, [56 x i8] } } %168, { i64, [56 x i8] } %160, 2
  ret { i64, i64, { i64, [56 x i8] } } %169

170:                                              ; preds = %16
  %171 = phi { ptr, i32, i32, i32 } [ %20, %16 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %171)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %19)
  %172 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %173 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %172, 0
  %174 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %173, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %174, ptr %11, align 8
  %175 = load { i64, [56 x i8] }, ptr %11, align 8
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %135

181:                                              ; preds = %170
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %18, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184
}

define private { i64, i64, { i64, [56 x i8] } } @f42(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f42"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f42(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f42(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$211"(ptr %0) {
  %2 = load { ptr, i32, i32, i32 }, ptr %0, align 8
  call void @"drop$26"({ ptr, i32, i32, i32 } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$211"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 24)
  %3 = load { ptr, i32, i32, i32 }, ptr %0, align 8
  %4 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %3)
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 0
  %6 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 1
  store { ptr, i32, i32, i32 } %5, ptr %0, align 8
  store { ptr, i32, i32, i32 } %6, ptr %2, align 8
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$210"({ i128, [32 x i8] } %0) {
  %2 = alloca { i128, [32 x i8] }, i64 1, align 16
  store { i128, [32 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [32 x i8] }, { i128, [32 x i8] } } @"dup$210"({ i128, [32 x i8] } %0) {
  %2 = alloca { i128, [32 x i8] }, i64 1, align 16
  store { i128, [32 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i252 } }, ptr %2, align 16
  %6 = extractvalue { i1, { i252 } } %5, 1
  %7 = insertvalue { i1, { i252 } } %5, { i252 } %6, 1
  store { i1, { i252 } } %7, ptr %2, align 16
  %8 = load { i128, [32 x i8] }, ptr %2, align 16
  %9 = insertvalue { i1, { i252 } } %5, { i252 } %6, 1
  store { i1, { i252 } } %9, ptr %2, align 16
  %10 = load { i128, [32 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } undef, { i128, [32 x i8] } %8, 0
  %12 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } %11, { i128, [32 x i8] } %10, 1
  ret { { i128, [32 x i8] }, { i128, [32 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i128, [32 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i128, [32 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } undef, { i128, [32 x i8] } %20, 0
  %24 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } %23, { i128, [32 x i8] } %22, 1
  ret { { i128, [32 x i8] }, { i128, [32 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f43"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = alloca i64, i64 1, align 8
  %9 = insertvalue { ptr, ptr, i64 } undef, ptr %8, 0
  %10 = insertvalue { ptr, ptr, i64 } %9, ptr %8, 1
  %11 = insertvalue { ptr, ptr, i64 } %10, i64 0, 2
  %12 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 0, ptr %12, align 8
  %13 = alloca { i64, [72 x i8] }, i64 1, align 8
  %14 = alloca { i64, [72 x i8] }, i64 1, align 8
  %15 = alloca { i128, [32 x i8] }, i64 1, align 16
  %16 = alloca { i64, [72 x i8] }, i64 1, align 8
  br label %17

17:                                               ; preds = %118, %7
  %18 = phi i64 [ %63, %118 ], [ %0, %7 ]
  %19 = phi i64 [ %77, %118 ], [ %1, %7 ]
  %20 = phi i64 [ %65, %118 ], [ %2, %7 ]
  %21 = phi i64 [ %66, %118 ], [ %3, %7 ]
  %22 = phi ptr [ %67, %118 ], [ %4, %7 ]
  %23 = phi { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } [ %131, %118 ], [ %5, %7 ]
  %24 = phi { ptr, i32, i32, i32 } [ %127, %118 ], [ %6, %7 ]
  %25 = add i64 %18, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = getelementptr inbounds i64, ptr %27, i32 1
  %29 = load i64, ptr %28, align 8
  %30 = load i64, ptr %27, align 8
  %31 = mul i64 %30, 25770
  %32 = add i64 %29, %31
  %33 = icmp uge i64 %19, %32
  %34 = call i64 @llvm.usub.sat.i64(i64 %19, i64 %32)
  br i1 %33, label %35, label %202

35:                                               ; preds = %17
  %36 = phi { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } [ %23, %17 ]
  %37 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %36, 0
  %38 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %36, 1
  %39 = extractvalue { { ptr, i32, i32, i32 } } %37, 0
  %40 = extractvalue { ptr, i32, i32, i32 } %39, 1
  %41 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %42 = sub i32 %41, %40
  %43 = icmp uge i32 %42, 1
  br i1 %43, label %44, label %172

44:                                               ; preds = %35
  %45 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %46 = load ptr, ptr %45, align 8
  %47 = zext i32 %40 to i64
  %48 = mul i64 %47, 24
  %49 = getelementptr inbounds i8, ptr %46, i64 %48
  %50 = add i32 %40, 1
  %51 = insertvalue { ptr, i32, i32, i32 } %39, i32 %50, 1
  %52 = call ptr @realloc(ptr null, i64 24)
  %53 = load { ptr, i32, i32, i32 }, ptr %49, align 8
  %54 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %53)
  %55 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %54, 0
  %56 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %54, 1
  store { ptr, i32, i32, i32 } %55, ptr %49, align 8
  store { ptr, i32, i32, i32 } %56, ptr %52, align 8
  %57 = call { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } @"dup$326"({ { {} }, { { ptr, i32, i32, i32 } } } %38)
  %58 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %57, 0
  %59 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %57, 1
  %60 = load { ptr, i32, i32, i32 }, ptr %52, align 8
  call void @free(ptr %52)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %60, 0
  %62 = call fastcc { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f70"(i64 %25, i64 %34, i64 %20, i64 %21, ptr %22, { { {} }, { { ptr, i32, i32, i32 } } } %59, { { ptr, i32, i32, i32 } } %61)
  %63 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %62, 0
  %64 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %62, 1
  %65 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %62, 2
  %66 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %62, 3
  %67 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %62, 4
  %68 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %62, 5
  store { i128, [32 x i8] } %68, ptr %15, align 16
  %69 = load i1, ptr %15, align 1
  switch i1 %69, label %70 [
    i1 false, label %72
    i1 true, label %136
  ]

70:                                               ; preds = %44
  br i1 false, label %71, label %220

71:                                               ; preds = %70
  unreachable

72:                                               ; preds = %44
  %73 = load { i1, { i252 } }, ptr %15, align 16
  %74 = extractvalue { i1, { i252 } } %73, 1
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %64, i64 0)
  %78 = extractvalue { i252 } %74, 0
  %79 = extractvalue { ptr, i32, i32, i32 } %24, 3
  %80 = icmp eq i32 %79, 0
  br i1 %80, label %81, label %95

81:                                               ; preds = %72
  %82 = shl i32 %79, 1
  %83 = call i32 @llvm.umin.i32(i32 %82, i32 1024)
  %84 = add i32 %83, %79
  %85 = call i32 @llvm.umax.i32(i32 %84, i32 8)
  %86 = zext i32 %85 to i64
  %87 = mul i64 %86, 32
  %88 = add i64 %87, 16
  %89 = call ptr @realloc(ptr null, i64 %88)
  store i32 1, ptr %89, align 4
  %90 = getelementptr inbounds i8, ptr %89, i32 4
  store i32 0, ptr %90, align 4
  %91 = getelementptr inbounds i8, ptr %89, i32 16
  %92 = call ptr @realloc(ptr null, i64 8)
  store ptr %91, ptr %92, align 8
  %93 = insertvalue { ptr, i32, i32, i32 } %24, ptr %92, 0
  %94 = insertvalue { ptr, i32, i32, i32 } %93, i32 %85, 3
  br label %116

95:                                               ; preds = %72
  %96 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %97 = icmp ult i32 %96, %79
  br i1 %97, label %98, label %99

98:                                               ; preds = %95
  br label %113

99:                                               ; preds = %95
  %100 = shl i32 %79, 1
  %101 = call i32 @llvm.umin.i32(i32 %100, i32 1024)
  %102 = add i32 %101, %79
  %103 = call i32 @llvm.umax.i32(i32 %102, i32 8)
  %104 = zext i32 %103 to i64
  %105 = mul i64 %104, 32
  %106 = add i64 %105, 16
  %107 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %108 = load ptr, ptr %107, align 8
  %109 = getelementptr inbounds i8, ptr %108, i32 -16
  %110 = call ptr @realloc(ptr %109, i64 %106)
  %111 = getelementptr inbounds i8, ptr %110, i32 16
  store ptr %111, ptr %107, align 8
  %112 = insertvalue { ptr, i32, i32, i32 } %24, i32 %103, 3
  br label %113

113:                                              ; preds = %98, %99
  %114 = phi { ptr, i32, i32, i32 } [ %112, %99 ], [ %24, %98 ]
  br label %115

115:                                              ; preds = %113
  br label %116

116:                                              ; preds = %81, %115
  %117 = phi { ptr, i32, i32, i32 } [ %114, %115 ], [ %94, %81 ]
  br label %118

118:                                              ; preds = %116
  %119 = extractvalue { ptr, i32, i32, i32 } %117, 0
  %120 = load ptr, ptr %119, align 8
  %121 = extractvalue { ptr, i32, i32, i32 } %117, 2
  %122 = zext i32 %121 to i64
  %123 = mul i64 %122, 32
  %124 = getelementptr inbounds i8, ptr %120, i64 %123
  store i252 %78, ptr %124, align 16
  %125 = extractvalue { ptr, i32, i32, i32 } %117, 2
  %126 = add i32 %125, 1
  %127 = insertvalue { ptr, i32, i32, i32 } %117, i32 %126, 2
  %128 = getelementptr inbounds i8, ptr %120, i32 -12
  store i32 %126, ptr %128, align 4
  %129 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %51, 0
  %130 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %129, 0
  %131 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %130, { { {} }, { { ptr, i32, i32, i32 } } } %58, 1
  %132 = extractvalue { ptr, ptr, i64 } %11, 1
  %133 = load i64, ptr %132, align 8
  %134 = add i64 %133, 1
  %135 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %134, ptr %135, align 8
  br label %17

136:                                              ; preds = %44
  %137 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %138 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %137, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %51)
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %58)
  call void @"drop$26"({ ptr, i32, i32, i32 } %24)
  %139 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %138, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %139, ptr %16, align 8
  %140 = load { i64, [72 x i8] }, ptr %16, align 8
  %141 = extractvalue { ptr, ptr, i64 } %11, 1
  %142 = load i64, ptr %141, align 8
  %143 = icmp eq i64 %142, 0
  %144 = sub i64 %142, 1
  %145 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %144, ptr %145, align 8
  br i1 %143, label %165, label %146

146:                                              ; preds = %146, %136, %172, %202
  %147 = phi i64 [ %25, %202 ], [ %25, %172 ], [ %147, %146 ], [ %63, %136 ]
  %148 = phi i64 [ %19, %202 ], [ %181, %172 ], [ %148, %146 ], [ %64, %136 ]
  %149 = phi i64 [ %20, %202 ], [ %20, %172 ], [ %149, %146 ], [ %65, %136 ]
  %150 = phi i64 [ %21, %202 ], [ %21, %172 ], [ %150, %146 ], [ %66, %136 ]
  %151 = phi ptr [ %22, %202 ], [ %22, %172 ], [ %151, %146 ], [ %67, %136 ]
  %152 = phi { i64, [72 x i8] } [ %207, %202 ], [ %189, %172 ], [ %152, %146 ], [ %140, %136 ]
  %153 = extractvalue { ptr, ptr, i64 } %11, 1
  %154 = load i64, ptr %153, align 8
  %155 = icmp eq i64 %154, 0
  %156 = sub i64 %154, 1
  %157 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %156, ptr %157, align 8
  br i1 %155, label %158, label %146

158:                                              ; preds = %146
  %159 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %147, 0
  %160 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %159, i64 %148, 1
  %161 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %160, i64 %149, 2
  %162 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %161, i64 %150, 3
  %163 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %162, ptr %151, 4
  %164 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %163, { i64, [72 x i8] } %152, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %164

165:                                              ; preds = %136
  %166 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %63, 0
  %167 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %166, i64 %64, 1
  %168 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %167, i64 %65, 2
  %169 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %168, i64 %66, 3
  %170 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %169, ptr %67, 4
  %171 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %170, { i64, [72 x i8] } %140, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %171

172:                                              ; preds = %35
  %173 = phi i64 [ %34, %35 ]
  %174 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %175 = call ptr %174()
  %176 = getelementptr inbounds i64, ptr %175, i32 1
  %177 = load i64, ptr %176, align 8
  %178 = load i64, ptr %175, align 8
  %179 = mul i64 %178, 25970
  %180 = add i64 %177, %179
  %181 = call i64 @llvm.uadd.sat.i64(i64 %173, i64 %180)
  %182 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %39, 0
  %183 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %182, 0
  %184 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %183, { { {} }, { { ptr, i32, i32, i32 } } } %38, 1
  %185 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %184, 0
  %186 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %185, { ptr, i32, i32, i32 } %24, 1
  %187 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %186, {} undef, 2
  %188 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %187, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %188, ptr %14, align 8
  %189 = load { i64, [72 x i8] }, ptr %14, align 8
  %190 = extractvalue { ptr, ptr, i64 } %11, 1
  %191 = load i64, ptr %190, align 8
  %192 = icmp eq i64 %191, 0
  %193 = sub i64 %191, 1
  %194 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %193, ptr %194, align 8
  br i1 %192, label %195, label %146

195:                                              ; preds = %172
  %196 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %25, 0
  %197 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %196, i64 %181, 1
  %198 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %197, i64 %20, 2
  %199 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %198, i64 %21, 3
  %200 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %199, ptr %22, 4
  %201 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %200, { i64, [72 x i8] } %189, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %201

202:                                              ; preds = %17
  %203 = phi { ptr, i32, i32, i32 } [ %24, %17 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %203)
  call void @"drop$327"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %23)
  %204 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %205 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %204, 0
  %206 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %205, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %206, ptr %13, align 8
  %207 = load { i64, [72 x i8] }, ptr %13, align 8
  %208 = extractvalue { ptr, ptr, i64 } %11, 1
  %209 = load i64, ptr %208, align 8
  %210 = icmp eq i64 %209, 0
  %211 = sub i64 %209, 1
  %212 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %211, ptr %212, align 8
  br i1 %210, label %213, label %146

213:                                              ; preds = %202
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %25, 0
  %215 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %214, i64 %19, 1
  %216 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %215, i64 %20, 2
  %217 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %216, i64 %21, 3
  %218 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %217, ptr %22, 4
  %219 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %218, { i64, [72 x i8] } %207, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %219

220:                                              ; preds = %70
  call void @puts(ptr @assert_msg_88)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @f43(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f43"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, { ptr, i32, i32, i32 } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %19, { i64, [72 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %20
}

define void @_mlir_ciface_f43(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %6, { ptr, i32, i32, i32 } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @f43(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %6, { ptr, i32, i32, i32 } %7)
  store { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %9, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } @"impl$f44"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = alloca i64, i64 1, align 8
  %9 = insertvalue { ptr, ptr, i64 } undef, ptr %8, 0
  %10 = insertvalue { ptr, ptr, i64 } %9, ptr %8, 1
  %11 = insertvalue { ptr, ptr, i64 } %10, i64 0, 2
  %12 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 0, ptr %12, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [56 x i8] }, i64 1, align 8
  %15 = alloca { i128, [32 x i8] }, i64 1, align 16
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %17

17:                                               ; preds = %115, %7
  %18 = phi i64 [ %60, %115 ], [ %0, %7 ]
  %19 = phi i64 [ %74, %115 ], [ %1, %7 ]
  %20 = phi i64 [ %62, %115 ], [ %2, %7 ]
  %21 = phi i64 [ %63, %115 ], [ %3, %7 ]
  %22 = phi ptr [ %64, %115 ], [ %4, %7 ]
  %23 = phi { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } [ %128, %115 ], [ %5, %7 ]
  %24 = phi { ptr, i32, i32, i32 } [ %124, %115 ], [ %6, %7 ]
  %25 = add i64 %18, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = getelementptr inbounds i64, ptr %27, i32 1
  %29 = load i64, ptr %28, align 8
  %30 = load i64, ptr %27, align 8
  %31 = mul i64 %30, 22450
  %32 = add i64 %29, %31
  %33 = icmp uge i64 %19, %32
  %34 = call i64 @llvm.usub.sat.i64(i64 %19, i64 %32)
  br i1 %33, label %35, label %199

35:                                               ; preds = %17
  %36 = phi { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } [ %23, %17 ]
  %37 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %36, 0
  %38 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %36, 1
  %39 = extractvalue { { ptr, i32, i32, i32 } } %37, 0
  %40 = extractvalue { ptr, i32, i32, i32 } %39, 1
  %41 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %42 = sub i32 %41, %40
  %43 = icmp uge i32 %42, 1
  br i1 %43, label %44, label %169

44:                                               ; preds = %35
  %45 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %46 = load ptr, ptr %45, align 8
  %47 = zext i32 %40 to i64
  %48 = mul i64 %47, 24
  %49 = getelementptr inbounds i8, ptr %46, i64 %48
  %50 = add i32 %40, 1
  %51 = insertvalue { ptr, i32, i32, i32 } %39, i32 %50, 1
  %52 = call ptr @realloc(ptr null, i64 24)
  %53 = load { ptr, i32, i32, i32 }, ptr %49, align 8
  %54 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %53)
  %55 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %54, 0
  %56 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %54, 1
  store { ptr, i32, i32, i32 } %55, ptr %49, align 8
  store { ptr, i32, i32, i32 } %56, ptr %52, align 8
  %57 = load { ptr, i32, i32, i32 }, ptr %52, align 8
  call void @free(ptr %52)
  %58 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %57, 0
  %59 = call fastcc { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f71"(i64 %25, i64 %34, i64 %20, i64 %21, ptr %22, { { {} }, i32 } %38, { { ptr, i32, i32, i32 } } %58)
  %60 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %59, 0
  %61 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %59, 1
  %62 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %59, 2
  %63 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %59, 3
  %64 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %59, 4
  %65 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %59, 5
  store { i128, [32 x i8] } %65, ptr %15, align 16
  %66 = load i1, ptr %15, align 1
  switch i1 %66, label %67 [
    i1 false, label %69
    i1 true, label %133
  ]

67:                                               ; preds = %44
  br i1 false, label %68, label %217

68:                                               ; preds = %67
  unreachable

69:                                               ; preds = %44
  %70 = load { i1, { i252 } }, ptr %15, align 16
  %71 = extractvalue { i1, { i252 } } %70, 1
  %72 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %73 = call ptr %72()
  %74 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 0)
  %75 = extractvalue { i252 } %71, 0
  %76 = extractvalue { ptr, i32, i32, i32 } %24, 3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %78, label %92

78:                                               ; preds = %69
  %79 = shl i32 %76, 1
  %80 = call i32 @llvm.umin.i32(i32 %79, i32 1024)
  %81 = add i32 %80, %76
  %82 = call i32 @llvm.umax.i32(i32 %81, i32 8)
  %83 = zext i32 %82 to i64
  %84 = mul i64 %83, 32
  %85 = add i64 %84, 16
  %86 = call ptr @realloc(ptr null, i64 %85)
  store i32 1, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %86, i32 4
  store i32 0, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %86, i32 16
  %89 = call ptr @realloc(ptr null, i64 8)
  store ptr %88, ptr %89, align 8
  %90 = insertvalue { ptr, i32, i32, i32 } %24, ptr %89, 0
  %91 = insertvalue { ptr, i32, i32, i32 } %90, i32 %82, 3
  br label %113

92:                                               ; preds = %69
  %93 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %94 = icmp ult i32 %93, %76
  br i1 %94, label %95, label %96

95:                                               ; preds = %92
  br label %110

96:                                               ; preds = %92
  %97 = shl i32 %76, 1
  %98 = call i32 @llvm.umin.i32(i32 %97, i32 1024)
  %99 = add i32 %98, %76
  %100 = call i32 @llvm.umax.i32(i32 %99, i32 8)
  %101 = zext i32 %100 to i64
  %102 = mul i64 %101, 32
  %103 = add i64 %102, 16
  %104 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %105 = load ptr, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %105, i32 -16
  %107 = call ptr @realloc(ptr %106, i64 %103)
  %108 = getelementptr inbounds i8, ptr %107, i32 16
  store ptr %108, ptr %104, align 8
  %109 = insertvalue { ptr, i32, i32, i32 } %24, i32 %100, 3
  br label %110

110:                                              ; preds = %95, %96
  %111 = phi { ptr, i32, i32, i32 } [ %109, %96 ], [ %24, %95 ]
  br label %112

112:                                              ; preds = %110
  br label %113

113:                                              ; preds = %78, %112
  %114 = phi { ptr, i32, i32, i32 } [ %111, %112 ], [ %91, %78 ]
  br label %115

115:                                              ; preds = %113
  %116 = extractvalue { ptr, i32, i32, i32 } %114, 0
  %117 = load ptr, ptr %116, align 8
  %118 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %119 = zext i32 %118 to i64
  %120 = mul i64 %119, 32
  %121 = getelementptr inbounds i8, ptr %117, i64 %120
  store i252 %75, ptr %121, align 16
  %122 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %123 = add i32 %122, 1
  %124 = insertvalue { ptr, i32, i32, i32 } %114, i32 %123, 2
  %125 = getelementptr inbounds i8, ptr %117, i32 -12
  store i32 %123, ptr %125, align 4
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %51, 0
  %127 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } undef, { { ptr, i32, i32, i32 } } %126, 0
  %128 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %127, { { {} }, i32 } %38, 1
  %129 = extractvalue { ptr, ptr, i64 } %11, 1
  %130 = load i64, ptr %129, align 8
  %131 = add i64 %130, 1
  %132 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %131, ptr %132, align 8
  br label %17

133:                                              ; preds = %44
  %134 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %135 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %134, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %51)
  call void @"drop$26"({ ptr, i32, i32, i32 } %24)
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %16, align 8
  %137 = load { i64, [56 x i8] }, ptr %16, align 8
  %138 = extractvalue { ptr, ptr, i64 } %11, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %162, label %143

143:                                              ; preds = %143, %133, %169, %199
  %144 = phi i64 [ %25, %199 ], [ %25, %169 ], [ %144, %143 ], [ %60, %133 ]
  %145 = phi i64 [ %19, %199 ], [ %178, %169 ], [ %145, %143 ], [ %61, %133 ]
  %146 = phi i64 [ %20, %199 ], [ %20, %169 ], [ %146, %143 ], [ %62, %133 ]
  %147 = phi i64 [ %21, %199 ], [ %21, %169 ], [ %147, %143 ], [ %63, %133 ]
  %148 = phi ptr [ %22, %199 ], [ %22, %169 ], [ %148, %143 ], [ %64, %133 ]
  %149 = phi { i64, [56 x i8] } [ %204, %199 ], [ %186, %169 ], [ %149, %143 ], [ %137, %133 ]
  %150 = extractvalue { ptr, ptr, i64 } %11, 1
  %151 = load i64, ptr %150, align 8
  %152 = icmp eq i64 %151, 0
  %153 = sub i64 %151, 1
  %154 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %153, ptr %154, align 8
  br i1 %152, label %155, label %143

155:                                              ; preds = %143
  %156 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } undef, i64 %144, 0
  %157 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %156, i64 %145, 1
  %158 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %157, i64 %146, 2
  %159 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %158, i64 %147, 3
  %160 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %159, ptr %148, 4
  %161 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %160, { i64, [56 x i8] } %149, 5
  ret { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %161

162:                                              ; preds = %133
  %163 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } undef, i64 %60, 0
  %164 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %163, i64 %61, 1
  %165 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %164, i64 %62, 2
  %166 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %165, i64 %63, 3
  %167 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %166, ptr %64, 4
  %168 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %167, { i64, [56 x i8] } %137, 5
  ret { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %168

169:                                              ; preds = %35
  %170 = phi i64 [ %34, %35 ]
  %171 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %172 = call ptr %171()
  %173 = getelementptr inbounds i64, ptr %172, i32 1
  %174 = load i64, ptr %173, align 8
  %175 = load i64, ptr %172, align 8
  %176 = mul i64 %175, 22650
  %177 = add i64 %174, %176
  %178 = call i64 @llvm.uadd.sat.i64(i64 %170, i64 %177)
  %179 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %39, 0
  %180 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } undef, { { ptr, i32, i32, i32 } } %179, 0
  %181 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %180, { { {} }, i32 } %38, 1
  %182 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %181, 0
  %183 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %182, { ptr, i32, i32, i32 } %24, 1
  %184 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %183, {} undef, 2
  %185 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } %184, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i32 } }, { ptr, i32, i32, i32 }, {} } } %185, ptr %14, align 8
  %186 = load { i64, [56 x i8] }, ptr %14, align 8
  %187 = extractvalue { ptr, ptr, i64 } %11, 1
  %188 = load i64, ptr %187, align 8
  %189 = icmp eq i64 %188, 0
  %190 = sub i64 %188, 1
  %191 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %190, ptr %191, align 8
  br i1 %189, label %192, label %143

192:                                              ; preds = %169
  %193 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } undef, i64 %25, 0
  %194 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %193, i64 %178, 1
  %195 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %194, i64 %20, 2
  %196 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %195, i64 %21, 3
  %197 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %196, ptr %22, 4
  %198 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %197, { i64, [56 x i8] } %186, 5
  ret { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %198

199:                                              ; preds = %17
  %200 = phi { ptr, i32, i32, i32 } [ %24, %17 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %200)
  call void @"drop$323"({ { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %23)
  %201 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %202 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %201, 0
  %203 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %202, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %203, ptr %13, align 8
  %204 = load { i64, [56 x i8] }, ptr %13, align 8
  %205 = extractvalue { ptr, ptr, i64 } %11, 1
  %206 = load i64, ptr %205, align 8
  %207 = icmp eq i64 %206, 0
  %208 = sub i64 %206, 1
  %209 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %208, ptr %209, align 8
  br i1 %207, label %210, label %143

210:                                              ; preds = %199
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } undef, i64 %25, 0
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %211, i64 %19, 1
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %212, i64 %20, 2
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %213, i64 %21, 3
  %215 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %214, ptr %22, 4
  %216 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %215, { i64, [56 x i8] } %204, 5
  ret { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %216

217:                                              ; preds = %67
  call void @puts(ptr @assert_msg_89)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } @f44(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } @"impl$f44"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %5, { ptr, i32, i32, i32 } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %19, { i64, [56 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %20
}

define void @_mlir_ciface_f44(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %6, { ptr, i32, i32, i32 } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } @f44(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, { { {} }, i32 } } %6, { ptr, i32, i32, i32 } %7)
  store { i64, i64, i64, i64, ptr, { i64, [56 x i8] } } %9, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f45"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %117, %5
  %17 = phi i64 [ %71, %117 ], [ %0, %5 ]
  %18 = phi i64 [ %77, %117 ], [ %1, %5 ]
  %19 = phi { { ptr, i32, i32, i32 } } [ %134, %117 ], [ %2, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %126, %117 ], [ %3, %5 ]
  %21 = phi i252 [ %133, %117 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 2680
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %185

29:                                               ; preds = %16
  %30 = phi i252 [ %21, %16 ]
  %31 = icmp eq i252 %30, 0
  br i1 %31, label %32, label %54

32:                                               ; preds = %29
  %33 = phi i64 [ %28, %29 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = load i64, ptr %35, align 8
  %37 = mul i64 %36, 3580
  %38 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %37)
  %39 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %20, 1
  store { i1, { ptr, i32, i32, i32 } } %39, ptr %14, align 8
  %40 = load { i64, [24 x i8] }, ptr %14, align 8
  %41 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %19, 0
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %41, { i64, [24 x i8] } %40, 1
  %43 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %43, ptr %15, align 8
  %44 = load { i64, [56 x i8] }, ptr %15, align 8
  %45 = extractvalue { ptr, ptr, i64 } %9, 1
  %46 = load i64, ptr %45, align 8
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %46, 1
  %49 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %48, ptr %49, align 8
  br i1 %47, label %50, label %139

50:                                               ; preds = %32
  %51 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } %51, i64 %38, 1
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, { i64, [56 x i8] } %44, 2
  ret { i64, i64, { i64, [56 x i8] } } %53

54:                                               ; preds = %29
  %55 = phi { { ptr, i32, i32, i32 } } [ %19, %29 ]
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %159

61:                                               ; preds = %54
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %71 = add i64 %17, 4
  %72 = icmp ule i252 %70, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %72, label %73, label %152

73:                                               ; preds = %61
  %74 = trunc i252 %70 to i248
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 0)
  %78 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %94

80:                                               ; preds = %73
  %81 = shl i32 %78, 1
  %82 = call i32 @llvm.umin.i32(i32 %81, i32 1024)
  %83 = add i32 %82, %78
  %84 = call i32 @llvm.umax.i32(i32 %83, i32 8)
  %85 = zext i32 %84 to i64
  %86 = mul i64 %85, 32
  %87 = add i64 %86, 16
  %88 = call ptr @realloc(ptr null, i64 %87)
  store i32 1, ptr %88, align 4
  %89 = getelementptr inbounds i8, ptr %88, i32 4
  store i32 0, ptr %89, align 4
  %90 = getelementptr inbounds i8, ptr %88, i32 16
  %91 = call ptr @realloc(ptr null, i64 8)
  store ptr %90, ptr %91, align 8
  %92 = insertvalue { ptr, i32, i32, i32 } %20, ptr %91, 0
  %93 = insertvalue { ptr, i32, i32, i32 } %92, i32 %84, 3
  br label %115

94:                                               ; preds = %73
  %95 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %96 = icmp ult i32 %95, %78
  br i1 %96, label %97, label %98

97:                                               ; preds = %94
  br label %112

98:                                               ; preds = %94
  %99 = shl i32 %78, 1
  %100 = call i32 @llvm.umin.i32(i32 %99, i32 1024)
  %101 = add i32 %100, %78
  %102 = call i32 @llvm.umax.i32(i32 %101, i32 8)
  %103 = zext i32 %102 to i64
  %104 = mul i64 %103, 32
  %105 = add i64 %104, 16
  %106 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr inbounds i8, ptr %107, i32 -16
  %109 = call ptr @realloc(ptr %108, i64 %105)
  %110 = getelementptr inbounds i8, ptr %109, i32 16
  store ptr %110, ptr %106, align 8
  %111 = insertvalue { ptr, i32, i32, i32 } %20, i32 %102, 3
  br label %112

112:                                              ; preds = %97, %98
  %113 = phi { ptr, i32, i32, i32 } [ %111, %98 ], [ %20, %97 ]
  br label %114

114:                                              ; preds = %112
  br label %115

115:                                              ; preds = %80, %114
  %116 = phi { ptr, i32, i32, i32 } [ %113, %114 ], [ %93, %80 ]
  br label %117

117:                                              ; preds = %115
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %119 = load ptr, ptr %118, align 8
  %120 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %121 = zext i32 %120 to i64
  %122 = mul i64 %121, 32
  %123 = getelementptr inbounds i8, ptr %119, i64 %122
  store i248 %74, ptr %123, align 16
  %124 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %125 = add i32 %124, 1
  %126 = insertvalue { ptr, i32, i32, i32 } %116, i32 %125, 2
  %127 = getelementptr inbounds i8, ptr %119, i32 -12
  store i32 %125, ptr %127, align 4
  %128 = zext i252 %30 to i256
  %129 = sub i256 %128, 1
  %130 = add i256 %128, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %131 = icmp ult i256 %128, 1
  %132 = select i1 %131, i256 %130, i256 %129
  %133 = trunc i256 %132 to i252
  %134 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %135 = extractvalue { ptr, ptr, i64 } %9, 1
  %136 = load i64, ptr %135, align 8
  %137 = add i64 %136, 1
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %137, ptr %138, align 8
  br label %16

139:                                              ; preds = %139, %32, %166, %185
  %140 = phi i64 [ %22, %185 ], [ %167, %166 ], [ %140, %139 ], [ %22, %32 ]
  %141 = phi i64 [ %18, %185 ], [ %168, %166 ], [ %141, %139 ], [ %38, %32 ]
  %142 = phi { i64, [56 x i8] } [ %190, %185 ], [ %175, %166 ], [ %142, %139 ], [ %44, %32 ]
  %143 = extractvalue { ptr, ptr, i64 } %9, 1
  %144 = load i64, ptr %143, align 8
  %145 = icmp eq i64 %144, 0
  %146 = sub i64 %144, 1
  %147 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %146, ptr %147, align 8
  br i1 %145, label %148, label %139

148:                                              ; preds = %139
  %149 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %140, 0
  %150 = insertvalue { i64, i64, { i64, [56 x i8] } } %149, i64 %141, 1
  %151 = insertvalue { i64, i64, { i64, [56 x i8] } } %150, { i64, [56 x i8] } %142, 2
  ret { i64, i64, { i64, [56 x i8] } } %151

152:                                              ; preds = %61
  %153 = phi { ptr, i32, i32, i32 } [ %20, %61 ]
  call void @"drop$40"({ ptr, i32, i32, i32 } %153)
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = load i64, ptr %155, align 8
  %157 = mul i64 %156, 1670
  %158 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %157)
  br label %166

159:                                              ; preds = %54
  %160 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$40"({ ptr, i32, i32, i32 } %160)
  %161 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %162 = call ptr %161()
  %163 = load i64, ptr %162, align 8
  %164 = mul i64 %163, 2880
  %165 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %164)
  br label %166

166:                                              ; preds = %152, %159
  %167 = phi i64 [ %22, %159 ], [ %71, %152 ]
  %168 = phi i64 [ %165, %159 ], [ %158, %152 ]
  %169 = phi { ptr, i32, i32, i32 } [ %56, %159 ], [ %68, %152 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %170 = load { i64, [24 x i8] }, ptr %12, align 8
  %171 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %169, 0
  %172 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %171, 0
  %173 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %172, { i64, [24 x i8] } %170, 1
  %174 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %173, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %174, ptr %13, align 8
  %175 = load { i64, [56 x i8] }, ptr %13, align 8
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %139

181:                                              ; preds = %166
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %168, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184

185:                                              ; preds = %16
  %186 = phi { ptr, i32, i32, i32 } [ %20, %16 ]
  call void @"drop$40"({ ptr, i32, i32, i32 } %186)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %19)
  %187 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %188 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %187, 0
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %11, align 8
  %190 = load { i64, [56 x i8] }, ptr %11, align 8
  %191 = extractvalue { ptr, ptr, i64 } %9, 1
  %192 = load i64, ptr %191, align 8
  %193 = icmp eq i64 %192, 0
  %194 = sub i64 %192, 1
  %195 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %194, ptr %195, align 8
  br i1 %193, label %196, label %139

196:                                              ; preds = %185
  %197 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %198 = insertvalue { i64, i64, { i64, [56 x i8] } } %197, i64 %18, 1
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } %198, { i64, [56 x i8] } %190, 2
  ret { i64, i64, { i64, [56 x i8] } } %199
}

define private { i64, i64, { i64, [56 x i8] } } @f45(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f45"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f45(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f45(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$206"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, 1
  call void @"drop$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$206"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %10, ptr %2, align 16
  %11 = load { i128, [144 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %12, ptr %2, align 16
  %13 = load { i128, [144 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %11, 0
  %15 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %14, { i128, [144 x i8] } %13, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [144 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [144 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %20, 0
  %24 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %23, { i128, [144 x i8] } %22, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$207"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  call void @"drop$206"({ i128, [144 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$207"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  %9 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$206"({ i128, [144 x i8] } %8)
  %10 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 0
  %11 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6, { i128, [144 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %7, { i128, [144 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %15
}

define private void @"drop$208"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  call void @"drop$207"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [192 x i8] }, { i128, [192 x i8] } } @"dup$208"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$207"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [192 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [192 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %11, 0
  %15 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %14, { i128, [192 x i8] } %13, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [192 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [192 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %23, 0
  %27 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %26, { i128, [192 x i8] } %25, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [208 x i8] } } @"impl$f46"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [160 x i8] }, i64 1, align 16
  %5 = alloca { i128, [208 x i8] }, i64 1, align 16
  %6 = alloca { i128, [160 x i8] }, i64 1, align 16
  %7 = alloca { i128, [208 x i8] }, i64 1, align 16
  %8 = alloca { i128, [192 x i8] }, i64 1, align 16
  %9 = alloca { i128, [208 x i8] }, i64 1, align 16
  %10 = alloca { i128, [144 x i8] }, i64 1, align 16
  %11 = alloca { i128, [160 x i8] }, i64 1, align 16
  %12 = alloca { i128, [208 x i8] }, i64 1, align 16
  %13 = alloca { i128, [144 x i8] }, i64 1, align 16
  %14 = alloca { i128, [160 x i8] }, i64 1, align 16
  %15 = alloca { i128, [208 x i8] }, i64 1, align 16
  %16 = alloca { i128, [128 x i8] }, i64 1, align 16
  %17 = alloca { i128, [208 x i8] }, i64 1, align 16
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i128, [144 x i8] }, i64 1, align 16
  %20 = alloca { i128, [160 x i8] }, i64 1, align 16
  %21 = alloca { i128, [208 x i8] }, i64 1, align 16
  %22 = alloca { i128, [144 x i8] }, i64 1, align 16
  %23 = alloca { i128, [160 x i8] }, i64 1, align 16
  %24 = alloca { i128, [208 x i8] }, i64 1, align 16
  %25 = extractvalue { { ptr, i32, i32, i32 } } %2, 0
  %26 = extractvalue { ptr, i32, i32, i32 } %25, 1
  %27 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %28 = sub i32 %27, %26
  %29 = icmp uge i32 %28, 1
  br i1 %29, label %30, label %227

30:                                               ; preds = %3
  %31 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %32 = load ptr, ptr %31, align 8
  %33 = zext i32 %26 to i64
  %34 = mul i64 %33, 32
  %35 = getelementptr inbounds i8, ptr %32, i64 %34
  %36 = add i32 %26, 1
  %37 = insertvalue { ptr, i32, i32, i32 } %25, i32 %36, 1
  %38 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %38, ptr %35, i64 32, i1 false)
  %39 = load i252, ptr %38, align 16
  call void @free(ptr %38)
  %40 = icmp eq i252 %39, 0
  br i1 %40, label %41, label %81

41:                                               ; preds = %30
  %42 = phi { ptr, i32, i32, i32 } [ %37, %30 ]
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %74

47:                                               ; preds = %41
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  %56 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %57 = call ptr %56()
  %58 = load i64, ptr %57, align 8
  %59 = mul i64 %58, 22140
  %60 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %59)
  %61 = load i252, ptr %55, align 16
  call void @free(ptr %55)
  %62 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %54, 0
  %63 = insertvalue { i2, i252 } { i2 0, i252 undef }, i252 %61, 1
  store { i2, i252 } %63, ptr %22, align 16
  %64 = load { i128, [144 x i8] }, ptr %22, align 16
  %65 = insertvalue { i1, { i128, [144 x i8] } } { i1 false, { i128, [144 x i8] } undef }, { i128, [144 x i8] } %64, 1
  store { i1, { i128, [144 x i8] } } %65, ptr %23, align 16
  %66 = load { i128, [160 x i8] }, ptr %23, align 16
  %67 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %62, 0
  %68 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %67, { i128, [160 x i8] } %66, 1
  %69 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %68, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %69, ptr %24, align 16
  %70 = load { i128, [208 x i8] }, ptr %24, align 16
  %71 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %0, 0
  %72 = insertvalue { i64, i64, { i128, [208 x i8] } } %71, i64 %60, 1
  %73 = insertvalue { i64, i64, { i128, [208 x i8] } } %72, { i128, [208 x i8] } %70, 2
  ret { i64, i64, { i128, [208 x i8] } } %73

74:                                               ; preds = %41
  %75 = phi i64 [ %1, %41 ]
  %76 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %77 = call ptr %76()
  %78 = load i64, ptr %77, align 8
  %79 = mul i64 %78, 21640
  %80 = call i64 @llvm.uadd.sat.i64(i64 %75, i64 %79)
  br label %234

81:                                               ; preds = %30
  %82 = phi { ptr, i32, i32, i32 } [ %37, %30 ]
  %83 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %82, 0
  %84 = zext i252 %39 to i256
  %85 = sub i256 %84, 1
  %86 = add i256 %84, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %87 = icmp ult i256 %84, 1
  %88 = select i1 %87, i256 %86, i256 %85
  %89 = trunc i256 %88 to i252
  %90 = icmp eq i252 %89, 0
  br i1 %90, label %91, label %141

91:                                               ; preds = %81
  %92 = phi i64 [ %0, %81 ]
  %93 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f23"(i64 %92, i64 %1, { { ptr, i32, i32, i32 } } %83)
  %94 = extractvalue { i64, i64, { i128, [128 x i8] } } %93, 0
  %95 = extractvalue { i64, i64, { i128, [128 x i8] } } %93, 1
  %96 = extractvalue { i64, i64, { i128, [128 x i8] } } %93, 2
  store { i128, [128 x i8] } %96, ptr %16, align 16
  %97 = load i1, ptr %16, align 1
  switch i1 %97, label %98 [
    i1 false, label %100
    i1 true, label %106
  ]

98:                                               ; preds = %91
  br i1 false, label %99, label %247

99:                                               ; preds = %98
  unreachable

100:                                              ; preds = %91
  %101 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %16, align 16
  %102 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %101, 1
  %103 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %102, 0
  %104 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %102, 1
  store { i128, [80 x i8] } %104, ptr %18, align 16
  %105 = load i1, ptr %18, align 1
  switch i1 %105, label %114 [
    i1 false, label %116
    i1 true, label %135
  ]

106:                                              ; preds = %91
  %107 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %108 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %107, 1
  %109 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %108, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %109, ptr %17, align 8
  %110 = load { i128, [208 x i8] }, ptr %17, align 16
  %111 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %94, 0
  %112 = insertvalue { i64, i64, { i128, [208 x i8] } } %111, i64 %95, 1
  %113 = insertvalue { i64, i64, { i128, [208 x i8] } } %112, { i128, [208 x i8] } %110, 2
  ret { i64, i64, { i128, [208 x i8] } } %113

114:                                              ; preds = %100
  br i1 false, label %115, label %248

115:                                              ; preds = %114
  unreachable

116:                                              ; preds = %100
  %117 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %18, align 16
  %118 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %117, 1
  %119 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %120 = call ptr %119()
  %121 = load i64, ptr %120, align 8
  %122 = mul i64 %121, 14560
  %123 = call i64 @llvm.uadd.sat.i64(i64 %95, i64 %122)
  %124 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } { i2 1, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %118, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %124, ptr %19, align 16
  %125 = load { i128, [144 x i8] }, ptr %19, align 16
  %126 = insertvalue { i1, { i128, [144 x i8] } } { i1 false, { i128, [144 x i8] } undef }, { i128, [144 x i8] } %125, 1
  store { i1, { i128, [144 x i8] } } %126, ptr %20, align 16
  %127 = load { i128, [160 x i8] }, ptr %20, align 16
  %128 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %103, 0
  %129 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %128, { i128, [160 x i8] } %127, 1
  %130 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %129, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %130, ptr %21, align 16
  %131 = load { i128, [208 x i8] }, ptr %21, align 16
  %132 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %94, 0
  %133 = insertvalue { i64, i64, { i128, [208 x i8] } } %132, i64 %123, 1
  %134 = insertvalue { i64, i64, { i128, [208 x i8] } } %133, { i128, [208 x i8] } %131, 2
  ret { i64, i64, { i128, [208 x i8] } } %134

135:                                              ; preds = %100
  %136 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %137 = call ptr %136()
  %138 = load i64, ptr %137, align 8
  %139 = mul i64 %138, 14060
  %140 = call i64 @llvm.uadd.sat.i64(i64 %95, i64 %139)
  br label %200

141:                                              ; preds = %81
  %142 = phi i252 [ %39, %81 ]
  %143 = phi i252 [ 2, %81 ]
  %144 = zext i252 %142 to i256
  %145 = zext i252 %143 to i256
  %146 = sub i256 %144, %145
  %147 = add i256 %146, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %148 = icmp ult i256 %144, %145
  %149 = select i1 %148, i256 %147, i256 %146
  %150 = trunc i256 %149 to i252
  %151 = icmp eq i252 %150, 0
  br i1 %151, label %152, label %212

152:                                              ; preds = %141
  %153 = phi i64 [ %0, %141 ]
  %154 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f72"(i64 %153, i64 %1, { { ptr, i32, i32, i32 } } %83)
  %155 = extractvalue { i64, i64, { i128, [192 x i8] } } %154, 0
  %156 = extractvalue { i64, i64, { i128, [192 x i8] } } %154, 1
  %157 = extractvalue { i64, i64, { i128, [192 x i8] } } %154, 2
  store { i128, [192 x i8] } %157, ptr %8, align 16
  %158 = load i1, ptr %8, align 1
  switch i1 %158, label %159 [
    i1 false, label %161
    i1 true, label %167
  ]

159:                                              ; preds = %152
  br i1 false, label %160, label %249

160:                                              ; preds = %159
  unreachable

161:                                              ; preds = %152
  %162 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %8, align 16
  %163 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %162, 1
  %164 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %163, 0
  %165 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %163, 1
  store { i128, [144 x i8] } %165, ptr %10, align 16
  %166 = load i1, ptr %10, align 1
  switch i1 %166, label %175 [
    i1 false, label %177
    i1 true, label %196
  ]

167:                                              ; preds = %152
  %168 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %169 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %168, 1
  %170 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %169, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %170, ptr %9, align 8
  %171 = load { i128, [208 x i8] }, ptr %9, align 16
  %172 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %155, 0
  %173 = insertvalue { i64, i64, { i128, [208 x i8] } } %172, i64 %156, 1
  %174 = insertvalue { i64, i64, { i128, [208 x i8] } } %173, { i128, [208 x i8] } %171, 2
  ret { i64, i64, { i128, [208 x i8] } } %174

175:                                              ; preds = %161
  br i1 false, label %176, label %250

176:                                              ; preds = %175
  unreachable

177:                                              ; preds = %161
  %178 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %10, align 16
  %179 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %178, 1
  %180 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %181 = call ptr %180()
  %182 = load i64, ptr %181, align 8
  %183 = mul i64 %182, 400
  %184 = call i64 @llvm.uadd.sat.i64(i64 %156, i64 %183)
  %185 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } { i2 -2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %179, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %185, ptr %13, align 16
  %186 = load { i128, [144 x i8] }, ptr %13, align 16
  %187 = insertvalue { i1, { i128, [144 x i8] } } { i1 false, { i128, [144 x i8] } undef }, { i128, [144 x i8] } %186, 1
  store { i1, { i128, [144 x i8] } } %187, ptr %14, align 16
  %188 = load { i128, [160 x i8] }, ptr %14, align 16
  %189 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %164, 0
  %190 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %189, { i128, [160 x i8] } %188, 1
  %191 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %190, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %191, ptr %15, align 16
  %192 = load { i128, [208 x i8] }, ptr %15, align 16
  %193 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %155, 0
  %194 = insertvalue { i64, i64, { i128, [208 x i8] } } %193, i64 %184, 1
  %195 = insertvalue { i64, i64, { i128, [208 x i8] } } %194, { i128, [208 x i8] } %192, 2
  ret { i64, i64, { i128, [208 x i8] } } %195

196:                                              ; preds = %161
  %197 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %198 = call ptr %197()
  %199 = call i64 @llvm.uadd.sat.i64(i64 %156, i64 0)
  br label %200

200:                                              ; preds = %135, %196
  %201 = phi i64 [ %155, %196 ], [ %94, %135 ]
  %202 = phi i64 [ %199, %196 ], [ %140, %135 ]
  %203 = phi { { ptr, i32, i32, i32 } } [ %164, %196 ], [ %103, %135 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %11, align 1
  %204 = load { i128, [160 x i8] }, ptr %11, align 16
  %205 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %203, 0
  %206 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %205, { i128, [160 x i8] } %204, 1
  %207 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %206, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %207, ptr %12, align 16
  %208 = load { i128, [208 x i8] }, ptr %12, align 16
  %209 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %201, 0
  %210 = insertvalue { i64, i64, { i128, [208 x i8] } } %209, i64 %202, 1
  %211 = insertvalue { i64, i64, { i128, [208 x i8] } } %210, { i128, [208 x i8] } %208, 2
  ret { i64, i64, { i128, [208 x i8] } } %211

212:                                              ; preds = %141
  %213 = phi i64 [ %1, %141 ]
  %214 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %215 = call ptr %214()
  %216 = load i64, ptr %215, align 8
  %217 = mul i64 %216, 22140
  %218 = call i64 @llvm.uadd.sat.i64(i64 %213, i64 %217)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %6, align 1
  %219 = load { i128, [160 x i8] }, ptr %6, align 16
  %220 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %83, 0
  %221 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %220, { i128, [160 x i8] } %219, 1
  %222 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %221, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %222, ptr %7, align 16
  %223 = load { i128, [208 x i8] }, ptr %7, align 16
  %224 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %0, 0
  %225 = insertvalue { i64, i64, { i128, [208 x i8] } } %224, i64 %218, 1
  %226 = insertvalue { i64, i64, { i128, [208 x i8] } } %225, { i128, [208 x i8] } %223, 2
  ret { i64, i64, { i128, [208 x i8] } } %226

227:                                              ; preds = %3
  %228 = phi i64 [ %1, %3 ]
  %229 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %230 = call ptr %229()
  %231 = load i64, ptr %230, align 8
  %232 = mul i64 %231, 22340
  %233 = call i64 @llvm.uadd.sat.i64(i64 %228, i64 %232)
  br label %234

234:                                              ; preds = %74, %227
  %235 = phi i64 [ %0, %227 ], [ %0, %74 ]
  %236 = phi i64 [ %233, %227 ], [ %80, %74 ]
  %237 = phi { ptr, i32, i32, i32 } [ %25, %227 ], [ %42, %74 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %238 = load { i128, [160 x i8] }, ptr %4, align 16
  %239 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %237, 0
  %240 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %239, 0
  %241 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %240, { i128, [160 x i8] } %238, 1
  %242 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %241, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %242, ptr %5, align 16
  %243 = load { i128, [208 x i8] }, ptr %5, align 16
  %244 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %235, 0
  %245 = insertvalue { i64, i64, { i128, [208 x i8] } } %244, i64 %236, 1
  %246 = insertvalue { i64, i64, { i128, [208 x i8] } } %245, { i128, [208 x i8] } %243, 2
  ret { i64, i64, { i128, [208 x i8] } } %246

247:                                              ; preds = %98
  call void @puts(ptr @assert_msg_90)
  call void @abort()
  unreachable

248:                                              ; preds = %114
  call void @puts(ptr @assert_msg_91)
  call void @abort()
  unreachable

249:                                              ; preds = %159
  call void @puts(ptr @assert_msg_92)
  call void @abort()
  unreachable

250:                                              ; preds = %175
  call void @puts(ptr @assert_msg_93)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [208 x i8] } } @f46(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [208 x i8] } } @"impl$f46"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [208 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [208 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [208 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [208 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [208 x i8] } } %9, { i128, [208 x i8] } %7, 2
  ret { i64, i64, { i128, [208 x i8] } } %10
}

define void @_mlir_ciface_f46(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [208 x i8] } } @f46(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [208 x i8] } } %5, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f47"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4) {
  %6 = alloca { i1, [31 x i8] }, i64 1, align 8
  %7 = alloca i64, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca { i1, [47 x i8] }, i64 1, align 16
  %13 = alloca i64, i64 1, align 8
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i128, [80 x i8] }, i64 1, align 16
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = load ptr, ptr %3, align 8
  store i64 %1, ptr %7, align 8
  %21 = getelementptr inbounds ptr, ptr %3, i32 3
  %22 = load ptr, ptr %21, align 8
  call void %22(ptr %6, ptr %20, ptr %7)
  %23 = load { i1, [31 x i8] }, ptr %6, align 1
  %24 = extractvalue { i1, [31 x i8] } %23, 0
  %25 = getelementptr inbounds i8, ptr %6, i32 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr inbounds i8, ptr %6, i32 8
  %28 = load { ptr, i32, i32, i32 }, ptr %27, align 8
  %29 = load i64, ptr %7, align 8
  br i1 %24, label %140, label %30

30:                                               ; preds = %5
  %31 = phi ptr [ %26, %5 ]
  %32 = load { ptr, ptr, i252, i252, i252 }, ptr %31, align 16
  call void @free(ptr %31)
  %33 = extractvalue { ptr, ptr, i252, i252, i252 } %32, 0
  %34 = extractvalue { ptr, ptr, i252, i252, i252 } %32, 1
  %35 = extractvalue { ptr, ptr, i252, i252, i252 } %32, 2
  call void @"drop$258"(ptr %33)
  call void @"drop$257"(ptr %34)
  %36 = add i64 %2, 3
  %37 = zext i252 %35 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %9, align 16
  store i256 %37, ptr %10, align 16
  %38 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %38(ptr %11, ptr %9, ptr %10)
  %39 = load i256, ptr %11, align 16
  %40 = trunc i256 %39 to i252
  %41 = add i64 %0, 3
  %42 = sub i252 %40, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %43 = icmp ult i252 %40, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %44 = select i1 %43, i252 %40, i252 %42
  %45 = load ptr, ptr %3, align 8
  store i64 %29, ptr %13, align 8
  store i252 %44, ptr %14, align 16
  %46 = getelementptr inbounds ptr, ptr %3, i32 8
  %47 = load ptr, ptr %46, align 8
  call void %47(ptr %12, ptr %45, ptr %13, i32 0, ptr %14)
  %48 = load { i1, [47 x i8] }, ptr %12, align 1
  %49 = extractvalue { i1, [47 x i8] } %48, 0
  %50 = getelementptr inbounds i8, ptr %12, i32 16
  %51 = load i252, ptr %50, align 16
  %52 = getelementptr inbounds i8, ptr %12, i32 8
  %53 = load { ptr, i32, i32, i32 }, ptr %52, align 8
  %54 = load i64, ptr %13, align 8
  br i1 %49, label %128, label %55

55:                                               ; preds = %30
  %56 = phi i252 [ %51, %30 ]
  %57 = icmp eq i252 %56, 0
  br i1 %57, label %58, label %63

58:                                               ; preds = %55
  %59 = phi i64 [ %54, %55 ]
  %60 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %61 = call ptr %60()
  %62 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  br label %70

63:                                               ; preds = %55
  %64 = phi i64 [ %54, %55 ]
  %65 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %66 = call ptr %65()
  %67 = load i64, ptr %66, align 8
  %68 = mul i64 %67, 100
  %69 = call i64 @llvm.uadd.sat.i64(i64 %64, i64 %68)
  br label %70

70:                                               ; preds = %58, %63
  %71 = phi i64 [ %36, %63 ], [ %36, %58 ]
  %72 = phi ptr [ %3, %63 ], [ %3, %58 ]
  %73 = phi i64 [ %41, %63 ], [ %41, %58 ]
  %74 = phi i64 [ %69, %63 ], [ %62, %58 ]
  %75 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %63 ], [ { i1 true, [0 x i8] undef }, %58 ]
  %76 = extractvalue { i1, [0 x i8] } %75, 0
  %77 = xor i1 %76, true
  switch i1 %77, label %78 [
    i1 false, label %80
    i1 true, label %115
  ]

78:                                               ; preds = %70
  br i1 false, label %79, label %152

79:                                               ; preds = %78
  unreachable

80:                                               ; preds = %70
  %81 = call fastcc { i64, { i128, [80 x i8] } } @"impl$f59"(i64 %73, { { ptr, i32, i32, i32 }, i252, i32 } zeroinitializer, i252 25210060730641651003830129888238850617644299624277362, i32 22)
  %82 = extractvalue { i64, { i128, [80 x i8] } } %81, 0
  %83 = extractvalue { i64, { i128, [80 x i8] } } %81, 1
  store { i128, [80 x i8] } %83, ptr %17, align 16
  %84 = load i1, ptr %17, align 1
  switch i1 %84, label %85 [
    i1 false, label %87
    i1 true, label %105
  ]

85:                                               ; preds = %80
  br i1 false, label %86, label %153

86:                                               ; preds = %85
  unreachable

87:                                               ; preds = %80
  %88 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %17, align 16
  %89 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %88, 1
  %90 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %89, 0
  %91 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %90)
  %92 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %91, 0
  %93 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %91, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %92)
  %94 = call fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f60"(i64 %82, i64 %74, { { ptr, i32, i32, i32 }, i252, i32 } %93)
  %95 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %94, 0
  %96 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %94, 1
  %97 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %94, 2
  %98 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %97, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %98, ptr %19, align 8
  %99 = load { i64, [24 x i8] }, ptr %19, align 8
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %95, 0
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %96, 1
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, i64 %71, 2
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, ptr %72, 3
  %104 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %103, { i64, [24 x i8] } %99, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %104

105:                                              ; preds = %80
  %106 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %107 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %106, 1
  %108 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %107, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %108, ptr %18, align 8
  %109 = load { i64, [24 x i8] }, ptr %18, align 8
  %110 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %110, i64 %74, 1
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, i64 %71, 2
  %113 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %112, ptr %72, 3
  %114 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %113, { i64, [24 x i8] } %109, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %114

115:                                              ; preds = %70
  %116 = phi i64 [ %74, %70 ]
  %117 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %118 = call ptr %117()
  %119 = load i64, ptr %118, align 8
  %120 = mul i64 %119, 17910
  %121 = call i64 @llvm.uadd.sat.i64(i64 %116, i64 %120)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %16, align 1
  %122 = load { i64, [24 x i8] }, ptr %16, align 8
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %73, 0
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, i64 %121, 1
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, i64 %71, 2
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %125, ptr %72, 3
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, { i64, [24 x i8] } %122, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %127

128:                                              ; preds = %30
  %129 = phi {} [ undef, %30 ]
  %130 = phi { ptr, i32, i32, i32 } [ %53, %30 ]
  %131 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %129, 0
  %132 = insertvalue { {}, { ptr, i32, i32, i32 } } %131, { ptr, i32, i32, i32 } %130, 1
  %133 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %132, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %133, ptr %15, align 8
  %134 = load { i64, [24 x i8] }, ptr %15, align 8
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %41, 0
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %54, 1
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %36, 2
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, ptr %3, 3
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, { i64, [24 x i8] } %134, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %139

140:                                              ; preds = %5
  %141 = phi {} [ undef, %5 ]
  %142 = phi { ptr, i32, i32, i32 } [ %28, %5 ]
  %143 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %141, 0
  %144 = insertvalue { {}, { ptr, i32, i32, i32 } } %143, { ptr, i32, i32, i32 } %142, 1
  %145 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %144, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %145, ptr %8, align 8
  %146 = load { i64, [24 x i8] }, ptr %8, align 8
  %147 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %148 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, i64 %29, 1
  %149 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %148, i64 %2, 2
  %150 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, ptr %3, 3
  %151 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, { i64, [24 x i8] } %146, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %151

152:                                              ; preds = %78
  call void @puts(ptr @assert_msg_94)
  call void @abort()
  unreachable

153:                                              ; preds = %85
  call void @puts(ptr @assert_msg_95)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f47(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f47"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f47(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f47(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { { ptr, i32, i32, i32 } } @"impl$f48"(ptr %0, { ptr, i32, i32, i32 } %1) {
  %3 = alloca { i32, [4 x i8] }, i64 1, align 4
  %4 = load { i32, [4 x i8] }, ptr %0, align 4
  store { i32, [4 x i8] } %4, ptr %3, align 4
  %5 = load i3, ptr %3, align 1
  switch i3 %5, label %6 [
    i3 0, label %8
    i3 1, label %60
    i3 2, label %164
    i3 3, label %268
    i3 -4, label %372
    i3 -3, label %476
    i3 -2, label %580
  ]

6:                                                ; preds = %2
  br i1 false, label %7, label %684

7:                                                ; preds = %6
  unreachable

8:                                                ; preds = %2
  %9 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %25

11:                                               ; preds = %8
  %12 = shl i32 %9, 1
  %13 = call i32 @llvm.umin.i32(i32 %12, i32 1024)
  %14 = add i32 %13, %9
  %15 = call i32 @llvm.umax.i32(i32 %14, i32 8)
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 32
  %18 = add i64 %17, 16
  %19 = call ptr @realloc(ptr null, i64 %18)
  store i32 1, ptr %19, align 4
  %20 = getelementptr inbounds i8, ptr %19, i32 4
  store i32 0, ptr %20, align 4
  %21 = getelementptr inbounds i8, ptr %19, i32 16
  %22 = call ptr @realloc(ptr null, i64 8)
  store ptr %21, ptr %22, align 8
  %23 = insertvalue { ptr, i32, i32, i32 } %1, ptr %22, 0
  %24 = insertvalue { ptr, i32, i32, i32 } %23, i32 %15, 3
  br label %46

25:                                               ; preds = %8
  %26 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %27 = icmp ult i32 %26, %9
  br i1 %27, label %28, label %29

28:                                               ; preds = %25
  br label %43

29:                                               ; preds = %25
  %30 = shl i32 %9, 1
  %31 = call i32 @llvm.umin.i32(i32 %30, i32 1024)
  %32 = add i32 %31, %9
  %33 = call i32 @llvm.umax.i32(i32 %32, i32 8)
  %34 = zext i32 %33 to i64
  %35 = mul i64 %34, 32
  %36 = add i64 %35, 16
  %37 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr inbounds i8, ptr %38, i32 -16
  %40 = call ptr @realloc(ptr %39, i64 %36)
  %41 = getelementptr inbounds i8, ptr %40, i32 16
  store ptr %41, ptr %37, align 8
  %42 = insertvalue { ptr, i32, i32, i32 } %1, i32 %33, 3
  br label %43

43:                                               ; preds = %28, %29
  %44 = phi { ptr, i32, i32, i32 } [ %42, %29 ], [ %1, %28 ]
  br label %45

45:                                               ; preds = %43
  br label %46

46:                                               ; preds = %11, %45
  %47 = phi { ptr, i32, i32, i32 } [ %44, %45 ], [ %24, %11 ]
  br label %48

48:                                               ; preds = %46
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %50 = load ptr, ptr %49, align 8
  %51 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %52 = zext i32 %51 to i64
  %53 = mul i64 %52, 32
  %54 = getelementptr inbounds i8, ptr %50, i64 %53
  store i252 0, ptr %54, align 16
  %55 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %56 = add i32 %55, 1
  %57 = insertvalue { ptr, i32, i32, i32 } %47, i32 %56, 2
  %58 = getelementptr inbounds i8, ptr %50, i32 -12
  store i32 %56, ptr %58, align 4
  %59 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %57, 0
  ret { { ptr, i32, i32, i32 } } %59

60:                                               ; preds = %2
  %61 = load { i3, i32 }, ptr %3, align 4
  %62 = extractvalue { i3, i32 } %61, 1
  %63 = zext i32 %62 to i252
  %64 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %65 = icmp eq i32 %64, 0
  br i1 %65, label %66, label %80

66:                                               ; preds = %60
  %67 = shl i32 %64, 1
  %68 = call i32 @llvm.umin.i32(i32 %67, i32 1024)
  %69 = add i32 %68, %64
  %70 = call i32 @llvm.umax.i32(i32 %69, i32 8)
  %71 = zext i32 %70 to i64
  %72 = mul i64 %71, 32
  %73 = add i64 %72, 16
  %74 = call ptr @realloc(ptr null, i64 %73)
  store i32 1, ptr %74, align 4
  %75 = getelementptr inbounds i8, ptr %74, i32 4
  store i32 0, ptr %75, align 4
  %76 = getelementptr inbounds i8, ptr %74, i32 16
  %77 = call ptr @realloc(ptr null, i64 8)
  store ptr %76, ptr %77, align 8
  %78 = insertvalue { ptr, i32, i32, i32 } %1, ptr %77, 0
  %79 = insertvalue { ptr, i32, i32, i32 } %78, i32 %70, 3
  br label %101

80:                                               ; preds = %60
  %81 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %82 = icmp ult i32 %81, %64
  br i1 %82, label %83, label %84

83:                                               ; preds = %80
  br label %98

84:                                               ; preds = %80
  %85 = shl i32 %64, 1
  %86 = call i32 @llvm.umin.i32(i32 %85, i32 1024)
  %87 = add i32 %86, %64
  %88 = call i32 @llvm.umax.i32(i32 %87, i32 8)
  %89 = zext i32 %88 to i64
  %90 = mul i64 %89, 32
  %91 = add i64 %90, 16
  %92 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %93 = load ptr, ptr %92, align 8
  %94 = getelementptr inbounds i8, ptr %93, i32 -16
  %95 = call ptr @realloc(ptr %94, i64 %91)
  %96 = getelementptr inbounds i8, ptr %95, i32 16
  store ptr %96, ptr %92, align 8
  %97 = insertvalue { ptr, i32, i32, i32 } %1, i32 %88, 3
  br label %98

98:                                               ; preds = %83, %84
  %99 = phi { ptr, i32, i32, i32 } [ %97, %84 ], [ %1, %83 ]
  br label %100

100:                                              ; preds = %98
  br label %101

101:                                              ; preds = %66, %100
  %102 = phi { ptr, i32, i32, i32 } [ %99, %100 ], [ %79, %66 ]
  br label %103

103:                                              ; preds = %101
  %104 = extractvalue { ptr, i32, i32, i32 } %102, 0
  %105 = load ptr, ptr %104, align 8
  %106 = extractvalue { ptr, i32, i32, i32 } %102, 2
  %107 = zext i32 %106 to i64
  %108 = mul i64 %107, 32
  %109 = getelementptr inbounds i8, ptr %105, i64 %108
  store i252 1, ptr %109, align 16
  %110 = extractvalue { ptr, i32, i32, i32 } %102, 2
  %111 = add i32 %110, 1
  %112 = insertvalue { ptr, i32, i32, i32 } %102, i32 %111, 2
  %113 = getelementptr inbounds i8, ptr %105, i32 -12
  store i32 %111, ptr %113, align 4
  %114 = extractvalue { ptr, i32, i32, i32 } %102, 3
  %115 = icmp eq i32 %114, 0
  br i1 %115, label %116, label %130

116:                                              ; preds = %103
  %117 = shl i32 %114, 1
  %118 = call i32 @llvm.umin.i32(i32 %117, i32 1024)
  %119 = add i32 %118, %114
  %120 = call i32 @llvm.umax.i32(i32 %119, i32 8)
  %121 = zext i32 %120 to i64
  %122 = mul i64 %121, 32
  %123 = add i64 %122, 16
  %124 = call ptr @realloc(ptr null, i64 %123)
  store i32 1, ptr %124, align 4
  %125 = getelementptr inbounds i8, ptr %124, i32 4
  store i32 0, ptr %125, align 4
  %126 = getelementptr inbounds i8, ptr %124, i32 16
  %127 = call ptr @realloc(ptr null, i64 8)
  store ptr %126, ptr %127, align 8
  %128 = insertvalue { ptr, i32, i32, i32 } %112, ptr %127, 0
  %129 = insertvalue { ptr, i32, i32, i32 } %128, i32 %120, 3
  br label %150

130:                                              ; preds = %103
  %131 = icmp ult i32 %111, %114
  br i1 %131, label %132, label %133

132:                                              ; preds = %130
  br label %147

133:                                              ; preds = %130
  %134 = shl i32 %114, 1
  %135 = call i32 @llvm.umin.i32(i32 %134, i32 1024)
  %136 = add i32 %135, %114
  %137 = call i32 @llvm.umax.i32(i32 %136, i32 8)
  %138 = zext i32 %137 to i64
  %139 = mul i64 %138, 32
  %140 = add i64 %139, 16
  %141 = extractvalue { ptr, i32, i32, i32 } %102, 0
  %142 = load ptr, ptr %141, align 8
  %143 = getelementptr inbounds i8, ptr %142, i32 -16
  %144 = call ptr @realloc(ptr %143, i64 %140)
  %145 = getelementptr inbounds i8, ptr %144, i32 16
  store ptr %145, ptr %141, align 8
  %146 = insertvalue { ptr, i32, i32, i32 } %112, i32 %137, 3
  br label %147

147:                                              ; preds = %132, %133
  %148 = phi { ptr, i32, i32, i32 } [ %146, %133 ], [ %112, %132 ]
  br label %149

149:                                              ; preds = %147
  br label %150

150:                                              ; preds = %116, %149
  %151 = phi { ptr, i32, i32, i32 } [ %148, %149 ], [ %129, %116 ]
  br label %152

152:                                              ; preds = %150
  %153 = extractvalue { ptr, i32, i32, i32 } %151, 0
  %154 = load ptr, ptr %153, align 8
  %155 = extractvalue { ptr, i32, i32, i32 } %151, 2
  %156 = zext i32 %155 to i64
  %157 = mul i64 %156, 32
  %158 = getelementptr inbounds i8, ptr %154, i64 %157
  store i252 %63, ptr %158, align 16
  %159 = extractvalue { ptr, i32, i32, i32 } %151, 2
  %160 = add i32 %159, 1
  %161 = insertvalue { ptr, i32, i32, i32 } %151, i32 %160, 2
  %162 = getelementptr inbounds i8, ptr %154, i32 -12
  store i32 %160, ptr %162, align 4
  %163 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %161, 0
  ret { { ptr, i32, i32, i32 } } %163

164:                                              ; preds = %2
  %165 = load { i3, i32 }, ptr %3, align 4
  %166 = extractvalue { i3, i32 } %165, 1
  %167 = zext i32 %166 to i252
  %168 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %169 = icmp eq i32 %168, 0
  br i1 %169, label %170, label %184

170:                                              ; preds = %164
  %171 = shl i32 %168, 1
  %172 = call i32 @llvm.umin.i32(i32 %171, i32 1024)
  %173 = add i32 %172, %168
  %174 = call i32 @llvm.umax.i32(i32 %173, i32 8)
  %175 = zext i32 %174 to i64
  %176 = mul i64 %175, 32
  %177 = add i64 %176, 16
  %178 = call ptr @realloc(ptr null, i64 %177)
  store i32 1, ptr %178, align 4
  %179 = getelementptr inbounds i8, ptr %178, i32 4
  store i32 0, ptr %179, align 4
  %180 = getelementptr inbounds i8, ptr %178, i32 16
  %181 = call ptr @realloc(ptr null, i64 8)
  store ptr %180, ptr %181, align 8
  %182 = insertvalue { ptr, i32, i32, i32 } %1, ptr %181, 0
  %183 = insertvalue { ptr, i32, i32, i32 } %182, i32 %174, 3
  br label %205

184:                                              ; preds = %164
  %185 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %186 = icmp ult i32 %185, %168
  br i1 %186, label %187, label %188

187:                                              ; preds = %184
  br label %202

188:                                              ; preds = %184
  %189 = shl i32 %168, 1
  %190 = call i32 @llvm.umin.i32(i32 %189, i32 1024)
  %191 = add i32 %190, %168
  %192 = call i32 @llvm.umax.i32(i32 %191, i32 8)
  %193 = zext i32 %192 to i64
  %194 = mul i64 %193, 32
  %195 = add i64 %194, 16
  %196 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %197 = load ptr, ptr %196, align 8
  %198 = getelementptr inbounds i8, ptr %197, i32 -16
  %199 = call ptr @realloc(ptr %198, i64 %195)
  %200 = getelementptr inbounds i8, ptr %199, i32 16
  store ptr %200, ptr %196, align 8
  %201 = insertvalue { ptr, i32, i32, i32 } %1, i32 %192, 3
  br label %202

202:                                              ; preds = %187, %188
  %203 = phi { ptr, i32, i32, i32 } [ %201, %188 ], [ %1, %187 ]
  br label %204

204:                                              ; preds = %202
  br label %205

205:                                              ; preds = %170, %204
  %206 = phi { ptr, i32, i32, i32 } [ %203, %204 ], [ %183, %170 ]
  br label %207

207:                                              ; preds = %205
  %208 = extractvalue { ptr, i32, i32, i32 } %206, 0
  %209 = load ptr, ptr %208, align 8
  %210 = extractvalue { ptr, i32, i32, i32 } %206, 2
  %211 = zext i32 %210 to i64
  %212 = mul i64 %211, 32
  %213 = getelementptr inbounds i8, ptr %209, i64 %212
  store i252 2, ptr %213, align 16
  %214 = extractvalue { ptr, i32, i32, i32 } %206, 2
  %215 = add i32 %214, 1
  %216 = insertvalue { ptr, i32, i32, i32 } %206, i32 %215, 2
  %217 = getelementptr inbounds i8, ptr %209, i32 -12
  store i32 %215, ptr %217, align 4
  %218 = extractvalue { ptr, i32, i32, i32 } %206, 3
  %219 = icmp eq i32 %218, 0
  br i1 %219, label %220, label %234

220:                                              ; preds = %207
  %221 = shl i32 %218, 1
  %222 = call i32 @llvm.umin.i32(i32 %221, i32 1024)
  %223 = add i32 %222, %218
  %224 = call i32 @llvm.umax.i32(i32 %223, i32 8)
  %225 = zext i32 %224 to i64
  %226 = mul i64 %225, 32
  %227 = add i64 %226, 16
  %228 = call ptr @realloc(ptr null, i64 %227)
  store i32 1, ptr %228, align 4
  %229 = getelementptr inbounds i8, ptr %228, i32 4
  store i32 0, ptr %229, align 4
  %230 = getelementptr inbounds i8, ptr %228, i32 16
  %231 = call ptr @realloc(ptr null, i64 8)
  store ptr %230, ptr %231, align 8
  %232 = insertvalue { ptr, i32, i32, i32 } %216, ptr %231, 0
  %233 = insertvalue { ptr, i32, i32, i32 } %232, i32 %224, 3
  br label %254

234:                                              ; preds = %207
  %235 = icmp ult i32 %215, %218
  br i1 %235, label %236, label %237

236:                                              ; preds = %234
  br label %251

237:                                              ; preds = %234
  %238 = shl i32 %218, 1
  %239 = call i32 @llvm.umin.i32(i32 %238, i32 1024)
  %240 = add i32 %239, %218
  %241 = call i32 @llvm.umax.i32(i32 %240, i32 8)
  %242 = zext i32 %241 to i64
  %243 = mul i64 %242, 32
  %244 = add i64 %243, 16
  %245 = extractvalue { ptr, i32, i32, i32 } %206, 0
  %246 = load ptr, ptr %245, align 8
  %247 = getelementptr inbounds i8, ptr %246, i32 -16
  %248 = call ptr @realloc(ptr %247, i64 %244)
  %249 = getelementptr inbounds i8, ptr %248, i32 16
  store ptr %249, ptr %245, align 8
  %250 = insertvalue { ptr, i32, i32, i32 } %216, i32 %241, 3
  br label %251

251:                                              ; preds = %236, %237
  %252 = phi { ptr, i32, i32, i32 } [ %250, %237 ], [ %216, %236 ]
  br label %253

253:                                              ; preds = %251
  br label %254

254:                                              ; preds = %220, %253
  %255 = phi { ptr, i32, i32, i32 } [ %252, %253 ], [ %233, %220 ]
  br label %256

256:                                              ; preds = %254
  %257 = extractvalue { ptr, i32, i32, i32 } %255, 0
  %258 = load ptr, ptr %257, align 8
  %259 = extractvalue { ptr, i32, i32, i32 } %255, 2
  %260 = zext i32 %259 to i64
  %261 = mul i64 %260, 32
  %262 = getelementptr inbounds i8, ptr %258, i64 %261
  store i252 %167, ptr %262, align 16
  %263 = extractvalue { ptr, i32, i32, i32 } %255, 2
  %264 = add i32 %263, 1
  %265 = insertvalue { ptr, i32, i32, i32 } %255, i32 %264, 2
  %266 = getelementptr inbounds i8, ptr %258, i32 -12
  store i32 %264, ptr %266, align 4
  %267 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %265, 0
  ret { { ptr, i32, i32, i32 } } %267

268:                                              ; preds = %2
  %269 = load { i3, i32 }, ptr %3, align 4
  %270 = extractvalue { i3, i32 } %269, 1
  %271 = zext i32 %270 to i252
  %272 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %273 = icmp eq i32 %272, 0
  br i1 %273, label %274, label %288

274:                                              ; preds = %268
  %275 = shl i32 %272, 1
  %276 = call i32 @llvm.umin.i32(i32 %275, i32 1024)
  %277 = add i32 %276, %272
  %278 = call i32 @llvm.umax.i32(i32 %277, i32 8)
  %279 = zext i32 %278 to i64
  %280 = mul i64 %279, 32
  %281 = add i64 %280, 16
  %282 = call ptr @realloc(ptr null, i64 %281)
  store i32 1, ptr %282, align 4
  %283 = getelementptr inbounds i8, ptr %282, i32 4
  store i32 0, ptr %283, align 4
  %284 = getelementptr inbounds i8, ptr %282, i32 16
  %285 = call ptr @realloc(ptr null, i64 8)
  store ptr %284, ptr %285, align 8
  %286 = insertvalue { ptr, i32, i32, i32 } %1, ptr %285, 0
  %287 = insertvalue { ptr, i32, i32, i32 } %286, i32 %278, 3
  br label %309

288:                                              ; preds = %268
  %289 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %290 = icmp ult i32 %289, %272
  br i1 %290, label %291, label %292

291:                                              ; preds = %288
  br label %306

292:                                              ; preds = %288
  %293 = shl i32 %272, 1
  %294 = call i32 @llvm.umin.i32(i32 %293, i32 1024)
  %295 = add i32 %294, %272
  %296 = call i32 @llvm.umax.i32(i32 %295, i32 8)
  %297 = zext i32 %296 to i64
  %298 = mul i64 %297, 32
  %299 = add i64 %298, 16
  %300 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %301 = load ptr, ptr %300, align 8
  %302 = getelementptr inbounds i8, ptr %301, i32 -16
  %303 = call ptr @realloc(ptr %302, i64 %299)
  %304 = getelementptr inbounds i8, ptr %303, i32 16
  store ptr %304, ptr %300, align 8
  %305 = insertvalue { ptr, i32, i32, i32 } %1, i32 %296, 3
  br label %306

306:                                              ; preds = %291, %292
  %307 = phi { ptr, i32, i32, i32 } [ %305, %292 ], [ %1, %291 ]
  br label %308

308:                                              ; preds = %306
  br label %309

309:                                              ; preds = %274, %308
  %310 = phi { ptr, i32, i32, i32 } [ %307, %308 ], [ %287, %274 ]
  br label %311

311:                                              ; preds = %309
  %312 = extractvalue { ptr, i32, i32, i32 } %310, 0
  %313 = load ptr, ptr %312, align 8
  %314 = extractvalue { ptr, i32, i32, i32 } %310, 2
  %315 = zext i32 %314 to i64
  %316 = mul i64 %315, 32
  %317 = getelementptr inbounds i8, ptr %313, i64 %316
  store i252 3, ptr %317, align 16
  %318 = extractvalue { ptr, i32, i32, i32 } %310, 2
  %319 = add i32 %318, 1
  %320 = insertvalue { ptr, i32, i32, i32 } %310, i32 %319, 2
  %321 = getelementptr inbounds i8, ptr %313, i32 -12
  store i32 %319, ptr %321, align 4
  %322 = extractvalue { ptr, i32, i32, i32 } %310, 3
  %323 = icmp eq i32 %322, 0
  br i1 %323, label %324, label %338

324:                                              ; preds = %311
  %325 = shl i32 %322, 1
  %326 = call i32 @llvm.umin.i32(i32 %325, i32 1024)
  %327 = add i32 %326, %322
  %328 = call i32 @llvm.umax.i32(i32 %327, i32 8)
  %329 = zext i32 %328 to i64
  %330 = mul i64 %329, 32
  %331 = add i64 %330, 16
  %332 = call ptr @realloc(ptr null, i64 %331)
  store i32 1, ptr %332, align 4
  %333 = getelementptr inbounds i8, ptr %332, i32 4
  store i32 0, ptr %333, align 4
  %334 = getelementptr inbounds i8, ptr %332, i32 16
  %335 = call ptr @realloc(ptr null, i64 8)
  store ptr %334, ptr %335, align 8
  %336 = insertvalue { ptr, i32, i32, i32 } %320, ptr %335, 0
  %337 = insertvalue { ptr, i32, i32, i32 } %336, i32 %328, 3
  br label %358

338:                                              ; preds = %311
  %339 = icmp ult i32 %319, %322
  br i1 %339, label %340, label %341

340:                                              ; preds = %338
  br label %355

341:                                              ; preds = %338
  %342 = shl i32 %322, 1
  %343 = call i32 @llvm.umin.i32(i32 %342, i32 1024)
  %344 = add i32 %343, %322
  %345 = call i32 @llvm.umax.i32(i32 %344, i32 8)
  %346 = zext i32 %345 to i64
  %347 = mul i64 %346, 32
  %348 = add i64 %347, 16
  %349 = extractvalue { ptr, i32, i32, i32 } %310, 0
  %350 = load ptr, ptr %349, align 8
  %351 = getelementptr inbounds i8, ptr %350, i32 -16
  %352 = call ptr @realloc(ptr %351, i64 %348)
  %353 = getelementptr inbounds i8, ptr %352, i32 16
  store ptr %353, ptr %349, align 8
  %354 = insertvalue { ptr, i32, i32, i32 } %320, i32 %345, 3
  br label %355

355:                                              ; preds = %340, %341
  %356 = phi { ptr, i32, i32, i32 } [ %354, %341 ], [ %320, %340 ]
  br label %357

357:                                              ; preds = %355
  br label %358

358:                                              ; preds = %324, %357
  %359 = phi { ptr, i32, i32, i32 } [ %356, %357 ], [ %337, %324 ]
  br label %360

360:                                              ; preds = %358
  %361 = extractvalue { ptr, i32, i32, i32 } %359, 0
  %362 = load ptr, ptr %361, align 8
  %363 = extractvalue { ptr, i32, i32, i32 } %359, 2
  %364 = zext i32 %363 to i64
  %365 = mul i64 %364, 32
  %366 = getelementptr inbounds i8, ptr %362, i64 %365
  store i252 %271, ptr %366, align 16
  %367 = extractvalue { ptr, i32, i32, i32 } %359, 2
  %368 = add i32 %367, 1
  %369 = insertvalue { ptr, i32, i32, i32 } %359, i32 %368, 2
  %370 = getelementptr inbounds i8, ptr %362, i32 -12
  store i32 %368, ptr %370, align 4
  %371 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %369, 0
  ret { { ptr, i32, i32, i32 } } %371

372:                                              ; preds = %2
  %373 = load { i3, i32 }, ptr %3, align 4
  %374 = extractvalue { i3, i32 } %373, 1
  %375 = zext i32 %374 to i252
  %376 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %377 = icmp eq i32 %376, 0
  br i1 %377, label %378, label %392

378:                                              ; preds = %372
  %379 = shl i32 %376, 1
  %380 = call i32 @llvm.umin.i32(i32 %379, i32 1024)
  %381 = add i32 %380, %376
  %382 = call i32 @llvm.umax.i32(i32 %381, i32 8)
  %383 = zext i32 %382 to i64
  %384 = mul i64 %383, 32
  %385 = add i64 %384, 16
  %386 = call ptr @realloc(ptr null, i64 %385)
  store i32 1, ptr %386, align 4
  %387 = getelementptr inbounds i8, ptr %386, i32 4
  store i32 0, ptr %387, align 4
  %388 = getelementptr inbounds i8, ptr %386, i32 16
  %389 = call ptr @realloc(ptr null, i64 8)
  store ptr %388, ptr %389, align 8
  %390 = insertvalue { ptr, i32, i32, i32 } %1, ptr %389, 0
  %391 = insertvalue { ptr, i32, i32, i32 } %390, i32 %382, 3
  br label %413

392:                                              ; preds = %372
  %393 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %394 = icmp ult i32 %393, %376
  br i1 %394, label %395, label %396

395:                                              ; preds = %392
  br label %410

396:                                              ; preds = %392
  %397 = shl i32 %376, 1
  %398 = call i32 @llvm.umin.i32(i32 %397, i32 1024)
  %399 = add i32 %398, %376
  %400 = call i32 @llvm.umax.i32(i32 %399, i32 8)
  %401 = zext i32 %400 to i64
  %402 = mul i64 %401, 32
  %403 = add i64 %402, 16
  %404 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %405 = load ptr, ptr %404, align 8
  %406 = getelementptr inbounds i8, ptr %405, i32 -16
  %407 = call ptr @realloc(ptr %406, i64 %403)
  %408 = getelementptr inbounds i8, ptr %407, i32 16
  store ptr %408, ptr %404, align 8
  %409 = insertvalue { ptr, i32, i32, i32 } %1, i32 %400, 3
  br label %410

410:                                              ; preds = %395, %396
  %411 = phi { ptr, i32, i32, i32 } [ %409, %396 ], [ %1, %395 ]
  br label %412

412:                                              ; preds = %410
  br label %413

413:                                              ; preds = %378, %412
  %414 = phi { ptr, i32, i32, i32 } [ %411, %412 ], [ %391, %378 ]
  br label %415

415:                                              ; preds = %413
  %416 = extractvalue { ptr, i32, i32, i32 } %414, 0
  %417 = load ptr, ptr %416, align 8
  %418 = extractvalue { ptr, i32, i32, i32 } %414, 2
  %419 = zext i32 %418 to i64
  %420 = mul i64 %419, 32
  %421 = getelementptr inbounds i8, ptr %417, i64 %420
  store i252 4, ptr %421, align 16
  %422 = extractvalue { ptr, i32, i32, i32 } %414, 2
  %423 = add i32 %422, 1
  %424 = insertvalue { ptr, i32, i32, i32 } %414, i32 %423, 2
  %425 = getelementptr inbounds i8, ptr %417, i32 -12
  store i32 %423, ptr %425, align 4
  %426 = extractvalue { ptr, i32, i32, i32 } %414, 3
  %427 = icmp eq i32 %426, 0
  br i1 %427, label %428, label %442

428:                                              ; preds = %415
  %429 = shl i32 %426, 1
  %430 = call i32 @llvm.umin.i32(i32 %429, i32 1024)
  %431 = add i32 %430, %426
  %432 = call i32 @llvm.umax.i32(i32 %431, i32 8)
  %433 = zext i32 %432 to i64
  %434 = mul i64 %433, 32
  %435 = add i64 %434, 16
  %436 = call ptr @realloc(ptr null, i64 %435)
  store i32 1, ptr %436, align 4
  %437 = getelementptr inbounds i8, ptr %436, i32 4
  store i32 0, ptr %437, align 4
  %438 = getelementptr inbounds i8, ptr %436, i32 16
  %439 = call ptr @realloc(ptr null, i64 8)
  store ptr %438, ptr %439, align 8
  %440 = insertvalue { ptr, i32, i32, i32 } %424, ptr %439, 0
  %441 = insertvalue { ptr, i32, i32, i32 } %440, i32 %432, 3
  br label %462

442:                                              ; preds = %415
  %443 = icmp ult i32 %423, %426
  br i1 %443, label %444, label %445

444:                                              ; preds = %442
  br label %459

445:                                              ; preds = %442
  %446 = shl i32 %426, 1
  %447 = call i32 @llvm.umin.i32(i32 %446, i32 1024)
  %448 = add i32 %447, %426
  %449 = call i32 @llvm.umax.i32(i32 %448, i32 8)
  %450 = zext i32 %449 to i64
  %451 = mul i64 %450, 32
  %452 = add i64 %451, 16
  %453 = extractvalue { ptr, i32, i32, i32 } %414, 0
  %454 = load ptr, ptr %453, align 8
  %455 = getelementptr inbounds i8, ptr %454, i32 -16
  %456 = call ptr @realloc(ptr %455, i64 %452)
  %457 = getelementptr inbounds i8, ptr %456, i32 16
  store ptr %457, ptr %453, align 8
  %458 = insertvalue { ptr, i32, i32, i32 } %424, i32 %449, 3
  br label %459

459:                                              ; preds = %444, %445
  %460 = phi { ptr, i32, i32, i32 } [ %458, %445 ], [ %424, %444 ]
  br label %461

461:                                              ; preds = %459
  br label %462

462:                                              ; preds = %428, %461
  %463 = phi { ptr, i32, i32, i32 } [ %460, %461 ], [ %441, %428 ]
  br label %464

464:                                              ; preds = %462
  %465 = extractvalue { ptr, i32, i32, i32 } %463, 0
  %466 = load ptr, ptr %465, align 8
  %467 = extractvalue { ptr, i32, i32, i32 } %463, 2
  %468 = zext i32 %467 to i64
  %469 = mul i64 %468, 32
  %470 = getelementptr inbounds i8, ptr %466, i64 %469
  store i252 %375, ptr %470, align 16
  %471 = extractvalue { ptr, i32, i32, i32 } %463, 2
  %472 = add i32 %471, 1
  %473 = insertvalue { ptr, i32, i32, i32 } %463, i32 %472, 2
  %474 = getelementptr inbounds i8, ptr %466, i32 -12
  store i32 %472, ptr %474, align 4
  %475 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %473, 0
  ret { { ptr, i32, i32, i32 } } %475

476:                                              ; preds = %2
  %477 = load { i3, i32 }, ptr %3, align 4
  %478 = extractvalue { i3, i32 } %477, 1
  %479 = zext i32 %478 to i252
  %480 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %481 = icmp eq i32 %480, 0
  br i1 %481, label %482, label %496

482:                                              ; preds = %476
  %483 = shl i32 %480, 1
  %484 = call i32 @llvm.umin.i32(i32 %483, i32 1024)
  %485 = add i32 %484, %480
  %486 = call i32 @llvm.umax.i32(i32 %485, i32 8)
  %487 = zext i32 %486 to i64
  %488 = mul i64 %487, 32
  %489 = add i64 %488, 16
  %490 = call ptr @realloc(ptr null, i64 %489)
  store i32 1, ptr %490, align 4
  %491 = getelementptr inbounds i8, ptr %490, i32 4
  store i32 0, ptr %491, align 4
  %492 = getelementptr inbounds i8, ptr %490, i32 16
  %493 = call ptr @realloc(ptr null, i64 8)
  store ptr %492, ptr %493, align 8
  %494 = insertvalue { ptr, i32, i32, i32 } %1, ptr %493, 0
  %495 = insertvalue { ptr, i32, i32, i32 } %494, i32 %486, 3
  br label %517

496:                                              ; preds = %476
  %497 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %498 = icmp ult i32 %497, %480
  br i1 %498, label %499, label %500

499:                                              ; preds = %496
  br label %514

500:                                              ; preds = %496
  %501 = shl i32 %480, 1
  %502 = call i32 @llvm.umin.i32(i32 %501, i32 1024)
  %503 = add i32 %502, %480
  %504 = call i32 @llvm.umax.i32(i32 %503, i32 8)
  %505 = zext i32 %504 to i64
  %506 = mul i64 %505, 32
  %507 = add i64 %506, 16
  %508 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %509 = load ptr, ptr %508, align 8
  %510 = getelementptr inbounds i8, ptr %509, i32 -16
  %511 = call ptr @realloc(ptr %510, i64 %507)
  %512 = getelementptr inbounds i8, ptr %511, i32 16
  store ptr %512, ptr %508, align 8
  %513 = insertvalue { ptr, i32, i32, i32 } %1, i32 %504, 3
  br label %514

514:                                              ; preds = %499, %500
  %515 = phi { ptr, i32, i32, i32 } [ %513, %500 ], [ %1, %499 ]
  br label %516

516:                                              ; preds = %514
  br label %517

517:                                              ; preds = %482, %516
  %518 = phi { ptr, i32, i32, i32 } [ %515, %516 ], [ %495, %482 ]
  br label %519

519:                                              ; preds = %517
  %520 = extractvalue { ptr, i32, i32, i32 } %518, 0
  %521 = load ptr, ptr %520, align 8
  %522 = extractvalue { ptr, i32, i32, i32 } %518, 2
  %523 = zext i32 %522 to i64
  %524 = mul i64 %523, 32
  %525 = getelementptr inbounds i8, ptr %521, i64 %524
  store i252 5, ptr %525, align 16
  %526 = extractvalue { ptr, i32, i32, i32 } %518, 2
  %527 = add i32 %526, 1
  %528 = insertvalue { ptr, i32, i32, i32 } %518, i32 %527, 2
  %529 = getelementptr inbounds i8, ptr %521, i32 -12
  store i32 %527, ptr %529, align 4
  %530 = extractvalue { ptr, i32, i32, i32 } %518, 3
  %531 = icmp eq i32 %530, 0
  br i1 %531, label %532, label %546

532:                                              ; preds = %519
  %533 = shl i32 %530, 1
  %534 = call i32 @llvm.umin.i32(i32 %533, i32 1024)
  %535 = add i32 %534, %530
  %536 = call i32 @llvm.umax.i32(i32 %535, i32 8)
  %537 = zext i32 %536 to i64
  %538 = mul i64 %537, 32
  %539 = add i64 %538, 16
  %540 = call ptr @realloc(ptr null, i64 %539)
  store i32 1, ptr %540, align 4
  %541 = getelementptr inbounds i8, ptr %540, i32 4
  store i32 0, ptr %541, align 4
  %542 = getelementptr inbounds i8, ptr %540, i32 16
  %543 = call ptr @realloc(ptr null, i64 8)
  store ptr %542, ptr %543, align 8
  %544 = insertvalue { ptr, i32, i32, i32 } %528, ptr %543, 0
  %545 = insertvalue { ptr, i32, i32, i32 } %544, i32 %536, 3
  br label %566

546:                                              ; preds = %519
  %547 = icmp ult i32 %527, %530
  br i1 %547, label %548, label %549

548:                                              ; preds = %546
  br label %563

549:                                              ; preds = %546
  %550 = shl i32 %530, 1
  %551 = call i32 @llvm.umin.i32(i32 %550, i32 1024)
  %552 = add i32 %551, %530
  %553 = call i32 @llvm.umax.i32(i32 %552, i32 8)
  %554 = zext i32 %553 to i64
  %555 = mul i64 %554, 32
  %556 = add i64 %555, 16
  %557 = extractvalue { ptr, i32, i32, i32 } %518, 0
  %558 = load ptr, ptr %557, align 8
  %559 = getelementptr inbounds i8, ptr %558, i32 -16
  %560 = call ptr @realloc(ptr %559, i64 %556)
  %561 = getelementptr inbounds i8, ptr %560, i32 16
  store ptr %561, ptr %557, align 8
  %562 = insertvalue { ptr, i32, i32, i32 } %528, i32 %553, 3
  br label %563

563:                                              ; preds = %548, %549
  %564 = phi { ptr, i32, i32, i32 } [ %562, %549 ], [ %528, %548 ]
  br label %565

565:                                              ; preds = %563
  br label %566

566:                                              ; preds = %532, %565
  %567 = phi { ptr, i32, i32, i32 } [ %564, %565 ], [ %545, %532 ]
  br label %568

568:                                              ; preds = %566
  %569 = extractvalue { ptr, i32, i32, i32 } %567, 0
  %570 = load ptr, ptr %569, align 8
  %571 = extractvalue { ptr, i32, i32, i32 } %567, 2
  %572 = zext i32 %571 to i64
  %573 = mul i64 %572, 32
  %574 = getelementptr inbounds i8, ptr %570, i64 %573
  store i252 %479, ptr %574, align 16
  %575 = extractvalue { ptr, i32, i32, i32 } %567, 2
  %576 = add i32 %575, 1
  %577 = insertvalue { ptr, i32, i32, i32 } %567, i32 %576, 2
  %578 = getelementptr inbounds i8, ptr %570, i32 -12
  store i32 %576, ptr %578, align 4
  %579 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %577, 0
  ret { { ptr, i32, i32, i32 } } %579

580:                                              ; preds = %2
  %581 = load { i3, i32 }, ptr %3, align 4
  %582 = extractvalue { i3, i32 } %581, 1
  %583 = zext i32 %582 to i252
  %584 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %585 = icmp eq i32 %584, 0
  br i1 %585, label %586, label %600

586:                                              ; preds = %580
  %587 = shl i32 %584, 1
  %588 = call i32 @llvm.umin.i32(i32 %587, i32 1024)
  %589 = add i32 %588, %584
  %590 = call i32 @llvm.umax.i32(i32 %589, i32 8)
  %591 = zext i32 %590 to i64
  %592 = mul i64 %591, 32
  %593 = add i64 %592, 16
  %594 = call ptr @realloc(ptr null, i64 %593)
  store i32 1, ptr %594, align 4
  %595 = getelementptr inbounds i8, ptr %594, i32 4
  store i32 0, ptr %595, align 4
  %596 = getelementptr inbounds i8, ptr %594, i32 16
  %597 = call ptr @realloc(ptr null, i64 8)
  store ptr %596, ptr %597, align 8
  %598 = insertvalue { ptr, i32, i32, i32 } %1, ptr %597, 0
  %599 = insertvalue { ptr, i32, i32, i32 } %598, i32 %590, 3
  br label %621

600:                                              ; preds = %580
  %601 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %602 = icmp ult i32 %601, %584
  br i1 %602, label %603, label %604

603:                                              ; preds = %600
  br label %618

604:                                              ; preds = %600
  %605 = shl i32 %584, 1
  %606 = call i32 @llvm.umin.i32(i32 %605, i32 1024)
  %607 = add i32 %606, %584
  %608 = call i32 @llvm.umax.i32(i32 %607, i32 8)
  %609 = zext i32 %608 to i64
  %610 = mul i64 %609, 32
  %611 = add i64 %610, 16
  %612 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %613 = load ptr, ptr %612, align 8
  %614 = getelementptr inbounds i8, ptr %613, i32 -16
  %615 = call ptr @realloc(ptr %614, i64 %611)
  %616 = getelementptr inbounds i8, ptr %615, i32 16
  store ptr %616, ptr %612, align 8
  %617 = insertvalue { ptr, i32, i32, i32 } %1, i32 %608, 3
  br label %618

618:                                              ; preds = %603, %604
  %619 = phi { ptr, i32, i32, i32 } [ %617, %604 ], [ %1, %603 ]
  br label %620

620:                                              ; preds = %618
  br label %621

621:                                              ; preds = %586, %620
  %622 = phi { ptr, i32, i32, i32 } [ %619, %620 ], [ %599, %586 ]
  br label %623

623:                                              ; preds = %621
  %624 = extractvalue { ptr, i32, i32, i32 } %622, 0
  %625 = load ptr, ptr %624, align 8
  %626 = extractvalue { ptr, i32, i32, i32 } %622, 2
  %627 = zext i32 %626 to i64
  %628 = mul i64 %627, 32
  %629 = getelementptr inbounds i8, ptr %625, i64 %628
  store i252 6, ptr %629, align 16
  %630 = extractvalue { ptr, i32, i32, i32 } %622, 2
  %631 = add i32 %630, 1
  %632 = insertvalue { ptr, i32, i32, i32 } %622, i32 %631, 2
  %633 = getelementptr inbounds i8, ptr %625, i32 -12
  store i32 %631, ptr %633, align 4
  %634 = extractvalue { ptr, i32, i32, i32 } %622, 3
  %635 = icmp eq i32 %634, 0
  br i1 %635, label %636, label %650

636:                                              ; preds = %623
  %637 = shl i32 %634, 1
  %638 = call i32 @llvm.umin.i32(i32 %637, i32 1024)
  %639 = add i32 %638, %634
  %640 = call i32 @llvm.umax.i32(i32 %639, i32 8)
  %641 = zext i32 %640 to i64
  %642 = mul i64 %641, 32
  %643 = add i64 %642, 16
  %644 = call ptr @realloc(ptr null, i64 %643)
  store i32 1, ptr %644, align 4
  %645 = getelementptr inbounds i8, ptr %644, i32 4
  store i32 0, ptr %645, align 4
  %646 = getelementptr inbounds i8, ptr %644, i32 16
  %647 = call ptr @realloc(ptr null, i64 8)
  store ptr %646, ptr %647, align 8
  %648 = insertvalue { ptr, i32, i32, i32 } %632, ptr %647, 0
  %649 = insertvalue { ptr, i32, i32, i32 } %648, i32 %640, 3
  br label %670

650:                                              ; preds = %623
  %651 = icmp ult i32 %631, %634
  br i1 %651, label %652, label %653

652:                                              ; preds = %650
  br label %667

653:                                              ; preds = %650
  %654 = shl i32 %634, 1
  %655 = call i32 @llvm.umin.i32(i32 %654, i32 1024)
  %656 = add i32 %655, %634
  %657 = call i32 @llvm.umax.i32(i32 %656, i32 8)
  %658 = zext i32 %657 to i64
  %659 = mul i64 %658, 32
  %660 = add i64 %659, 16
  %661 = extractvalue { ptr, i32, i32, i32 } %622, 0
  %662 = load ptr, ptr %661, align 8
  %663 = getelementptr inbounds i8, ptr %662, i32 -16
  %664 = call ptr @realloc(ptr %663, i64 %660)
  %665 = getelementptr inbounds i8, ptr %664, i32 16
  store ptr %665, ptr %661, align 8
  %666 = insertvalue { ptr, i32, i32, i32 } %632, i32 %657, 3
  br label %667

667:                                              ; preds = %652, %653
  %668 = phi { ptr, i32, i32, i32 } [ %666, %653 ], [ %632, %652 ]
  br label %669

669:                                              ; preds = %667
  br label %670

670:                                              ; preds = %636, %669
  %671 = phi { ptr, i32, i32, i32 } [ %668, %669 ], [ %649, %636 ]
  br label %672

672:                                              ; preds = %670
  %673 = extractvalue { ptr, i32, i32, i32 } %671, 0
  %674 = load ptr, ptr %673, align 8
  %675 = extractvalue { ptr, i32, i32, i32 } %671, 2
  %676 = zext i32 %675 to i64
  %677 = mul i64 %676, 32
  %678 = getelementptr inbounds i8, ptr %674, i64 %677
  store i252 %583, ptr %678, align 16
  %679 = extractvalue { ptr, i32, i32, i32 } %671, 2
  %680 = add i32 %679, 1
  %681 = insertvalue { ptr, i32, i32, i32 } %671, i32 %680, 2
  %682 = getelementptr inbounds i8, ptr %674, i32 -12
  store i32 %680, ptr %682, align 4
  %683 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %681, 0
  ret { { ptr, i32, i32, i32 } } %683

684:                                              ; preds = %6
  call void @puts(ptr @assert_msg_96)
  call void @abort()
  unreachable
}

define private { ptr, i32, i32, i32 } @f48(ptr %0, { ptr, i32, i32, i32 } %1) {
  %3 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f48"(ptr %0, { ptr, i32, i32, i32 } %1)
  %4 = extractvalue { { ptr, i32, i32, i32 } } %3, 0
  ret { ptr, i32, i32, i32 } %4
}

define void @_mlir_ciface_f48(ptr %0, ptr %1, { ptr, i32, i32, i32 } %2) {
  %4 = call { ptr, i32, i32, i32 } @f48(ptr %1, { ptr, i32, i32, i32 } %2)
  store { ptr, i32, i32, i32 } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %0, i64 %1, i64 %2, ptr %3, { i252, i252, i252 } %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i128, [64 x i8] }, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca i256, i64 1, align 16
  %15 = alloca i256, i64 1, align 16
  %16 = alloca { i128, [64 x i8] }, i64 1, align 16
  %17 = alloca i256, i64 1, align 16
  %18 = alloca i256, i64 1, align 16
  %19 = alloca i256, i64 1, align 16
  %20 = alloca { i128, [64 x i8] }, i64 1, align 16
  %21 = alloca i256, i64 1, align 16
  %22 = alloca i256, i64 1, align 16
  %23 = alloca i256, i64 1, align 16
  br label %24

24:                                               ; preds = %104, %6
  %25 = phi i64 [ %99, %104 ], [ %0, %6 ]
  %26 = phi i64 [ %108, %104 ], [ %1, %6 ]
  %27 = phi i64 [ %88, %104 ], [ %2, %6 ]
  %28 = phi ptr [ %28, %104 ], [ %3, %6 ]
  %29 = phi { i252, i252, i252 } [ %111, %104 ], [ %4, %6 ]
  %30 = phi { { ptr, i32, i32, i32 } } [ %112, %104 ], [ %5, %6 ]
  %31 = add i64 %25, 1
  %32 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %33 = call ptr %32()
  %34 = getelementptr inbounds i64, ptr %33, i32 4
  %35 = load i64, ptr %34, align 8
  %36 = load i64, ptr %33, align 8
  %37 = mul i64 %36, 1770
  %38 = add i64 %35, %37
  %39 = icmp uge i64 %26, %38
  %40 = call i64 @llvm.usub.sat.i64(i64 %26, i64 %38)
  br i1 %39, label %41, label %214

41:                                               ; preds = %24
  %42 = phi { i252, i252, i252 } [ %29, %24 ]
  %43 = extractvalue { i252, i252, i252 } %42, 0
  %44 = extractvalue { i252, i252, i252 } %42, 1
  %45 = extractvalue { i252, i252, i252 } %42, 2
  %46 = extractvalue { { ptr, i32, i32, i32 } } %30, 0
  %47 = extractvalue { ptr, i32, i32, i32 } %46, 1
  %48 = extractvalue { ptr, i32, i32, i32 } %46, 2
  %49 = sub i32 %48, %47
  %50 = icmp uge i32 %49, 1
  br i1 %50, label %51, label %179

51:                                               ; preds = %41
  %52 = extractvalue { ptr, i32, i32, i32 } %46, 0
  %53 = load ptr, ptr %52, align 8
  %54 = zext i32 %47 to i64
  %55 = mul i64 %54, 32
  %56 = getelementptr inbounds i8, ptr %53, i64 %55
  %57 = add i32 %47, 1
  %58 = insertvalue { ptr, i32, i32, i32 } %46, i32 %57, 1
  %59 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %59, ptr %56, i64 32, i1 false)
  %60 = load i252, ptr %59, align 16
  call void @free(ptr %59)
  %61 = extractvalue { ptr, i32, i32, i32 } %46, 2
  %62 = sub i32 %61, %57
  %63 = icmp uge i32 %62, 1
  br i1 %63, label %64, label %137

64:                                               ; preds = %51
  %65 = extractvalue { ptr, i32, i32, i32 } %46, 0
  %66 = load ptr, ptr %65, align 8
  %67 = zext i32 %57 to i64
  %68 = mul i64 %67, 32
  %69 = getelementptr inbounds i8, ptr %66, i64 %68
  %70 = add i32 %47, 2
  %71 = insertvalue { ptr, i32, i32, i32 } %58, i32 %70, 1
  %72 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %72, ptr %69, i64 32, i1 false)
  %73 = load i252, ptr %72, align 16
  call void @free(ptr %72)
  %74 = zext i252 %43 to i256
  %75 = zext i252 %60 to i256
  %76 = add i256 %74, %75
  %77 = sub i256 %76, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %78 = icmp uge i256 %76, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %79 = select i1 %78, i256 %77, i256 %76
  %80 = trunc i256 %79 to i252
  %81 = zext i252 %44 to i256
  %82 = zext i252 %73 to i256
  %83 = add i256 %81, %82
  %84 = sub i256 %83, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %85 = icmp uge i256 %83, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %86 = select i1 %85, i256 %84, i256 %83
  %87 = trunc i256 %86 to i252
  %88 = add i64 %27, 6
  %89 = zext i252 %80 to i256
  %90 = zext i252 %87 to i256
  %91 = zext i252 %45 to i256
  store i256 %89, ptr %21, align 16
  store i256 %90, ptr %22, align 16
  store i256 %91, ptr %23, align 16
  %92 = load ptr, ptr @cairo_native__libfunc__hades_permutation, align 8
  call void %92(ptr %21, ptr %22, ptr %23)
  %93 = load i256, ptr %21, align 16
  %94 = load i256, ptr %22, align 16
  %95 = load i256, ptr %23, align 16
  %96 = trunc i256 %93 to i252
  %97 = trunc i256 %94 to i252
  %98 = trunc i256 %95 to i252
  %99 = add i64 %25, 2
  %100 = load i64, ptr %28, align 8
  %101 = mul i64 %100, 1970
  %102 = icmp uge i64 %40, %101
  %103 = call i64 @llvm.usub.sat.i64(i64 %40, i64 %101)
  br i1 %102, label %104, label %132

104:                                              ; preds = %64
  %105 = phi i64 [ %103, %64 ]
  %106 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %107 = call ptr %106()
  %108 = call i64 @llvm.uadd.sat.i64(i64 %105, i64 0)
  %109 = insertvalue { i252, i252, i252 } undef, i252 %96, 0
  %110 = insertvalue { i252, i252, i252 } %109, i252 %97, 1
  %111 = insertvalue { i252, i252, i252 } %110, i252 %98, 2
  %112 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %71, 0
  %113 = extractvalue { ptr, ptr, i64 } %10, 1
  %114 = load i64, ptr %113, align 8
  %115 = add i64 %114, 1
  %116 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %115, ptr %116, align 8
  br label %24

117:                                              ; preds = %117, %219, %137, %179
  %118 = phi i64 [ %220, %219 ], [ %31, %179 ], [ %31, %137 ], [ %118, %117 ]
  %119 = phi i64 [ %221, %219 ], [ %185, %179 ], [ %143, %137 ], [ %119, %117 ]
  %120 = phi i64 [ %222, %219 ], [ %192, %179 ], [ %157, %137 ], [ %120, %117 ]
  %121 = phi { i128, [64 x i8] } [ %226, %219 ], [ %203, %179 ], [ %168, %137 ], [ %121, %117 ]
  %122 = extractvalue { ptr, ptr, i64 } %10, 1
  %123 = load i64, ptr %122, align 8
  %124 = icmp eq i64 %123, 0
  %125 = sub i64 %123, 1
  %126 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %125, ptr %126, align 8
  br i1 %124, label %127, label %117

127:                                              ; preds = %117
  %128 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } undef, i64 %118, 0
  %129 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %128, i64 %119, 1
  %130 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %129, i64 %120, 2
  %131 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %130, { i128, [64 x i8] } %121, 3
  ret { i64, i64, i64, { i128, [64 x i8] } } %131

132:                                              ; preds = %64
  %133 = phi { ptr, i32, i32, i32 } [ %71, %64 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %133)
  %134 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %135 = call ptr %134()
  %136 = call i64 @llvm.uadd.sat.i64(i64 %40, i64 0)
  br label %219

137:                                              ; preds = %51
  %138 = phi i64 [ %40, %51 ]
  %139 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %140 = call ptr %139()
  %141 = load i64, ptr %140, align 8
  %142 = mul i64 %141, 1870
  %143 = call i64 @llvm.uadd.sat.i64(i64 %138, i64 %142)
  %144 = zext i252 %43 to i256
  %145 = zext i252 %60 to i256
  %146 = add i256 %144, %145
  %147 = sub i256 %146, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %148 = icmp uge i256 %146, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %149 = select i1 %148, i256 %147, i256 %146
  %150 = trunc i256 %149 to i252
  %151 = zext i252 %44 to i256
  %152 = add i256 %151, 1
  %153 = add i256 %151, -3618502788666131213697322783095070105623107215331596699973092056135872020480
  %154 = icmp uge i256 %152, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %155 = select i1 %154, i256 %153, i256 %152
  %156 = trunc i256 %155 to i252
  %157 = add i64 %27, 6
  %158 = zext i252 %150 to i256
  %159 = zext i252 %156 to i256
  %160 = zext i252 %45 to i256
  store i256 %158, ptr %17, align 16
  store i256 %159, ptr %18, align 16
  store i256 %160, ptr %19, align 16
  %161 = load ptr, ptr @cairo_native__libfunc__hades_permutation, align 8
  call void %161(ptr %17, ptr %18, ptr %19)
  %162 = load i256, ptr %17, align 16
  %163 = trunc i256 %162 to i252
  %164 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 0
  %165 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } undef, { { ptr, i32, i32, i32 } } %164, 0
  %166 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } %165, i252 %163, 1
  %167 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } { i1 false, { { { ptr, i32, i32, i32 } }, i252 } undef }, { { { ptr, i32, i32, i32 } }, i252 } %166, 1
  store { i1, { { { ptr, i32, i32, i32 } }, i252 } } %167, ptr %20, align 16
  %168 = load { i128, [64 x i8] }, ptr %20, align 16
  %169 = extractvalue { ptr, ptr, i64 } %10, 1
  %170 = load i64, ptr %169, align 8
  %171 = icmp eq i64 %170, 0
  %172 = sub i64 %170, 1
  %173 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %172, ptr %173, align 8
  br i1 %171, label %174, label %117

174:                                              ; preds = %137
  %175 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } undef, i64 %31, 0
  %176 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %175, i64 %143, 1
  %177 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %176, i64 %157, 2
  %178 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %177, { i128, [64 x i8] } %168, 3
  ret { i64, i64, i64, { i128, [64 x i8] } } %178

179:                                              ; preds = %41
  %180 = phi i64 [ %40, %41 ]
  %181 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %182 = call ptr %181()
  %183 = load i64, ptr %182, align 8
  %184 = mul i64 %183, 2470
  %185 = call i64 @llvm.uadd.sat.i64(i64 %180, i64 %184)
  %186 = zext i252 %43 to i256
  %187 = add i256 %186, 1
  %188 = add i256 %186, -3618502788666131213697322783095070105623107215331596699973092056135872020480
  %189 = icmp uge i256 %187, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %190 = select i1 %189, i256 %188, i256 %187
  %191 = trunc i256 %190 to i252
  %192 = add i64 %27, 6
  %193 = zext i252 %191 to i256
  %194 = zext i252 %44 to i256
  %195 = zext i252 %45 to i256
  store i256 %193, ptr %13, align 16
  store i256 %194, ptr %14, align 16
  store i256 %195, ptr %15, align 16
  %196 = load ptr, ptr @cairo_native__libfunc__hades_permutation, align 8
  call void %196(ptr %13, ptr %14, ptr %15)
  %197 = load i256, ptr %13, align 16
  %198 = trunc i256 %197 to i252
  %199 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %46, 0
  %200 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } undef, { { ptr, i32, i32, i32 } } %199, 0
  %201 = insertvalue { { { ptr, i32, i32, i32 } }, i252 } %200, i252 %198, 1
  %202 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } { i1 false, { { { ptr, i32, i32, i32 } }, i252 } undef }, { { { ptr, i32, i32, i32 } }, i252 } %201, 1
  store { i1, { { { ptr, i32, i32, i32 } }, i252 } } %202, ptr %16, align 16
  %203 = load { i128, [64 x i8] }, ptr %16, align 16
  %204 = extractvalue { ptr, ptr, i64 } %10, 1
  %205 = load i64, ptr %204, align 8
  %206 = icmp eq i64 %205, 0
  %207 = sub i64 %205, 1
  %208 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %207, ptr %208, align 8
  br i1 %206, label %209, label %117

209:                                              ; preds = %179
  %210 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } undef, i64 %31, 0
  %211 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %210, i64 %185, 1
  %212 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %211, i64 %192, 2
  %213 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %212, { i128, [64 x i8] } %203, 3
  ret { i64, i64, i64, { i128, [64 x i8] } } %213

214:                                              ; preds = %24
  %215 = phi { { ptr, i32, i32, i32 } } [ %30, %24 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %215)
  %216 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %217 = call ptr %216()
  %218 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 0)
  br label %219

219:                                              ; preds = %132, %214
  %220 = phi i64 [ %31, %214 ], [ %99, %132 ]
  %221 = phi i64 [ %218, %214 ], [ %136, %132 ]
  %222 = phi i64 [ %27, %214 ], [ %88, %132 ]
  %223 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %224 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %223, 0
  %225 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %224, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %225, ptr %12, align 8
  %226 = load { i128, [64 x i8] }, ptr %12, align 16
  %227 = extractvalue { ptr, ptr, i64 } %10, 1
  %228 = load i64, ptr %227, align 8
  %229 = icmp eq i64 %228, 0
  %230 = sub i64 %228, 1
  %231 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %230, ptr %231, align 8
  br i1 %229, label %232, label %117

232:                                              ; preds = %219
  %233 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } undef, i64 %220, 0
  %234 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %233, i64 %221, 1
  %235 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %234, i64 %222, 2
  %236 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %235, { i128, [64 x i8] } %226, 3
  ret { i64, i64, i64, { i128, [64 x i8] } } %236
}

define private { i64, i64, i64, { i128, [64 x i8] } } @f49(i64 %0, i64 %1, i64 %2, ptr %3, { i252, i252, i252 } %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %0, i64 %1, i64 %2, ptr %3, { i252, i252, i252 } %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %7, 3
  %12 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } undef, i64 %8, 0
  %13 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %12, i64 %9, 1
  %14 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %13, i64 %10, 2
  %15 = insertvalue { i64, i64, i64, { i128, [64 x i8] } } %14, { i128, [64 x i8] } %11, 3
  ret { i64, i64, i64, { i128, [64 x i8] } } %15
}

define void @_mlir_ciface_f49(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { i252, i252, i252 } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, { i128, [64 x i8] } } @f49(i64 %1, i64 %2, i64 %3, ptr %4, { i252, i252, i252 } %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, { i128, [64 x i8] } } %8, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f50"(i64 %0, i64 %1, ptr %2, { i252 } %3, { i32, i32, i32, i32 } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i1, [31 x i8] }, i64 1, align 8
  %9 = alloca i64, i64 1, align 8
  %10 = alloca i252, i64 1, align 16
  %11 = alloca i252, i64 1, align 16
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = extractvalue { i32, i32, i32, i32 } %4, 0
  %15 = extractvalue { i32, i32, i32, i32 } %4, 1
  %16 = extractvalue { i32, i32, i32, i32 } %4, 2
  %17 = extractvalue { i32, i32, i32, i32 } %4, 3
  %18 = zext i32 %14 to i128
  %19 = zext i32 %15 to i128
  %20 = zext i128 %19 to i256
  %21 = mul i256 %20, 4294967296
  %22 = trunc i256 %21 to i128
  %23 = lshr i256 %21, 128
  %24 = trunc i256 %23 to i128
  %25 = add i64 %0, 9
  %26 = zext i128 %24 to i252
  %27 = icmp eq i252 %26, 0
  br i1 %27, label %28, label %156

28:                                               ; preds = %5
  %29 = phi i64 [ %25, %5 ]
  %30 = phi i128 [ %18, %5 ]
  %31 = phi i128 [ %22, %5 ]
  %32 = add i64 %29, 1
  %33 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %30, i128 %31)
  %34 = extractvalue { i128, i1 } %33, 0
  %35 = extractvalue { i128, i1 } %33, 1
  br i1 %35, label %137, label %36

36:                                               ; preds = %28
  %37 = phi i32 [ %16, %28 ]
  %38 = zext i32 %37 to i128
  %39 = zext i128 %38 to i256
  %40 = mul i256 %39, 18446744073709551616
  %41 = trunc i256 %40 to i128
  %42 = lshr i256 %40, 128
  %43 = trunc i256 %42 to i128
  %44 = add i64 %29, 10
  %45 = zext i128 %43 to i252
  %46 = icmp eq i252 %45, 0
  br i1 %46, label %47, label %130

47:                                               ; preds = %36
  %48 = phi i64 [ %44, %36 ]
  %49 = phi i128 [ %34, %36 ]
  %50 = phi i128 [ %41, %36 ]
  %51 = add i64 %48, 1
  %52 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %49, i128 %50)
  %53 = extractvalue { i128, i1 } %52, 0
  %54 = extractvalue { i128, i1 } %52, 1
  br i1 %54, label %123, label %55

55:                                               ; preds = %47
  %56 = phi i32 [ %17, %47 ]
  %57 = zext i32 %56 to i128
  %58 = zext i128 %57 to i256
  %59 = mul i256 %58, 79228162514264337593543950336
  %60 = trunc i256 %59 to i128
  %61 = lshr i256 %59, 128
  %62 = trunc i256 %61 to i128
  %63 = add i64 %48, 10
  %64 = zext i128 %62 to i252
  %65 = icmp eq i252 %64, 0
  br i1 %65, label %66, label %116

66:                                               ; preds = %55
  %67 = phi i64 [ %63, %55 ]
  %68 = phi i128 [ %53, %55 ]
  %69 = phi i128 [ %60, %55 ]
  %70 = add i64 %67, 1
  %71 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %68, i128 %69)
  %72 = extractvalue { i128, i1 } %71, 0
  %73 = extractvalue { i128, i1 } %71, 1
  br i1 %73, label %109, label %74

74:                                               ; preds = %66
  %75 = phi i128 [ %72, %66 ]
  %76 = zext i128 %75 to i252
  %77 = extractvalue { i252 } %3, 0
  %78 = load ptr, ptr %2, align 8
  store i64 %1, ptr %9, align 8
  store i252 %77, ptr %10, align 16
  store i252 %76, ptr %11, align 16
  %79 = getelementptr inbounds ptr, ptr %2, i32 9
  %80 = load ptr, ptr %79, align 8
  call void %80(ptr %8, ptr %78, ptr %9, i32 0, ptr %10, ptr %11)
  %81 = load { i1, [31 x i8] }, ptr %8, align 1
  %82 = extractvalue { i1, [31 x i8] } %81, 0
  %83 = getelementptr inbounds i8, ptr %8, i32 8
  %84 = load { ptr, i32, i32, i32 }, ptr %83, align 8
  %85 = load i64, ptr %9, align 8
  br i1 %82, label %98, label %86

86:                                               ; preds = %74
  %87 = phi i64 [ %85, %74 ]
  %88 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %89 = call ptr %88()
  %90 = load i64, ptr %89, align 8
  %91 = mul i64 %90, 10
  %92 = call i64 @llvm.uadd.sat.i64(i64 %87, i64 %91)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %13, align 1
  %93 = load { i64, [24 x i8] }, ptr %13, align 8
  %94 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %70, 0
  %95 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %92, 1
  %96 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %95, ptr %2, 2
  %97 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %93, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %97

98:                                               ; preds = %74
  %99 = phi {} [ undef, %74 ]
  %100 = phi { ptr, i32, i32, i32 } [ %84, %74 ]
  %101 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %99, 0
  %102 = insertvalue { {}, { ptr, i32, i32, i32 } } %101, { ptr, i32, i32, i32 } %100, 1
  %103 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %102, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %103, ptr %12, align 8
  %104 = load { i64, [24 x i8] }, ptr %12, align 8
  %105 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %70, 0
  %106 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %105, i64 %85, 1
  %107 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %106, ptr %2, 2
  %108 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %107, { i64, [24 x i8] } %104, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %108

109:                                              ; preds = %66
  %110 = phi i64 [ %1, %66 ]
  %111 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %112 = call ptr %111()
  %113 = load i64, ptr %112, align 8
  %114 = mul i64 %113, 9780
  %115 = call i64 @llvm.uadd.sat.i64(i64 %110, i64 %114)
  br label %144

116:                                              ; preds = %55
  %117 = phi i64 [ %1, %55 ]
  %118 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %119 = call ptr %118()
  %120 = load i64, ptr %119, align 8
  %121 = mul i64 %120, 10220
  %122 = call i64 @llvm.uadd.sat.i64(i64 %117, i64 %121)
  br label %163

123:                                              ; preds = %47
  %124 = phi i64 [ %1, %47 ]
  %125 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %126 = call ptr %125()
  %127 = load i64, ptr %126, align 8
  %128 = mul i64 %127, 13080
  %129 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 %128)
  br label %144

130:                                              ; preds = %36
  %131 = phi i64 [ %1, %36 ]
  %132 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %133 = call ptr %132()
  %134 = load i64, ptr %133, align 8
  %135 = mul i64 %134, 13620
  %136 = call i64 @llvm.uadd.sat.i64(i64 %131, i64 %135)
  br label %163

137:                                              ; preds = %28
  %138 = phi i64 [ %1, %28 ]
  %139 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %140 = call ptr %139()
  %141 = load i64, ptr %140, align 8
  %142 = mul i64 %141, 16580
  %143 = call i64 @llvm.uadd.sat.i64(i64 %138, i64 %142)
  br label %144

144:                                              ; preds = %137, %123, %109
  %145 = phi ptr [ %2, %137 ], [ %2, %123 ], [ %2, %109 ]
  %146 = phi i64 [ %32, %137 ], [ %51, %123 ], [ %70, %109 ]
  %147 = phi i64 [ %143, %137 ], [ %129, %123 ], [ %115, %109 ]
  %148 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f73"()
  %149 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %148, 0
  %150 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %149, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %150, ptr %7, align 8
  %151 = load { i64, [24 x i8] }, ptr %7, align 8
  %152 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %146, 0
  %153 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %152, i64 %147, 1
  %154 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %153, ptr %145, 2
  %155 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %154, { i64, [24 x i8] } %151, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %155

156:                                              ; preds = %5
  %157 = phi i64 [ %1, %5 ]
  %158 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %159 = call ptr %158()
  %160 = load i64, ptr %159, align 8
  %161 = mul i64 %160, 17120
  %162 = call i64 @llvm.uadd.sat.i64(i64 %157, i64 %161)
  br label %163

163:                                              ; preds = %116, %130, %156
  %164 = phi ptr [ %2, %156 ], [ %2, %130 ], [ %2, %116 ]
  %165 = phi i64 [ %25, %156 ], [ %44, %130 ], [ %63, %116 ]
  %166 = phi i64 [ %162, %156 ], [ %136, %130 ], [ %122, %116 ]
  %167 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f74"()
  %168 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %167, 0
  %169 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %168, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %169, ptr %6, align 8
  %170 = load { i64, [24 x i8] }, ptr %6, align 8
  %171 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %165, 0
  %172 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %171, i64 %166, 1
  %173 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %172, ptr %164, 2
  %174 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %173, { i64, [24 x i8] } %170, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %174
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f50(i64 %0, i64 %1, ptr %2, { i252 } %3, { i32, i32, i32, i32 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f50"(i64 %0, i64 %1, ptr %2, { i252 } %3, { i32, i32, i32, i32 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f50(ptr %0, i64 %1, i64 %2, ptr %3, { i252 } %4, { i32, i32, i32, i32 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f50(i64 %1, i64 %2, ptr %3, { i252 } %4, { i32, i32, i32, i32 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$107"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$106"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$107"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$201"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$107"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$201"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$107"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f51"(i64 %0, i64 %1, ptr %2, { i252 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i1, [31 x i8] }, i64 1, align 8
  %9 = alloca i64, i64 1, align 8
  %10 = alloca i252, i64 1, align 16
  %11 = alloca i252, i64 1, align 16
  %12 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %4)
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 0
  %21 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 1
  call void @"drop$106"({ ptr, i32, i32, i32 } %20)
  %22 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$107"({ ptr, i32, i32, i32 } %21)
  %23 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %22, 0
  %24 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %22, 1
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  call void @"drop$107"({ ptr, i32, i32, i32 } %24)
  %28 = zext i32 %27 to i252
  %29 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %29, align 4
  %30 = getelementptr inbounds i8, ptr %29, i32 4
  store i32 0, ptr %30, align 4
  %31 = getelementptr inbounds i8, ptr %29, i32 16
  %32 = call ptr @realloc(ptr null, i64 8)
  store ptr %31, ptr %32, align 8
  %33 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %32, 0
  %34 = insertvalue { ptr, i32, i32, i32 } %33, i32 8, 3
  %35 = load ptr, ptr %32, align 8
  store i252 %28, ptr %35, align 16
  %36 = insertvalue { ptr, i32, i32, i32 } %34, i32 1, 2
  %37 = getelementptr inbounds i8, ptr %35, i32 -12
  store i32 1, ptr %37, align 4
  %38 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %23, 0
  %39 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f75"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %38, { ptr, i32, i32, i32 } %36)
  %40 = extractvalue { i64, i64, { i64, [24 x i8] } } %39, 0
  %41 = extractvalue { i64, i64, { i64, [24 x i8] } } %39, 1
  %42 = extractvalue { i64, i64, { i64, [24 x i8] } } %39, 2
  store { i64, [24 x i8] } %42, ptr %6, align 8
  %43 = load i1, ptr %6, align 1
  switch i1 %43, label %44 [
    i1 false, label %46
    i1 true, label %65
  ]

44:                                               ; preds = %5
  br i1 false, label %45, label %165

45:                                               ; preds = %44
  unreachable

46:                                               ; preds = %5
  %47 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %48 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %47, 1
  %49 = extractvalue { { ptr, i32, i32, i32 }, {} } %48, 0
  %50 = extractvalue { i252 } %3, 0
  %51 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %49)
  %52 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %51, 0
  %53 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %51, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %52)
  %54 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %53, 0
  %55 = load ptr, ptr %2, align 8
  store i64 %41, ptr %9, align 8
  store i252 %50, ptr %10, align 16
  store i252 1043237155915217200023777142698719717442160588069512551429544266543089341477, ptr %11, align 16
  store { { ptr, i32, i32, i32 } } %54, ptr %12, align 8
  %56 = getelementptr inbounds ptr, ptr %2, i32 7
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %8, ptr %55, ptr %9, ptr %10, ptr %11, ptr %12)
  %58 = load { i1, [31 x i8] }, ptr %8, align 1
  %59 = extractvalue { i1, [31 x i8] } %58, 0
  %60 = getelementptr inbounds i8, ptr %8, i32 8
  %61 = load { { ptr, i32, i32, i32 } }, ptr %60, align 8
  %62 = getelementptr inbounds i8, ptr %8, i32 8
  %63 = load { ptr, i32, i32, i32 }, ptr %62, align 8
  %64 = load i64, ptr %9, align 8
  br i1 %59, label %154, label %74

65:                                               ; preds = %5
  %66 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %67 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %66, 1
  %68 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %67, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %68, ptr %7, align 8
  %69 = load { i64, [24 x i8] }, ptr %7, align 8
  %70 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %40, 0
  %71 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %41, 1
  %72 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %71, ptr %2, 2
  %73 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %72, { i64, [24 x i8] } %69, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %73

74:                                               ; preds = %46
  %75 = phi { { ptr, i32, i32, i32 } } [ %61, %46 ]
  %76 = extractvalue { { ptr, i32, i32, i32 } } %75, 0
  %77 = extractvalue { ptr, i32, i32, i32 } %76, 1
  %78 = extractvalue { ptr, i32, i32, i32 } %76, 2
  %79 = sub i32 %78, %77
  %80 = icmp uge i32 %79, 1
  br i1 %80, label %81, label %135

81:                                               ; preds = %74
  %82 = extractvalue { ptr, i32, i32, i32 } %76, 0
  %83 = load ptr, ptr %82, align 8
  %84 = zext i32 %77 to i64
  %85 = mul i64 %84, 32
  %86 = getelementptr inbounds i8, ptr %83, i64 %85
  %87 = add i32 %77, 1
  %88 = insertvalue { ptr, i32, i32, i32 } %76, i32 %87, 1
  %89 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %89, ptr %86, i64 32, i1 false)
  %90 = load i252, ptr %89, align 16
  call void @free(ptr %89)
  %91 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %88, 0
  %92 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f42"(i64 %40, i64 %64, { { ptr, i32, i32, i32 } } %91, { ptr, i32, i32, i32 } zeroinitializer, i252 %90)
  %93 = extractvalue { i64, i64, { i64, [56 x i8] } } %92, 0
  %94 = extractvalue { i64, i64, { i64, [56 x i8] } } %92, 1
  %95 = extractvalue { i64, i64, { i64, [56 x i8] } } %92, 2
  store { i64, [56 x i8] } %95, ptr %15, align 8
  %96 = load i1, ptr %15, align 1
  switch i1 %96, label %97 [
    i1 false, label %99
    i1 true, label %105
  ]

97:                                               ; preds = %81
  br i1 false, label %98, label %166

98:                                               ; preds = %97
  unreachable

99:                                               ; preds = %81
  %100 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %15, align 8
  %101 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %100, 1
  %102 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %101, 0
  %103 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %101, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %102)
  store { i64, [24 x i8] } %103, ptr %17, align 8
  %104 = load i1, ptr %17, align 1
  switch i1 %104, label %114 [
    i1 false, label %116
    i1 true, label %131
  ]

105:                                              ; preds = %81
  %106 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %107 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %106, 1
  %108 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %107, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %108, ptr %16, align 8
  %109 = load { i64, [24 x i8] }, ptr %16, align 8
  %110 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %93, 0
  %111 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %110, i64 %94, 1
  %112 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %111, ptr %2, 2
  %113 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %112, { i64, [24 x i8] } %109, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %113

114:                                              ; preds = %99
  br i1 false, label %115, label %167

115:                                              ; preds = %114
  unreachable

116:                                              ; preds = %99
  %117 = load { i1, { ptr, i32, i32, i32 } }, ptr %17, align 8
  %118 = extractvalue { i1, { ptr, i32, i32, i32 } } %117, 1
  %119 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %120 = call ptr %119()
  %121 = load i64, ptr %120, align 8
  %122 = mul i64 %121, 1200
  %123 = call i64 @llvm.uadd.sat.i64(i64 %94, i64 %122)
  %124 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %118, 0
  %125 = insertvalue { i1, { { ptr, i32, i32, i32 } } } { i1 false, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %124, 1
  store { i1, { { ptr, i32, i32, i32 } } } %125, ptr %18, align 8
  %126 = load { i64, [24 x i8] }, ptr %18, align 8
  %127 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %93, 0
  %128 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %123, 1
  %129 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %128, ptr %2, 2
  %130 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %129, { i64, [24 x i8] } %126, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %130

131:                                              ; preds = %99
  %132 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %133 = call ptr %132()
  %134 = call i64 @llvm.uadd.sat.i64(i64 %94, i64 0)
  br label %142

135:                                              ; preds = %74
  %136 = phi { ptr, i32, i32, i32 } [ %76, %74 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %136)
  %137 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %138 = call ptr %137()
  %139 = load i64, ptr %138, align 8
  %140 = mul i64 %139, 3270
  %141 = call i64 @llvm.uadd.sat.i64(i64 %64, i64 %140)
  br label %142

142:                                              ; preds = %131, %135
  %143 = phi ptr [ %2, %135 ], [ %2, %131 ]
  %144 = phi i64 [ %40, %135 ], [ %93, %131 ]
  %145 = phi i64 [ %141, %135 ], [ %134, %131 ]
  %146 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f41"()
  %147 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %146, 0
  %148 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %147, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %148, ptr %14, align 8
  %149 = load { i64, [24 x i8] }, ptr %14, align 8
  %150 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %144, 0
  %151 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %150, i64 %145, 1
  %152 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %151, ptr %143, 2
  %153 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %152, { i64, [24 x i8] } %149, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %153

154:                                              ; preds = %46
  %155 = phi {} [ undef, %46 ]
  %156 = phi { ptr, i32, i32, i32 } [ %63, %46 ]
  %157 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %155, 0
  %158 = insertvalue { {}, { ptr, i32, i32, i32 } } %157, { ptr, i32, i32, i32 } %156, 1
  %159 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %158, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %159, ptr %13, align 8
  %160 = load { i64, [24 x i8] }, ptr %13, align 8
  %161 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %40, 0
  %162 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %161, i64 %64, 1
  %163 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %162, ptr %2, 2
  %164 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %163, { i64, [24 x i8] } %160, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %164

165:                                              ; preds = %44
  call void @puts(ptr @assert_msg_97)
  call void @abort()
  unreachable

166:                                              ; preds = %97
  call void @puts(ptr @assert_msg_98)
  call void @abort()
  unreachable

167:                                              ; preds = %114
  call void @puts(ptr @assert_msg_99)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f51(i64 %0, i64 %1, ptr %2, { i252 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f51"(i64 %0, i64 %1, ptr %2, { i252 } %3, { ptr, i32, i32, i32 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f51(ptr %0, i64 %1, i64 %2, ptr %3, { i252 } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f51(i64 %1, i64 %2, ptr %3, { i252 } %4, { ptr, i32, i32, i32 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f52"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, i252 %5, i32 %6, { i252 } %7) {
  %9 = alloca i64, i64 1, align 8
  %10 = insertvalue { ptr, ptr, i64 } undef, ptr %9, 0
  %11 = insertvalue { ptr, ptr, i64 } %10, ptr %9, 1
  %12 = insertvalue { ptr, ptr, i64 } %11, i64 0, 2
  %13 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 0, ptr %13, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [64 x i8] }, i64 1, align 16
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca i256, i64 1, align 16
  %18 = alloca i256, i64 1, align 16
  %19 = alloca i256, i64 1, align 16
  %20 = alloca { i1, [47 x i8] }, i64 1, align 16
  %21 = alloca i64, i64 1, align 8
  %22 = alloca i252, i64 1, align 16
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca i256, i64 1, align 16
  %25 = alloca i256, i64 1, align 16
  %26 = alloca i256, i64 1, align 16
  %27 = alloca { i1, [31 x i8] }, i64 1, align 8
  %28 = alloca i64, i64 1, align 8
  %29 = alloca i252, i64 1, align 16
  %30 = alloca i252, i64 1, align 16
  %31 = alloca { i64, [24 x i8] }, i64 1, align 8
  %32 = alloca { i64, [24 x i8] }, i64 1, align 8
  %33 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %34

34:                                               ; preds = %178, %8
  %35 = phi i64 [ %174, %178 ], [ %0, %8 ]
  %36 = phi i64 [ %182, %178 ], [ %1, %8 ]
  %37 = phi i64 [ %152, %178 ], [ %2, %8 ]
  %38 = phi i64 [ %79, %178 ], [ %3, %8 ]
  %39 = phi ptr [ %39, %178 ], [ %4, %8 ]
  %40 = phi i252 [ %55, %178 ], [ %5, %8 ]
  %41 = phi i32 [ %176, %178 ], [ %6, %8 ]
  %42 = phi { i252 } [ %150, %178 ], [ %7, %8 ]
  %43 = add i64 %35, 1
  %44 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %45 = call ptr %44()
  %46 = getelementptr inbounds i64, ptr %45, i32 1
  %47 = load i64, ptr %46, align 8
  %48 = mul i64 %47, 2
  %49 = load i64, ptr %45, align 8
  %50 = mul i64 %49, 32930
  %51 = add i64 %48, %50
  %52 = icmp uge i64 %36, %51
  %53 = call i64 @llvm.usub.sat.i64(i64 %36, i64 %51)
  br i1 %52, label %54, label %268

54:                                               ; preds = %34
  %55 = phi i252 [ %40, %34 ]
  %56 = zext i32 %41 to i252
  %57 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %58 = call ptr %57()
  %59 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %59, align 4
  %60 = getelementptr inbounds i8, ptr %59, i32 4
  store i32 0, ptr %60, align 4
  %61 = getelementptr inbounds i8, ptr %59, i32 16
  %62 = call ptr @realloc(ptr null, i64 8)
  store ptr %61, ptr %62, align 8
  %63 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %62, 0
  %64 = insertvalue { ptr, i32, i32, i32 } %63, i32 8, 3
  %65 = load ptr, ptr %62, align 8
  store i252 %55, ptr %65, align 16
  %66 = insertvalue { ptr, i32, i32, i32 } %64, i32 1, 2
  %67 = getelementptr inbounds i8, ptr %65, i32 -12
  store i32 1, ptr %67, align 4
  %68 = load ptr, ptr %62, align 8
  %69 = getelementptr inbounds i8, ptr %68, i32 32
  store i252 %56, ptr %69, align 16
  %70 = insertvalue { ptr, i32, i32, i32 } %66, i32 2, 2
  %71 = getelementptr inbounds i8, ptr %68, i32 -12
  store i32 2, ptr %71, align 4
  %72 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %70)
  %73 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %72, 0
  %74 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %72, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %73)
  %75 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %74, 0
  %76 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %43, i64 %53, i64 %38, ptr %58, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %75)
  %77 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %76, 0
  %78 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %76, 1
  %79 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %76, 2
  %80 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %76, 3
  store { i128, [64 x i8] } %80, ptr %15, align 16
  %81 = load i1, ptr %15, align 1
  switch i1 %81, label %82 [
    i1 false, label %84
    i1 true, label %110
  ]

82:                                               ; preds = %54
  br i1 false, label %83, label %285

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %54
  %85 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %15, align 16
  %86 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %85, 1
  %87 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %86, 0
  %88 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %86, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %87)
  %89 = extractvalue { i252 } %42, 0
  %90 = add i64 %37, 3
  %91 = zext i252 %89 to i256
  %92 = zext i252 %88 to i256
  store i256 %91, ptr %17, align 16
  store i256 %92, ptr %18, align 16
  %93 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %93(ptr %19, ptr %17, ptr %18)
  %94 = load i256, ptr %19, align 16
  %95 = trunc i256 %94 to i252
  %96 = add i64 %77, 3
  %97 = sub i252 %95, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %98 = icmp ult i252 %95, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %99 = select i1 %98, i252 %95, i252 %97
  %100 = load ptr, ptr %39, align 8
  store i64 %78, ptr %21, align 8
  store i252 %99, ptr %22, align 16
  %101 = getelementptr inbounds ptr, ptr %39, i32 8
  %102 = load ptr, ptr %101, align 8
  call void %102(ptr %20, ptr %100, ptr %21, i32 0, ptr %22)
  %103 = load { i1, [47 x i8] }, ptr %20, align 1
  %104 = extractvalue { i1, [47 x i8] } %103, 0
  %105 = getelementptr inbounds i8, ptr %20, i32 16
  %106 = load i252, ptr %105, align 16
  %107 = getelementptr inbounds i8, ptr %20, i32 8
  %108 = load { ptr, i32, i32, i32 }, ptr %107, align 8
  %109 = load i64, ptr %21, align 8
  br i1 %104, label %242, label %120

110:                                              ; preds = %54
  %111 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %112 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %111, 1
  %113 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %112, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %113, ptr %16, align 8
  %114 = load { i64, [24 x i8] }, ptr %16, align 8
  %115 = extractvalue { ptr, ptr, i64 } %12, 1
  %116 = load i64, ptr %115, align 8
  %117 = icmp eq i64 %116, 0
  %118 = sub i64 %116, 1
  %119 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %118, ptr %119, align 8
  br i1 %117, label %261, label %187

120:                                              ; preds = %84
  %121 = phi i252 [ %106, %84 ]
  %122 = icmp eq i252 %121, 0
  br i1 %122, label %123, label %149

123:                                              ; preds = %120
  %124 = phi i64 [ %109, %120 ]
  %125 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %126 = call ptr %125()
  %127 = getelementptr inbounds i64, ptr %126, i32 1
  %128 = load i64, ptr %127, align 8
  %129 = load i64, ptr %126, align 8
  %130 = mul i64 %129, 15750
  %131 = add i64 %128, %130
  %132 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 %131)
  %133 = insertvalue { i32, {} } undef, i32 %41, 0
  %134 = insertvalue { i32, {} } %133, {} undef, 1
  %135 = insertvalue { i1, { i32, {} } } { i1 false, { i32, {} } undef }, { i32, {} } %134, 1
  store { i1, { i32, {} } } %135, ptr %33, align 4
  %136 = load { i64, [24 x i8] }, ptr %33, align 8
  %137 = extractvalue { ptr, ptr, i64 } %12, 1
  %138 = load i64, ptr %137, align 8
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %138, 1
  %141 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %140, ptr %141, align 8
  br i1 %139, label %142, label %187

142:                                              ; preds = %123
  %143 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %96, 0
  %144 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %143, i64 %132, 1
  %145 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %144, i64 %90, 2
  %146 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %145, i64 %79, 3
  %147 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %146, ptr %39, 4
  %148 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %147, { i64, [24 x i8] } %136, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %148

149:                                              ; preds = %120
  %150 = phi { i252 } [ %42, %120 ]
  %151 = extractvalue { i252 } %150, 0
  %152 = add i64 %37, 6
  %153 = zext i252 %151 to i256
  %154 = zext i252 %88 to i256
  store i256 %153, ptr %24, align 16
  store i256 %154, ptr %25, align 16
  %155 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %155(ptr %26, ptr %24, ptr %25)
  %156 = load i256, ptr %26, align 16
  %157 = trunc i256 %156 to i252
  %158 = add i64 %77, 6
  %159 = sub i252 %157, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %160 = icmp ult i252 %157, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %161 = select i1 %160, i252 %157, i252 %159
  %162 = load ptr, ptr %39, align 8
  store i64 %109, ptr %28, align 8
  store i252 %161, ptr %29, align 16
  store i252 0, ptr %30, align 16
  %163 = getelementptr inbounds ptr, ptr %39, i32 9
  %164 = load ptr, ptr %163, align 8
  call void %164(ptr %27, ptr %162, ptr %28, i32 0, ptr %29, ptr %30)
  %165 = load { i1, [31 x i8] }, ptr %27, align 1
  %166 = extractvalue { i1, [31 x i8] } %165, 0
  %167 = getelementptr inbounds i8, ptr %27, i32 8
  %168 = load { ptr, i32, i32, i32 }, ptr %167, align 8
  %169 = load i64, ptr %28, align 8
  br i1 %166, label %223, label %170

170:                                              ; preds = %149
  %171 = phi i64 [ %158, %149 ]
  %172 = phi i32 [ %41, %149 ]
  %173 = phi i32 [ 1, %149 ]
  %174 = add i64 %171, 1
  %175 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %172, i32 %173)
  %176 = extractvalue { i32, i1 } %175, 0
  %177 = extractvalue { i32, i1 } %175, 1
  br i1 %177, label %206, label %178

178:                                              ; preds = %170
  %179 = phi i64 [ %169, %170 ]
  %180 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %181 = call ptr %180()
  %182 = call i64 @llvm.uadd.sat.i64(i64 %179, i64 0)
  %183 = extractvalue { ptr, ptr, i64 } %12, 1
  %184 = load i64, ptr %183, align 8
  %185 = add i64 %184, 1
  %186 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %185, ptr %186, align 8
  br label %34

187:                                              ; preds = %187, %242, %123, %223, %206, %110, %268
  %188 = phi i64 [ %43, %268 ], [ %96, %242 ], [ %158, %223 ], [ %174, %206 ], [ %188, %187 ], [ %96, %123 ], [ %77, %110 ]
  %189 = phi i64 [ %36, %268 ], [ %109, %242 ], [ %169, %223 ], [ %169, %206 ], [ %189, %187 ], [ %132, %123 ], [ %78, %110 ]
  %190 = phi i64 [ %37, %268 ], [ %90, %242 ], [ %152, %223 ], [ %152, %206 ], [ %190, %187 ], [ %90, %123 ], [ %37, %110 ]
  %191 = phi i64 [ %38, %268 ], [ %79, %242 ], [ %79, %223 ], [ %79, %206 ], [ %191, %187 ], [ %79, %123 ], [ %79, %110 ]
  %192 = phi ptr [ %39, %268 ], [ %39, %242 ], [ %39, %223 ], [ %39, %206 ], [ %192, %187 ], [ %39, %123 ], [ %39, %110 ]
  %193 = phi { i64, [24 x i8] } [ %272, %268 ], [ %248, %242 ], [ %229, %223 ], [ %210, %206 ], [ %193, %187 ], [ %136, %123 ], [ %114, %110 ]
  %194 = extractvalue { ptr, ptr, i64 } %12, 1
  %195 = load i64, ptr %194, align 8
  %196 = icmp eq i64 %195, 0
  %197 = sub i64 %195, 1
  %198 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %197, ptr %198, align 8
  br i1 %196, label %199, label %187

199:                                              ; preds = %187
  %200 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %188, 0
  %201 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %200, i64 %189, 1
  %202 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %201, i64 %190, 2
  %203 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %202, i64 %191, 3
  %204 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %203, ptr %192, 4
  %205 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %204, { i64, [24 x i8] } %193, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %205

206:                                              ; preds = %170
  %207 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"()
  %208 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %207, 0
  %209 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %208, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %209, ptr %32, align 8
  %210 = load { i64, [24 x i8] }, ptr %32, align 8
  %211 = extractvalue { ptr, ptr, i64 } %12, 1
  %212 = load i64, ptr %211, align 8
  %213 = icmp eq i64 %212, 0
  %214 = sub i64 %212, 1
  %215 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %214, ptr %215, align 8
  br i1 %213, label %216, label %187

216:                                              ; preds = %206
  %217 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %174, 0
  %218 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %217, i64 %169, 1
  %219 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %218, i64 %152, 2
  %220 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %219, i64 %79, 3
  %221 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %220, ptr %39, 4
  %222 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %221, { i64, [24 x i8] } %210, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %222

223:                                              ; preds = %149
  %224 = phi {} [ undef, %149 ]
  %225 = phi { ptr, i32, i32, i32 } [ %168, %149 ]
  %226 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %224, 0
  %227 = insertvalue { {}, { ptr, i32, i32, i32 } } %226, { ptr, i32, i32, i32 } %225, 1
  %228 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %227, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %228, ptr %31, align 8
  %229 = load { i64, [24 x i8] }, ptr %31, align 8
  %230 = extractvalue { ptr, ptr, i64 } %12, 1
  %231 = load i64, ptr %230, align 8
  %232 = icmp eq i64 %231, 0
  %233 = sub i64 %231, 1
  %234 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %233, ptr %234, align 8
  br i1 %232, label %235, label %187

235:                                              ; preds = %223
  %236 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %158, 0
  %237 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %236, i64 %169, 1
  %238 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %237, i64 %152, 2
  %239 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %238, i64 %79, 3
  %240 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %239, ptr %39, 4
  %241 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %240, { i64, [24 x i8] } %229, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %241

242:                                              ; preds = %84
  %243 = phi {} [ undef, %84 ]
  %244 = phi { ptr, i32, i32, i32 } [ %108, %84 ]
  %245 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %243, 0
  %246 = insertvalue { {}, { ptr, i32, i32, i32 } } %245, { ptr, i32, i32, i32 } %244, 1
  %247 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %246, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %247, ptr %23, align 8
  %248 = load { i64, [24 x i8] }, ptr %23, align 8
  %249 = extractvalue { ptr, ptr, i64 } %12, 1
  %250 = load i64, ptr %249, align 8
  %251 = icmp eq i64 %250, 0
  %252 = sub i64 %250, 1
  %253 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %252, ptr %253, align 8
  br i1 %251, label %254, label %187

254:                                              ; preds = %242
  %255 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %96, 0
  %256 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %255, i64 %109, 1
  %257 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %256, i64 %90, 2
  %258 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %257, i64 %79, 3
  %259 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %258, ptr %39, 4
  %260 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %259, { i64, [24 x i8] } %248, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %260

261:                                              ; preds = %110
  %262 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %77, 0
  %263 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %262, i64 %78, 1
  %264 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %263, i64 %37, 2
  %265 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %264, i64 %79, 3
  %266 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %265, ptr %39, 4
  %267 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %266, { i64, [24 x i8] } %114, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %267

268:                                              ; preds = %34
  %269 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %270 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %269, 0
  %271 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %270, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %271, ptr %14, align 8
  %272 = load { i64, [24 x i8] }, ptr %14, align 8
  %273 = extractvalue { ptr, ptr, i64 } %12, 1
  %274 = load i64, ptr %273, align 8
  %275 = icmp eq i64 %274, 0
  %276 = sub i64 %274, 1
  %277 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %276, ptr %277, align 8
  br i1 %275, label %278, label %187

278:                                              ; preds = %268
  %279 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %43, 0
  %280 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %279, i64 %36, 1
  %281 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %280, i64 %37, 2
  %282 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %281, i64 %38, 3
  %283 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %282, ptr %39, 4
  %284 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %283, { i64, [24 x i8] } %272, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %284

285:                                              ; preds = %82
  call void @puts(ptr @assert_msg_100)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f52(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, i252 %5, i32 %6, { i252 } %7) {
  %9 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f52"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, i252 %5, i32 %6, { i252 } %7)
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 4
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 5
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %10, 0
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 1
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %12, 2
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %13, 3
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, ptr %14, 4
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, { i64, [24 x i8] } %15, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21
}

define void @_mlir_ciface_f52(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, i252 %6, i32 %7, { i252 } %8) {
  %10 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f52(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, i252 %6, i32 %7, { i252 } %8)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } @"impl$f53"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, i32 } %5, i252 %6, i32 %7, { i252 } %8, { i3, [0 x i8] } %9) {
  %11 = alloca i64, i64 1, align 8
  %12 = insertvalue { ptr, ptr, i64 } undef, ptr %11, 0
  %13 = insertvalue { ptr, ptr, i64 } %12, ptr %11, 1
  %14 = insertvalue { ptr, ptr, i64 } %13, i64 0, 2
  %15 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 0, ptr %15, align 8
  %16 = alloca { i64, [32 x i8] }, i64 1, align 8
  %17 = alloca { i64, [32 x i8] }, i64 1, align 8
  %18 = alloca { i64, [32 x i8] }, i64 1, align 8
  %19 = alloca { i128, [64 x i8] }, i64 1, align 16
  %20 = alloca { i64, [32 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [32 x i8] }, i64 1, align 8
  %23 = alloca i256, i64 1, align 16
  %24 = alloca i256, i64 1, align 16
  %25 = alloca i256, i64 1, align 16
  %26 = alloca { i1, [31 x i8] }, i64 1, align 8
  %27 = alloca i64, i64 1, align 8
  %28 = alloca i252, i64 1, align 16
  %29 = alloca i252, i64 1, align 16
  %30 = alloca { i64, [32 x i8] }, i64 1, align 8
  br label %31

31:                                               ; preds = %162, %10
  %32 = phi i64 [ %140, %162 ], [ %0, %10 ]
  %33 = phi i64 [ %166, %162 ], [ %1, %10 ]
  %34 = phi i64 [ %134, %162 ], [ %2, %10 ]
  %35 = phi i64 [ %99, %162 ], [ %3, %10 ]
  %36 = phi ptr [ %117, %162 ], [ %4, %10 ]
  %37 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %169, %162 ], [ %5, %10 ]
  %38 = phi i252 [ %75, %162 ], [ %6, %10 ]
  %39 = phi i32 [ %39, %162 ], [ %7, %10 ]
  %40 = phi { i252 } [ %40, %162 ], [ %8, %10 ]
  %41 = phi { i3, [0 x i8] } [ %41, %162 ], [ %9, %10 ]
  %42 = add i64 %32, 1
  %43 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %44 = call ptr %43()
  %45 = getelementptr inbounds i64, ptr %44, i32 1
  %46 = load i64, ptr %45, align 8
  %47 = load i64, ptr %44, align 8
  %48 = mul i64 %47, 39990
  %49 = add i64 %46, %48
  %50 = icmp uge i64 %33, %49
  %51 = call i64 @llvm.usub.sat.i64(i64 %33, i64 %49)
  br i1 %50, label %52, label %271

52:                                               ; preds = %31
  %53 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %37, %31 ]
  %54 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %53, 0
  %55 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %53, 1
  %56 = extractvalue { { ptr, i32, i32, i32 } } %54, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %242

61:                                               ; preds = %52
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = add i64 %32, 2
  %71 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %55, i32 1)
  %72 = extractvalue { i32, i1 } %71, 0
  %73 = extractvalue { i32, i1 } %71, 1
  br i1 %73, label %224, label %74

74:                                               ; preds = %61
  %75 = phi i252 [ %38, %61 ]
  %76 = zext i32 %55 to i252
  %77 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %78 = call ptr %77()
  %79 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %79, align 4
  %80 = getelementptr inbounds i8, ptr %79, i32 4
  store i32 0, ptr %80, align 4
  %81 = getelementptr inbounds i8, ptr %79, i32 16
  %82 = call ptr @realloc(ptr null, i64 8)
  store ptr %81, ptr %82, align 8
  %83 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %82, 0
  %84 = insertvalue { ptr, i32, i32, i32 } %83, i32 8, 3
  %85 = load ptr, ptr %82, align 8
  store i252 %75, ptr %85, align 16
  %86 = insertvalue { ptr, i32, i32, i32 } %84, i32 1, 2
  %87 = getelementptr inbounds i8, ptr %85, i32 -12
  store i32 1, ptr %87, align 4
  %88 = load ptr, ptr %82, align 8
  %89 = getelementptr inbounds i8, ptr %88, i32 32
  store i252 %76, ptr %89, align 16
  %90 = insertvalue { ptr, i32, i32, i32 } %86, i32 2, 2
  %91 = getelementptr inbounds i8, ptr %88, i32 -12
  store i32 2, ptr %91, align 4
  %92 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %90)
  %93 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %92, 0
  %94 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %92, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %93)
  %95 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %94, 0
  %96 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %70, i64 %51, i64 %35, ptr %78, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %95)
  %97 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %96, 0
  %98 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %96, 1
  %99 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %96, 2
  %100 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %96, 3
  store { i128, [64 x i8] } %100, ptr %19, align 16
  %101 = load i1, ptr %19, align 1
  switch i1 %101, label %102 [
    i1 false, label %104
    i1 true, label %120
  ]

102:                                              ; preds = %74
  br i1 false, label %103, label %289

103:                                              ; preds = %102
  unreachable

104:                                              ; preds = %74
  %105 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %19, align 16
  %106 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %105, 1
  %107 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %108 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %106, 0
  %109 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %106, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %108)
  %110 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } undef, { i3, [0 x i8] } %41, 0
  %111 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %110, i32 %39, 1
  %112 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %111, i32 %55, 2
  %113 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %112, i252 %107, 3
  %114 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f76"(i64 %97, i64 %98, ptr %36, i252 %109, { { i3, [0 x i8] }, i32, i32, i252 } %113)
  %115 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %114, 0
  %116 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %114, 1
  %117 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %114, 2
  %118 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %114, 3
  store { i64, [24 x i8] } %118, ptr %21, align 8
  %119 = load i1, ptr %21, align 1
  switch i1 %119, label %130 [
    i1 false, label %132
    i1 true, label %152
  ]

120:                                              ; preds = %74
  %121 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %122 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %121, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %68)
  call void @"drop$409"(ptr %69)
  %123 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %122, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %123, ptr %20, align 8
  %124 = load { i64, [32 x i8] }, ptr %20, align 8
  %125 = extractvalue { ptr, ptr, i64 } %14, 1
  %126 = load i64, ptr %125, align 8
  %127 = icmp eq i64 %126, 0
  %128 = sub i64 %126, 1
  %129 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %128, ptr %129, align 8
  br i1 %127, label %217, label %174

130:                                              ; preds = %104
  br i1 false, label %131, label %290

131:                                              ; preds = %130
  unreachable

132:                                              ; preds = %104
  %133 = extractvalue { i252 } %40, 0
  %134 = add i64 %34, 3
  %135 = zext i252 %133 to i256
  %136 = zext i252 %109 to i256
  store i256 %135, ptr %23, align 16
  store i256 %136, ptr %24, align 16
  %137 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %137(ptr %25, ptr %23, ptr %24)
  %138 = load i256, ptr %25, align 16
  %139 = trunc i256 %138 to i252
  %140 = add i64 %115, 3
  %141 = sub i252 %139, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %142 = icmp ult i252 %139, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %143 = select i1 %142, i252 %139, i252 %141
  %144 = load ptr, ptr %117, align 8
  store i64 %116, ptr %27, align 8
  store i252 %143, ptr %28, align 16
  store i252 %107, ptr %29, align 16
  %145 = getelementptr inbounds ptr, ptr %117, i32 9
  %146 = load ptr, ptr %145, align 8
  call void %146(ptr %26, ptr %144, ptr %27, i32 0, ptr %28, ptr %29)
  %147 = load { i1, [31 x i8] }, ptr %26, align 1
  %148 = extractvalue { i1, [31 x i8] } %147, 0
  %149 = getelementptr inbounds i8, ptr %26, i32 8
  %150 = load { ptr, i32, i32, i32 }, ptr %149, align 8
  %151 = load i64, ptr %27, align 8
  br i1 %148, label %193, label %162

152:                                              ; preds = %104
  %153 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %21, align 8
  %154 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %153, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %68)
  %155 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %154, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %155, ptr %22, align 8
  %156 = load { i64, [32 x i8] }, ptr %22, align 8
  %157 = extractvalue { ptr, ptr, i64 } %14, 1
  %158 = load i64, ptr %157, align 8
  %159 = icmp eq i64 %158, 0
  %160 = sub i64 %158, 1
  %161 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %160, ptr %161, align 8
  br i1 %159, label %210, label %174

162:                                              ; preds = %132
  %163 = phi i64 [ %151, %132 ]
  %164 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %165 = call ptr %164()
  %166 = call i64 @llvm.uadd.sat.i64(i64 %163, i64 0)
  %167 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %168 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %167, 0
  %169 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %168, i32 %72, 1
  %170 = extractvalue { ptr, ptr, i64 } %14, 1
  %171 = load i64, ptr %170, align 8
  %172 = add i64 %171, 1
  %173 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %172, ptr %173, align 8
  br label %31

174:                                              ; preds = %174, %224, %193, %152, %120, %242, %271
  %175 = phi i64 [ %42, %271 ], [ %42, %242 ], [ %70, %224 ], [ %140, %193 ], [ %175, %174 ], [ %115, %152 ], [ %97, %120 ]
  %176 = phi i64 [ %33, %271 ], [ %251, %242 ], [ %51, %224 ], [ %151, %193 ], [ %176, %174 ], [ %116, %152 ], [ %98, %120 ]
  %177 = phi i64 [ %34, %271 ], [ %34, %242 ], [ %34, %224 ], [ %134, %193 ], [ %177, %174 ], [ %34, %152 ], [ %34, %120 ]
  %178 = phi i64 [ %35, %271 ], [ %35, %242 ], [ %35, %224 ], [ %99, %193 ], [ %178, %174 ], [ %99, %152 ], [ %99, %120 ]
  %179 = phi ptr [ %36, %271 ], [ %36, %242 ], [ %36, %224 ], [ %117, %193 ], [ %179, %174 ], [ %117, %152 ], [ %36, %120 ]
  %180 = phi { i64, [32 x i8] } [ %276, %271 ], [ %258, %242 ], [ %229, %224 ], [ %197, %193 ], [ %180, %174 ], [ %156, %152 ], [ %124, %120 ]
  %181 = extractvalue { ptr, ptr, i64 } %14, 1
  %182 = load i64, ptr %181, align 8
  %183 = icmp eq i64 %182, 0
  %184 = sub i64 %182, 1
  %185 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %184, ptr %185, align 8
  br i1 %183, label %186, label %174

186:                                              ; preds = %174
  %187 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %175, 0
  %188 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %187, i64 %176, 1
  %189 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %188, i64 %177, 2
  %190 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %189, i64 %178, 3
  %191 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %190, ptr %179, 4
  %192 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %191, { i64, [32 x i8] } %180, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %192

193:                                              ; preds = %132
  %194 = phi { ptr, i32, i32, i32 } [ %68, %132 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %194)
  %195 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %150, 1
  %196 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %195, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %196, ptr %30, align 8
  %197 = load { i64, [32 x i8] }, ptr %30, align 8
  %198 = extractvalue { ptr, ptr, i64 } %14, 1
  %199 = load i64, ptr %198, align 8
  %200 = icmp eq i64 %199, 0
  %201 = sub i64 %199, 1
  %202 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %201, ptr %202, align 8
  br i1 %200, label %203, label %174

203:                                              ; preds = %193
  %204 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %140, 0
  %205 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %204, i64 %151, 1
  %206 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %205, i64 %134, 2
  %207 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %206, i64 %99, 3
  %208 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %207, ptr %117, 4
  %209 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %208, { i64, [32 x i8] } %197, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %209

210:                                              ; preds = %152
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %115, 0
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %211, i64 %116, 1
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %212, i64 %34, 2
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %213, i64 %99, 3
  %215 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %214, ptr %117, 4
  %216 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %215, { i64, [32 x i8] } %156, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %216

217:                                              ; preds = %120
  %218 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %97, 0
  %219 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %218, i64 %98, 1
  %220 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %219, i64 %34, 2
  %221 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %220, i64 %99, 3
  %222 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %221, ptr %36, 4
  %223 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %222, { i64, [32 x i8] } %124, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %223

224:                                              ; preds = %61
  %225 = phi { ptr, i32, i32, i32 } [ %68, %61 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %225)
  call void @"drop$409"(ptr %69)
  %226 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"()
  %227 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %226, 0
  %228 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %227, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %228, ptr %18, align 8
  %229 = load { i64, [32 x i8] }, ptr %18, align 8
  %230 = extractvalue { ptr, ptr, i64 } %14, 1
  %231 = load i64, ptr %230, align 8
  %232 = icmp eq i64 %231, 0
  %233 = sub i64 %231, 1
  %234 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %233, ptr %234, align 8
  br i1 %232, label %235, label %174

235:                                              ; preds = %224
  %236 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %70, 0
  %237 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %236, i64 %51, 1
  %238 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %237, i64 %34, 2
  %239 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %238, i64 %35, 3
  %240 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %239, ptr %36, 4
  %241 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %240, { i64, [32 x i8] } %229, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %241

242:                                              ; preds = %52
  %243 = phi i64 [ %51, %52 ]
  %244 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %245 = call ptr %244()
  %246 = getelementptr inbounds i64, ptr %245, i32 1
  %247 = load i64, ptr %246, align 8
  %248 = load i64, ptr %245, align 8
  %249 = mul i64 %248, 40190
  %250 = add i64 %247, %249
  %251 = call i64 @llvm.uadd.sat.i64(i64 %243, i64 %250)
  %252 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %56, 0
  %253 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %252, 0
  %254 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %253, i32 %55, 1
  %255 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, i32 } %254, 0
  %256 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, {} } %255, {} undef, 1
  %257 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } }, i32 }, {} } %256, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, {} } } %257, ptr %17, align 8
  %258 = load { i64, [32 x i8] }, ptr %17, align 8
  %259 = extractvalue { ptr, ptr, i64 } %14, 1
  %260 = load i64, ptr %259, align 8
  %261 = icmp eq i64 %260, 0
  %262 = sub i64 %260, 1
  %263 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %262, ptr %263, align 8
  br i1 %261, label %264, label %174

264:                                              ; preds = %242
  %265 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %42, 0
  %266 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %265, i64 %251, 1
  %267 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %266, i64 %34, 2
  %268 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %267, i64 %35, 3
  %269 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %268, ptr %36, 4
  %270 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %269, { i64, [32 x i8] } %258, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %270

271:                                              ; preds = %31
  %272 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %37, %31 ]
  call void @"drop$286"({ { { ptr, i32, i32, i32 } }, i32 } %272)
  %273 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %274 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %273, 0
  %275 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %274, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %275, ptr %16, align 8
  %276 = load { i64, [32 x i8] }, ptr %16, align 8
  %277 = extractvalue { ptr, ptr, i64 } %14, 1
  %278 = load i64, ptr %277, align 8
  %279 = icmp eq i64 %278, 0
  %280 = sub i64 %278, 1
  %281 = extractvalue { ptr, ptr, i64 } %14, 1
  store i64 %280, ptr %281, align 8
  br i1 %279, label %282, label %174

282:                                              ; preds = %271
  %283 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %42, 0
  %284 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %283, i64 %33, 1
  %285 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %284, i64 %34, 2
  %286 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %285, i64 %35, 3
  %287 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %286, ptr %36, 4
  %288 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %287, { i64, [32 x i8] } %276, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %288

289:                                              ; preds = %102
  call void @puts(ptr @assert_msg_101)
  call void @abort()
  unreachable

290:                                              ; preds = %130
  call void @puts(ptr @assert_msg_102)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } @f53(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, i32 } %5, i252 %6, i32 %7, { i252 } %8, { i3, [0 x i8] } %9) {
  %11 = call fastcc { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } @"impl$f53"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, i32 } %5, i252 %6, i32 %7, { i252 } %8, { i3, [0 x i8] } %9)
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %11, 0
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %11, 1
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %11, 2
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %11, 3
  %16 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %11, 4
  %17 = extractvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %11, 5
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %12, 0
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %18, i64 %13, 1
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %19, i64 %14, 2
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %20, i64 %15, 3
  %22 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %21, ptr %16, 4
  %23 = insertvalue { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %22, { i64, [32 x i8] } %17, 5
  ret { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %23
}

define void @_mlir_ciface_f53(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, i32 } %6, i252 %7, i32 %8, { i252 } %9, { i3, [0 x i8] } %10) {
  %12 = call { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } @f53(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, i32 } %6, i252 %7, i32 %8, { i252 } %9, { i3, [0 x i8] } %10)
  store { i64, i64, i64, i64, ptr, { i64, [32 x i8] } } %12, ptr %0, align 8
  ret void
}

define private void @"drop$192"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$192"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 96)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 96, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f54"(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %14 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f77"(i64 %0, i64 %1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %5)
  %18 = extractvalue { i64, i64, { i64, [24 x i8] } } %17, 0
  %19 = extractvalue { i64, i64, { i64, [24 x i8] } } %17, 1
  %20 = extractvalue { i64, i64, { i64, [24 x i8] } } %17, 2
  store { i64, [24 x i8] } %20, ptr %7, align 8
  %21 = load i1, ptr %7, align 1
  switch i1 %21, label %22 [
    i1 false, label %24
    i1 true, label %60
  ]

22:                                               ; preds = %6
  br i1 false, label %23, label %118

23:                                               ; preds = %22
  unreachable

24:                                               ; preds = %6
  %25 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %7, align 8
  %26 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %25, 1
  %27 = insertvalue { i252, i252, i252 } { i252 1062799989286861497646673457769309433976004466846907043354399004328696077865, i252 undef, i252 undef }, i252 %3, 1
  %28 = insertvalue { i252, i252, i252 } %27, i252 %4, 2
  %29 = call ptr @realloc(ptr null, i64 96)
  store { i252, i252, i252 } %28, ptr %29, align 16
  %30 = call ptr @realloc(ptr null, i64 112)
  store { i32, i32 } { i32 1, i32 3 }, ptr %30, align 4
  %31 = getelementptr inbounds i8, ptr %30, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %31, ptr %29, i64 96, i1 false)
  call void @free(ptr %29)
  %32 = call ptr @realloc(ptr null, i64 8)
  store ptr %31, ptr %32, align 8
  %33 = insertvalue { ptr, i32, i32, i32 } undef, ptr %32, 0
  %34 = insertvalue { ptr, i32, i32, i32 } %33, i32 0, 1
  %35 = insertvalue { ptr, i32, i32, i32 } %34, i32 3, 2
  %36 = insertvalue { ptr, i32, i32, i32 } %35, i32 3, 3
  %37 = extractvalue { { { ptr, i32, i32, i32 } } } %26, 0
  %38 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %37)
  %39 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %38, 0
  %40 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %38, 1
  %41 = extractvalue { { ptr, i32, i32, i32 } } %40, 0
  %42 = extractvalue { ptr, i32, i32, i32 } %41, 1
  %43 = extractvalue { ptr, i32, i32, i32 } %41, 2
  %44 = sub i32 %43, %42
  call void @"drop$27"({ ptr, i32, i32, i32 } %41)
  %45 = zext i32 %44 to i252
  %46 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %46, align 4
  %47 = getelementptr inbounds i8, ptr %46, i32 4
  store i32 0, ptr %47, align 4
  %48 = getelementptr inbounds i8, ptr %46, i32 16
  %49 = call ptr @realloc(ptr null, i64 8)
  store ptr %48, ptr %49, align 8
  %50 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %49, 0
  %51 = insertvalue { ptr, i32, i32, i32 } %50, i32 8, 3
  %52 = load ptr, ptr %49, align 8
  store i252 %45, ptr %52, align 16
  %53 = insertvalue { ptr, i32, i32, i32 } %51, i32 1, 2
  %54 = getelementptr inbounds i8, ptr %52, i32 -12
  store i32 1, ptr %54, align 4
  %55 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %18, i64 %19, { { ptr, i32, i32, i32 } } %39, { ptr, i32, i32, i32 } %53)
  %56 = extractvalue { i64, i64, { i64, [24 x i8] } } %55, 0
  %57 = extractvalue { i64, i64, { i64, [24 x i8] } } %55, 1
  %58 = extractvalue { i64, i64, { i64, [24 x i8] } } %55, 2
  store { i64, [24 x i8] } %58, ptr %9, align 8
  %59 = load i1, ptr %9, align 1
  switch i1 %59, label %69 [
    i1 false, label %71
    i1 true, label %88
  ]

60:                                               ; preds = %6
  %61 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %62 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %61, 1
  %63 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %62, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %63, ptr %8, align 8
  %64 = load { i64, [24 x i8] }, ptr %8, align 8
  %65 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %18, 0
  %66 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %65, i64 %19, 1
  %67 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %66, ptr %2, 2
  %68 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %67, { i64, [24 x i8] } %64, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %68

69:                                               ; preds = %24
  br i1 false, label %70, label %119

70:                                               ; preds = %69
  unreachable

71:                                               ; preds = %24
  %72 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %9, align 8
  %73 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %72, 1
  %74 = extractvalue { { ptr, i32, i32, i32 }, {} } %73, 0
  %75 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %74)
  %76 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %75, 0
  %77 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %75, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %76)
  %78 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %36, 0
  %79 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %77, 0
  %80 = load ptr, ptr %2, align 8
  store i64 %57, ptr %12, align 8
  store { { ptr, i32, i32, i32 } } %78, ptr %13, align 8
  store { { ptr, i32, i32, i32 } } %79, ptr %14, align 8
  %81 = getelementptr inbounds ptr, ptr %2, i32 10
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %11, ptr %80, ptr %12, ptr %13, ptr %14)
  %83 = load { i1, [31 x i8] }, ptr %11, align 1
  %84 = extractvalue { i1, [31 x i8] } %83, 0
  %85 = getelementptr inbounds i8, ptr %11, i32 8
  %86 = load { ptr, i32, i32, i32 }, ptr %85, align 8
  %87 = load i64, ptr %12, align 8
  br i1 %84, label %107, label %97

88:                                               ; preds = %24
  %89 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %90 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %89, 1
  call void @"drop$27"({ ptr, i32, i32, i32 } %36)
  %91 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %90, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %91, ptr %10, align 8
  %92 = load { i64, [24 x i8] }, ptr %10, align 8
  %93 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %56, 0
  %94 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %57, 1
  %95 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %94, ptr %2, 2
  %96 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %95, { i64, [24 x i8] } %92, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %96

97:                                               ; preds = %71
  %98 = phi i64 [ %87, %71 ]
  %99 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %100 = call ptr %99()
  %101 = call i64 @llvm.uadd.sat.i64(i64 %98, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %16, align 1
  %102 = load { i64, [24 x i8] }, ptr %16, align 8
  %103 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %56, 0
  %104 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %103, i64 %101, 1
  %105 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %104, ptr %2, 2
  %106 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %105, { i64, [24 x i8] } %102, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %106

107:                                              ; preds = %71
  %108 = phi {} [ undef, %71 ]
  %109 = phi { ptr, i32, i32, i32 } [ %86, %71 ]
  %110 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %108, 0
  %111 = insertvalue { {}, { ptr, i32, i32, i32 } } %110, { ptr, i32, i32, i32 } %109, 1
  %112 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %111, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %112, ptr %15, align 8
  %113 = load { i64, [24 x i8] }, ptr %15, align 8
  %114 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %56, 0
  %115 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %114, i64 %87, 1
  %116 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %115, ptr %2, 2
  %117 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %116, { i64, [24 x i8] } %113, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %117

118:                                              ; preds = %22
  call void @puts(ptr @assert_msg_103)
  call void @abort()
  unreachable

119:                                              ; preds = %69
  call void @puts(ptr @assert_msg_104)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f54(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f54"(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %9, 1
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, ptr %10, 2
  %15 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %11, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %15
}

define void @_mlir_ciface_f54(ptr %0, i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, ptr, { i64, [24 x i8] } } @f54(i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %6)
  store { i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 1749165063169615148890104124711417950509560691)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f55() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f55(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f55()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f56"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i32, [8 x i8] }, i64 1, align 4
  %5 = alloca { i128, [144 x i8] }, i64 1, align 16
  %6 = alloca { i128, [192 x i8] }, i64 1, align 16
  %7 = alloca { i128, [128 x i8] }, i64 1, align 16
  %8 = alloca { i128, [192 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [144 x i8] }, i64 1, align 16
  %11 = alloca { i128, [192 x i8] }, i64 1, align 16
  %12 = alloca { i64, [56 x i8] }, i64 1, align 8
  %13 = alloca { i128, [192 x i8] }, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [144 x i8] }, i64 1, align 16
  %16 = alloca { i128, [192 x i8] }, i64 1, align 16
  %17 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f22"(i64 %0, { { ptr, i32, i32, i32 } } %2)
  %18 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %17, 0
  %19 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %17, 1
  %20 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %17, 2
  store { i32, [8 x i8] } %20, ptr %4, align 4
  %21 = load i1, ptr %4, align 1
  switch i1 %21, label %22 [
    i1 false, label %24
    i1 true, label %32
  ]

22:                                               ; preds = %3
  br i1 false, label %23, label %306

23:                                               ; preds = %22
  unreachable

24:                                               ; preds = %3
  %25 = load { i1, { i32, [4 x i8] } }, ptr %4, align 4
  %26 = extractvalue { i1, { i32, [4 x i8] } } %25, 1
  %27 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f23"(i64 %18, i64 %1, { { ptr, i32, i32, i32 } } %19)
  %28 = extractvalue { i64, i64, { i128, [128 x i8] } } %27, 0
  %29 = extractvalue { i64, i64, { i128, [128 x i8] } } %27, 1
  %30 = extractvalue { i64, i64, { i128, [128 x i8] } } %27, 2
  store { i128, [128 x i8] } %30, ptr %7, align 16
  %31 = load i1, ptr %7, align 1
  switch i1 %31, label %38 [
    i1 false, label %40
    i1 true, label %46
  ]

32:                                               ; preds = %3
  %33 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %34 = call ptr %33()
  %35 = load i64, ptr %34, align 8
  %36 = mul i64 %35, 16110
  %37 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %36)
  br label %294

38:                                               ; preds = %24
  br i1 false, label %39, label %307

39:                                               ; preds = %38
  unreachable

40:                                               ; preds = %24
  %41 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %7, align 16
  %42 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %41, 1
  %43 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %42, 0
  %44 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %42, 1
  store { i128, [80 x i8] } %44, ptr %9, align 16
  %45 = load i1, ptr %9, align 1
  switch i1 %45, label %54 [
    i1 false, label %56
    i1 true, label %64
  ]

46:                                               ; preds = %24
  %47 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %48 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %47, 1
  %49 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %48, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %49, ptr %8, align 8
  %50 = load { i128, [192 x i8] }, ptr %8, align 16
  %51 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %28, 0
  %52 = insertvalue { i64, i64, { i128, [192 x i8] } } %51, i64 %29, 1
  %53 = insertvalue { i64, i64, { i128, [192 x i8] } } %52, { i128, [192 x i8] } %50, 2
  ret { i64, i64, { i128, [192 x i8] } } %53

54:                                               ; preds = %40
  br i1 false, label %55, label %308

55:                                               ; preds = %54
  unreachable

56:                                               ; preds = %40
  %57 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %9, align 16
  %58 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %57, 1
  %59 = extractvalue { { ptr, i32, i32, i32 } } %43, 0
  %60 = extractvalue { ptr, i32, i32, i32 } %59, 1
  %61 = extractvalue { ptr, i32, i32, i32 } %59, 2
  %62 = sub i32 %61, %60
  %63 = icmp uge i32 %62, 1
  br i1 %63, label %70, label %274

64:                                               ; preds = %40
  %65 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %66 = call ptr %65()
  %67 = load i64, ptr %66, align 8
  %68 = mul i64 %67, 8050
  %69 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %68)
  br label %294

70:                                               ; preds = %56
  %71 = extractvalue { ptr, i32, i32, i32 } %59, 0
  %72 = load ptr, ptr %71, align 8
  %73 = zext i32 %60 to i64
  %74 = mul i64 %73, 32
  %75 = getelementptr inbounds i8, ptr %72, i64 %74
  %76 = add i32 %60, 1
  %77 = insertvalue { ptr, i32, i32, i32 } %59, i32 %76, 1
  %78 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %78, ptr %75, i64 32, i1 false)
  %79 = load i252, ptr %78, align 16
  call void @free(ptr %78)
  %80 = icmp ult i252 %79, 4294967296
  %81 = add i64 %28, 2
  %82 = add i64 %28, 3
  %83 = select i1 %80, i64 %81, i64 %82
  %84 = trunc i252 %79 to i32
  br i1 %80, label %85, label %267

85:                                               ; preds = %70
  %86 = phi { ptr, i32, i32, i32 } [ %77, %70 ]
  %87 = extractvalue { ptr, i32, i32, i32 } %86, 1
  %88 = extractvalue { ptr, i32, i32, i32 } %86, 2
  %89 = sub i32 %88, %87
  %90 = icmp uge i32 %89, 1
  br i1 %90, label %91, label %260

91:                                               ; preds = %85
  %92 = extractvalue { ptr, i32, i32, i32 } %86, 0
  %93 = load ptr, ptr %92, align 8
  %94 = zext i32 %87 to i64
  %95 = mul i64 %94, 32
  %96 = getelementptr inbounds i8, ptr %93, i64 %95
  %97 = add i32 %87, 1
  %98 = insertvalue { ptr, i32, i32, i32 } %86, i32 %97, 1
  %99 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %99, ptr %96, i64 32, i1 false)
  %100 = load i252, ptr %99, align 16
  call void @free(ptr %99)
  %101 = icmp ult i252 %100, 4294967296
  %102 = add i64 %83, 2
  %103 = add i64 %83, 3
  %104 = select i1 %101, i64 %102, i64 %103
  %105 = trunc i252 %100 to i32
  br i1 %101, label %106, label %253

106:                                              ; preds = %91
  %107 = phi { ptr, i32, i32, i32 } [ %98, %91 ]
  %108 = extractvalue { ptr, i32, i32, i32 } %107, 1
  %109 = extractvalue { ptr, i32, i32, i32 } %107, 2
  %110 = sub i32 %109, %108
  %111 = icmp uge i32 %110, 1
  br i1 %111, label %112, label %246

112:                                              ; preds = %106
  %113 = extractvalue { ptr, i32, i32, i32 } %107, 0
  %114 = load ptr, ptr %113, align 8
  %115 = zext i32 %108 to i64
  %116 = mul i64 %115, 32
  %117 = getelementptr inbounds i8, ptr %114, i64 %116
  %118 = add i32 %108, 1
  %119 = insertvalue { ptr, i32, i32, i32 } %107, i32 %118, 1
  %120 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %120, ptr %117, i64 32, i1 false)
  %121 = load i252, ptr %120, align 16
  call void @free(ptr %120)
  %122 = icmp ult i252 %121, 4294967296
  %123 = add i64 %104, 2
  %124 = add i64 %104, 3
  %125 = select i1 %122, i64 %123, i64 %124
  %126 = trunc i252 %121 to i32
  br i1 %122, label %127, label %239

127:                                              ; preds = %112
  %128 = phi { ptr, i32, i32, i32 } [ %119, %112 ]
  %129 = extractvalue { ptr, i32, i32, i32 } %128, 1
  %130 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %131 = sub i32 %130, %129
  %132 = icmp uge i32 %131, 1
  br i1 %132, label %133, label %232

133:                                              ; preds = %127
  %134 = extractvalue { ptr, i32, i32, i32 } %128, 0
  %135 = load ptr, ptr %134, align 8
  %136 = zext i32 %129 to i64
  %137 = mul i64 %136, 32
  %138 = getelementptr inbounds i8, ptr %135, i64 %137
  %139 = add i32 %129, 1
  %140 = insertvalue { ptr, i32, i32, i32 } %128, i32 %139, 1
  %141 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %141, ptr %138, i64 32, i1 false)
  %142 = load i252, ptr %141, align 16
  call void @free(ptr %141)
  %143 = icmp ult i252 %142, 4294967296
  %144 = add i64 %125, 2
  %145 = add i64 %125, 3
  %146 = select i1 %143, i64 %144, i64 %145
  %147 = trunc i252 %142 to i32
  br i1 %143, label %148, label %225

148:                                              ; preds = %133
  %149 = phi { ptr, i32, i32, i32 } [ %140, %133 ]
  %150 = extractvalue { ptr, i32, i32, i32 } %149, 1
  %151 = extractvalue { ptr, i32, i32, i32 } %149, 2
  %152 = sub i32 %151, %150
  %153 = icmp uge i32 %152, 1
  br i1 %153, label %154, label %217

154:                                              ; preds = %148
  %155 = extractvalue { ptr, i32, i32, i32 } %149, 0
  %156 = load ptr, ptr %155, align 8
  %157 = zext i32 %150 to i64
  %158 = mul i64 %157, 32
  %159 = getelementptr inbounds i8, ptr %156, i64 %158
  %160 = add i32 %150, 1
  %161 = insertvalue { ptr, i32, i32, i32 } %149, i32 %160, 1
  %162 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %162, ptr %159, i64 32, i1 false)
  %163 = load i252, ptr %162, align 16
  call void @free(ptr %162)
  %164 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %161, 0
  %165 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f24"(i64 %146, i64 %29, { { ptr, i32, i32, i32 } } %164, { ptr, i32, i32, i32 } zeroinitializer, i252 %163)
  %166 = extractvalue { i64, i64, { i64, [56 x i8] } } %165, 0
  %167 = extractvalue { i64, i64, { i64, [56 x i8] } } %165, 1
  %168 = extractvalue { i64, i64, { i64, [56 x i8] } } %165, 2
  store { i64, [56 x i8] } %168, ptr %12, align 8
  %169 = load i1, ptr %12, align 1
  switch i1 %169, label %170 [
    i1 false, label %172
    i1 true, label %178
  ]

170:                                              ; preds = %154
  br i1 false, label %171, label %309

171:                                              ; preds = %170
  unreachable

172:                                              ; preds = %154
  %173 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %12, align 8
  %174 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %173, 1
  %175 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %174, 0
  %176 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %174, 1
  store { i64, [24 x i8] } %176, ptr %14, align 8
  %177 = load i1, ptr %14, align 1
  switch i1 %177, label %186 [
    i1 false, label %188
    i1 true, label %213
  ]

178:                                              ; preds = %154
  %179 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %180 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %179, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %58)
  %181 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %180, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %181, ptr %13, align 8
  %182 = load { i128, [192 x i8] }, ptr %13, align 16
  %183 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %166, 0
  %184 = insertvalue { i64, i64, { i128, [192 x i8] } } %183, i64 %167, 1
  %185 = insertvalue { i64, i64, { i128, [192 x i8] } } %184, { i128, [192 x i8] } %182, 2
  ret { i64, i64, { i128, [192 x i8] } } %185

186:                                              ; preds = %172
  br i1 false, label %187, label %310

187:                                              ; preds = %186
  unreachable

188:                                              ; preds = %172
  %189 = load { i1, { ptr, i32, i32, i32 } }, ptr %14, align 8
  %190 = extractvalue { i1, { ptr, i32, i32, i32 } } %189, 1
  %191 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %192 = call ptr %191()
  %193 = load i64, ptr %192, align 8
  %194 = mul i64 %193, 500
  %195 = call i64 @llvm.uadd.sat.i64(i64 %167, i64 %194)
  %196 = insertvalue { i32, i32, i32, i32 } undef, i32 %84, 0
  %197 = insertvalue { i32, i32, i32, i32 } %196, i32 %105, 1
  %198 = insertvalue { i32, i32, i32, i32 } %197, i32 %126, 2
  %199 = insertvalue { i32, i32, i32, i32 } %198, i32 %147, 3
  %200 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { i32, [4 x i8] } %26, 0
  %201 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %200, { { ptr, i32, i32, i32 }, i252, i32 } %58, 1
  %202 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, { i32, i32, i32, i32 } %199, 2
  %203 = insertvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %202, { ptr, i32, i32, i32 } %190, 3
  %204 = insertvalue { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } { i1 false, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %203, 1
  store { i1, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %204, ptr %15, align 16
  %205 = load { i128, [144 x i8] }, ptr %15, align 16
  %206 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %175, 0
  %207 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %206, { i128, [144 x i8] } %205, 1
  %208 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %207, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %208, ptr %16, align 16
  %209 = load { i128, [192 x i8] }, ptr %16, align 16
  %210 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %166, 0
  %211 = insertvalue { i64, i64, { i128, [192 x i8] } } %210, i64 %195, 1
  %212 = insertvalue { i64, i64, { i128, [192 x i8] } } %211, { i128, [192 x i8] } %209, 2
  ret { i64, i64, { i128, [192 x i8] } } %212

213:                                              ; preds = %172
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %58)
  %214 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %215 = call ptr %214()
  %216 = call i64 @llvm.uadd.sat.i64(i64 %167, i64 0)
  br label %294

217:                                              ; preds = %148
  %218 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %148 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %218)
  %219 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %220 = call ptr %219()
  %221 = load i64, ptr %220, align 8
  %222 = mul i64 %221, 3270
  %223 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %222)
  %224 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %149, 0
  br label %294

225:                                              ; preds = %133
  %226 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %133 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %226)
  %227 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %228 = call ptr %227()
  %229 = load i64, ptr %228, align 8
  %230 = mul i64 %229, 3100
  %231 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %230)
  br label %281

232:                                              ; preds = %127
  %233 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %127 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %233)
  %234 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %235 = call ptr %234()
  %236 = load i64, ptr %235, align 8
  %237 = mul i64 %236, 4300
  %238 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %237)
  br label %281

239:                                              ; preds = %112
  %240 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %112 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %240)
  %241 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %242 = call ptr %241()
  %243 = load i64, ptr %242, align 8
  %244 = mul i64 %243, 4130
  %245 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %244)
  br label %281

246:                                              ; preds = %106
  %247 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %106 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %247)
  %248 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %249 = call ptr %248()
  %250 = load i64, ptr %249, align 8
  %251 = mul i64 %250, 5330
  %252 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %251)
  br label %281

253:                                              ; preds = %91
  %254 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %91 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %254)
  %255 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %256 = call ptr %255()
  %257 = load i64, ptr %256, align 8
  %258 = mul i64 %257, 5160
  %259 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %258)
  br label %281

260:                                              ; preds = %85
  %261 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %85 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %261)
  %262 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %263 = call ptr %262()
  %264 = load i64, ptr %263, align 8
  %265 = mul i64 %264, 6360
  %266 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %265)
  br label %281

267:                                              ; preds = %70
  %268 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %70 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %268)
  %269 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %270 = call ptr %269()
  %271 = load i64, ptr %270, align 8
  %272 = mul i64 %271, 6190
  %273 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %272)
  br label %281

274:                                              ; preds = %56
  %275 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %56 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %275)
  %276 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %277 = call ptr %276()
  %278 = load i64, ptr %277, align 8
  %279 = mul i64 %278, 7490
  %280 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %279)
  br label %281

281:                                              ; preds = %225, %232, %239, %246, %253, %260, %267, %274
  %282 = phi i64 [ %28, %274 ], [ %83, %267 ], [ %83, %260 ], [ %104, %253 ], [ %104, %246 ], [ %125, %239 ], [ %125, %232 ], [ %146, %225 ]
  %283 = phi i64 [ %280, %274 ], [ %273, %267 ], [ %266, %260 ], [ %259, %253 ], [ %252, %246 ], [ %245, %239 ], [ %238, %232 ], [ %231, %225 ]
  %284 = phi { ptr, i32, i32, i32 } [ %59, %274 ], [ %77, %267 ], [ %86, %260 ], [ %98, %253 ], [ %107, %246 ], [ %119, %239 ], [ %128, %232 ], [ %140, %225 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %10, align 1
  %285 = load { i128, [144 x i8] }, ptr %10, align 16
  %286 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %284, 0
  %287 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %286, 0
  %288 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %287, { i128, [144 x i8] } %285, 1
  %289 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %288, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %289, ptr %11, align 16
  %290 = load { i128, [192 x i8] }, ptr %11, align 16
  %291 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %282, 0
  %292 = insertvalue { i64, i64, { i128, [192 x i8] } } %291, i64 %283, 1
  %293 = insertvalue { i64, i64, { i128, [192 x i8] } } %292, { i128, [192 x i8] } %290, 2
  ret { i64, i64, { i128, [192 x i8] } } %293

294:                                              ; preds = %213, %217, %64, %32
  %295 = phi i64 [ %146, %217 ], [ %166, %213 ], [ %28, %64 ], [ %18, %32 ]
  %296 = phi i64 [ %223, %217 ], [ %216, %213 ], [ %69, %64 ], [ %37, %32 ]
  %297 = phi { { ptr, i32, i32, i32 } } [ %224, %217 ], [ %175, %213 ], [ %43, %64 ], [ %19, %32 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %5, align 1
  %298 = load { i128, [144 x i8] }, ptr %5, align 16
  %299 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %297, 0
  %300 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %299, { i128, [144 x i8] } %298, 1
  %301 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %300, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %301, ptr %6, align 16
  %302 = load { i128, [192 x i8] }, ptr %6, align 16
  %303 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %295, 0
  %304 = insertvalue { i64, i64, { i128, [192 x i8] } } %303, i64 %296, 1
  %305 = insertvalue { i64, i64, { i128, [192 x i8] } } %304, { i128, [192 x i8] } %302, 2
  ret { i64, i64, { i128, [192 x i8] } } %305

306:                                              ; preds = %22
  call void @puts(ptr @assert_msg_105)
  call void @abort()
  unreachable

307:                                              ; preds = %38
  call void @puts(ptr @assert_msg_106)
  call void @abort()
  unreachable

308:                                              ; preds = %54
  call void @puts(ptr @assert_msg_107)
  call void @abort()
  unreachable

309:                                              ; preds = %170
  call void @puts(ptr @assert_msg_108)
  call void @abort()
  unreachable

310:                                              ; preds = %186
  call void @puts(ptr @assert_msg_109)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [192 x i8] } } @f56(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f56"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [192 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [192 x i8] } } %9, { i128, [192 x i8] } %7, 2
  ret { i64, i64, { i128, [192 x i8] } } %10
}

define void @_mlir_ciface_f56(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [192 x i8] } } @f56(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [192 x i8] } } %5, ptr %0, align 16
  ret void
}

define private void @"drop$180"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$106"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$180"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$181"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  call void @"drop$180"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$181"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$180"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %6, i32 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %7, i32 %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } undef, { { { ptr, i32, i32, i32 } }, i32 } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %11, { { { ptr, i32, i32, i32 } }, i32 } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %12
}

define private void @"drop$183"({ { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$181"({ { { ptr, i32, i32, i32 } }, i32 } %2)
  %3 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$106"({ ptr, i32, i32, i32 } %3)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 2
  call void @"drop$182"({ ptr, i32, i32, i32 } %4)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } @"dup$183"({ { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$181"({ { { ptr, i32, i32, i32 } }, i32 } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, { { { ptr, i32, i32, i32 } }, i32 } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, i32 } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$182"({ ptr, i32, i32, i32 } %14)
  %16 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %15, 0
  %17 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %15, 1
  %18 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %12, { ptr, i32, i32, i32 } %16, 2
  %19 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %13, { ptr, i32, i32, i32 } %17, 2
  %20 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %0, 3
  %21 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %18, {} %20, 3
  %22 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %19, {} %20, 3
  %23 = insertvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %21, 0
  %24 = insertvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %23, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %22, 1
  ret { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %24
}

define private void @"drop$185"(ptr %0) {
  %2 = load { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, ptr %0, align 16
  call void @"drop$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$185"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 144)
  %3 = load { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, ptr %0, align 16
  %4 = call { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3)
  %5 = extractvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %4, 0
  %6 = extractvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %4, 1
  store { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, ptr %0, align 16
  store { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$184"({ i64, [80 x i8] } %0) {
  %2 = alloca { i64, [80 x i8] }, i64 1, align 8
  store { i64, [80 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$183"({ { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [80 x i8] }, { i64, [80 x i8] } } @"dup$184"({ i64, [80 x i8] } %0) {
  %2 = alloca { i64, [80 x i8] }, i64 1, align 8
  store { i64, [80 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } @"dup$183"({ { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [80 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [80 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [80 x i8] }, { i64, [80 x i8] } } undef, { i64, [80 x i8] } %11, 0
  %15 = insertvalue { { i64, [80 x i8] }, { i64, [80 x i8] } } %14, { i64, [80 x i8] } %13, 1
  ret { { i64, [80 x i8] }, { i64, [80 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [80 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [80 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [80 x i8] }, { i64, [80 x i8] } } undef, { i64, [80 x i8] } %23, 0
  %27 = insertvalue { { i64, [80 x i8] }, { i64, [80 x i8] } } %26, { i64, [80 x i8] } %25, 1
  ret { { i64, [80 x i8] }, { i64, [80 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f57"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6, { ptr, i32, i32, i32 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = alloca i64, i64 1, align 8
  %11 = insertvalue { ptr, ptr, i64 } undef, ptr %10, 0
  %12 = insertvalue { ptr, ptr, i64 } %11, ptr %10, 1
  %13 = insertvalue { ptr, ptr, i64 } %12, i64 0, 2
  %14 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 0, ptr %14, align 8
  %15 = alloca { i64, [72 x i8] }, i64 1, align 8
  %16 = alloca { i64, [72 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [72 x i8] }, i64 1, align 8
  %19 = alloca { i32, [4 x i8] }, i64 1, align 4
  %20 = alloca { i128, [64 x i8] }, i64 1, align 16
  %21 = alloca { i64, [72 x i8] }, i64 1, align 8
  %22 = alloca { i32, [4 x i8] }, i64 1, align 4
  %23 = alloca i256, i64 1, align 16
  %24 = alloca i256, i64 1, align 16
  %25 = alloca i256, i64 1, align 16
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = alloca { i64, [72 x i8] }, i64 1, align 8
  %28 = alloca { i64, [24 x i8] }, i64 1, align 8
  %29 = alloca { i64, [72 x i8] }, i64 1, align 8
  %30 = alloca { i32, [4 x i8] }, i64 1, align 4
  %31 = alloca { i64, [80 x i8] }, i64 1, align 8
  %32 = alloca { i64, [72 x i8] }, i64 1, align 8
  %33 = alloca { i64, [24 x i8] }, i64 1, align 8
  %34 = alloca { i64, [72 x i8] }, i64 1, align 8
  br label %35

35:                                               ; preds = %346, %9
  %36 = phi i64 [ %329, %346 ], [ %0, %9 ]
  %37 = phi i64 [ %349, %346 ], [ %1, %9 ]
  %38 = phi i64 [ %296, %346 ], [ %2, %9 ]
  %39 = phi i64 [ %295, %346 ], [ %3, %9 ]
  %40 = phi ptr [ %331, %346 ], [ %4, %9 ]
  %41 = phi { { ptr, i32, i32, i32 } } [ %353, %346 ], [ %5, %9 ]
  %42 = phi { {} } [ %303, %346 ], [ %6, %9 ]
  %43 = phi { ptr, i32, i32, i32 } [ %352, %346 ], [ %7, %9 ]
  %44 = phi { ptr, i32, i32, i32 } [ %351, %346 ], [ %8, %9 ]
  %45 = add i64 %36, 1
  %46 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %47 = call ptr %46()
  %48 = getelementptr inbounds i64, ptr %47, i32 1
  %49 = load i64, ptr %48, align 8
  %50 = mul i64 %49, 2
  %51 = load i64, ptr %47, align 8
  %52 = mul i64 %51, 115930
  %53 = add i64 %50, %52
  %54 = icmp uge i64 %37, %53
  %55 = call i64 @llvm.usub.sat.i64(i64 %37, i64 %53)
  br i1 %54, label %56, label %460

56:                                               ; preds = %35
  %57 = phi { { ptr, i32, i32, i32 } } [ %41, %35 ]
  %58 = extractvalue { { ptr, i32, i32, i32 } } %57, 0
  %59 = extractvalue { ptr, i32, i32, i32 } %58, 1
  %60 = extractvalue { ptr, i32, i32, i32 } %58, 2
  %61 = sub i32 %60, %59
  %62 = icmp uge i32 %61, 1
  br i1 %62, label %63, label %429

63:                                               ; preds = %56
  %64 = extractvalue { ptr, i32, i32, i32 } %58, 0
  %65 = load ptr, ptr %64, align 8
  %66 = zext i32 %59 to i64
  %67 = mul i64 %66, 144
  %68 = getelementptr inbounds i8, ptr %65, i64 %67
  %69 = add i32 %59, 1
  %70 = insertvalue { ptr, i32, i32, i32 } %58, i32 %69, 1
  %71 = call ptr @realloc(ptr null, i64 144)
  %72 = load { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, ptr %68, align 16
  %73 = call { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$278"({ { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %72)
  %74 = extractvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %73, 0
  %75 = extractvalue { { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %73, 1
  store { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %74, ptr %68, align 16
  store { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %75, ptr %71, align 16
  %76 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f47"(i64 %45, i64 %55, i64 %38, ptr %40, { {} } %42)
  %77 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %76, 0
  %78 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %76, 1
  %79 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %76, 2
  %80 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %76, 3
  %81 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %76, 4
  store { i64, [24 x i8] } %81, ptr %17, align 8
  %82 = load i1, ptr %17, align 1
  switch i1 %82, label %83 [
    i1 false, label %85
    i1 true, label %105
  ]

83:                                               ; preds = %63
  br i1 false, label %84, label %478

84:                                               ; preds = %83
  unreachable

85:                                               ; preds = %63
  %86 = load { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } }, ptr %71, align 16
  call void @free(ptr %71)
  %87 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, 0
  %88 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, 1
  %89 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, 2
  %90 = extractvalue { { i32, [4 x i8] }, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, 3
  store { i32, [4 x i8] } %87, ptr %19, align 4
  %91 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f48"(ptr %19, { ptr, i32, i32, i32 } zeroinitializer)
  %92 = extractvalue { { ptr, i32, i32, i32 } } %91, 0
  %93 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %94 = call ptr %93()
  %95 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %92)
  %96 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 0
  %97 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %96)
  %98 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %97, 0
  %99 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %77, i64 %78, i64 %39, ptr %94, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %98)
  %100 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %99, 0
  %101 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %99, 1
  %102 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %99, 2
  %103 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %99, 3
  store { i128, [64 x i8] } %103, ptr %20, align 16
  %104 = load i1, ptr %20, align 1
  switch i1 %104, label %115 [
    i1 false, label %117
    i1 true, label %123
  ]

105:                                              ; preds = %63
  %106 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %107 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %106, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %70)
  call void @"drop$106"({ ptr, i32, i32, i32 } %44)
  call void @"drop$182"({ ptr, i32, i32, i32 } %43)
  call void @"drop$185"(ptr %71)
  %108 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %107, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %108, ptr %18, align 8
  %109 = load { i64, [72 x i8] }, ptr %18, align 8
  %110 = extractvalue { ptr, ptr, i64 } %13, 1
  %111 = load i64, ptr %110, align 8
  %112 = icmp eq i64 %111, 0
  %113 = sub i64 %111, 1
  %114 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %113, ptr %114, align 8
  br i1 %112, label %422, label %368

115:                                              ; preds = %85
  br i1 false, label %116, label %479

116:                                              ; preds = %115
  unreachable

117:                                              ; preds = %85
  %118 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %20, align 16
  %119 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %118, 1
  %120 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %119, 0
  %121 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %119, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %120)
  store { i32, [4 x i8] } %87, ptr %22, align 4
  %122 = load i3, ptr %22, align 1
  switch i3 %122, label %133 [
    i3 0, label %135
    i3 1, label %141
    i3 2, label %145
    i3 3, label %149
    i3 -4, label %153
    i3 -3, label %157
    i3 -2, label %163
  ]

123:                                              ; preds = %85
  %124 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %20, align 8
  %125 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %124, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %70)
  call void @"drop$106"({ ptr, i32, i32, i32 } %90)
  call void @"drop$106"({ ptr, i32, i32, i32 } %44)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %88)
  call void @"drop$182"({ ptr, i32, i32, i32 } %43)
  %126 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %125, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %126, ptr %21, align 8
  %127 = load { i64, [72 x i8] }, ptr %21, align 8
  %128 = extractvalue { ptr, ptr, i64 } %13, 1
  %129 = load i64, ptr %128, align 8
  %130 = icmp eq i64 %129, 0
  %131 = sub i64 %129, 1
  %132 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %131, ptr %132, align 8
  br i1 %130, label %415, label %368

133:                                              ; preds = %117
  br i1 false, label %134, label %480

134:                                              ; preds = %133
  unreachable

135:                                              ; preds = %117
  %136 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %137 = call ptr %136()
  %138 = load i64, ptr %137, align 8
  %139 = mul i64 %138, 100
  %140 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 %139)
  br label %169

141:                                              ; preds = %117
  %142 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %143 = call ptr %142()
  %144 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 0)
  br label %169

145:                                              ; preds = %117
  %146 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %147 = call ptr %146()
  %148 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 0)
  br label %169

149:                                              ; preds = %117
  %150 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %151 = call ptr %150()
  %152 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 0)
  br label %169

153:                                              ; preds = %117
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 0)
  br label %169

157:                                              ; preds = %117
  %158 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %159 = call ptr %158()
  %160 = load i64, ptr %159, align 8
  %161 = mul i64 %160, 100
  %162 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 %161)
  br label %169

163:                                              ; preds = %117
  %164 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %165 = call ptr %164()
  %166 = load i64, ptr %165, align 8
  %167 = mul i64 %166, 200
  %168 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 %167)
  br label %169

169:                                              ; preds = %135, %141, %145, %149, %153, %157, %163
  %170 = phi { ptr, i32, i32, i32 } [ %43, %163 ], [ %43, %157 ], [ %43, %153 ], [ %43, %149 ], [ %43, %145 ], [ %43, %141 ], [ %43, %135 ]
  %171 = phi { ptr, i32, i32, i32 } [ %44, %163 ], [ %44, %157 ], [ %44, %153 ], [ %44, %149 ], [ %44, %145 ], [ %44, %141 ], [ %44, %135 ]
  %172 = phi { ptr, i32, i32, i32 } [ %70, %163 ], [ %70, %157 ], [ %70, %153 ], [ %70, %149 ], [ %70, %145 ], [ %70, %141 ], [ %70, %135 ]
  %173 = phi i252 [ %121, %163 ], [ %121, %157 ], [ %121, %153 ], [ %121, %149 ], [ %121, %145 ], [ %121, %141 ], [ %121, %135 ]
  %174 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %88, %163 ], [ %88, %157 ], [ %88, %153 ], [ %88, %149 ], [ %88, %145 ], [ %88, %141 ], [ %88, %135 ]
  %175 = phi { i32, i32, i32, i32 } [ %89, %163 ], [ %89, %157 ], [ %89, %153 ], [ %89, %149 ], [ %89, %145 ], [ %89, %141 ], [ %89, %135 ]
  %176 = phi i252 [ 422073521398876225481035229297186717153911541103484599068011287805644405767, %163 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %157 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %153 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %149 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %145 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %141 ], [ 1334664777155929186801060013143550635909228974761917574271585221149587386350, %135 ]
  %177 = phi { ptr, i32, i32, i32 } [ %90, %163 ], [ %90, %157 ], [ %90, %153 ], [ %90, %149 ], [ %90, %145 ], [ %90, %141 ], [ %90, %135 ]
  %178 = phi ptr [ %80, %163 ], [ %80, %157 ], [ %80, %153 ], [ %80, %149 ], [ %80, %145 ], [ %80, %141 ], [ %80, %135 ]
  %179 = phi i64 [ %79, %163 ], [ %79, %157 ], [ %79, %153 ], [ %79, %149 ], [ %79, %145 ], [ %79, %141 ], [ %79, %135 ]
  %180 = phi { {} } [ %42, %163 ], [ %42, %157 ], [ %42, %153 ], [ %42, %149 ], [ %42, %145 ], [ %42, %141 ], [ %42, %135 ]
  %181 = phi { i32, [4 x i8] } [ %87, %163 ], [ %87, %157 ], [ %87, %153 ], [ %87, %149 ], [ %87, %145 ], [ %87, %141 ], [ %87, %135 ]
  %182 = phi i64 [ %100, %163 ], [ %100, %157 ], [ %100, %153 ], [ %100, %149 ], [ %100, %145 ], [ %100, %141 ], [ %100, %135 ]
  %183 = phi i64 [ %102, %163 ], [ %102, %157 ], [ %102, %153 ], [ %102, %149 ], [ %102, %145 ], [ %102, %141 ], [ %102, %135 ]
  %184 = phi i64 [ %168, %163 ], [ %162, %157 ], [ %156, %153 ], [ %152, %149 ], [ %148, %145 ], [ %144, %141 ], [ %140, %135 ]
  %185 = phi i252 [ 119674880063757522161687995182389208939526319504019663621515716359683735285, %163 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %157 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %153 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %149 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %145 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %141 ], [ 926137786937080942066379705305780976156692330066586492942502267841683559500, %135 ]
  %186 = add i64 %179, 3
  %187 = zext i252 %185 to i256
  %188 = zext i252 %173 to i256
  store i256 %187, ptr %23, align 16
  store i256 %188, ptr %24, align 16
  %189 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %189(ptr %25, ptr %23, ptr %24)
  %190 = load i256, ptr %25, align 16
  %191 = trunc i256 %190 to i252
  %192 = add i64 %182, 3
  %193 = sub i252 %191, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %194 = icmp ult i252 %191, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %195 = select i1 %194, i252 %191, i252 %193
  %196 = insertvalue { i252 } undef, i252 %195, 0
  %197 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f50"(i64 %192, i64 %184, ptr %178, { i252 } %196, { i32, i32, i32, i32 } %175)
  %198 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %197, 0
  %199 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %197, 1
  %200 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %197, 2
  %201 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %197, 3
  store { i64, [24 x i8] } %201, ptr %26, align 8
  %202 = load i1, ptr %26, align 1
  switch i1 %202, label %203 [
    i1 false, label %205
    i1 true, label %221
  ]

203:                                              ; preds = %169
  br i1 false, label %204, label %481

204:                                              ; preds = %203
  unreachable

205:                                              ; preds = %169
  %206 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$106"({ ptr, i32, i32, i32 } %177)
  %207 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %206, 0
  %208 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %206, 1
  %209 = extractvalue { ptr, i32, i32, i32 } %208, 1
  %210 = extractvalue { ptr, i32, i32, i32 } %208, 2
  %211 = sub i32 %210, %209
  call void @"drop$107"({ ptr, i32, i32, i32 } %208)
  %212 = insertvalue { i252 } undef, i252 %176, 0
  %213 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f52"(i64 %198, i64 %199, i64 %186, i64 %183, ptr %200, i252 %173, i32 %211, { i252 } %212)
  %214 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, 0
  %215 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, 1
  %216 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, 2
  %217 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, 3
  %218 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, 4
  %219 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, 5
  store { i64, [24 x i8] } %219, ptr %28, align 8
  %220 = load i1, ptr %28, align 1
  switch i1 %220, label %231 [
    i1 false, label %233
    i1 true, label %235
  ]

221:                                              ; preds = %169
  %222 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %26, align 8
  %223 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %222, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %172)
  call void @"drop$106"({ ptr, i32, i32, i32 } %171)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %174)
  call void @"drop$182"({ ptr, i32, i32, i32 } %170)
  call void @"drop$106"({ ptr, i32, i32, i32 } %177)
  %224 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %223, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %224, ptr %27, align 8
  %225 = load { i64, [72 x i8] }, ptr %27, align 8
  %226 = extractvalue { ptr, ptr, i64 } %13, 1
  %227 = load i64, ptr %226, align 8
  %228 = icmp eq i64 %227, 0
  %229 = sub i64 %227, 1
  %230 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %229, ptr %230, align 8
  br i1 %228, label %408, label %368

231:                                              ; preds = %205
  br i1 false, label %232, label %482

232:                                              ; preds = %231
  unreachable

233:                                              ; preds = %205
  store { i32, [4 x i8] } %181, ptr %30, align 4
  %234 = load i3, ptr %30, align 1
  switch i3 %234, label %245 [
    i3 0, label %247
    i3 1, label %253
    i3 2, label %259
    i3 3, label %265
    i3 -4, label %271
    i3 -3, label %277
    i3 -2, label %283
  ]

235:                                              ; preds = %205
  %236 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %28, align 8
  %237 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %236, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %172)
  call void @"drop$106"({ ptr, i32, i32, i32 } %207)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %174)
  call void @"drop$182"({ ptr, i32, i32, i32 } %170)
  call void @"drop$106"({ ptr, i32, i32, i32 } %171)
  %238 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %237, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %238, ptr %29, align 8
  %239 = load { i64, [72 x i8] }, ptr %29, align 8
  %240 = extractvalue { ptr, ptr, i64 } %13, 1
  %241 = load i64, ptr %240, align 8
  %242 = icmp eq i64 %241, 0
  %243 = sub i64 %241, 1
  %244 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %243, ptr %244, align 8
  br i1 %242, label %401, label %368

245:                                              ; preds = %233
  br i1 false, label %246, label %483

246:                                              ; preds = %245
  unreachable

247:                                              ; preds = %233
  %248 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %249 = call ptr %248()
  %250 = load i64, ptr %249, align 8
  %251 = mul i64 %250, 100
  %252 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 %251)
  br label %291

253:                                              ; preds = %233
  %254 = load { i3, i32 }, ptr %30, align 4
  %255 = extractvalue { i3, i32 } %254, 1
  %256 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %257 = call ptr %256()
  %258 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 0)
  br label %291

259:                                              ; preds = %233
  %260 = load { i3, i32 }, ptr %30, align 4
  %261 = extractvalue { i3, i32 } %260, 1
  %262 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %263 = call ptr %262()
  %264 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 0)
  br label %291

265:                                              ; preds = %233
  %266 = load { i3, i32 }, ptr %30, align 4
  %267 = extractvalue { i3, i32 } %266, 1
  %268 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %269 = call ptr %268()
  %270 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 0)
  br label %291

271:                                              ; preds = %233
  %272 = load { i3, i32 }, ptr %30, align 4
  %273 = extractvalue { i3, i32 } %272, 1
  %274 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %275 = call ptr %274()
  %276 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 0)
  br label %291

277:                                              ; preds = %233
  %278 = load { i3, i32 }, ptr %30, align 4
  %279 = extractvalue { i3, i32 } %278, 1
  %280 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %281 = call ptr %280()
  %282 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 0)
  br label %291

283:                                              ; preds = %233
  %284 = load { i3, i32 }, ptr %30, align 4
  %285 = extractvalue { i3, i32 } %284, 1
  %286 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %287 = call ptr %286()
  %288 = load i64, ptr %287, align 8
  %289 = mul i64 %288, 100
  %290 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 %289)
  br label %291

291:                                              ; preds = %247, %253, %259, %265, %271, %277, %283
  %292 = phi { ptr, i32, i32, i32 } [ %170, %283 ], [ %170, %277 ], [ %170, %271 ], [ %170, %265 ], [ %170, %259 ], [ %170, %253 ], [ %170, %247 ]
  %293 = phi { ptr, i32, i32, i32 } [ %171, %283 ], [ %171, %277 ], [ %171, %271 ], [ %171, %265 ], [ %171, %259 ], [ %171, %253 ], [ %171, %247 ]
  %294 = phi { ptr, i32, i32, i32 } [ %172, %283 ], [ %172, %277 ], [ %172, %271 ], [ %172, %265 ], [ %172, %259 ], [ %172, %253 ], [ %172, %247 ]
  %295 = phi i64 [ %217, %283 ], [ %217, %277 ], [ %217, %271 ], [ %217, %265 ], [ %217, %259 ], [ %217, %253 ], [ %217, %247 ]
  %296 = phi i64 [ %216, %283 ], [ %216, %277 ], [ %216, %271 ], [ %216, %265 ], [ %216, %259 ], [ %216, %253 ], [ %216, %247 ]
  %297 = phi { i3, [0 x i8] } [ { i3 -2, [0 x i8] undef }, %283 ], [ { i3 -3, [0 x i8] undef }, %277 ], [ { i3 -4, [0 x i8] undef }, %271 ], [ { i3 3, [0 x i8] undef }, %265 ], [ { i3 2, [0 x i8] undef }, %259 ], [ { i3 1, [0 x i8] undef }, %253 ], [ { i3 0, [0 x i8] undef }, %247 ]
  %298 = phi i32 [ %285, %283 ], [ %279, %277 ], [ %273, %271 ], [ %267, %265 ], [ %261, %259 ], [ %255, %253 ], [ 0, %247 ]
  %299 = phi i252 [ %173, %283 ], [ %173, %277 ], [ %173, %271 ], [ %173, %265 ], [ %173, %259 ], [ %173, %253 ], [ %173, %247 ]
  %300 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %174, %283 ], [ %174, %277 ], [ %174, %271 ], [ %174, %265 ], [ %174, %259 ], [ %174, %253 ], [ %174, %247 ]
  %301 = phi ptr [ %218, %283 ], [ %218, %277 ], [ %218, %271 ], [ %218, %265 ], [ %218, %259 ], [ %218, %253 ], [ %218, %247 ]
  %302 = phi { i32, i32, i32, i32 } [ %175, %283 ], [ %175, %277 ], [ %175, %271 ], [ %175, %265 ], [ %175, %259 ], [ %175, %253 ], [ %175, %247 ]
  %303 = phi { {} } [ %180, %283 ], [ %180, %277 ], [ %180, %271 ], [ %180, %265 ], [ %180, %259 ], [ %180, %253 ], [ %180, %247 ]
  %304 = phi { ptr, i32, i32, i32 } [ %207, %283 ], [ %207, %277 ], [ %207, %271 ], [ %207, %265 ], [ %207, %259 ], [ %207, %253 ], [ %207, %247 ]
  %305 = phi { i252 } [ %212, %283 ], [ %212, %277 ], [ %212, %271 ], [ %212, %265 ], [ %212, %259 ], [ %212, %253 ], [ %212, %247 ]
  %306 = phi i64 [ %214, %283 ], [ %214, %277 ], [ %214, %271 ], [ %214, %265 ], [ %214, %259 ], [ %214, %253 ], [ %214, %247 ]
  %307 = phi i64 [ %290, %283 ], [ %282, %277 ], [ %276, %271 ], [ %270, %265 ], [ %264, %259 ], [ %258, %253 ], [ %252, %247 ]
  %308 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %304, 0
  %309 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %308, 0
  %310 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %309, i32 0, 1
  %311 = call fastcc { i64, i64, { i64, [80 x i8] } } @"impl$f78"(i64 %306, i64 %307, { { { ptr, i32, i32, i32 } }, i32 } %310, { ptr, i32, i32, i32 } %293, i252 %299, { ptr, i32, i32, i32 } %292, { i252 } %305, { i3, [0 x i8] } %297, i32 %298)
  %312 = extractvalue { i64, i64, { i64, [80 x i8] } } %311, 0
  %313 = extractvalue { i64, i64, { i64, [80 x i8] } } %311, 1
  %314 = extractvalue { i64, i64, { i64, [80 x i8] } } %311, 2
  store { i64, [80 x i8] } %314, ptr %31, align 8
  %315 = load i1, ptr %31, align 1
  switch i1 %315, label %316 [
    i1 false, label %318
    i1 true, label %334
  ]

316:                                              ; preds = %291
  br i1 false, label %317, label %484

317:                                              ; preds = %316
  unreachable

318:                                              ; preds = %291
  %319 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } }, ptr %31, align 8
  %320 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %319, 1
  %321 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } undef, { i3, [0 x i8] } %297, 0
  %322 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %321, i32 %298, 1
  %323 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %322, { { ptr, i32, i32, i32 }, i252, i32 } %300, 2
  %324 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %323, { i32, i32, i32, i32 } %302, 3
  %325 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } @"dup$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %324)
  %326 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %325, 0
  %327 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %325, 1
  call void @"drop$284"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %326)
  %328 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f54"(i64 %312, i64 %313, ptr %301, i252 453315402536231072555619669907522599583709578777227265110163302022970973962, i252 %299, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %327)
  %329 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %328, 0
  %330 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %328, 1
  %331 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %328, 2
  %332 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %328, 3
  store { i64, [24 x i8] } %332, ptr %33, align 8
  %333 = load i1, ptr %33, align 1
  switch i1 %333, label %344 [
    i1 false, label %346
    i1 true, label %358
  ]

334:                                              ; preds = %291
  %335 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %31, align 8
  %336 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %335, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %294)
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %300)
  %337 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %336, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %337, ptr %32, align 8
  %338 = load { i64, [72 x i8] }, ptr %32, align 8
  %339 = extractvalue { ptr, ptr, i64 } %13, 1
  %340 = load i64, ptr %339, align 8
  %341 = icmp eq i64 %340, 0
  %342 = sub i64 %340, 1
  %343 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %342, ptr %343, align 8
  br i1 %341, label %394, label %368

344:                                              ; preds = %318
  br i1 false, label %345, label %485

345:                                              ; preds = %344
  unreachable

346:                                              ; preds = %318
  %347 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %348 = call ptr %347()
  %349 = call i64 @llvm.uadd.sat.i64(i64 %330, i64 0)
  %350 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %320, 0
  %351 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %320, 1
  %352 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %320, 2
  call void @"drop$181"({ { { ptr, i32, i32, i32 } }, i32 } %350)
  %353 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %294, 0
  %354 = extractvalue { ptr, ptr, i64 } %13, 1
  %355 = load i64, ptr %354, align 8
  %356 = add i64 %355, 1
  %357 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %356, ptr %357, align 8
  br label %35

358:                                              ; preds = %318
  %359 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %33, align 8
  %360 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %359, 1
  call void @"drop$189"({ ptr, i32, i32, i32 } %294)
  call void @"drop$183"({ { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %320)
  %361 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %360, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %361, ptr %34, align 8
  %362 = load { i64, [72 x i8] }, ptr %34, align 8
  %363 = extractvalue { ptr, ptr, i64 } %13, 1
  %364 = load i64, ptr %363, align 8
  %365 = icmp eq i64 %364, 0
  %366 = sub i64 %364, 1
  %367 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %366, ptr %367, align 8
  br i1 %365, label %387, label %368

368:                                              ; preds = %368, %358, %334, %235, %221, %123, %105, %429, %460
  %369 = phi i64 [ %45, %460 ], [ %45, %429 ], [ %369, %368 ], [ %329, %358 ], [ %312, %334 ], [ %214, %235 ], [ %198, %221 ], [ %100, %123 ], [ %77, %105 ]
  %370 = phi i64 [ %37, %460 ], [ %439, %429 ], [ %370, %368 ], [ %330, %358 ], [ %313, %334 ], [ %215, %235 ], [ %199, %221 ], [ %101, %123 ], [ %78, %105 ]
  %371 = phi i64 [ %38, %460 ], [ %38, %429 ], [ %371, %368 ], [ %296, %358 ], [ %296, %334 ], [ %216, %235 ], [ %186, %221 ], [ %79, %123 ], [ %79, %105 ]
  %372 = phi i64 [ %39, %460 ], [ %39, %429 ], [ %372, %368 ], [ %295, %358 ], [ %295, %334 ], [ %217, %235 ], [ %183, %221 ], [ %102, %123 ], [ %39, %105 ]
  %373 = phi ptr [ %40, %460 ], [ %40, %429 ], [ %373, %368 ], [ %331, %358 ], [ %301, %334 ], [ %218, %235 ], [ %200, %221 ], [ %80, %123 ], [ %80, %105 ]
  %374 = phi { i64, [72 x i8] } [ %465, %460 ], [ %447, %429 ], [ %374, %368 ], [ %362, %358 ], [ %338, %334 ], [ %239, %235 ], [ %225, %221 ], [ %127, %123 ], [ %109, %105 ]
  %375 = extractvalue { ptr, ptr, i64 } %13, 1
  %376 = load i64, ptr %375, align 8
  %377 = icmp eq i64 %376, 0
  %378 = sub i64 %376, 1
  %379 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %378, ptr %379, align 8
  br i1 %377, label %380, label %368

380:                                              ; preds = %368
  %381 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %369, 0
  %382 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %381, i64 %370, 1
  %383 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %382, i64 %371, 2
  %384 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %383, i64 %372, 3
  %385 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %384, ptr %373, 4
  %386 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %385, { i64, [72 x i8] } %374, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %386

387:                                              ; preds = %358
  %388 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %329, 0
  %389 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %388, i64 %330, 1
  %390 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %389, i64 %296, 2
  %391 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %390, i64 %295, 3
  %392 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %391, ptr %331, 4
  %393 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %392, { i64, [72 x i8] } %362, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %393

394:                                              ; preds = %334
  %395 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %312, 0
  %396 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %395, i64 %313, 1
  %397 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %396, i64 %296, 2
  %398 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %397, i64 %295, 3
  %399 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %398, ptr %301, 4
  %400 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %399, { i64, [72 x i8] } %338, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %400

401:                                              ; preds = %235
  %402 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %214, 0
  %403 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %402, i64 %215, 1
  %404 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %403, i64 %216, 2
  %405 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %404, i64 %217, 3
  %406 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %405, ptr %218, 4
  %407 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %406, { i64, [72 x i8] } %239, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %407

408:                                              ; preds = %221
  %409 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %198, 0
  %410 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %409, i64 %199, 1
  %411 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %410, i64 %186, 2
  %412 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %411, i64 %183, 3
  %413 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %412, ptr %200, 4
  %414 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %413, { i64, [72 x i8] } %225, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %414

415:                                              ; preds = %123
  %416 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %100, 0
  %417 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %416, i64 %101, 1
  %418 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %417, i64 %79, 2
  %419 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %418, i64 %102, 3
  %420 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %419, ptr %80, 4
  %421 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %420, { i64, [72 x i8] } %127, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %421

422:                                              ; preds = %105
  %423 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %77, 0
  %424 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %423, i64 %78, 1
  %425 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %424, i64 %79, 2
  %426 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %425, i64 %39, 3
  %427 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %426, ptr %80, 4
  %428 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %427, { i64, [72 x i8] } %109, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %428

429:                                              ; preds = %56
  %430 = phi i64 [ %55, %56 ]
  %431 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %432 = call ptr %431()
  %433 = getelementptr inbounds i64, ptr %432, i32 1
  %434 = load i64, ptr %433, align 8
  %435 = mul i64 %434, 2
  %436 = load i64, ptr %432, align 8
  %437 = mul i64 %436, 116030
  %438 = add i64 %435, %437
  %439 = call i64 @llvm.uadd.sat.i64(i64 %430, i64 %438)
  %440 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 0
  %441 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %440, 0
  %442 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %441, { {} } %42, 1
  %443 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %442, { ptr, i32, i32, i32 } %43, 2
  %444 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %443, { ptr, i32, i32, i32 } %44, 3
  %445 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %444, {} undef, 4
  %446 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } undef }, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %445, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %446, ptr %16, align 8
  %447 = load { i64, [72 x i8] }, ptr %16, align 8
  %448 = extractvalue { ptr, ptr, i64 } %13, 1
  %449 = load i64, ptr %448, align 8
  %450 = icmp eq i64 %449, 0
  %451 = sub i64 %449, 1
  %452 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %451, ptr %452, align 8
  br i1 %450, label %453, label %368

453:                                              ; preds = %429
  %454 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %45, 0
  %455 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %454, i64 %439, 1
  %456 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %455, i64 %38, 2
  %457 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %456, i64 %39, 3
  %458 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %457, ptr %40, 4
  %459 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %458, { i64, [72 x i8] } %447, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %459

460:                                              ; preds = %35
  %461 = phi { { ptr, i32, i32, i32 } } [ %41, %35 ]
  call void @"drop$273"({ { ptr, i32, i32, i32 } } %461)
  call void @"drop$106"({ ptr, i32, i32, i32 } %44)
  call void @"drop$182"({ ptr, i32, i32, i32 } %43)
  %462 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %463 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %462, 0
  %464 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %463, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %464, ptr %15, align 8
  %465 = load { i64, [72 x i8] }, ptr %15, align 8
  %466 = extractvalue { ptr, ptr, i64 } %13, 1
  %467 = load i64, ptr %466, align 8
  %468 = icmp eq i64 %467, 0
  %469 = sub i64 %467, 1
  %470 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %469, ptr %470, align 8
  br i1 %468, label %471, label %368

471:                                              ; preds = %460
  %472 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %45, 0
  %473 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %472, i64 %37, 1
  %474 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %473, i64 %38, 2
  %475 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %474, i64 %39, 3
  %476 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %475, ptr %40, 4
  %477 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %476, { i64, [72 x i8] } %465, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %477

478:                                              ; preds = %83
  call void @puts(ptr @assert_msg_110)
  call void @abort()
  unreachable

479:                                              ; preds = %115
  call void @puts(ptr @assert_msg_111)
  call void @abort()
  unreachable

480:                                              ; preds = %133
  call void @puts(ptr @assert_msg_112)
  call void @abort()
  unreachable

481:                                              ; preds = %203
  call void @puts(ptr @assert_msg_113)
  call void @abort()
  unreachable

482:                                              ; preds = %231
  call void @puts(ptr @assert_msg_114)
  call void @abort()
  unreachable

483:                                              ; preds = %245
  call void @puts(ptr @assert_msg_115)
  call void @abort()
  unreachable

484:                                              ; preds = %316
  call void @puts(ptr @assert_msg_116)
  call void @abort()
  unreachable

485:                                              ; preds = %344
  call void @puts(ptr @assert_msg_117)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @f57(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6, { ptr, i32, i32, i32 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = call fastcc { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f57"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6, { ptr, i32, i32, i32 } %7, { ptr, i32, i32, i32 } %8)
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %10, 2
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %10, 3
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %10, 4
  %16 = extractvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %10, 5
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %11, 0
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %17, i64 %12, 1
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %18, i64 %13, 2
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %19, i64 %14, 3
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %20, ptr %15, 4
  %22 = insertvalue { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %21, { i64, [72 x i8] } %16, 5
  ret { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %22
}

define void @_mlir_ciface_f57(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6, { {} } %7, { ptr, i32, i32, i32 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } @f57(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6, { {} } %7, { ptr, i32, i32, i32 } %8, { ptr, i32, i32, i32 } %9)
  store { i64, i64, i64, i64, ptr, { i64, [72 x i8] } } %11, ptr %0, align 8
  ret void
}

define private void @"drop$177"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$177"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 96)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 96, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f58"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [48 x i8] }, i64 1, align 8
  %13 = alloca { i64, [48 x i8] }, i64 1, align 8
  %14 = alloca { i128, [64 x i8] }, i64 1, align 16
  %15 = alloca { i64, [48 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [48 x i8] }, i64 1, align 8
  %18 = alloca i256, i64 1, align 16
  %19 = alloca i256, i64 1, align 16
  %20 = alloca i256, i64 1, align 16
  %21 = alloca { i1, [31 x i8] }, i64 1, align 8
  %22 = alloca i64, i64 1, align 8
  %23 = alloca i252, i64 1, align 16
  %24 = alloca i252, i64 1, align 16
  %25 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %26

26:                                               ; preds = %167, %6
  %27 = phi i64 [ %145, %167 ], [ %0, %6 ]
  %28 = phi i64 [ %171, %167 ], [ %1, %6 ]
  %29 = phi i64 [ %139, %167 ], [ %2, %6 ]
  %30 = phi i64 [ %104, %167 ], [ %3, %6 ]
  %31 = phi ptr [ %122, %167 ], [ %4, %6 ]
  %32 = phi { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } [ %175, %167 ], [ %5, %6 ]
  %33 = add i64 %27, 1
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = getelementptr inbounds i64, ptr %35, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = load i64, ptr %35, align 8
  %39 = mul i64 %38, 39820
  %40 = add i64 %37, %39
  %41 = icmp uge i64 %28, %40
  %42 = call i64 @llvm.usub.sat.i64(i64 %28, i64 %40)
  br i1 %41, label %43, label %278

43:                                               ; preds = %26
  %44 = phi { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } [ %32, %26 ]
  %45 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %44, 0
  %46 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %44, 1
  %47 = extractvalue { { ptr, i32, i32, i32 } } %45, 0
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %52, label %241

52:                                               ; preds = %43
  %53 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %54 = load ptr, ptr %53, align 8
  %55 = zext i32 %48 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %54, i64 %56
  %58 = add i32 %48, 1
  %59 = insertvalue { ptr, i32, i32, i32 } %47, i32 %58, 1
  %60 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %60, ptr %57, i64 32, i1 false)
  %61 = extractvalue { { ptr, i32, i32, i32 } } %46, 0
  %62 = extractvalue { ptr, i32, i32, i32 } %61, 1
  %63 = extractvalue { ptr, i32, i32, i32 } %61, 2
  %64 = sub i32 %63, %62
  %65 = icmp uge i32 %64, 1
  br i1 %65, label %66, label %230

66:                                               ; preds = %52
  %67 = extractvalue { ptr, i32, i32, i32 } %61, 0
  %68 = load ptr, ptr %67, align 8
  %69 = zext i32 %62 to i64
  %70 = mul i64 %69, 96
  %71 = getelementptr inbounds i8, ptr %68, i64 %70
  %72 = add i32 %62, 1
  %73 = insertvalue { ptr, i32, i32, i32 } %61, i32 %72, 1
  %74 = call ptr @realloc(ptr null, i64 96)
  call void @llvm.memcpy.p0.p0.i64(ptr %74, ptr %71, i64 96, i1 false)
  %75 = load { { i252 }, { i3, [0 x i8] }, i32, i252, i32 }, ptr %74, align 16
  call void @free(ptr %74)
  %76 = extractvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %75, 0
  %77 = extractvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %75, 1
  %78 = extractvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %75, 2
  %79 = extractvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %75, 3
  %80 = extractvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %75, 4
  %81 = zext i32 %80 to i252
  %82 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %83 = call ptr %82()
  %84 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %84, align 4
  %85 = getelementptr inbounds i8, ptr %84, i32 4
  store i32 0, ptr %85, align 4
  %86 = getelementptr inbounds i8, ptr %84, i32 16
  %87 = call ptr @realloc(ptr null, i64 8)
  store ptr %86, ptr %87, align 8
  %88 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %87, 0
  %89 = insertvalue { ptr, i32, i32, i32 } %88, i32 8, 3
  %90 = load ptr, ptr %87, align 8
  store i252 %79, ptr %90, align 16
  %91 = insertvalue { ptr, i32, i32, i32 } %89, i32 1, 2
  %92 = getelementptr inbounds i8, ptr %90, i32 -12
  store i32 1, ptr %92, align 4
  %93 = load ptr, ptr %87, align 8
  %94 = getelementptr inbounds i8, ptr %93, i32 32
  store i252 %81, ptr %94, align 16
  %95 = insertvalue { ptr, i32, i32, i32 } %91, i32 2, 2
  %96 = getelementptr inbounds i8, ptr %93, i32 -12
  store i32 2, ptr %96, align 4
  %97 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %95)
  %98 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 0
  %99 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %98)
  %100 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %99, 0
  %101 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %33, i64 %42, i64 %30, ptr %83, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %100)
  %102 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %101, 0
  %103 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %101, 1
  %104 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %101, 2
  %105 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %101, 3
  store { i128, [64 x i8] } %105, ptr %14, align 16
  %106 = load i1, ptr %14, align 1
  switch i1 %106, label %107 [
    i1 false, label %109
    i1 true, label %125
  ]

107:                                              ; preds = %66
  br i1 false, label %108, label %296

108:                                              ; preds = %107
  unreachable

109:                                              ; preds = %66
  %110 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %14, align 16
  %111 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %110, 1
  %112 = load i252, ptr %60, align 16
  call void @free(ptr %60)
  %113 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %111, 0
  %114 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %111, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %113)
  %115 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } undef, { i3, [0 x i8] } %77, 0
  %116 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %115, i32 %78, 1
  %117 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %116, i32 %80, 2
  %118 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %117, i252 %112, 3
  %119 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f76"(i64 %102, i64 %103, ptr %31, i252 %114, { { i3, [0 x i8] }, i32, i32, i252 } %118)
  %120 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %119, 0
  %121 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %119, 1
  %122 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %119, 2
  %123 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %119, 3
  store { i64, [24 x i8] } %123, ptr %16, align 8
  %124 = load i1, ptr %16, align 1
  switch i1 %124, label %135 [
    i1 false, label %137
    i1 true, label %157
  ]

125:                                              ; preds = %66
  %126 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %127 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %126, 1
  call void @"drop$182"({ ptr, i32, i32, i32 } %73)
  call void @"drop$26"({ ptr, i32, i32, i32 } %59)
  call void @"drop$409"(ptr %60)
  %128 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %127, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %128, ptr %15, align 8
  %129 = load { i64, [48 x i8] }, ptr %15, align 8
  %130 = extractvalue { ptr, ptr, i64 } %10, 1
  %131 = load i64, ptr %130, align 8
  %132 = icmp eq i64 %131, 0
  %133 = sub i64 %131, 1
  %134 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %133, ptr %134, align 8
  br i1 %132, label %223, label %180

135:                                              ; preds = %109
  br i1 false, label %136, label %297

136:                                              ; preds = %135
  unreachable

137:                                              ; preds = %109
  %138 = extractvalue { i252 } %76, 0
  %139 = add i64 %29, 3
  %140 = zext i252 %138 to i256
  %141 = zext i252 %114 to i256
  store i256 %140, ptr %18, align 16
  store i256 %141, ptr %19, align 16
  %142 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %142(ptr %20, ptr %18, ptr %19)
  %143 = load i256, ptr %20, align 16
  %144 = trunc i256 %143 to i252
  %145 = add i64 %120, 3
  %146 = sub i252 %144, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %147 = icmp ult i252 %144, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %148 = select i1 %147, i252 %144, i252 %146
  %149 = load ptr, ptr %122, align 8
  store i64 %121, ptr %22, align 8
  store i252 %148, ptr %23, align 16
  store i252 %112, ptr %24, align 16
  %150 = getelementptr inbounds ptr, ptr %122, i32 9
  %151 = load ptr, ptr %150, align 8
  call void %151(ptr %21, ptr %149, ptr %22, i32 0, ptr %23, ptr %24)
  %152 = load { i1, [31 x i8] }, ptr %21, align 1
  %153 = extractvalue { i1, [31 x i8] } %152, 0
  %154 = getelementptr inbounds i8, ptr %21, i32 8
  %155 = load { ptr, i32, i32, i32 }, ptr %154, align 8
  %156 = load i64, ptr %22, align 8
  br i1 %153, label %199, label %167

157:                                              ; preds = %109
  %158 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %159 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %158, 1
  call void @"drop$182"({ ptr, i32, i32, i32 } %73)
  call void @"drop$26"({ ptr, i32, i32, i32 } %59)
  %160 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %159, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %160, ptr %17, align 8
  %161 = load { i64, [48 x i8] }, ptr %17, align 8
  %162 = extractvalue { ptr, ptr, i64 } %10, 1
  %163 = load i64, ptr %162, align 8
  %164 = icmp eq i64 %163, 0
  %165 = sub i64 %163, 1
  %166 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %165, ptr %166, align 8
  br i1 %164, label %216, label %180

167:                                              ; preds = %137
  %168 = phi i64 [ %156, %137 ]
  %169 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %170 = call ptr %169()
  %171 = call i64 @llvm.uadd.sat.i64(i64 %168, i64 0)
  %172 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %59, 0
  %173 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %73, 0
  %174 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %172, 0
  %175 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %174, { { ptr, i32, i32, i32 } } %173, 1
  %176 = extractvalue { ptr, ptr, i64 } %10, 1
  %177 = load i64, ptr %176, align 8
  %178 = add i64 %177, 1
  %179 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %178, ptr %179, align 8
  br label %26

180:                                              ; preds = %180, %199, %157, %125, %251, %278
  %181 = phi i64 [ %33, %278 ], [ %255, %251 ], [ %145, %199 ], [ %181, %180 ], [ %120, %157 ], [ %102, %125 ]
  %182 = phi i64 [ %28, %278 ], [ %256, %251 ], [ %156, %199 ], [ %182, %180 ], [ %121, %157 ], [ %103, %125 ]
  %183 = phi i64 [ %29, %278 ], [ %252, %251 ], [ %139, %199 ], [ %183, %180 ], [ %29, %157 ], [ %29, %125 ]
  %184 = phi i64 [ %30, %278 ], [ %253, %251 ], [ %104, %199 ], [ %184, %180 ], [ %104, %157 ], [ %104, %125 ]
  %185 = phi ptr [ %31, %278 ], [ %254, %251 ], [ %122, %199 ], [ %185, %180 ], [ %122, %157 ], [ %31, %125 ]
  %186 = phi { i64, [48 x i8] } [ %283, %278 ], [ %265, %251 ], [ %203, %199 ], [ %186, %180 ], [ %161, %157 ], [ %129, %125 ]
  %187 = extractvalue { ptr, ptr, i64 } %10, 1
  %188 = load i64, ptr %187, align 8
  %189 = icmp eq i64 %188, 0
  %190 = sub i64 %188, 1
  %191 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %190, ptr %191, align 8
  br i1 %189, label %192, label %180

192:                                              ; preds = %180
  %193 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %181, 0
  %194 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %193, i64 %182, 1
  %195 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %194, i64 %183, 2
  %196 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %195, i64 %184, 3
  %197 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %196, ptr %185, 4
  %198 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %197, { i64, [48 x i8] } %186, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %198

199:                                              ; preds = %137
  %200 = phi { ptr, i32, i32, i32 } [ %73, %137 ]
  call void @"drop$182"({ ptr, i32, i32, i32 } %200)
  call void @"drop$26"({ ptr, i32, i32, i32 } %59)
  %201 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %155, 1
  %202 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %201, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %202, ptr %25, align 8
  %203 = load { i64, [48 x i8] }, ptr %25, align 8
  %204 = extractvalue { ptr, ptr, i64 } %10, 1
  %205 = load i64, ptr %204, align 8
  %206 = icmp eq i64 %205, 0
  %207 = sub i64 %205, 1
  %208 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %207, ptr %208, align 8
  br i1 %206, label %209, label %180

209:                                              ; preds = %199
  %210 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %145, 0
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %210, i64 %156, 1
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %211, i64 %139, 2
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %212, i64 %104, 3
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %213, ptr %122, 4
  %215 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %214, { i64, [48 x i8] } %203, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %215

216:                                              ; preds = %157
  %217 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %120, 0
  %218 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %217, i64 %121, 1
  %219 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %218, i64 %29, 2
  %220 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %219, i64 %104, 3
  %221 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %220, ptr %122, 4
  %222 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %221, { i64, [48 x i8] } %161, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %222

223:                                              ; preds = %125
  %224 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %102, 0
  %225 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %224, i64 %103, 1
  %226 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %225, i64 %29, 2
  %227 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %226, i64 %104, 3
  %228 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %227, ptr %31, 4
  %229 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %228, { i64, [48 x i8] } %129, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %229

230:                                              ; preds = %52
  %231 = phi ptr [ %60, %52 ]
  call void @"drop$409"(ptr %231)
  %232 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %233 = call ptr %232()
  %234 = getelementptr inbounds i64, ptr %233, i32 1
  %235 = load i64, ptr %234, align 8
  %236 = load i64, ptr %233, align 8
  %237 = mul i64 %236, 39040
  %238 = add i64 %235, %237
  %239 = call i64 @llvm.uadd.sat.i64(i64 %42, i64 %238)
  %240 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %61, 0
  br label %251

241:                                              ; preds = %43
  %242 = phi i64 [ %42, %43 ]
  %243 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %244 = call ptr %243()
  %245 = getelementptr inbounds i64, ptr %244, i32 1
  %246 = load i64, ptr %245, align 8
  %247 = load i64, ptr %244, align 8
  %248 = mul i64 %247, 39410
  %249 = add i64 %246, %248
  %250 = call i64 @llvm.uadd.sat.i64(i64 %242, i64 %249)
  br label %251

251:                                              ; preds = %230, %241
  %252 = phi i64 [ %29, %241 ], [ %29, %230 ]
  %253 = phi i64 [ %30, %241 ], [ %30, %230 ]
  %254 = phi ptr [ %31, %241 ], [ %31, %230 ]
  %255 = phi i64 [ %33, %241 ], [ %33, %230 ]
  %256 = phi i64 [ %250, %241 ], [ %239, %230 ]
  %257 = phi { ptr, i32, i32, i32 } [ %47, %241 ], [ %59, %230 ]
  %258 = phi { { ptr, i32, i32, i32 } } [ %46, %241 ], [ %240, %230 ]
  %259 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %257, 0
  %260 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %259, 0
  %261 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %260, { { ptr, i32, i32, i32 } } %258, 1
  %262 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %261, 0
  %263 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %262, {} undef, 1
  %264 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } undef }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } %263, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, {} } } %264, ptr %13, align 8
  %265 = load { i64, [48 x i8] }, ptr %13, align 8
  %266 = extractvalue { ptr, ptr, i64 } %10, 1
  %267 = load i64, ptr %266, align 8
  %268 = icmp eq i64 %267, 0
  %269 = sub i64 %267, 1
  %270 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %269, ptr %270, align 8
  br i1 %268, label %271, label %180

271:                                              ; preds = %251
  %272 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %255, 0
  %273 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %272, i64 %256, 1
  %274 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %273, i64 %252, 2
  %275 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %274, i64 %253, 3
  %276 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %275, ptr %254, 4
  %277 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %276, { i64, [48 x i8] } %265, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %277

278:                                              ; preds = %26
  %279 = phi { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } [ %32, %26 ]
  call void @"drop$270"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %279)
  %280 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %281 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %280, 0
  %282 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %281, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %282, ptr %12, align 8
  %283 = load { i64, [48 x i8] }, ptr %12, align 8
  %284 = extractvalue { ptr, ptr, i64 } %10, 1
  %285 = load i64, ptr %284, align 8
  %286 = icmp eq i64 %285, 0
  %287 = sub i64 %285, 1
  %288 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %287, ptr %288, align 8
  br i1 %286, label %289, label %180

289:                                              ; preds = %278
  %290 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %33, 0
  %291 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %290, i64 %28, 1
  %292 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %291, i64 %29, 2
  %293 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %292, i64 %30, 3
  %294 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %293, ptr %31, 4
  %295 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %294, { i64, [48 x i8] } %283, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %295

296:                                              ; preds = %107
  call void @puts(ptr @assert_msg_118)
  call void @abort()
  unreachable

297:                                              ; preds = %135
  call void @puts(ptr @assert_msg_119)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @f58(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f58"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %18, { i64, [48 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %19
}

define void @_mlir_ciface_f58(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @f58(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i128, [80 x i8] } } @"impl$f59"(i64 %0, { { ptr, i32, i32, i32 }, i252, i32 } %1, i252 %2, i32 %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = alloca { i128, [32 x i8] }, i64 1, align 16
  %7 = alloca { i128, [80 x i8] }, i64 1, align 16
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [32 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [48 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = alloca { i128, [80 x i8] }, i64 1, align 16
  %17 = icmp eq i32 %3, 0
  br i1 %17, label %18, label %27

18:                                               ; preds = %4
  %19 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %1, %4 ]
  %20 = phi {} [ undef, %4 ]
  %21 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %19, 0
  %22 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %21, {} %20, 1
  %23 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %22, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %23, ptr %16, align 16
  %24 = load { i128, [80 x i8] }, ptr %16, align 16
  %25 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %0, 0
  %26 = insertvalue { i64, { i128, [80 x i8] } } %25, { i128, [80 x i8] } %24, 1
  ret { i64, { i128, [80 x i8] } } %26

27:                                               ; preds = %4
  %28 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %1, %4 ]
  %29 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %28, 0
  %30 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %28, 1
  %31 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %28, 2
  %32 = add i64 %0, 1
  %33 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %31, i32 %3)
  %34 = extractvalue { i32, i1 } %33, 0
  %35 = extractvalue { i32, i1 } %33, 1
  br i1 %35, label %366, label %36

36:                                               ; preds = %27
  %37 = phi i32 [ %34, %27 ]
  %38 = add i64 %0, 2
  %39 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %37, i32 31)
  %40 = extractvalue { i32, i1 } %39, 0
  %41 = extractvalue { i32, i1 } %39, 1
  br i1 %41, label %324, label %42

42:                                               ; preds = %36
  %43 = phi i64 [ %38, %36 ]
  %44 = phi i32 [ 31, %36 ]
  %45 = phi i32 [ %31, %36 ]
  %46 = add i64 %43, 1
  %47 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %44, i32 %45)
  %48 = extractvalue { i32, i1 } %47, 0
  %49 = extractvalue { i32, i1 } %47, 1
  br i1 %49, label %316, label %50

50:                                               ; preds = %42
  %51 = phi i64 [ %46, %42 ]
  %52 = call fastcc { i64, { i128, [32 x i8] } } @"impl$f79"(i64 %51, i32 %48)
  %53 = extractvalue { i64, { i128, [32 x i8] } } %52, 0
  %54 = extractvalue { i64, { i128, [32 x i8] } } %52, 1
  store { i128, [32 x i8] } %54, ptr %10, align 16
  %55 = load i1, ptr %10, align 1
  switch i1 %55, label %56 [
    i1 false, label %58
    i1 true, label %63
  ]

56:                                               ; preds = %50
  br i1 false, label %57, label %375

57:                                               ; preds = %56
  unreachable

58:                                               ; preds = %50
  %59 = load { i1, { i252 } }, ptr %10, align 16
  %60 = extractvalue { i1, { i252 } } %59, 1
  %61 = extractvalue { i252 } %60, 0
  %62 = icmp eq i32 %40, 0
  br i1 %62, label %70, label %155

63:                                               ; preds = %50
  %64 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %65 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %64, 1
  call void @"drop$40"({ ptr, i32, i32, i32 } %29)
  %66 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %65, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %66, ptr %11, align 8
  %67 = load { i128, [80 x i8] }, ptr %11, align 16
  %68 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %53, 0
  %69 = insertvalue { i64, { i128, [80 x i8] } } %68, { i128, [80 x i8] } %67, 1
  ret { i64, { i128, [80 x i8] } } %69

70:                                               ; preds = %58
  %71 = phi i252 [ %30, %58 ]
  %72 = phi i252 [ %61, %58 ]
  %73 = zext i252 %71 to i512
  %74 = zext i252 %72 to i512
  %75 = mul i512 %73, %74
  %76 = urem i512 %75, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %77 = icmp uge i512 %75, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %78 = select i1 %77, i512 %76, i512 %75
  %79 = trunc i512 %78 to i252
  %80 = zext i252 %2 to i256
  %81 = zext i252 %79 to i256
  %82 = add i256 %80, %81
  %83 = sub i256 %82, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %84 = icmp uge i256 %82, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %85 = select i1 %84, i256 %83, i256 %82
  %86 = trunc i256 %85 to i252
  %87 = add i64 %53, 3
  %88 = icmp ule i252 %86, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %88, label %89, label %91

89:                                               ; preds = %70
  %90 = trunc i256 %85 to i248
  br label %91

91:                                               ; preds = %89, %70
  %92 = phi { ptr, i32, i32, i32 } [ %29, %89 ], [ %29, %70 ]
  %93 = phi i252 [ 0, %89 ], [ 0, %70 ]
  %94 = phi i64 [ %87, %89 ], [ %87, %70 ]
  %95 = phi i248 [ %90, %89 ], [ 88068479653790488123916992367510505285, %70 ]
  %96 = extractvalue { ptr, i32, i32, i32 } %92, 3
  %97 = icmp eq i32 %96, 0
  br i1 %97, label %98, label %112

98:                                               ; preds = %91
  %99 = shl i32 %96, 1
  %100 = call i32 @llvm.umin.i32(i32 %99, i32 1024)
  %101 = add i32 %100, %96
  %102 = call i32 @llvm.umax.i32(i32 %101, i32 8)
  %103 = zext i32 %102 to i64
  %104 = mul i64 %103, 32
  %105 = add i64 %104, 16
  %106 = call ptr @realloc(ptr null, i64 %105)
  store i32 1, ptr %106, align 4
  %107 = getelementptr inbounds i8, ptr %106, i32 4
  store i32 0, ptr %107, align 4
  %108 = getelementptr inbounds i8, ptr %106, i32 16
  %109 = call ptr @realloc(ptr null, i64 8)
  store ptr %108, ptr %109, align 8
  %110 = insertvalue { ptr, i32, i32, i32 } %92, ptr %109, 0
  %111 = insertvalue { ptr, i32, i32, i32 } %110, i32 %102, 3
  br label %133

112:                                              ; preds = %91
  %113 = extractvalue { ptr, i32, i32, i32 } %92, 2
  %114 = icmp ult i32 %113, %96
  br i1 %114, label %115, label %116

115:                                              ; preds = %112
  br label %130

116:                                              ; preds = %112
  %117 = shl i32 %96, 1
  %118 = call i32 @llvm.umin.i32(i32 %117, i32 1024)
  %119 = add i32 %118, %96
  %120 = call i32 @llvm.umax.i32(i32 %119, i32 8)
  %121 = zext i32 %120 to i64
  %122 = mul i64 %121, 32
  %123 = add i64 %122, 16
  %124 = extractvalue { ptr, i32, i32, i32 } %92, 0
  %125 = load ptr, ptr %124, align 8
  %126 = getelementptr inbounds i8, ptr %125, i32 -16
  %127 = call ptr @realloc(ptr %126, i64 %123)
  %128 = getelementptr inbounds i8, ptr %127, i32 16
  store ptr %128, ptr %124, align 8
  %129 = insertvalue { ptr, i32, i32, i32 } %92, i32 %120, 3
  br label %130

130:                                              ; preds = %115, %116
  %131 = phi { ptr, i32, i32, i32 } [ %129, %116 ], [ %92, %115 ]
  br label %132

132:                                              ; preds = %130
  br label %133

133:                                              ; preds = %98, %132
  %134 = phi { ptr, i32, i32, i32 } [ %131, %132 ], [ %111, %98 ]
  br label %135

135:                                              ; preds = %133
  %136 = extractvalue { ptr, i32, i32, i32 } %134, 0
  %137 = load ptr, ptr %136, align 8
  %138 = extractvalue { ptr, i32, i32, i32 } %134, 2
  %139 = zext i32 %138 to i64
  %140 = mul i64 %139, 32
  %141 = getelementptr inbounds i8, ptr %137, i64 %140
  store i248 %95, ptr %141, align 16
  %142 = extractvalue { ptr, i32, i32, i32 } %134, 2
  %143 = add i32 %142, 1
  %144 = insertvalue { ptr, i32, i32, i32 } %134, i32 %143, 2
  %145 = getelementptr inbounds i8, ptr %137, i32 -12
  store i32 %143, ptr %145, align 4
  %146 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %144, 0
  %147 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %146, i252 %93, 1
  %148 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %147, i32 0, 2
  %149 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %148, 0
  %150 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %149, {} undef, 1
  %151 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %150, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %151, ptr %15, align 16
  %152 = load { i128, [80 x i8] }, ptr %15, align 16
  %153 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %94, 0
  %154 = insertvalue { i64, { i128, [80 x i8] } } %153, { i128, [80 x i8] } %152, 1
  ret { i64, { i128, [80 x i8] } } %154

155:                                              ; preds = %58
  %156 = phi i64 [ %53, %58 ]
  %157 = phi i252 [ %2, %58 ]
  %158 = trunc i252 %157 to i128
  %159 = lshr i252 %157, 128
  %160 = trunc i252 %159 to i128
  %161 = icmp ne i128 %160, 0
  %162 = add i64 %156, 3
  %163 = add i64 %156, 1
  %164 = select i1 %161, i64 %162, i64 %163
  %165 = call fastcc { i64, { i128, [48 x i8] } } @"impl$f80"(i64 %164, i32 %40)
  %166 = extractvalue { i64, { i128, [48 x i8] } } %165, 0
  %167 = extractvalue { i64, { i128, [48 x i8] } } %165, 1
  store { i128, [48 x i8] } %167, ptr %12, align 16
  %168 = load i2, ptr %12, align 1
  switch i2 %168, label %169 [
    i2 0, label %171
    i2 1, label %174
    i2 -2, label %197
    i2 -1, label %218
  ]

169:                                              ; preds = %155
  br i1 false, label %170, label %376

170:                                              ; preds = %169
  unreachable

171:                                              ; preds = %155
  %172 = zext i128 %160 to i252
  %173 = zext i128 %158 to i252
  br label %225

174:                                              ; preds = %155
  %175 = load { i2, { i128, i252 } }, ptr %12, align 16
  %176 = extractvalue { i2, { i128, i252 } } %175, 1
  %177 = extractvalue { i128, i252 } %176, 0
  %178 = extractvalue { i128, i252 } %176, 1
  %179 = add i64 %166, 4
  %180 = udiv i128 %158, %177
  %181 = urem i128 %158, %177
  %182 = zext i128 %181 to i252
  %183 = zext i128 %160 to i512
  %184 = zext i252 %178 to i512
  %185 = mul i512 %183, %184
  %186 = urem i512 %185, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %187 = icmp uge i512 %185, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %188 = select i1 %187, i512 %186, i512 %185
  %189 = trunc i512 %188 to i252
  %190 = zext i252 %189 to i256
  %191 = zext i128 %180 to i256
  %192 = add i256 %190, %191
  %193 = sub i256 %192, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %194 = icmp uge i256 %192, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %195 = select i1 %194, i256 %193, i256 %192
  %196 = trunc i256 %195 to i252
  br label %225

197:                                              ; preds = %155
  %198 = load { i2, { i128 } }, ptr %12, align 16
  %199 = extractvalue { i2, { i128 } } %198, 1
  %200 = extractvalue { i128 } %199, 0
  %201 = add i64 %166, 4
  %202 = udiv i128 %160, %200
  %203 = urem i128 %160, %200
  %204 = zext i128 %202 to i252
  %205 = zext i128 %203 to i512
  %206 = mul i512 %205, 340282366920938463463374607431768211456
  %207 = urem i512 %206, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %208 = icmp uge i512 %206, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %209 = select i1 %208, i512 %207, i512 %206
  %210 = trunc i512 %209 to i252
  %211 = zext i252 %210 to i256
  %212 = zext i128 %158 to i256
  %213 = add i256 %211, %212
  %214 = sub i256 %213, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %215 = icmp uge i256 %213, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %216 = select i1 %215, i256 %214, i256 %213
  %217 = trunc i256 %216 to i252
  br label %225

218:                                              ; preds = %155
  call void @"drop$40"({ ptr, i32, i32, i32 } %29)
  %219 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f81"()
  %220 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %219, 0
  %221 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %220, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %221, ptr %13, align 8
  %222 = load { i128, [80 x i8] }, ptr %13, align 16
  %223 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %166, 0
  %224 = insertvalue { i64, { i128, [80 x i8] } } %223, { i128, [80 x i8] } %222, 1
  ret { i64, { i128, [80 x i8] } } %224

225:                                              ; preds = %171, %174, %197
  %226 = phi { ptr, i32, i32, i32 } [ %29, %197 ], [ %29, %174 ], [ %29, %171 ]
  %227 = phi i252 [ %30, %197 ], [ %30, %174 ], [ %30, %171 ]
  %228 = phi i32 [ %40, %197 ], [ %40, %174 ], [ %40, %171 ]
  %229 = phi i252 [ %61, %197 ], [ %61, %174 ], [ %61, %171 ]
  %230 = phi i64 [ %201, %197 ], [ %179, %174 ], [ %166, %171 ]
  %231 = phi i252 [ %204, %197 ], [ %196, %174 ], [ %172, %171 ]
  %232 = phi i252 [ %217, %197 ], [ %182, %174 ], [ %173, %171 ]
  %233 = zext i252 %227 to i512
  %234 = zext i252 %229 to i512
  %235 = mul i512 %233, %234
  %236 = urem i512 %235, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %237 = icmp uge i512 %235, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %238 = select i1 %237, i512 %236, i512 %235
  %239 = trunc i512 %238 to i252
  %240 = zext i252 %231 to i256
  %241 = zext i252 %239 to i256
  %242 = add i256 %240, %241
  %243 = sub i256 %242, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %244 = icmp uge i256 %242, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %245 = select i1 %244, i256 %243, i256 %242
  %246 = trunc i256 %245 to i252
  %247 = add i64 %230, 3
  %248 = icmp ule i252 %246, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %248, label %249, label %251

249:                                              ; preds = %225
  %250 = trunc i256 %245 to i248
  br label %251

251:                                              ; preds = %249, %225
  %252 = phi { ptr, i32, i32, i32 } [ %226, %249 ], [ %226, %225 ]
  %253 = phi i32 [ %228, %249 ], [ %228, %225 ]
  %254 = phi i252 [ %232, %249 ], [ %232, %225 ]
  %255 = phi i64 [ %247, %249 ], [ %247, %225 ]
  %256 = phi i248 [ %250, %249 ], [ 88068479653790488123916992367510505285, %225 ]
  %257 = extractvalue { ptr, i32, i32, i32 } %252, 3
  %258 = icmp eq i32 %257, 0
  br i1 %258, label %259, label %273

259:                                              ; preds = %251
  %260 = shl i32 %257, 1
  %261 = call i32 @llvm.umin.i32(i32 %260, i32 1024)
  %262 = add i32 %261, %257
  %263 = call i32 @llvm.umax.i32(i32 %262, i32 8)
  %264 = zext i32 %263 to i64
  %265 = mul i64 %264, 32
  %266 = add i64 %265, 16
  %267 = call ptr @realloc(ptr null, i64 %266)
  store i32 1, ptr %267, align 4
  %268 = getelementptr inbounds i8, ptr %267, i32 4
  store i32 0, ptr %268, align 4
  %269 = getelementptr inbounds i8, ptr %267, i32 16
  %270 = call ptr @realloc(ptr null, i64 8)
  store ptr %269, ptr %270, align 8
  %271 = insertvalue { ptr, i32, i32, i32 } %252, ptr %270, 0
  %272 = insertvalue { ptr, i32, i32, i32 } %271, i32 %263, 3
  br label %294

273:                                              ; preds = %251
  %274 = extractvalue { ptr, i32, i32, i32 } %252, 2
  %275 = icmp ult i32 %274, %257
  br i1 %275, label %276, label %277

276:                                              ; preds = %273
  br label %291

277:                                              ; preds = %273
  %278 = shl i32 %257, 1
  %279 = call i32 @llvm.umin.i32(i32 %278, i32 1024)
  %280 = add i32 %279, %257
  %281 = call i32 @llvm.umax.i32(i32 %280, i32 8)
  %282 = zext i32 %281 to i64
  %283 = mul i64 %282, 32
  %284 = add i64 %283, 16
  %285 = extractvalue { ptr, i32, i32, i32 } %252, 0
  %286 = load ptr, ptr %285, align 8
  %287 = getelementptr inbounds i8, ptr %286, i32 -16
  %288 = call ptr @realloc(ptr %287, i64 %284)
  %289 = getelementptr inbounds i8, ptr %288, i32 16
  store ptr %289, ptr %285, align 8
  %290 = insertvalue { ptr, i32, i32, i32 } %252, i32 %281, 3
  br label %291

291:                                              ; preds = %276, %277
  %292 = phi { ptr, i32, i32, i32 } [ %290, %277 ], [ %252, %276 ]
  br label %293

293:                                              ; preds = %291
  br label %294

294:                                              ; preds = %259, %293
  %295 = phi { ptr, i32, i32, i32 } [ %292, %293 ], [ %272, %259 ]
  br label %296

296:                                              ; preds = %294
  %297 = extractvalue { ptr, i32, i32, i32 } %295, 0
  %298 = load ptr, ptr %297, align 8
  %299 = extractvalue { ptr, i32, i32, i32 } %295, 2
  %300 = zext i32 %299 to i64
  %301 = mul i64 %300, 32
  %302 = getelementptr inbounds i8, ptr %298, i64 %301
  store i248 %256, ptr %302, align 16
  %303 = extractvalue { ptr, i32, i32, i32 } %295, 2
  %304 = add i32 %303, 1
  %305 = insertvalue { ptr, i32, i32, i32 } %295, i32 %304, 2
  %306 = getelementptr inbounds i8, ptr %298, i32 -12
  store i32 %304, ptr %306, align 4
  %307 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %305, 0
  %308 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %307, i252 %254, 1
  %309 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %308, i32 %253, 2
  %310 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %309, 0
  %311 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %310, {} undef, 1
  %312 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %311, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %312, ptr %14, align 16
  %313 = load { i128, [80 x i8] }, ptr %14, align 16
  %314 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %255, 0
  %315 = insertvalue { i64, { i128, [80 x i8] } } %314, { i128, [80 x i8] } %313, 1
  ret { i64, { i128, [80 x i8] } } %315

316:                                              ; preds = %42
  %317 = phi { ptr, i32, i32, i32 } [ %29, %42 ]
  call void @"drop$40"({ ptr, i32, i32, i32 } %317)
  %318 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f82"()
  %319 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %318, 0
  %320 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %319, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %320, ptr %9, align 8
  %321 = load { i128, [80 x i8] }, ptr %9, align 16
  %322 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %46, 0
  %323 = insertvalue { i64, { i128, [80 x i8] } } %322, { i128, [80 x i8] } %321, 1
  ret { i64, { i128, [80 x i8] } } %323

324:                                              ; preds = %36
  %325 = phi i64 [ %38, %36 ]
  %326 = call fastcc { i64, { i128, [32 x i8] } } @"impl$f79"(i64 %325, i32 %3)
  %327 = extractvalue { i64, { i128, [32 x i8] } } %326, 0
  %328 = extractvalue { i64, { i128, [32 x i8] } } %326, 1
  store { i128, [32 x i8] } %328, ptr %6, align 16
  %329 = load i1, ptr %6, align 1
  switch i1 %329, label %330 [
    i1 false, label %332
    i1 true, label %359
  ]

330:                                              ; preds = %324
  br i1 false, label %331, label %374

331:                                              ; preds = %330
  unreachable

332:                                              ; preds = %324
  %333 = load { i1, { i252 } }, ptr %6, align 16
  %334 = extractvalue { i1, { i252 } } %333, 1
  %335 = extractvalue { i252 } %334, 0
  %336 = zext i252 %30 to i512
  %337 = zext i252 %335 to i512
  %338 = mul i512 %336, %337
  %339 = urem i512 %338, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %340 = icmp uge i512 %338, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %341 = select i1 %340, i512 %339, i512 %338
  %342 = trunc i512 %341 to i252
  %343 = zext i252 %2 to i256
  %344 = zext i252 %342 to i256
  %345 = add i256 %343, %344
  %346 = sub i256 %345, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %347 = icmp uge i256 %345, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %348 = select i1 %347, i256 %346, i256 %345
  %349 = trunc i256 %348 to i252
  %350 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %29, 0
  %351 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %350, i252 %349, 1
  %352 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %351, i32 %37, 2
  %353 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %352, 0
  %354 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %353, {} undef, 1
  %355 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %354, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %355, ptr %8, align 16
  %356 = load { i128, [80 x i8] }, ptr %8, align 16
  %357 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %327, 0
  %358 = insertvalue { i64, { i128, [80 x i8] } } %357, { i128, [80 x i8] } %356, 1
  ret { i64, { i128, [80 x i8] } } %358

359:                                              ; preds = %324
  %360 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %361 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %360, 1
  call void @"drop$40"({ ptr, i32, i32, i32 } %29)
  %362 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %361, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %362, ptr %7, align 8
  %363 = load { i128, [80 x i8] }, ptr %7, align 16
  %364 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %327, 0
  %365 = insertvalue { i64, { i128, [80 x i8] } } %364, { i128, [80 x i8] } %363, 1
  ret { i64, { i128, [80 x i8] } } %365

366:                                              ; preds = %27
  %367 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$40"({ ptr, i32, i32, i32 } %367)
  %368 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"()
  %369 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %368, 0
  %370 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %369, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %370, ptr %5, align 8
  %371 = load { i128, [80 x i8] }, ptr %5, align 16
  %372 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %32, 0
  %373 = insertvalue { i64, { i128, [80 x i8] } } %372, { i128, [80 x i8] } %371, 1
  ret { i64, { i128, [80 x i8] } } %373

374:                                              ; preds = %330
  call void @puts(ptr @assert_msg_120)
  call void @abort()
  unreachable

375:                                              ; preds = %56
  call void @puts(ptr @assert_msg_121)
  call void @abort()
  unreachable

376:                                              ; preds = %169
  call void @puts(ptr @assert_msg_122)
  call void @abort()
  unreachable
}

define private { i64, { i128, [80 x i8] } } @f59(i64 %0, { { ptr, i32, i32, i32 }, i252, i32 } %1, i252 %2, i32 %3) {
  %5 = call fastcc { i64, { i128, [80 x i8] } } @"impl$f59"(i64 %0, { { ptr, i32, i32, i32 }, i252, i32 } %1, i252 %2, i32 %3)
  %6 = extractvalue { i64, { i128, [80 x i8] } } %5, 0
  %7 = extractvalue { i64, { i128, [80 x i8] } } %5, 1
  %8 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %6, 0
  %9 = insertvalue { i64, { i128, [80 x i8] } } %8, { i128, [80 x i8] } %7, 1
  ret { i64, { i128, [80 x i8] } } %9
}

define void @_mlir_ciface_f59(ptr %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2, i252 %3, i32 %4) {
  %6 = call { i64, { i128, [80 x i8] } } @f59(i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2, i252 %3, i32 %4)
  store { i64, { i128, [80 x i8] } } %6, ptr %0, align 16
  ret void
}

define private void @"drop$163"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$40"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$40"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$164"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$163"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$164"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f60"(i64 %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %6 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 0
  %7 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 1
  %8 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %7, 0
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = extractvalue { ptr, i32, i32, i32 } %11, 1
  %13 = extractvalue { ptr, i32, i32, i32 } %11, 2
  %14 = sub i32 %13, %12
  call void @"drop$163"({ ptr, i32, i32, i32 } %11)
  %15 = zext i32 %14 to i252
  %16 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %16, align 4
  %17 = getelementptr inbounds i8, ptr %16, i32 4
  store i32 0, ptr %17, align 4
  %18 = getelementptr inbounds i8, ptr %16, i32 16
  %19 = call ptr @realloc(ptr null, i64 8)
  store ptr %18, ptr %19, align 8
  %20 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %19, 0
  %21 = insertvalue { ptr, i32, i32, i32 } %20, i32 8, 3
  %22 = load ptr, ptr %19, align 8
  store i252 1997209042069643135709344952807065910992472029923670688473712229447419591075, ptr %22, align 16
  %23 = insertvalue { ptr, i32, i32, i32 } %21, i32 1, 2
  %24 = getelementptr inbounds i8, ptr %22, i32 -12
  store i32 1, ptr %24, align 4
  %25 = load ptr, ptr %19, align 8
  %26 = getelementptr inbounds i8, ptr %25, i32 32
  store i252 %15, ptr %26, align 16
  %27 = insertvalue { ptr, i32, i32, i32 } %23, i32 2, 2
  %28 = getelementptr inbounds i8, ptr %25, i32 -12
  store i32 2, ptr %28, align 4
  %29 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %10, 0
  %30 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %29, { ptr, i32, i32, i32 } %27)
  %31 = extractvalue { i64, i64, { i64, [24 x i8] } } %30, 0
  %32 = extractvalue { i64, i64, { i64, [24 x i8] } } %30, 1
  %33 = extractvalue { i64, i64, { i64, [24 x i8] } } %30, 2
  store { i64, [24 x i8] } %33, ptr %4, align 8
  %34 = load i1, ptr %4, align 1
  switch i1 %34, label %35 [
    i1 false, label %37
    i1 true, label %152
  ]

35:                                               ; preds = %3
  br i1 false, label %36, label %158

36:                                               ; preds = %35
  unreachable

37:                                               ; preds = %3
  %38 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %4, align 8
  %39 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %38, 1
  %40 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  %41 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %40, 0
  %42 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %40, 1
  %43 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %42, 0
  %44 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %42, 2
  call void @"drop$163"({ ptr, i32, i32, i32 } %43)
  %45 = zext i32 %44 to i252
  %46 = extractvalue { { ptr, i32, i32, i32 }, {} } %39, 0
  %47 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %41, 0
  %48 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %41, 1
  call void @"drop$163"({ ptr, i32, i32, i32 } %47)
  %49 = extractvalue { ptr, i32, i32, i32 } %46, 3
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %51, label %65

51:                                               ; preds = %37
  %52 = shl i32 %49, 1
  %53 = call i32 @llvm.umin.i32(i32 %52, i32 1024)
  %54 = add i32 %53, %49
  %55 = call i32 @llvm.umax.i32(i32 %54, i32 8)
  %56 = zext i32 %55 to i64
  %57 = mul i64 %56, 32
  %58 = add i64 %57, 16
  %59 = call ptr @realloc(ptr null, i64 %58)
  store i32 1, ptr %59, align 4
  %60 = getelementptr inbounds i8, ptr %59, i32 4
  store i32 0, ptr %60, align 4
  %61 = getelementptr inbounds i8, ptr %59, i32 16
  %62 = call ptr @realloc(ptr null, i64 8)
  store ptr %61, ptr %62, align 8
  %63 = insertvalue { ptr, i32, i32, i32 } %46, ptr %62, 0
  %64 = insertvalue { ptr, i32, i32, i32 } %63, i32 %55, 3
  br label %86

65:                                               ; preds = %37
  %66 = extractvalue { ptr, i32, i32, i32 } %46, 2
  %67 = icmp ult i32 %66, %49
  br i1 %67, label %68, label %69

68:                                               ; preds = %65
  br label %83

69:                                               ; preds = %65
  %70 = shl i32 %49, 1
  %71 = call i32 @llvm.umin.i32(i32 %70, i32 1024)
  %72 = add i32 %71, %49
  %73 = call i32 @llvm.umax.i32(i32 %72, i32 8)
  %74 = zext i32 %73 to i64
  %75 = mul i64 %74, 32
  %76 = add i64 %75, 16
  %77 = extractvalue { ptr, i32, i32, i32 } %46, 0
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr inbounds i8, ptr %78, i32 -16
  %80 = call ptr @realloc(ptr %79, i64 %76)
  %81 = getelementptr inbounds i8, ptr %80, i32 16
  store ptr %81, ptr %77, align 8
  %82 = insertvalue { ptr, i32, i32, i32 } %46, i32 %73, 3
  br label %83

83:                                               ; preds = %68, %69
  %84 = phi { ptr, i32, i32, i32 } [ %82, %69 ], [ %46, %68 ]
  br label %85

85:                                               ; preds = %83
  br label %86

86:                                               ; preds = %51, %85
  %87 = phi { ptr, i32, i32, i32 } [ %84, %85 ], [ %64, %51 ]
  br label %88

88:                                               ; preds = %86
  %89 = extractvalue { ptr, i32, i32, i32 } %87, 0
  %90 = load ptr, ptr %89, align 8
  %91 = extractvalue { ptr, i32, i32, i32 } %87, 2
  %92 = zext i32 %91 to i64
  %93 = mul i64 %92, 32
  %94 = getelementptr inbounds i8, ptr %90, i64 %93
  store i252 %48, ptr %94, align 16
  %95 = extractvalue { ptr, i32, i32, i32 } %87, 2
  %96 = add i32 %95, 1
  %97 = insertvalue { ptr, i32, i32, i32 } %87, i32 %96, 2
  %98 = getelementptr inbounds i8, ptr %90, i32 -12
  store i32 %96, ptr %98, align 4
  %99 = extractvalue { ptr, i32, i32, i32 } %87, 3
  %100 = icmp eq i32 %99, 0
  br i1 %100, label %101, label %115

101:                                              ; preds = %88
  %102 = shl i32 %99, 1
  %103 = call i32 @llvm.umin.i32(i32 %102, i32 1024)
  %104 = add i32 %103, %99
  %105 = call i32 @llvm.umax.i32(i32 %104, i32 8)
  %106 = zext i32 %105 to i64
  %107 = mul i64 %106, 32
  %108 = add i64 %107, 16
  %109 = call ptr @realloc(ptr null, i64 %108)
  store i32 1, ptr %109, align 4
  %110 = getelementptr inbounds i8, ptr %109, i32 4
  store i32 0, ptr %110, align 4
  %111 = getelementptr inbounds i8, ptr %109, i32 16
  %112 = call ptr @realloc(ptr null, i64 8)
  store ptr %111, ptr %112, align 8
  %113 = insertvalue { ptr, i32, i32, i32 } %97, ptr %112, 0
  %114 = insertvalue { ptr, i32, i32, i32 } %113, i32 %105, 3
  br label %135

115:                                              ; preds = %88
  %116 = icmp ult i32 %96, %99
  br i1 %116, label %117, label %118

117:                                              ; preds = %115
  br label %132

118:                                              ; preds = %115
  %119 = shl i32 %99, 1
  %120 = call i32 @llvm.umin.i32(i32 %119, i32 1024)
  %121 = add i32 %120, %99
  %122 = call i32 @llvm.umax.i32(i32 %121, i32 8)
  %123 = zext i32 %122 to i64
  %124 = mul i64 %123, 32
  %125 = add i64 %124, 16
  %126 = extractvalue { ptr, i32, i32, i32 } %87, 0
  %127 = load ptr, ptr %126, align 8
  %128 = getelementptr inbounds i8, ptr %127, i32 -16
  %129 = call ptr @realloc(ptr %128, i64 %125)
  %130 = getelementptr inbounds i8, ptr %129, i32 16
  store ptr %130, ptr %126, align 8
  %131 = insertvalue { ptr, i32, i32, i32 } %97, i32 %122, 3
  br label %132

132:                                              ; preds = %117, %118
  %133 = phi { ptr, i32, i32, i32 } [ %131, %118 ], [ %97, %117 ]
  br label %134

134:                                              ; preds = %132
  br label %135

135:                                              ; preds = %101, %134
  %136 = phi { ptr, i32, i32, i32 } [ %133, %134 ], [ %114, %101 ]
  br label %137

137:                                              ; preds = %135
  %138 = extractvalue { ptr, i32, i32, i32 } %136, 0
  %139 = load ptr, ptr %138, align 8
  %140 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %141 = zext i32 %140 to i64
  %142 = mul i64 %141, 32
  %143 = getelementptr inbounds i8, ptr %139, i64 %142
  store i252 %45, ptr %143, align 16
  %144 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %145 = add i32 %144, 1
  %146 = insertvalue { ptr, i32, i32, i32 } %136, i32 %145, 2
  %147 = getelementptr inbounds i8, ptr %139, i32 -12
  store i32 %145, ptr %147, align 4
  %148 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %146, 1
  %149 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } undef, i64 %31, 0
  %150 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %149, i64 %32, 1
  %151 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %150, { {}, { ptr, i32, i32, i32 } } %148, 2
  ret { i64, i64, { {}, { ptr, i32, i32, i32 } } } %151

152:                                              ; preds = %3
  %153 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %154 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %153, 1
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  %155 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } undef, i64 %31, 0
  %156 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %155, i64 %32, 1
  %157 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %156, { {}, { ptr, i32, i32, i32 } } %154, 2
  ret { i64, i64, { {}, { ptr, i32, i32, i32 } } } %157

158:                                              ; preds = %35
  call void @puts(ptr @assert_msg_123)
  call void @abort()
  unreachable
}

define private { i64, i64, { {}, { ptr, i32, i32, i32 } } } @f60(i64 %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2) {
  %4 = call fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f60"(i64 %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2)
  %5 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %4, 0
  %6 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %4, 1
  %7 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %4, 2
  %8 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %9, { {}, { ptr, i32, i32, i32 } } %7, 2
  ret { i64, i64, { {}, { ptr, i32, i32, i32 } } } %10
}

define void @_mlir_ciface_f60(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 }, i252, i32 } %3) {
  %5 = call { i64, i64, { {}, { ptr, i32, i32, i32 } } } @f60(i64 %1, i64 %2, { { ptr, i32, i32, i32 }, i252, i32 } %3)
  store { i64, i64, { {}, { ptr, i32, i32, i32 } } } %5, ptr %0, align 8
  ret void
}

define private fastcc { i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %0, ptr %1, { {} } %2, ptr %3) {
  %5 = alloca { i128, [32 x i8] }, i64 1, align 16
  %6 = alloca { i1, [31 x i8] }, i64 1, align 8
  %7 = alloca i64, i64 1, align 8
  %8 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %9 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = load { i128, [32 x i8] }, ptr %3, align 16
  store { i128, [32 x i8] } %12, ptr %5, align 16
  %13 = load i1, ptr %5, align 1
  switch i1 %13, label %14 [
    i1 false, label %16
    i1 true, label %36
  ]

14:                                               ; preds = %4
  br i1 false, label %15, label %100

15:                                               ; preds = %14
  unreachable

16:                                               ; preds = %4
  %17 = load { i1, { i252 } }, ptr %5, align 16
  %18 = extractvalue { i1, { i252 } } %17, 1
  %19 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %20 = call ptr %19()
  %21 = call i64 @llvm.uadd.sat.i64(i64 %0, i64 0)
  %22 = extractvalue { i252 } %18, 0
  %23 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %23, align 4
  %24 = getelementptr inbounds i8, ptr %23, i32 4
  store i32 0, ptr %24, align 4
  %25 = getelementptr inbounds i8, ptr %23, i32 16
  %26 = call ptr @realloc(ptr null, i64 8)
  store ptr %25, ptr %26, align 8
  %27 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %26, 0
  %28 = insertvalue { ptr, i32, i32, i32 } %27, i32 8, 3
  %29 = load ptr, ptr %26, align 8
  store i252 589022817552792543318509852632045264175748210744615699137722900036442648072, ptr %29, align 16
  %30 = insertvalue { ptr, i32, i32, i32 } %28, i32 1, 2
  %31 = getelementptr inbounds i8, ptr %29, i32 -12
  store i32 1, ptr %31, align 4
  %32 = load ptr, ptr %26, align 8
  %33 = getelementptr inbounds i8, ptr %32, i32 32
  store i252 %22, ptr %33, align 16
  %34 = insertvalue { ptr, i32, i32, i32 } %30, i32 2, 2
  %35 = getelementptr inbounds i8, ptr %32, i32 -12
  store i32 2, ptr %35, align 4
  br label %58

36:                                               ; preds = %4
  %37 = load { i1, { i252 } }, ptr %5, align 16
  %38 = extractvalue { i1, { i252 } } %37, 1
  %39 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %40 = call ptr %39()
  %41 = load i64, ptr %40, align 8
  %42 = mul i64 %41, 100
  %43 = call i64 @llvm.uadd.sat.i64(i64 %0, i64 %42)
  %44 = extractvalue { i252 } %38, 0
  %45 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %45, align 4
  %46 = getelementptr inbounds i8, ptr %45, i32 4
  store i32 0, ptr %46, align 4
  %47 = getelementptr inbounds i8, ptr %45, i32 16
  %48 = call ptr @realloc(ptr null, i64 8)
  store ptr %47, ptr %48, align 8
  %49 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %48, 0
  %50 = insertvalue { ptr, i32, i32, i32 } %49, i32 8, 3
  %51 = load ptr, ptr %48, align 8
  store i252 592812847939322677565668720816539444019393425324860683642110029332411209997, ptr %51, align 16
  %52 = insertvalue { ptr, i32, i32, i32 } %50, i32 1, 2
  %53 = getelementptr inbounds i8, ptr %51, i32 -12
  store i32 1, ptr %53, align 4
  %54 = load ptr, ptr %48, align 8
  %55 = getelementptr inbounds i8, ptr %54, i32 32
  store i252 %44, ptr %55, align 16
  %56 = insertvalue { ptr, i32, i32, i32 } %52, i32 2, 2
  %57 = getelementptr inbounds i8, ptr %54, i32 -12
  store i32 2, ptr %57, align 4
  br label %58

58:                                               ; preds = %16, %36
  %59 = phi ptr [ %1, %36 ], [ %1, %16 ]
  %60 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %36 ], [ zeroinitializer, %16 ]
  %61 = phi i64 [ %43, %36 ], [ %21, %16 ]
  %62 = phi { ptr, i32, i32, i32 } [ %56, %36 ], [ %34, %16 ]
  %63 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %62)
  %64 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %63, 0
  %65 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %63, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %64)
  %66 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %60)
  %67 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %66, 0
  %68 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %66, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %67)
  %69 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %65, 0
  %70 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %71 = load ptr, ptr %59, align 8
  store i64 %61, ptr %7, align 8
  store { { ptr, i32, i32, i32 } } %69, ptr %8, align 8
  store { { ptr, i32, i32, i32 } } %70, ptr %9, align 8
  %72 = getelementptr inbounds ptr, ptr %59, i32 10
  %73 = load ptr, ptr %72, align 8
  call void %73(ptr %6, ptr %71, ptr %7, ptr %8, ptr %9)
  %74 = load { i1, [31 x i8] }, ptr %6, align 1
  %75 = extractvalue { i1, [31 x i8] } %74, 0
  %76 = getelementptr inbounds i8, ptr %6, i32 8
  %77 = load { ptr, i32, i32, i32 }, ptr %76, align 8
  %78 = load i64, ptr %7, align 8
  br i1 %75, label %90, label %79

79:                                               ; preds = %58
  %80 = phi i64 [ %78, %58 ]
  %81 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %82 = call ptr %81()
  %83 = load i64, ptr %82, align 8
  %84 = mul i64 %83, 10
  %85 = call i64 @llvm.uadd.sat.i64(i64 %80, i64 %84)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %11, align 1
  %86 = load { i64, [24 x i8] }, ptr %11, align 8
  %87 = insertvalue { i64, ptr, { i64, [24 x i8] } } undef, i64 %85, 0
  %88 = insertvalue { i64, ptr, { i64, [24 x i8] } } %87, ptr %59, 1
  %89 = insertvalue { i64, ptr, { i64, [24 x i8] } } %88, { i64, [24 x i8] } %86, 2
  ret { i64, ptr, { i64, [24 x i8] } } %89

90:                                               ; preds = %58
  %91 = phi {} [ undef, %58 ]
  %92 = phi { ptr, i32, i32, i32 } [ %77, %58 ]
  %93 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %91, 0
  %94 = insertvalue { {}, { ptr, i32, i32, i32 } } %93, { ptr, i32, i32, i32 } %92, 1
  %95 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %94, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %95, ptr %10, align 8
  %96 = load { i64, [24 x i8] }, ptr %10, align 8
  %97 = insertvalue { i64, ptr, { i64, [24 x i8] } } undef, i64 %78, 0
  %98 = insertvalue { i64, ptr, { i64, [24 x i8] } } %97, ptr %59, 1
  %99 = insertvalue { i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %96, 2
  ret { i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %14
  call void @puts(ptr @assert_msg_124)
  call void @abort()
  unreachable
}

define private { i64, ptr, { i64, [24 x i8] } } @f61(i64 %0, ptr %1, { {} } %2, ptr %3) {
  %5 = call fastcc { i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %0, ptr %1, { {} } %2, ptr %3)
  %6 = extractvalue { i64, ptr, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, ptr, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, ptr, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, ptr, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, ptr, { i64, [24 x i8] } } %9, ptr %7, 1
  %11 = insertvalue { i64, ptr, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, ptr, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f61(ptr %0, i64 %1, ptr %2, { {} } %3, ptr %4) {
  %6 = call { i64, ptr, { i64, [24 x i8] } } @f61(i64 %1, ptr %2, { {} } %3, ptr %4)
  store { i64, ptr, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f62"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, { {} } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca i256, i64 1, align 16
  %15 = alloca i256, i64 1, align 16
  %16 = alloca i256, i64 1, align 16
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca i252, i64 1, align 16
  %20 = alloca i252, i64 1, align 16
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %22

22:                                               ; preds = %73, %6
  %23 = phi i64 [ %61, %73 ], [ %0, %6 ]
  %24 = phi i64 [ %77, %73 ], [ %1, %6 ]
  %25 = phi i64 [ %56, %73 ], [ %2, %6 ]
  %26 = phi ptr [ %26, %73 ], [ %3, %6 ]
  %27 = phi { { ptr, i32, i32, i32 } } [ %78, %73 ], [ %4, %6 ]
  %28 = phi { {} } [ %28, %73 ], [ %5, %6 ]
  %29 = add i64 %23, 1
  %30 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %31 = call ptr %30()
  %32 = getelementptr inbounds i64, ptr %31, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = load i64, ptr %31, align 8
  %35 = mul i64 %34, 14780
  %36 = add i64 %33, %35
  %37 = icmp uge i64 %24, %36
  %38 = call i64 @llvm.usub.sat.i64(i64 %24, i64 %36)
  br i1 %37, label %39, label %143

39:                                               ; preds = %22
  %40 = phi { { ptr, i32, i32, i32 } } [ %27, %22 ]
  %41 = extractvalue { { ptr, i32, i32, i32 } } %40, 0
  %42 = extractvalue { ptr, i32, i32, i32 } %41, 1
  %43 = extractvalue { ptr, i32, i32, i32 } %41, 2
  %44 = sub i32 %43, %42
  %45 = icmp uge i32 %44, 1
  br i1 %45, label %46, label %116

46:                                               ; preds = %39
  %47 = extractvalue { ptr, i32, i32, i32 } %41, 0
  %48 = load ptr, ptr %47, align 8
  %49 = zext i32 %42 to i64
  %50 = mul i64 %49, 32
  %51 = getelementptr inbounds i8, ptr %48, i64 %50
  %52 = add i32 %42, 1
  %53 = insertvalue { ptr, i32, i32, i32 } %41, i32 %52, 1
  %54 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %54, ptr %51, i64 32, i1 false)
  %55 = load i252, ptr %54, align 16
  call void @free(ptr %54)
  %56 = add i64 %25, 3
  %57 = zext i252 %55 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %14, align 16
  store i256 %57, ptr %15, align 16
  %58 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %58(ptr %16, ptr %14, ptr %15)
  %59 = load i256, ptr %16, align 16
  %60 = trunc i256 %59 to i252
  %61 = add i64 %23, 4
  %62 = sub i252 %60, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %63 = icmp ult i252 %60, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %64 = select i1 %63, i252 %60, i252 %62
  %65 = load ptr, ptr %26, align 8
  store i64 %38, ptr %18, align 8
  store i252 %64, ptr %19, align 16
  store i252 1, ptr %20, align 16
  %66 = getelementptr inbounds ptr, ptr %26, i32 9
  %67 = load ptr, ptr %66, align 8
  call void %67(ptr %17, ptr %65, ptr %18, i32 0, ptr %19, ptr %20)
  %68 = load { i1, [31 x i8] }, ptr %17, align 1
  %69 = extractvalue { i1, [31 x i8] } %68, 0
  %70 = getelementptr inbounds i8, ptr %17, i32 8
  %71 = load { ptr, i32, i32, i32 }, ptr %70, align 8
  %72 = load i64, ptr %18, align 8
  br i1 %69, label %100, label %73

73:                                               ; preds = %46
  %74 = phi i64 [ %72, %46 ]
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %74, i64 0)
  %78 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %53, 0
  %79 = extractvalue { ptr, ptr, i64 } %10, 1
  %80 = load i64, ptr %79, align 8
  %81 = add i64 %80, 1
  %82 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %81, ptr %82, align 8
  br label %22

83:                                               ; preds = %83, %100, %116, %143
  %84 = phi i64 [ %29, %143 ], [ %29, %116 ], [ %61, %100 ], [ %84, %83 ]
  %85 = phi i64 [ %24, %143 ], [ %125, %116 ], [ %72, %100 ], [ %85, %83 ]
  %86 = phi i64 [ %25, %143 ], [ %25, %116 ], [ %56, %100 ], [ %86, %83 ]
  %87 = phi ptr [ %26, %143 ], [ %26, %116 ], [ %26, %100 ], [ %87, %83 ]
  %88 = phi { i64, [24 x i8] } [ %148, %143 ], [ %131, %116 ], [ %104, %100 ], [ %88, %83 ]
  %89 = extractvalue { ptr, ptr, i64 } %10, 1
  %90 = load i64, ptr %89, align 8
  %91 = icmp eq i64 %90, 0
  %92 = sub i64 %90, 1
  %93 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %92, ptr %93, align 8
  br i1 %91, label %94, label %83

94:                                               ; preds = %83
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %84, 0
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %85, 1
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %86, 2
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, ptr %87, 3
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %88, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %46
  %101 = phi { ptr, i32, i32, i32 } [ %53, %46 ]
  call void @"drop$241"({ ptr, i32, i32, i32 } %101)
  %102 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %71, 1
  %103 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %102, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %103, ptr %21, align 8
  %104 = load { i64, [24 x i8] }, ptr %21, align 8
  %105 = extractvalue { ptr, ptr, i64 } %10, 1
  %106 = load i64, ptr %105, align 8
  %107 = icmp eq i64 %106, 0
  %108 = sub i64 %106, 1
  %109 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %108, ptr %109, align 8
  br i1 %107, label %110, label %83

110:                                              ; preds = %100
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %61, 0
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, i64 %72, 1
  %113 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %112, i64 %56, 2
  %114 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %113, ptr %26, 3
  %115 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %114, { i64, [24 x i8] } %104, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %115

116:                                              ; preds = %39
  %117 = phi i64 [ %38, %39 ]
  %118 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %119 = call ptr %118()
  %120 = getelementptr inbounds i64, ptr %119, i32 1
  %121 = load i64, ptr %120, align 8
  %122 = load i64, ptr %119, align 8
  %123 = mul i64 %122, 14980
  %124 = add i64 %121, %123
  %125 = call i64 @llvm.uadd.sat.i64(i64 %117, i64 %124)
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %127 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } undef, { { ptr, i32, i32, i32 } } %126, 0
  %128 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %127, { {} } %28, 1
  %129 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %128, {} undef, 2
  %130 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { {} }, {} } undef }, { { { ptr, i32, i32, i32 } }, { {} }, {} } %129, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %130, ptr %13, align 8
  %131 = load { i64, [24 x i8] }, ptr %13, align 8
  %132 = extractvalue { ptr, ptr, i64 } %10, 1
  %133 = load i64, ptr %132, align 8
  %134 = icmp eq i64 %133, 0
  %135 = sub i64 %133, 1
  %136 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %135, ptr %136, align 8
  br i1 %134, label %137, label %83

137:                                              ; preds = %116
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %29, 0
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, i64 %125, 1
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, i64 %25, 2
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %140, ptr %26, 3
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, { i64, [24 x i8] } %131, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %142

143:                                              ; preds = %22
  %144 = phi { { ptr, i32, i32, i32 } } [ %27, %22 ]
  call void @"drop$242"({ { ptr, i32, i32, i32 } } %144)
  %145 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %146 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %145, 0
  %147 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %146, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %147, ptr %12, align 8
  %148 = load { i64, [24 x i8] }, ptr %12, align 8
  %149 = extractvalue { ptr, ptr, i64 } %10, 1
  %150 = load i64, ptr %149, align 8
  %151 = icmp eq i64 %150, 0
  %152 = sub i64 %150, 1
  %153 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %152, ptr %153, align 8
  br i1 %151, label %154, label %83

154:                                              ; preds = %143
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %29, 0
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %24, 1
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, i64 %25, 2
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, ptr %26, 3
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %158, { i64, [24 x i8] } %148, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %159
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f62(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, { {} } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f62"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, { {} } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f62(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f62(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 2
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, { { ptr, i32, i32, i32 }, i252, i32 } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %4, { { ptr, i32, i32, i32 }, i252, i32 } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 2
  %12 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$41"({ { ptr, i32, i32, i32 }, i252, i32 } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, { { ptr, i32, i32, i32 }, i252, i32 } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %10, { { ptr, i32, i32, i32 }, i252, i32 } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } undef, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %17, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %18
}

define private void @"drop$157"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  call void @"drop$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$157"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = call { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0)
  %3 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %2, 0
  %4 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %2, 1
  %5 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } undef, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %6 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %5, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %4, 1
  ret { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %6
}

define private void @"drop$155"({ { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 0
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 1
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$155"({ { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 1
  %9 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, { { ptr, i32, i32, i32 }, i252, i32 } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %7, { { ptr, i32, i32, i32 }, i252, i32 } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %14, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %13, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %15
}

define private void @"drop$30"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$29"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$30"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$29"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$31"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$30"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$31"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$30"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  call void @"drop$31"({ { ptr, i32, i32, i32 } } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$31"({ { ptr, i32, i32, i32 } } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, { { ptr, i32, i32, i32 } } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10, { { ptr, i32, i32, i32 } } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } undef, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %17, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %18
}

define private void @"drop$151"({ i252, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { i128, [80 x i8] } } %0, 1
  call void @"drop$35"({ i128, [80 x i8] } %2)
  ret void
}

define private { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } @"dup$151"({ i252, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { i128, [80 x i8] } } %0, 0
  %3 = insertvalue { i252, { i128, [80 x i8] } } %0, i252 %2, 0
  %4 = insertvalue { i252, { i128, [80 x i8] } } undef, i252 %2, 0
  %5 = extractvalue { i252, { i128, [80 x i8] } } %0, 1
  %6 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$35"({ i128, [80 x i8] } %5)
  %7 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %6, 0
  %8 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %6, 1
  %9 = insertvalue { i252, { i128, [80 x i8] } } %3, { i128, [80 x i8] } %7, 1
  %10 = insertvalue { i252, { i128, [80 x i8] } } %4, { i128, [80 x i8] } %8, 1
  %11 = insertvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } undef, { i252, { i128, [80 x i8] } } %9, 0
  %12 = insertvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %11, { i252, { i128, [80 x i8] } } %10, 1
  ret { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %12
}

define private void @"drop$6"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 128
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i252, { i128, [80 x i8] } }, ptr %22, align 16
  call void @"drop$151"({ i252, { i128, [80 x i8] } } %23)
  %24 = add i64 %19, 128
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$6"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$7"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$6"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$7"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$6"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$33"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$7"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$33"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$7"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  call void @"drop$33"({ { ptr, i32, i32, i32 } } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$33"({ { ptr, i32, i32, i32 } } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, { { ptr, i32, i32, i32 } } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10, { { ptr, i32, i32, i32 } } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } undef, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %17, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %18
}

define private void @"drop$2"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 96
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i128, [80 x i8] }, ptr %22, align 16
  call void @"drop$35"({ i128, [80 x i8] } %23)
  %24 = add i64 %19, 96
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$3"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$2"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$12"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$3"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$12"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$14"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  call void @"drop$12"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$14"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$12"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %6, i32 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %7, i32 %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } undef, { { { ptr, i32, i32, i32 } }, i32 } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %11, { { { ptr, i32, i32, i32 } }, i32 } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %12
}

define private void @"drop$35"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i3, ptr %2, align 1
  switch i3 %3, label %18 [
    i3 0, label %4
    i3 1, label %5
    i3 2, label %8
    i3 3, label %11
    i3 -4, label %11
    i3 -3, label %14
    i3 -2, label %15
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %7 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %6, 1
  call void @"drop$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7)
  ret void

8:                                                ; preds = %1
  %9 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %10 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %9, 1
  call void @"drop$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10)
  ret void

11:                                               ; preds = %1, %1
  %12 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %13 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %12, 1
  call void @"drop$12"({ { ptr, i32, i32, i32 } } %13)
  ret void

14:                                               ; preds = %1
  ret void

15:                                               ; preds = %1
  %16 = load { i3, { { { ptr, i32, i32, i32 } }, i32 } }, ptr %2, align 8
  %17 = extractvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %16, 1
  call void @"drop$14"({ { { ptr, i32, i32, i32 } }, i32 } %17)
  ret void

18:                                               ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$35"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i3, ptr %2, align 1
  switch i3 %3, label %70 [
    i3 0, label %4
    i3 1, label %13
    i3 2, label %25
    i3 3, label %37
    i3 -4, label %37
    i3 -3, label %49
    i3 -2, label %58
  ]

4:                                                ; preds = %1
  %5 = load { i3, i252 }, ptr %2, align 16
  %6 = extractvalue { i3, i252 } %5, 1
  %7 = insertvalue { i3, i252 } %5, i252 %6, 1
  store { i3, i252 } %7, ptr %2, align 16
  %8 = load { i128, [80 x i8] }, ptr %2, align 16
  %9 = insertvalue { i3, i252 } %5, i252 %6, 1
  store { i3, i252 } %9, ptr %2, align 16
  %10 = load { i128, [80 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %8, 0
  %12 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %11, { i128, [80 x i8] } %10, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %15 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, 1
  %16 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %15)
  %17 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %16, 0
  %18 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %16, 1
  %19 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %17, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %19, ptr %2, align 16
  %20 = load { i128, [80 x i8] }, ptr %2, align 16
  %21 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %18, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %21, ptr %2, align 16
  %22 = load { i128, [80 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %20, 0
  %24 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %23, { i128, [80 x i8] } %22, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %24

25:                                               ; preds = %1
  %26 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %27 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %26, 1
  %28 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %27)
  %29 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %28, 0
  %30 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %28, 1
  %31 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %26, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %29, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %31, ptr %2, align 16
  %32 = load { i128, [80 x i8] }, ptr %2, align 16
  %33 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %26, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %30, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %33, ptr %2, align 16
  %34 = load { i128, [80 x i8] }, ptr %2, align 16
  %35 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %32, 0
  %36 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %35, { i128, [80 x i8] } %34, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %36

37:                                               ; preds = %1, %1
  %38 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %39 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %38, 1
  %40 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$12"({ { ptr, i32, i32, i32 } } %39)
  %41 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %40, 0
  %42 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %40, 1
  %43 = insertvalue { i3, { { ptr, i32, i32, i32 } } } %38, { { ptr, i32, i32, i32 } } %41, 1
  store { i3, { { ptr, i32, i32, i32 } } } %43, ptr %2, align 8
  %44 = load { i128, [80 x i8] }, ptr %2, align 16
  %45 = insertvalue { i3, { { ptr, i32, i32, i32 } } } %38, { { ptr, i32, i32, i32 } } %42, 1
  store { i3, { { ptr, i32, i32, i32 } } } %45, ptr %2, align 8
  %46 = load { i128, [80 x i8] }, ptr %2, align 16
  %47 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %44, 0
  %48 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %47, { i128, [80 x i8] } %46, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %48

49:                                               ; preds = %1
  %50 = load { i3, {} }, ptr %2, align 1
  %51 = extractvalue { i3, {} } %50, 1
  %52 = insertvalue { i3, {} } %50, {} %51, 1
  store { i3, {} } %52, ptr %2, align 1
  %53 = load { i128, [80 x i8] }, ptr %2, align 16
  %54 = insertvalue { i3, {} } %50, {} %51, 1
  store { i3, {} } %54, ptr %2, align 1
  %55 = load { i128, [80 x i8] }, ptr %2, align 16
  %56 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %53, 0
  %57 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %56, { i128, [80 x i8] } %55, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %57

58:                                               ; preds = %1
  %59 = load { i3, { { { ptr, i32, i32, i32 } }, i32 } }, ptr %2, align 8
  %60 = extractvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %59, 1
  %61 = call { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$14"({ { { ptr, i32, i32, i32 } }, i32 } %60)
  %62 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %61, 0
  %63 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %61, 1
  %64 = insertvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %59, { { { ptr, i32, i32, i32 } }, i32 } %62, 1
  store { i3, { { { ptr, i32, i32, i32 } }, i32 } } %64, ptr %2, align 8
  %65 = load { i128, [80 x i8] }, ptr %2, align 16
  %66 = insertvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %59, { { { ptr, i32, i32, i32 } }, i32 } %63, 1
  store { i3, { { { ptr, i32, i32, i32 } }, i32 } } %66, ptr %2, align 8
  %67 = load { i128, [80 x i8] }, ptr %2, align 16
  %68 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %65, 0
  %69 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %68, { i128, [80 x i8] } %67, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %69

70:                                               ; preds = %1
  unreachable
}

define private void @"drop$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 2
  call void @"drop$35"({ i128, [80 x i8] } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 2
  %12 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$35"({ i128, [80 x i8] } %11)
  %13 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %12, 0
  %14 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %9, { i128, [80 x i8] } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %10, { i128, [80 x i8] } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } undef, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %17, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %18
}

define private void @"drop$29"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 160
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %22, align 16
  call void @"drop$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %23)
  %24 = add i64 %19, 160
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$29"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f63"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [80 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = alloca { i128, [80 x i8] }, i64 1, align 16
  %17 = alloca { i128, [80 x i8] }, i64 1, align 16
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i128, [80 x i8] }, i64 1, align 16
  %20 = alloca { i128, [80 x i8] }, i64 1, align 16
  %21 = alloca { i128, [80 x i8] }, i64 1, align 16
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca { i1, [31 x i8] }, i64 1, align 8
  %25 = alloca i64, i64 1, align 8
  %26 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %27 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %28 = alloca { i64, [24 x i8] }, i64 1, align 8
  %29 = alloca { i64, [24 x i8] }, i64 1, align 8
  %30 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } { i252 313215164569295318208292514394769381779806795543033682241894454505053143643, { { ptr, i32, i32, i32 }, i252, i32 } undef, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %4, 1
  %31 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %30, { { ptr, i32, i32, i32 }, i252, i32 } %3, 2
  %32 = call { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %31)
  %33 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %32, 0
  %34 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %32, 1
  call void @"drop$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %33)
  %35 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %34, 0
  %36 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %34, 1
  %37 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %34, 2
  %38 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %38, align 4
  %39 = getelementptr inbounds i8, ptr %38, i32 4
  store i32 0, ptr %39, align 4
  %40 = getelementptr inbounds i8, ptr %38, i32 16
  %41 = call ptr @realloc(ptr null, i64 8)
  store ptr %40, ptr %41, align 8
  %42 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %41, 0
  %43 = insertvalue { ptr, i32, i32, i32 } %42, i32 8, 3
  %44 = load ptr, ptr %41, align 8
  store i252 %35, ptr %44, align 16
  %45 = insertvalue { ptr, i32, i32, i32 } %43, i32 1, 2
  %46 = getelementptr inbounds i8, ptr %44, i32 -12
  store i32 1, ptr %46, align 4
  %47 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %36, 0
  %48 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %47, { { ptr, i32, i32, i32 }, i252, i32 } %37, 1
  %49 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %48, { ptr, i32, i32, i32 } %45)
  %50 = extractvalue { i64, i64, { i64, [24 x i8] } } %49, 0
  %51 = extractvalue { i64, i64, { i64, [24 x i8] } } %49, 1
  %52 = extractvalue { i64, i64, { i64, [24 x i8] } } %49, 2
  store { i64, [24 x i8] } %52, ptr %6, align 8
  %53 = load i1, ptr %6, align 1
  switch i1 %53, label %54 [
    i1 false, label %56
    i1 true, label %252
  ]

54:                                               ; preds = %5
  br i1 false, label %55, label %310

55:                                               ; preds = %54
  unreachable

56:                                               ; preds = %5
  %57 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %58 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %57, 1
  %59 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %60 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 0
  %61 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %60)
  %62 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %63 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 0
  %64 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %63)
  %65 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %66 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %65, 0
  %67 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %65, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %66)
  %68 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %69 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %68, 0
  %70 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %68, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %69)
  %71 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %70, 0
  %72 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %71, 1
  store { i3, { { ptr, i32, i32, i32 } } } %72, ptr %8, align 8
  %73 = load { i128, [80 x i8] }, ptr %8, align 16
  %74 = insertvalue { i252, { i128, [80 x i8] } } { i252 1315925605, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %73, 1
  %75 = call ptr @realloc(ptr null, i64 1040)
  store i32 1, ptr %75, align 4
  %76 = getelementptr inbounds i8, ptr %75, i32 4
  store i32 0, ptr %76, align 4
  %77 = getelementptr inbounds i8, ptr %75, i32 16
  %78 = call ptr @realloc(ptr null, i64 8)
  store ptr %77, ptr %78, align 8
  %79 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %78, 0
  %80 = insertvalue { ptr, i32, i32, i32 } %79, i32 8, 3
  %81 = load ptr, ptr %78, align 8
  store { i252, { i128, [80 x i8] } } %74, ptr %81, align 16
  %82 = insertvalue { ptr, i32, i32, i32 } %80, i32 1, 2
  %83 = getelementptr inbounds i8, ptr %81, i32 -12
  store i32 1, ptr %83, align 4
  %84 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %85 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %84, 0
  %86 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %84, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %85)
  %87 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %86, 0
  %88 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %87, 1
  store { i3, { { ptr, i32, i32, i32 } } } %88, ptr %9, align 8
  %89 = load { i128, [80 x i8] }, ptr %9, align 16
  %90 = insertvalue { i252, { i128, [80 x i8] } } { i252 313472685977919867416164, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %89, 1
  %91 = load ptr, ptr %78, align 8
  %92 = getelementptr inbounds i8, ptr %91, i32 128
  store { i252, { i128, [80 x i8] } } %90, ptr %92, align 16
  %93 = insertvalue { ptr, i32, i32, i32 } %82, i32 2, 2
  %94 = getelementptr inbounds i8, ptr %91, i32 -12
  store i32 2, ptr %94, align 4
  %95 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %96 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 0
  %97 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %96)
  %98 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %97, 0
  %99 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %98, 1
  store { i3, { { ptr, i32, i32, i32 } } } %99, ptr %10, align 8
  %100 = load { i128, [80 x i8] }, ptr %10, align 16
  %101 = insertvalue { i252, { i128, [80 x i8] } } { i252 71959718098290, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %100, 1
  %102 = load ptr, ptr %78, align 8
  %103 = getelementptr inbounds i8, ptr %102, i32 256
  store { i252, { i128, [80 x i8] } } %101, ptr %103, align 16
  %104 = insertvalue { ptr, i32, i32, i32 } %93, i32 3, 2
  %105 = getelementptr inbounds i8, ptr %102, i32 -12
  store i32 3, ptr %105, align 4
  %106 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %107 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %106, 0
  %108 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %106, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %107)
  %109 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %108, 0
  %110 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %109, 1
  store { i3, { { ptr, i32, i32, i32 } } } %110, ptr %11, align 8
  %111 = load { i128, [80 x i8] }, ptr %11, align 16
  %112 = insertvalue { i252, { i128, [80 x i8] } } { i252 20940711753708153, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %111, 1
  %113 = load ptr, ptr %78, align 8
  %114 = getelementptr inbounds i8, ptr %113, i32 384
  store { i252, { i128, [80 x i8] } } %112, ptr %114, align 16
  %115 = insertvalue { ptr, i32, i32, i32 } %104, i32 4, 2
  %116 = getelementptr inbounds i8, ptr %113, i32 -12
  store i32 4, ptr %116, align 4
  %117 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %118 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %117, 0
  %119 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %117, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %118)
  %120 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %119, 0
  %121 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %120, 1
  store { i3, { { ptr, i32, i32, i32 } } } %121, ptr %12, align 8
  %122 = load { i128, [80 x i8] }, ptr %12, align 16
  %123 = insertvalue { i252, { i128, [80 x i8] } } { i252 1298232171, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %122, 1
  %124 = load ptr, ptr %78, align 8
  %125 = getelementptr inbounds i8, ptr %124, i32 512
  store { i252, { i128, [80 x i8] } } %123, ptr %125, align 16
  %126 = insertvalue { ptr, i32, i32, i32 } %115, i32 5, 2
  %127 = getelementptr inbounds i8, ptr %124, i32 -12
  store i32 5, ptr %127, align 4
  %128 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %129 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %128, 0
  %130 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %128, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %129)
  %131 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %130, 0
  %132 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %131, 1
  store { i3, { { ptr, i32, i32, i32 } } } %132, ptr %13, align 8
  %133 = load { i128, [80 x i8] }, ptr %13, align 16
  %134 = insertvalue { i252, { i128, [80 x i8] } } { i252 96092938071918, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %133, 1
  %135 = load ptr, ptr %78, align 8
  %136 = getelementptr inbounds i8, ptr %135, i32 640
  store { i252, { i128, [80 x i8] } } %134, ptr %136, align 16
  %137 = insertvalue { ptr, i32, i32, i32 } %126, i32 6, 2
  %138 = getelementptr inbounds i8, ptr %135, i32 -12
  store i32 6, ptr %138, align 4
  %139 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %140 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %139, 0
  %141 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %139, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %140)
  %142 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %141, 0
  %143 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %142, 1
  store { i3, { { ptr, i32, i32, i32 } } } %143, ptr %14, align 8
  %144 = load { i128, [80 x i8] }, ptr %14, align 16
  %145 = insertvalue { i252, { i128, [80 x i8] } } { i252 74171727245165, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %144, 1
  %146 = load ptr, ptr %78, align 8
  %147 = getelementptr inbounds i8, ptr %146, i32 768
  store { i252, { i128, [80 x i8] } } %145, ptr %147, align 16
  %148 = insertvalue { ptr, i32, i32, i32 } %137, i32 7, 2
  %149 = getelementptr inbounds i8, ptr %146, i32 -12
  store i32 7, ptr %149, align 4
  %150 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$6"({ ptr, i32, i32, i32 } %148)
  %151 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %150, 0
  %152 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %150, 1
  call void @"drop$6"({ ptr, i32, i32, i32 } %151)
  %153 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %67, 0
  %154 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %152, 0
  %155 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 88292074925748493266188457033990501477, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %153, 1
  %156 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %155, { { ptr, i32, i32, i32 } } %154, 2
  %157 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } { i3 2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %156, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %157, ptr %15, align 16
  %158 = load { i128, [80 x i8] }, ptr %15, align 16
  %159 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %64, 0
  %160 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1797725632952473580645, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %159, 1
  %161 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %160, { i128, [80 x i8] } %158, 2
  %162 = call ptr @realloc(ptr null, i64 1296)
  store i32 1, ptr %162, align 4
  %163 = getelementptr inbounds i8, ptr %162, i32 4
  store i32 0, ptr %163, align 4
  %164 = getelementptr inbounds i8, ptr %162, i32 16
  %165 = call ptr @realloc(ptr null, i64 8)
  store ptr %164, ptr %165, align 8
  %166 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %165, 0
  %167 = insertvalue { ptr, i32, i32, i32 } %166, i32 8, 3
  %168 = load ptr, ptr %165, align 8
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %161, ptr %168, align 16
  %169 = insertvalue { ptr, i32, i32, i32 } %167, i32 1, 2
  %170 = getelementptr inbounds i8, ptr %168, i32 -12
  store i32 1, ptr %170, align 4
  %171 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %172 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %171, 0
  %173 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %171, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %172)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %16, align 16
  %174 = load { i128, [80 x i8] }, ptr %16, align 16
  %175 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %173, 0
  %176 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 452823639416, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %175, 1
  %177 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %176, { i128, [80 x i8] } %174, 2
  %178 = load ptr, ptr %165, align 8
  %179 = getelementptr inbounds i8, ptr %178, i32 160
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %177, ptr %179, align 16
  %180 = insertvalue { ptr, i32, i32, i32 } %169, i32 2, 2
  %181 = getelementptr inbounds i8, ptr %178, i32 -12
  store i32 2, ptr %181, align 4
  %182 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %183 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %182, 0
  %184 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %182, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %183)
  store { i3, [0 x i8] } { i3 -3, [0 x i8] undef }, ptr %17, align 1
  %185 = load { i128, [80 x i8] }, ptr %17, align 16
  %186 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %184, 0
  %187 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1851878757, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %186, 1
  %188 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %187, { i128, [80 x i8] } %185, 2
  %189 = load ptr, ptr %165, align 8
  %190 = getelementptr inbounds i8, ptr %189, i32 320
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %188, ptr %190, align 16
  %191 = insertvalue { ptr, i32, i32, i32 } %180, i32 3, 2
  %192 = getelementptr inbounds i8, ptr %189, i32 -12
  store i32 3, ptr %192, align 4
  %193 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %194 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %193, 0
  %195 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %193, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %194)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %18, align 16
  %196 = load { i128, [80 x i8] }, ptr %18, align 16
  %197 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %195, 0
  %198 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 8319400191629685864, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %197, 1
  %199 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %198, { i128, [80 x i8] } %196, 2
  %200 = load ptr, ptr %165, align 8
  %201 = getelementptr inbounds i8, ptr %200, i32 480
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %199, ptr %201, align 16
  %202 = insertvalue { ptr, i32, i32, i32 } %191, i32 4, 2
  %203 = getelementptr inbounds i8, ptr %200, i32 -12
  store i32 4, ptr %203, align 4
  %204 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %205 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %204, 0
  %206 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %204, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %205)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %19, align 16
  %207 = load { i128, [80 x i8] }, ptr %19, align 16
  %208 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %206, 0
  %209 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 8532478930809615481, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %208, 1
  %210 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %209, { i128, [80 x i8] } %207, 2
  %211 = load ptr, ptr %165, align 8
  %212 = getelementptr inbounds i8, ptr %211, i32 640
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %210, ptr %212, align 16
  %213 = insertvalue { ptr, i32, i32, i32 } %202, i32 5, 2
  %214 = getelementptr inbounds i8, ptr %211, i32 -12
  store i32 5, ptr %214, align 4
  %215 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %216 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 0
  %217 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %216)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %20, align 16
  %218 = load { i128, [80 x i8] }, ptr %20, align 16
  %219 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %217, 0
  %220 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1851986129345051194489, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %219, 1
  %221 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %220, { i128, [80 x i8] } %218, 2
  %222 = load ptr, ptr %165, align 8
  %223 = getelementptr inbounds i8, ptr %222, i32 800
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %221, ptr %223, align 16
  %224 = insertvalue { ptr, i32, i32, i32 } %213, i32 6, 2
  %225 = getelementptr inbounds i8, ptr %222, i32 -12
  store i32 6, ptr %225, align 4
  %226 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %227 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %226, 0
  %228 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %226, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %227)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %21, align 16
  %229 = load { i128, [80 x i8] }, ptr %21, align 16
  %230 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %228, 0
  %231 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1819632491, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %230, 1
  %232 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %231, { i128, [80 x i8] } %229, 2
  %233 = load ptr, ptr %165, align 8
  %234 = getelementptr inbounds i8, ptr %233, i32 960
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %232, ptr %234, align 16
  %235 = insertvalue { ptr, i32, i32, i32 } %224, i32 7, 2
  %236 = getelementptr inbounds i8, ptr %233, i32 -12
  store i32 7, ptr %236, align 4
  %237 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$29"({ ptr, i32, i32, i32 } %235)
  %238 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %237, 0
  %239 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %237, 1
  call void @"drop$29"({ ptr, i32, i32, i32 } %238)
  %240 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %61, 0
  %241 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %239, 0
  %242 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 88292074925748493264888317519795414387, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %240, 1
  %243 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %242, { { ptr, i32, i32, i32 } } %241, 2
  %244 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %243)
  %245 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %244, 0
  %246 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %244, 1
  call void @"drop$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %245)
  %247 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f85"(i64 %50, i64 %51, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %246)
  %248 = extractvalue { i64, i64, { i64, [24 x i8] } } %247, 0
  %249 = extractvalue { i64, i64, { i64, [24 x i8] } } %247, 1
  %250 = extractvalue { i64, i64, { i64, [24 x i8] } } %247, 2
  store { i64, [24 x i8] } %250, ptr %22, align 8
  %251 = load i1, ptr %22, align 1
  switch i1 %251, label %261 [
    i1 false, label %263
    i1 true, label %280
  ]

252:                                              ; preds = %5
  %253 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %254 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %253, 1
  %255 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %254, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %255, ptr %7, align 8
  %256 = load { i64, [24 x i8] }, ptr %7, align 8
  %257 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %50, 0
  %258 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %257, i64 %51, 1
  %259 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %258, ptr %2, 2
  %260 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %259, { i64, [24 x i8] } %256, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %260

261:                                              ; preds = %56
  br i1 false, label %262, label %311

262:                                              ; preds = %261
  unreachable

263:                                              ; preds = %56
  %264 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %22, align 8
  %265 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %264, 1
  %266 = extractvalue { { ptr, i32, i32, i32 }, {} } %58, 0
  %267 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %266)
  %268 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %267, 0
  %269 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %267, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %268)
  %270 = extractvalue { { { ptr, i32, i32, i32 } } } %265, 0
  %271 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %269, 0
  %272 = load ptr, ptr %2, align 8
  store i64 %249, ptr %25, align 8
  store { { ptr, i32, i32, i32 } } %271, ptr %26, align 8
  store { { ptr, i32, i32, i32 } } %270, ptr %27, align 8
  %273 = getelementptr inbounds ptr, ptr %2, i32 10
  %274 = load ptr, ptr %273, align 8
  call void %274(ptr %24, ptr %272, ptr %25, ptr %26, ptr %27)
  %275 = load { i1, [31 x i8] }, ptr %24, align 1
  %276 = extractvalue { i1, [31 x i8] } %275, 0
  %277 = getelementptr inbounds i8, ptr %24, i32 8
  %278 = load { ptr, i32, i32, i32 }, ptr %277, align 8
  %279 = load i64, ptr %25, align 8
  br i1 %276, label %299, label %289

280:                                              ; preds = %56
  %281 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %22, align 8
  %282 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %281, 1
  call void @"drop$159"({ { ptr, i32, i32, i32 }, {} } %58)
  %283 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %282, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %283, ptr %23, align 8
  %284 = load { i64, [24 x i8] }, ptr %23, align 8
  %285 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %248, 0
  %286 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %285, i64 %249, 1
  %287 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %286, ptr %2, 2
  %288 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %287, { i64, [24 x i8] } %284, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %288

289:                                              ; preds = %263
  %290 = phi i64 [ %279, %263 ]
  %291 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %292 = call ptr %291()
  %293 = call i64 @llvm.uadd.sat.i64(i64 %290, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %29, align 1
  %294 = load { i64, [24 x i8] }, ptr %29, align 8
  %295 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %248, 0
  %296 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %295, i64 %293, 1
  %297 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %296, ptr %2, 2
  %298 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %297, { i64, [24 x i8] } %294, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %298

299:                                              ; preds = %263
  %300 = phi {} [ undef, %263 ]
  %301 = phi { ptr, i32, i32, i32 } [ %278, %263 ]
  %302 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %300, 0
  %303 = insertvalue { {}, { ptr, i32, i32, i32 } } %302, { ptr, i32, i32, i32 } %301, 1
  %304 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %303, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %304, ptr %28, align 8
  %305 = load { i64, [24 x i8] }, ptr %28, align 8
  %306 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %248, 0
  %307 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %306, i64 %279, 1
  %308 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %307, ptr %2, 2
  %309 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %308, { i64, [24 x i8] } %305, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %309

310:                                              ; preds = %54
  call void @puts(ptr @assert_msg_125)
  call void @abort()
  unreachable

311:                                              ; preds = %261
  call void @puts(ptr @assert_msg_126)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f63(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f63"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f63(ptr %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f63(i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f64"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [80 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = alloca { i128, [80 x i8] }, i64 1, align 16
  %17 = alloca { i128, [80 x i8] }, i64 1, align 16
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i1, [31 x i8] }, i64 1, align 8
  %22 = alloca i64, i64 1, align 8
  %23 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %24 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %25 = alloca { i64, [24 x i8] }, i64 1, align 8
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } { i252 313215164569295318208292514394769381779806795543033682241894454505053143643, { { ptr, i32, i32, i32 }, i252, i32 } undef, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %4, 1
  %28 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %27, { { ptr, i32, i32, i32 }, i252, i32 } %3, 2
  %29 = call { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %28)
  %30 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %29, 0
  %31 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %29, 1
  call void @"drop$156"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %30)
  %32 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %31, 0
  %33 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %31, 1
  %34 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %31, 2
  %35 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %35, align 4
  %36 = getelementptr inbounds i8, ptr %35, i32 4
  store i32 0, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %35, i32 16
  %38 = call ptr @realloc(ptr null, i64 8)
  store ptr %37, ptr %38, align 8
  %39 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %38, 0
  %40 = insertvalue { ptr, i32, i32, i32 } %39, i32 8, 3
  %41 = load ptr, ptr %38, align 8
  store i252 %32, ptr %41, align 16
  %42 = insertvalue { ptr, i32, i32, i32 } %40, i32 1, 2
  %43 = getelementptr inbounds i8, ptr %41, i32 -12
  store i32 1, ptr %43, align 4
  %44 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %33, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %44, { { ptr, i32, i32, i32 }, i252, i32 } %34, 1
  %46 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %45, { ptr, i32, i32, i32 } %42)
  %47 = extractvalue { i64, i64, { i64, [24 x i8] } } %46, 0
  %48 = extractvalue { i64, i64, { i64, [24 x i8] } } %46, 1
  %49 = extractvalue { i64, i64, { i64, [24 x i8] } } %46, 2
  store { i64, [24 x i8] } %49, ptr %6, align 8
  %50 = load i1, ptr %6, align 1
  switch i1 %50, label %51 [
    i1 false, label %53
    i1 true, label %216
  ]

51:                                               ; preds = %5
  br i1 false, label %52, label %274

52:                                               ; preds = %51
  unreachable

53:                                               ; preds = %5
  %54 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %55 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %54, 1
  %56 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %57 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %56, 0
  %58 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %56, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %57)
  %59 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %60 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 0
  %61 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %60)
  %62 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %63 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 0
  %64 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %63)
  %65 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %66 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %65, 0
  %67 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %65, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %66)
  %68 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %67, 0
  %69 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %68, 1
  store { i3, { { ptr, i32, i32, i32 } } } %69, ptr %8, align 8
  %70 = load { i128, [80 x i8] }, ptr %8, align 16
  %71 = insertvalue { i252, { i128, [80 x i8] } } { i252 1315925605, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %70, 1
  %72 = call ptr @realloc(ptr null, i64 1040)
  store i32 1, ptr %72, align 4
  %73 = getelementptr inbounds i8, ptr %72, i32 4
  store i32 0, ptr %73, align 4
  %74 = getelementptr inbounds i8, ptr %72, i32 16
  %75 = call ptr @realloc(ptr null, i64 8)
  store ptr %74, ptr %75, align 8
  %76 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %75, 0
  %77 = insertvalue { ptr, i32, i32, i32 } %76, i32 8, 3
  %78 = load ptr, ptr %75, align 8
  store { i252, { i128, [80 x i8] } } %71, ptr %78, align 16
  %79 = insertvalue { ptr, i32, i32, i32 } %77, i32 1, 2
  %80 = getelementptr inbounds i8, ptr %78, i32 -12
  store i32 1, ptr %80, align 4
  %81 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %82 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %81, 0
  %83 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %81, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %82)
  %84 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %83, 0
  %85 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %84, 1
  store { i3, { { ptr, i32, i32, i32 } } } %85, ptr %9, align 8
  %86 = load { i128, [80 x i8] }, ptr %9, align 16
  %87 = insertvalue { i252, { i128, [80 x i8] } } { i252 313472685977919867416164, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %86, 1
  %88 = load ptr, ptr %75, align 8
  %89 = getelementptr inbounds i8, ptr %88, i32 128
  store { i252, { i128, [80 x i8] } } %87, ptr %89, align 16
  %90 = insertvalue { ptr, i32, i32, i32 } %79, i32 2, 2
  %91 = getelementptr inbounds i8, ptr %88, i32 -12
  store i32 2, ptr %91, align 4
  %92 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %93 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %92, 0
  %94 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %92, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %93)
  %95 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %94, 0
  %96 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %95, 1
  store { i3, { { ptr, i32, i32, i32 } } } %96, ptr %10, align 8
  %97 = load { i128, [80 x i8] }, ptr %10, align 16
  %98 = insertvalue { i252, { i128, [80 x i8] } } { i252 71959718098290, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %97, 1
  %99 = load ptr, ptr %75, align 8
  %100 = getelementptr inbounds i8, ptr %99, i32 256
  store { i252, { i128, [80 x i8] } } %98, ptr %100, align 16
  %101 = insertvalue { ptr, i32, i32, i32 } %90, i32 3, 2
  %102 = getelementptr inbounds i8, ptr %99, i32 -12
  store i32 3, ptr %102, align 4
  %103 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %104 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 0
  %105 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %104)
  %106 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %105, 0
  %107 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %106, 1
  store { i3, { { ptr, i32, i32, i32 } } } %107, ptr %11, align 8
  %108 = load { i128, [80 x i8] }, ptr %11, align 16
  %109 = insertvalue { i252, { i128, [80 x i8] } } { i252 20940711753708153, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %108, 1
  %110 = load ptr, ptr %75, align 8
  %111 = getelementptr inbounds i8, ptr %110, i32 384
  store { i252, { i128, [80 x i8] } } %109, ptr %111, align 16
  %112 = insertvalue { ptr, i32, i32, i32 } %101, i32 4, 2
  %113 = getelementptr inbounds i8, ptr %110, i32 -12
  store i32 4, ptr %113, align 4
  %114 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %115 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %114, 0
  %116 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %114, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %115)
  %117 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %116, 0
  %118 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %117, 1
  store { i3, { { ptr, i32, i32, i32 } } } %118, ptr %12, align 8
  %119 = load { i128, [80 x i8] }, ptr %12, align 16
  %120 = insertvalue { i252, { i128, [80 x i8] } } { i252 1298232171, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %119, 1
  %121 = load ptr, ptr %75, align 8
  %122 = getelementptr inbounds i8, ptr %121, i32 512
  store { i252, { i128, [80 x i8] } } %120, ptr %122, align 16
  %123 = insertvalue { ptr, i32, i32, i32 } %112, i32 5, 2
  %124 = getelementptr inbounds i8, ptr %121, i32 -12
  store i32 5, ptr %124, align 4
  %125 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %126 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %125, 0
  %127 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %125, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %126)
  %128 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %127, 0
  %129 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %128, 1
  store { i3, { { ptr, i32, i32, i32 } } } %129, ptr %13, align 8
  %130 = load { i128, [80 x i8] }, ptr %13, align 16
  %131 = insertvalue { i252, { i128, [80 x i8] } } { i252 96092938071918, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %130, 1
  %132 = load ptr, ptr %75, align 8
  %133 = getelementptr inbounds i8, ptr %132, i32 640
  store { i252, { i128, [80 x i8] } } %131, ptr %133, align 16
  %134 = insertvalue { ptr, i32, i32, i32 } %123, i32 6, 2
  %135 = getelementptr inbounds i8, ptr %132, i32 -12
  store i32 6, ptr %135, align 4
  %136 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %137 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %136, 0
  %138 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %136, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %137)
  %139 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %138, 0
  %140 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %139, 1
  store { i3, { { ptr, i32, i32, i32 } } } %140, ptr %14, align 8
  %141 = load { i128, [80 x i8] }, ptr %14, align 16
  %142 = insertvalue { i252, { i128, [80 x i8] } } { i252 74171727245165, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %141, 1
  %143 = load ptr, ptr %75, align 8
  %144 = getelementptr inbounds i8, ptr %143, i32 768
  store { i252, { i128, [80 x i8] } } %142, ptr %144, align 16
  %145 = insertvalue { ptr, i32, i32, i32 } %134, i32 7, 2
  %146 = getelementptr inbounds i8, ptr %143, i32 -12
  store i32 7, ptr %146, align 4
  %147 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$6"({ ptr, i32, i32, i32 } %145)
  %148 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 0
  %149 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 1
  call void @"drop$6"({ ptr, i32, i32, i32 } %148)
  %150 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %64, 0
  %151 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %149, 0
  %152 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 88292074925748493266188457033990501477, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %150, 1
  %153 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %152, { { ptr, i32, i32, i32 } } %151, 2
  %154 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } { i3 2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %153, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %154, ptr %15, align 16
  %155 = load { i128, [80 x i8] }, ptr %15, align 16
  %156 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %61, 0
  %157 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1797725632952473580645, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %156, 1
  %158 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %157, { i128, [80 x i8] } %155, 2
  %159 = call ptr @realloc(ptr null, i64 1296)
  store i32 1, ptr %159, align 4
  %160 = getelementptr inbounds i8, ptr %159, i32 4
  store i32 0, ptr %160, align 4
  %161 = getelementptr inbounds i8, ptr %159, i32 16
  %162 = call ptr @realloc(ptr null, i64 8)
  store ptr %161, ptr %162, align 8
  %163 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %162, 0
  %164 = insertvalue { ptr, i32, i32, i32 } %163, i32 8, 3
  %165 = load ptr, ptr %162, align 8
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %158, ptr %165, align 16
  %166 = insertvalue { ptr, i32, i32, i32 } %164, i32 1, 2
  %167 = getelementptr inbounds i8, ptr %165, i32 -12
  store i32 1, ptr %167, align 4
  %168 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %169 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %168, 0
  %170 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %168, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %169)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %16, align 16
  %171 = load { i128, [80 x i8] }, ptr %16, align 16
  %172 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %170, 0
  %173 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 452823639416, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %172, 1
  %174 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %173, { i128, [80 x i8] } %171, 2
  %175 = load ptr, ptr %162, align 8
  %176 = getelementptr inbounds i8, ptr %175, i32 160
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %174, ptr %176, align 16
  %177 = insertvalue { ptr, i32, i32, i32 } %166, i32 2, 2
  %178 = getelementptr inbounds i8, ptr %175, i32 -12
  store i32 2, ptr %178, align 4
  %179 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %180 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %179, 0
  %181 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %179, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %180)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %17, align 16
  %182 = load { i128, [80 x i8] }, ptr %17, align 16
  %183 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %181, 0
  %184 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1936486260, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %183, 1
  %185 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %184, { i128, [80 x i8] } %182, 2
  %186 = load ptr, ptr %162, align 8
  %187 = getelementptr inbounds i8, ptr %186, i32 320
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %185, ptr %187, align 16
  %188 = insertvalue { ptr, i32, i32, i32 } %177, i32 3, 2
  %189 = getelementptr inbounds i8, ptr %186, i32 -12
  store i32 3, ptr %189, align 4
  %190 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } zeroinitializer)
  %191 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %190, 0
  %192 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %190, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %191)
  store { i3, i252 } { i3 0, i252 28821964104807730 }, ptr %18, align 16
  %193 = load { i128, [80 x i8] }, ptr %18, align 16
  %194 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %192, 0
  %195 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 107152796640107, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %194, 1
  %196 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %195, { i128, [80 x i8] } %193, 2
  %197 = load ptr, ptr %162, align 8
  %198 = getelementptr inbounds i8, ptr %197, i32 480
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %196, ptr %198, align 16
  %199 = insertvalue { ptr, i32, i32, i32 } %188, i32 4, 2
  %200 = getelementptr inbounds i8, ptr %197, i32 -12
  store i32 4, ptr %200, align 4
  %201 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$29"({ ptr, i32, i32, i32 } %199)
  %202 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, 0
  %203 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, 1
  call void @"drop$29"({ ptr, i32, i32, i32 } %202)
  %204 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 0
  %205 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %203, 0
  %206 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 309102029792370999717748, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %204, 1
  %207 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %206, { { ptr, i32, i32, i32 } } %205, 2
  %208 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %207)
  %209 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %208, 0
  %210 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %208, 1
  call void @"drop$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %209)
  %211 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f85"(i64 %47, i64 %48, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %210)
  %212 = extractvalue { i64, i64, { i64, [24 x i8] } } %211, 0
  %213 = extractvalue { i64, i64, { i64, [24 x i8] } } %211, 1
  %214 = extractvalue { i64, i64, { i64, [24 x i8] } } %211, 2
  store { i64, [24 x i8] } %214, ptr %19, align 8
  %215 = load i1, ptr %19, align 1
  switch i1 %215, label %225 [
    i1 false, label %227
    i1 true, label %244
  ]

216:                                              ; preds = %5
  %217 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %218 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %217, 1
  %219 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %218, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %219, ptr %7, align 8
  %220 = load { i64, [24 x i8] }, ptr %7, align 8
  %221 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %47, 0
  %222 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %221, i64 %48, 1
  %223 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %222, ptr %2, 2
  %224 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %223, { i64, [24 x i8] } %220, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %224

225:                                              ; preds = %53
  br i1 false, label %226, label %275

226:                                              ; preds = %225
  unreachable

227:                                              ; preds = %53
  %228 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %19, align 8
  %229 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %228, 1
  %230 = extractvalue { { ptr, i32, i32, i32 }, {} } %55, 0
  %231 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %230)
  %232 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %231, 0
  %233 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %231, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %232)
  %234 = extractvalue { { { ptr, i32, i32, i32 } } } %229, 0
  %235 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %233, 0
  %236 = load ptr, ptr %2, align 8
  store i64 %213, ptr %22, align 8
  store { { ptr, i32, i32, i32 } } %235, ptr %23, align 8
  store { { ptr, i32, i32, i32 } } %234, ptr %24, align 8
  %237 = getelementptr inbounds ptr, ptr %2, i32 10
  %238 = load ptr, ptr %237, align 8
  call void %238(ptr %21, ptr %236, ptr %22, ptr %23, ptr %24)
  %239 = load { i1, [31 x i8] }, ptr %21, align 1
  %240 = extractvalue { i1, [31 x i8] } %239, 0
  %241 = getelementptr inbounds i8, ptr %21, i32 8
  %242 = load { ptr, i32, i32, i32 }, ptr %241, align 8
  %243 = load i64, ptr %22, align 8
  br i1 %240, label %263, label %253

244:                                              ; preds = %53
  %245 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %246 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %245, 1
  call void @"drop$159"({ { ptr, i32, i32, i32 }, {} } %55)
  %247 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %246, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %247, ptr %20, align 8
  %248 = load { i64, [24 x i8] }, ptr %20, align 8
  %249 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %212, 0
  %250 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %249, i64 %213, 1
  %251 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %250, ptr %2, 2
  %252 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %251, { i64, [24 x i8] } %248, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %252

253:                                              ; preds = %227
  %254 = phi i64 [ %243, %227 ]
  %255 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %256 = call ptr %255()
  %257 = call i64 @llvm.uadd.sat.i64(i64 %254, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %26, align 1
  %258 = load { i64, [24 x i8] }, ptr %26, align 8
  %259 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %212, 0
  %260 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %259, i64 %257, 1
  %261 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %260, ptr %2, 2
  %262 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %261, { i64, [24 x i8] } %258, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %262

263:                                              ; preds = %227
  %264 = phi {} [ undef, %227 ]
  %265 = phi { ptr, i32, i32, i32 } [ %242, %227 ]
  %266 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %264, 0
  %267 = insertvalue { {}, { ptr, i32, i32, i32 } } %266, { ptr, i32, i32, i32 } %265, 1
  %268 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %267, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %268, ptr %25, align 8
  %269 = load { i64, [24 x i8] }, ptr %25, align 8
  %270 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %212, 0
  %271 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %270, i64 %243, 1
  %272 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %271, ptr %2, 2
  %273 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %272, { i64, [24 x i8] } %269, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %273

274:                                              ; preds = %51
  call void @puts(ptr @assert_msg_127)
  call void @abort()
  unreachable

275:                                              ; preds = %225
  call void @puts(ptr @assert_msg_128)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f64(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f64"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f64(ptr %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f64(i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$129"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$129"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 8)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 8, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, i64, { i128, [80 x i8] } } @"impl$f65"(i64 %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3) {
  %5 = alloca { i32, [8 x i8] }, i64 1, align 4
  %6 = alloca { i32, [8 x i8] }, i64 1, align 4
  %7 = alloca { i128, [32 x i8] }, i64 1, align 16
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i32, [4 x i8] }, i64 1, align 4
  %10 = alloca { i128, [64 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [32 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i32, [8 x i8] }, i64 1, align 4
  %15 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %3, 0
  %16 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %3, 1
  %17 = extractvalue { { { ptr, i32, i32, i32 } } } %15, 0
  %18 = extractvalue { { ptr, i32, i32, i32 } } %17, 0
  %19 = extractvalue { ptr, i32, i32, i32 } %18, 1
  %20 = extractvalue { ptr, i32, i32, i32 } %18, 2
  %21 = sub i32 %20, %19
  %22 = icmp uge i32 %21, 1
  br i1 %22, label %23, label %38

23:                                               ; preds = %4
  %24 = extractvalue { ptr, i32, i32, i32 } %18, 0
  %25 = load ptr, ptr %24, align 8
  %26 = zext i32 %19 to i64
  %27 = mul i64 %26, 8
  %28 = getelementptr inbounds i8, ptr %25, i64 %27
  %29 = add i32 %19, 1
  %30 = insertvalue { ptr, i32, i32, i32 } %18, i32 %29, 1
  %31 = call ptr @realloc(ptr null, i64 8)
  call void @llvm.memcpy.p0.p0.i64(ptr %31, ptr %28, i64 8, i1 false)
  %32 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %33 = call ptr %32()
  %34 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %35 = load { i32, [4 x i8] }, ptr %31, align 4
  call void @free(ptr %31)
  %36 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %35, 1
  store { i1, { i32, [4 x i8] } } %36, ptr %14, align 4
  %37 = load { i32, [8 x i8] }, ptr %14, align 4
  br label %44

38:                                               ; preds = %4
  %39 = phi i64 [ %1, %4 ]
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %39, i64 0)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %5, align 1
  %43 = load { i32, [8 x i8] }, ptr %5, align 4
  br label %44

44:                                               ; preds = %23, %38
  %45 = phi i64 [ %0, %38 ], [ %0, %23 ]
  %46 = phi i64 [ %2, %38 ], [ %2, %23 ]
  %47 = phi { ptr, i32, i32, i32 } [ %18, %38 ], [ %30, %23 ]
  %48 = phi {} [ %16, %38 ], [ %16, %23 ]
  %49 = phi i64 [ %42, %38 ], [ %34, %23 ]
  %50 = phi { i32, [8 x i8] } [ %43, %38 ], [ %37, %23 ]
  %51 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %47, 0
  store { i32, [8 x i8] } %50, ptr %6, align 4
  %52 = load i1, ptr %6, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %72
  ]

53:                                               ; preds = %44
  br i1 false, label %54, label %122

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %44
  %56 = load { i1, { i32, [4 x i8] } }, ptr %6, align 4
  %57 = extractvalue { i1, { i32, [4 x i8] } } %56, 1
  store { i32, [4 x i8] } %57, ptr %9, align 4
  %58 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f48"(ptr %9, { ptr, i32, i32, i32 } zeroinitializer)
  %59 = extractvalue { { ptr, i32, i32, i32 } } %58, 0
  %60 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %61 = call ptr %60()
  %62 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %59)
  %63 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 0
  %64 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %63)
  %65 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %64, 0
  %66 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %45, i64 %49, i64 %46, ptr %61, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %65)
  %67 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %66, 0
  %68 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %66, 1
  %69 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %66, 2
  %70 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %66, 3
  store { i128, [64 x i8] } %70, ptr %10, align 16
  %71 = load i1, ptr %10, align 1
  switch i1 %71, label %90 [
    i1 false, label %92
    i1 true, label %113
  ]

72:                                               ; preds = %44
  %73 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %74 = call ptr %73()
  %75 = load i64, ptr %74, align 8
  %76 = mul i64 %75, 5970
  %77 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %76)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %7, align 1
  %78 = load { i128, [32 x i8] }, ptr %7, align 16
  %79 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %51, 0
  %80 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %79, 0
  %81 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %80, {} %48, 1
  %82 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, {} } %81, 0
  %83 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %82, { i128, [32 x i8] } %78, 1
  %84 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } undef }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %83, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %84, ptr %8, align 16
  %85 = load { i128, [80 x i8] }, ptr %8, align 16
  %86 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } undef, i64 %45, 0
  %87 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %86, i64 %77, 1
  %88 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %87, i64 %46, 2
  %89 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %88, { i128, [80 x i8] } %85, 3
  ret { i64, i64, i64, { i128, [80 x i8] } } %89

90:                                               ; preds = %55
  br i1 false, label %91, label %123

91:                                               ; preds = %90
  unreachable

92:                                               ; preds = %55
  %93 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %10, align 16
  %94 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %93, 1
  %95 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %96 = call ptr %95()
  %97 = call i64 @llvm.uadd.sat.i64(i64 %68, i64 0)
  %98 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %94, 0
  %99 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %94, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %98)
  %100 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %51, 0
  %101 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %100, 0
  %102 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %101, {} %48, 1
  %103 = insertvalue { i1, i252 } { i1 false, i252 undef }, i252 %99, 1
  store { i1, i252 } %103, ptr %12, align 16
  %104 = load { i128, [32 x i8] }, ptr %12, align 16
  %105 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, {} } %102, 0
  %106 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %105, { i128, [32 x i8] } %104, 1
  %107 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } undef }, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } %106, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { i128, [32 x i8] } } } %107, ptr %13, align 16
  %108 = load { i128, [80 x i8] }, ptr %13, align 16
  %109 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } undef, i64 %67, 0
  %110 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %109, i64 %97, 1
  %111 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %110, i64 %69, 2
  %112 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %111, { i128, [80 x i8] } %108, 3
  ret { i64, i64, i64, { i128, [80 x i8] } } %112

113:                                              ; preds = %55
  %114 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %115 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %114, 1
  call void @"drop$228"({ { ptr, i32, i32, i32 } } %51)
  %116 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %115, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %116, ptr %11, align 8
  %117 = load { i128, [80 x i8] }, ptr %11, align 16
  %118 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } undef, i64 %67, 0
  %119 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %118, i64 %68, 1
  %120 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %119, i64 %69, 2
  %121 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %120, { i128, [80 x i8] } %117, 3
  ret { i64, i64, i64, { i128, [80 x i8] } } %121

122:                                              ; preds = %53
  call void @puts(ptr @assert_msg_129)
  call void @abort()
  unreachable

123:                                              ; preds = %90
  call void @puts(ptr @assert_msg_130)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, { i128, [80 x i8] } } @f65(i64 %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3) {
  %5 = call fastcc { i64, i64, i64, { i128, [80 x i8] } } @"impl$f65"(i64 %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3)
  %6 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %5, 2
  %9 = extractvalue { i64, i64, i64, { i128, [80 x i8] } } %5, 3
  %10 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } undef, i64 %6, 0
  %11 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %10, i64 %7, 1
  %12 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %11, i64 %8, 2
  %13 = insertvalue { i64, i64, i64, { i128, [80 x i8] } } %12, { i128, [80 x i8] } %9, 3
  ret { i64, i64, i64, { i128, [80 x i8] } } %13
}

define void @_mlir_ciface_f65(ptr %0, i64 %1, i64 %2, i64 %3, { { { { ptr, i32, i32, i32 } } }, {} } %4) {
  %6 = call { i64, i64, i64, { i128, [80 x i8] } } @f65(i64 %1, i64 %2, i64 %3, { { { { ptr, i32, i32, i32 } } }, {} } %4)
  store { i64, i64, i64, { i128, [80 x i8] } } %6, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f66"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5) {
  %7 = alloca { i128, [32 x i8] }, i64 1, align 16
  %8 = alloca { i128, [32 x i8] }, i64 1, align 16
  %9 = alloca { i32, [16 x i8] }, i64 1, align 4
  %10 = alloca { i64, [48 x i8] }, i64 1, align 8
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [48 x i8] }, i64 1, align 8
  %16 = alloca { i32, [16 x i8] }, i64 1, align 4
  %17 = alloca { i64, [48 x i8] }, i64 1, align 8
  %18 = alloca { i128, [32 x i8] }, i64 1, align 16
  %19 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 0
  %20 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 1
  %21 = extractvalue { { { ptr, i32, i32, i32 } } } %19, 0
  %22 = extractvalue { { ptr, i32, i32, i32 } } %21, 0
  %23 = extractvalue { ptr, i32, i32, i32 } %22, 1
  %24 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %25 = sub i32 %24, %23
  %26 = icmp uge i32 %25, 1
  br i1 %26, label %27, label %42

27:                                               ; preds = %6
  %28 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %29 = load ptr, ptr %28, align 8
  %30 = zext i32 %23 to i64
  %31 = mul i64 %30, 32
  %32 = getelementptr inbounds i8, ptr %29, i64 %31
  %33 = add i32 %23, 1
  %34 = insertvalue { ptr, i32, i32, i32 } %22, i32 %33, 1
  %35 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %35, ptr %32, i64 32, i1 false)
  %36 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %37 = call ptr %36()
  %38 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %39 = load i252, ptr %35, align 16
  call void @free(ptr %35)
  %40 = insertvalue { i1, i252 } { i1 false, i252 undef }, i252 %39, 1
  store { i1, i252 } %40, ptr %18, align 16
  %41 = load { i128, [32 x i8] }, ptr %18, align 16
  br label %48

42:                                               ; preds = %6
  %43 = phi i64 [ %1, %6 ]
  %44 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %45 = call ptr %44()
  %46 = call i64 @llvm.uadd.sat.i64(i64 %43, i64 0)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %7, align 1
  %47 = load { i128, [32 x i8] }, ptr %7, align 16
  br label %48

48:                                               ; preds = %27, %42
  %49 = phi i64 [ %0, %42 ], [ %0, %27 ]
  %50 = phi i64 [ %2, %42 ], [ %2, %27 ]
  %51 = phi i64 [ %3, %42 ], [ %3, %27 ]
  %52 = phi ptr [ %4, %42 ], [ %4, %27 ]
  %53 = phi { { {} } } [ %20, %42 ], [ %20, %27 ]
  %54 = phi i64 [ %46, %42 ], [ %38, %27 ]
  %55 = phi { ptr, i32, i32, i32 } [ %22, %42 ], [ %34, %27 ]
  %56 = phi { i128, [32 x i8] } [ %47, %42 ], [ %41, %27 ]
  %57 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %55, 0
  store { i128, [32 x i8] } %56, ptr %8, align 16
  %58 = load i1, ptr %8, align 1
  switch i1 %58, label %59 [
    i1 false, label %61
    i1 true, label %81
  ]

59:                                               ; preds = %48
  br i1 false, label %60, label %143

60:                                               ; preds = %59
  unreachable

61:                                               ; preds = %48
  %62 = load { i1, i252 }, ptr %8, align 16
  %63 = extractvalue { i1, i252 } %62, 1
  %64 = add i64 %51, 3
  %65 = zext i252 %63 to i256
  store i256 926137786937080942066379705305780976156692330066586492942502267841683559500, ptr %11, align 16
  store i256 %65, ptr %12, align 16
  %66 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %66(ptr %13, ptr %11, ptr %12)
  %67 = load i256, ptr %13, align 16
  %68 = trunc i256 %67 to i252
  %69 = add i64 %49, 3
  %70 = sub i252 %68, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %71 = icmp ult i252 %68, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %72 = select i1 %71, i252 %68, i252 %70
  %73 = insertvalue { i252 } undef, i252 %72, 0
  %74 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %69, i64 %54, i64 %50, ptr %52, { i252 } %73)
  %75 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %74, 0
  %76 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %74, 1
  %77 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %74, 2
  %78 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %74, 3
  %79 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %74, 4
  store { i64, [24 x i8] } %79, ptr %14, align 8
  %80 = load i1, ptr %14, align 1
  switch i1 %80, label %108 [
    i1 false, label %110
    i1 true, label %132
  ]

81:                                               ; preds = %48
  %82 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %83 = call ptr %82()
  %84 = getelementptr inbounds i64, ptr %83, i32 1
  %85 = load i64, ptr %84, align 8
  %86 = getelementptr inbounds i64, ptr %83, i32 2
  %87 = load i64, ptr %86, align 8
  %88 = mul i64 %87, 4
  %89 = add i64 %85, %88
  %90 = load i64, ptr %83, align 8
  %91 = mul i64 %90, 21770
  %92 = add i64 %89, %91
  %93 = call i64 @llvm.uadd.sat.i64(i64 %54, i64 %92)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %94 = load { i32, [16 x i8] }, ptr %9, align 4
  %95 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %57, 0
  %96 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %95, 0
  %97 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %96, { { {} } } %53, 1
  %98 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %97, 0
  %99 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %98, { i32, [16 x i8] } %94, 1
  %100 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } undef }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %99, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %100, ptr %10, align 8
  %101 = load { i64, [48 x i8] }, ptr %10, align 8
  %102 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %49, 0
  %103 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %102, i64 %93, 1
  %104 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %103, i64 %50, 2
  %105 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %104, i64 %51, 3
  %106 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %105, ptr %52, 4
  %107 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %106, { i64, [48 x i8] } %101, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %107

108:                                              ; preds = %61
  br i1 false, label %109, label %144

109:                                              ; preds = %108
  unreachable

110:                                              ; preds = %61
  %111 = load { i1, { { i32, i32, i32, i32 } } }, ptr %14, align 4
  %112 = extractvalue { i1, { { i32, i32, i32, i32 } } } %111, 1
  %113 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %114 = call ptr %113()
  %115 = call i64 @llvm.uadd.sat.i64(i64 %76, i64 0)
  %116 = extractvalue { { i32, i32, i32, i32 } } %112, 0
  %117 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %57, 0
  %118 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %117, 0
  %119 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %118, { { {} } } %53, 1
  %120 = insertvalue { i1, { i32, i32, i32, i32 } } { i1 false, { i32, i32, i32, i32 } undef }, { i32, i32, i32, i32 } %116, 1
  store { i1, { i32, i32, i32, i32 } } %120, ptr %16, align 4
  %121 = load { i32, [16 x i8] }, ptr %16, align 4
  %122 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %119, 0
  %123 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %122, { i32, [16 x i8] } %121, 1
  %124 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } undef }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } %123, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i32, [16 x i8] } } } %124, ptr %17, align 8
  %125 = load { i64, [48 x i8] }, ptr %17, align 8
  %126 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %75, 0
  %127 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %126, i64 %115, 1
  %128 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %127, i64 %77, 2
  %129 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %128, i64 %64, 3
  %130 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %129, ptr %78, 4
  %131 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %130, { i64, [48 x i8] } %125, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %131

132:                                              ; preds = %61
  %133 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %134 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %133, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %57)
  %135 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %134, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %135, ptr %15, align 8
  %136 = load { i64, [48 x i8] }, ptr %15, align 8
  %137 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %75, 0
  %138 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %137, i64 %76, 1
  %139 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %138, i64 %77, 2
  %140 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %139, i64 %64, 3
  %141 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %140, ptr %78, 4
  %142 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %141, { i64, [48 x i8] } %136, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %142

143:                                              ; preds = %59
  call void @puts(ptr @assert_msg_131)
  call void @abort()
  unreachable

144:                                              ; preds = %108
  call void @puts(ptr @assert_msg_132)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @f66(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f66"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %18, { i64, [48 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %19
}

define void @_mlir_ciface_f66(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @f66(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 155785504323917466144735657540098748279)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f67() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f67(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f67()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f68"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 29721761890975875353235833581453094220424382983267374)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f68() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f68"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f68(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f68()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f69"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 476442828812030857794232422692155113556837216824)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f69() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f69"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f69(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f69()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f70"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = alloca { i128, [32 x i8] }, i64 1, align 16
  %9 = alloca { i128, [32 x i8] }, i64 1, align 16
  %10 = alloca { i128, [64 x i8] }, i64 1, align 16
  %11 = alloca { i128, [32 x i8] }, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca i256, i64 1, align 16
  %15 = alloca { i1, [47 x i8] }, i64 1, align 16
  %16 = alloca i64, i64 1, align 8
  %17 = alloca i252, i64 1, align 16
  %18 = alloca { i128, [32 x i8] }, i64 1, align 16
  %19 = alloca { i128, [32 x i8] }, i64 1, align 16
  %20 = extractvalue { { ptr, i32, i32, i32 } } %6, 0
  %21 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %20)
  %22 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %21, 0
  %23 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %21, 1
  %24 = extractvalue { ptr, i32, i32, i32 } %23, 1
  %25 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %26 = sub i32 %25, %24
  call void @"drop$27"({ ptr, i32, i32, i32 } %23)
  %27 = icmp eq i32 %26, 2
  br i1 %27, label %38, label %28

28:                                               ; preds = %7
  %29 = phi { { {} }, { { ptr, i32, i32, i32 } } } [ %5, %7 ]
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %29)
  call void @"drop$26"({ ptr, i32, i32, i32 } %22)
  %30 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %31 = call ptr %30()
  %32 = getelementptr inbounds i64, ptr %31, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = load i64, ptr %31, align 8
  %35 = mul i64 %34, 18800
  %36 = add i64 %33, %35
  %37 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %36)
  br label %232

38:                                               ; preds = %7
  %39 = phi { ptr, i32, i32, i32 } [ %22, %7 ]
  %40 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %39)
  %41 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %40, 0
  %42 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %40, 1
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %248

47:                                               ; preds = %38
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %54)
  %56 = load i252, ptr %55, align 16
  call void @free(ptr %55)
  %57 = icmp ult i252 %56, 4294967296
  %58 = add i64 %0, 2
  %59 = add i64 %0, 3
  %60 = select i1 %57, i64 %58, i64 %59
  %61 = trunc i252 %56 to i32
  br i1 %57, label %62, label %222

62:                                               ; preds = %47
  %63 = phi { ptr, i32, i32, i32 } [ %41, %47 ]
  %64 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %63)
  %65 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %64, 0
  %66 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %64, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %65)
  %67 = add i64 %60, 1
  %68 = extractvalue { ptr, i32, i32, i32 } %66, 1
  %69 = extractvalue { ptr, i32, i32, i32 } %66, 2
  %70 = sub i32 %69, %68
  %71 = icmp ugt i32 %70, 1
  br i1 %71, label %72, label %86

72:                                               ; preds = %62
  %73 = add i32 %68, 1
  %74 = zext i32 %73 to i64
  %75 = mul i64 %74, 32
  %76 = extractvalue { ptr, i32, i32, i32 } %66, 0
  %77 = load ptr, ptr %76, align 8
  %78 = getelementptr inbounds i8, ptr %77, i64 %75
  %79 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %79, ptr %78, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %66)
  %80 = load i252, ptr %79, align 16
  call void @free(ptr %79)
  %81 = icmp ult i252 %80, 4294967296
  %82 = add i64 %60, 3
  %83 = add i64 %60, 4
  %84 = select i1 %81, i64 %82, i64 %83
  %85 = trunc i252 %80 to i32
  br i1 %81, label %95, label %212

86:                                               ; preds = %62
  call void @"drop$27"({ ptr, i32, i32, i32 } %66)
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %5)
  %87 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %88 = call ptr %87()
  %89 = getelementptr inbounds i64, ptr %88, i32 1
  %90 = load i64, ptr %89, align 8
  %91 = load i64, ptr %88, align 8
  %92 = mul i64 %91, 17190
  %93 = add i64 %90, %92
  %94 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %93)
  br label %258

95:                                               ; preds = %72
  %96 = phi { { {} }, { { ptr, i32, i32, i32 } } } [ %5, %72 ]
  %97 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %96, 1
  %98 = extractvalue { { ptr, i32, i32, i32 } } %97, 0
  %99 = add i64 %84, 1
  %100 = extractvalue { ptr, i32, i32, i32 } %98, 1
  %101 = extractvalue { ptr, i32, i32, i32 } %98, 2
  %102 = sub i32 %101, %100
  %103 = icmp ult i32 %61, %102
  br i1 %103, label %104, label %139

104:                                              ; preds = %95
  %105 = add i32 %100, %61
  %106 = zext i32 %105 to i64
  %107 = mul i64 %106, 32
  %108 = extractvalue { ptr, i32, i32, i32 } %98, 0
  %109 = load ptr, ptr %108, align 8
  %110 = getelementptr inbounds i8, ptr %109, i64 %107
  %111 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %111, ptr %110, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %98)
  %112 = load i252, ptr %111, align 16
  call void @free(ptr %111)
  %113 = zext i32 %85 to i252
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %116, align 4
  %117 = getelementptr inbounds i8, ptr %116, i32 4
  store i32 0, ptr %117, align 4
  %118 = getelementptr inbounds i8, ptr %116, i32 16
  %119 = call ptr @realloc(ptr null, i64 8)
  store ptr %118, ptr %119, align 8
  %120 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %119, 0
  %121 = insertvalue { ptr, i32, i32, i32 } %120, i32 8, 3
  %122 = load ptr, ptr %119, align 8
  store i252 %112, ptr %122, align 16
  %123 = insertvalue { ptr, i32, i32, i32 } %121, i32 1, 2
  %124 = getelementptr inbounds i8, ptr %122, i32 -12
  store i32 1, ptr %124, align 4
  %125 = load ptr, ptr %119, align 8
  %126 = getelementptr inbounds i8, ptr %125, i32 32
  store i252 %113, ptr %126, align 16
  %127 = insertvalue { ptr, i32, i32, i32 } %123, i32 2, 2
  %128 = getelementptr inbounds i8, ptr %125, i32 -12
  store i32 2, ptr %128, align 4
  %129 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %127)
  %130 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %129, 0
  %131 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %129, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %130)
  %132 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %131, 0
  %133 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %99, i64 %1, i64 %3, ptr %115, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %132)
  %134 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %133, 0
  %135 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %133, 1
  %136 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %133, 2
  %137 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %133, 3
  store { i128, [64 x i8] } %137, ptr %10, align 16
  %138 = load i1, ptr %10, align 1
  switch i1 %138, label %148 [
    i1 false, label %150
    i1 true, label %174
  ]

139:                                              ; preds = %95
  call void @"drop$27"({ ptr, i32, i32, i32 } %98)
  %140 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %141 = call ptr %140()
  %142 = getelementptr inbounds i64, ptr %141, i32 1
  %143 = load i64, ptr %142, align 8
  %144 = load i64, ptr %141, align 8
  %145 = mul i64 %144, 15880
  %146 = add i64 %143, %145
  %147 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %146)
  br label %258

148:                                              ; preds = %104
  br i1 false, label %149, label %274

149:                                              ; preds = %148
  unreachable

150:                                              ; preds = %104
  %151 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %10, align 16
  %152 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %151, 1
  %153 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %152, 0
  %154 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %152, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %153)
  %155 = add i64 %2, 3
  %156 = zext i252 %154 to i256
  store i256 1334664777155929186801060013143550635909228974761917574271585221149587386350, ptr %12, align 16
  store i256 %156, ptr %13, align 16
  %157 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %157(ptr %14, ptr %12, ptr %13)
  %158 = load i256, ptr %14, align 16
  %159 = trunc i256 %158 to i252
  %160 = add i64 %134, 3
  %161 = sub i252 %159, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %162 = icmp ult i252 %159, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %163 = select i1 %162, i252 %159, i252 %161
  %164 = load ptr, ptr %4, align 8
  store i64 %135, ptr %16, align 8
  store i252 %163, ptr %17, align 16
  %165 = getelementptr inbounds ptr, ptr %4, i32 8
  %166 = load ptr, ptr %165, align 8
  call void %166(ptr %15, ptr %164, ptr %16, i32 0, ptr %17)
  %167 = load { i1, [47 x i8] }, ptr %15, align 1
  %168 = extractvalue { i1, [47 x i8] } %167, 0
  %169 = getelementptr inbounds i8, ptr %15, i32 16
  %170 = load i252, ptr %169, align 16
  %171 = getelementptr inbounds i8, ptr %15, i32 8
  %172 = load { ptr, i32, i32, i32 }, ptr %171, align 8
  %173 = load i64, ptr %16, align 8
  br i1 %168, label %199, label %185

174:                                              ; preds = %104
  %175 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %176 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %175, 1
  %177 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %176, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %177, ptr %11, align 8
  %178 = load { i128, [32 x i8] }, ptr %11, align 16
  %179 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %134, 0
  %180 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %179, i64 %135, 1
  %181 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %180, i64 %2, 2
  %182 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %181, i64 %136, 3
  %183 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %182, ptr %4, 4
  %184 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %183, { i128, [32 x i8] } %178, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %184

185:                                              ; preds = %150
  %186 = phi i64 [ %173, %150 ]
  %187 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %188 = call ptr %187()
  %189 = call i64 @llvm.uadd.sat.i64(i64 %186, i64 0)
  %190 = insertvalue { i252 } undef, i252 %170, 0
  %191 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %190, 1
  store { i1, { i252 } } %191, ptr %19, align 16
  %192 = load { i128, [32 x i8] }, ptr %19, align 16
  %193 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %160, 0
  %194 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %193, i64 %189, 1
  %195 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %194, i64 %155, 2
  %196 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %195, i64 %136, 3
  %197 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %196, ptr %4, 4
  %198 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %197, { i128, [32 x i8] } %192, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %198

199:                                              ; preds = %150
  %200 = phi {} [ undef, %150 ]
  %201 = phi { ptr, i32, i32, i32 } [ %172, %150 ]
  %202 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %200, 0
  %203 = insertvalue { {}, { ptr, i32, i32, i32 } } %202, { ptr, i32, i32, i32 } %201, 1
  %204 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %203, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %204, ptr %18, align 8
  %205 = load { i128, [32 x i8] }, ptr %18, align 16
  %206 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %160, 0
  %207 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %206, i64 %173, 1
  %208 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %207, i64 %155, 2
  %209 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %208, i64 %136, 3
  %210 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %209, ptr %4, 4
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %210, { i128, [32 x i8] } %205, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %211

212:                                              ; preds = %72
  %213 = phi { { {} }, { { ptr, i32, i32, i32 } } } [ %5, %72 ]
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %213)
  %214 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %215 = call ptr %214()
  %216 = getelementptr inbounds i64, ptr %215, i32 1
  %217 = load i64, ptr %216, align 8
  %218 = load i64, ptr %215, align 8
  %219 = mul i64 %218, 15780
  %220 = add i64 %217, %219
  %221 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %220)
  br label %232

222:                                              ; preds = %47
  %223 = phi { { {} }, { { ptr, i32, i32, i32 } } } [ %5, %47 ]
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %223)
  call void @"drop$26"({ ptr, i32, i32, i32 } %41)
  %224 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %225 = call ptr %224()
  %226 = getelementptr inbounds i64, ptr %225, i32 1
  %227 = load i64, ptr %226, align 8
  %228 = load i64, ptr %225, align 8
  %229 = mul i64 %228, 17290
  %230 = add i64 %227, %229
  %231 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %230)
  br label %232

232:                                              ; preds = %212, %222, %28
  %233 = phi i64 [ %2, %222 ], [ %2, %212 ], [ %2, %28 ]
  %234 = phi i64 [ %3, %222 ], [ %3, %212 ], [ %3, %28 ]
  %235 = phi ptr [ %4, %222 ], [ %4, %212 ], [ %4, %28 ]
  %236 = phi i64 [ %60, %222 ], [ %84, %212 ], [ %0, %28 ]
  %237 = phi i64 [ %231, %222 ], [ %221, %212 ], [ %37, %28 ]
  %238 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f86"()
  %239 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %238, 0
  %240 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %239, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %240, ptr %9, align 8
  %241 = load { i128, [32 x i8] }, ptr %9, align 16
  %242 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %236, 0
  %243 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %242, i64 %237, 1
  %244 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %243, i64 %233, 2
  %245 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %244, i64 %234, 3
  %246 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %245, ptr %235, 4
  %247 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %246, { i128, [32 x i8] } %241, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %247

248:                                              ; preds = %38
  %249 = phi { ptr, i32, i32, i32 } [ %42, %38 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %249)
  call void @"drop$326"({ { {} }, { { ptr, i32, i32, i32 } } } %5)
  call void @"drop$26"({ ptr, i32, i32, i32 } %41)
  %250 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %251 = call ptr %250()
  %252 = getelementptr inbounds i64, ptr %251, i32 1
  %253 = load i64, ptr %252, align 8
  %254 = load i64, ptr %251, align 8
  %255 = mul i64 %254, 18500
  %256 = add i64 %253, %255
  %257 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %256)
  br label %258

258:                                              ; preds = %139, %86, %248
  %259 = phi i64 [ %2, %248 ], [ %2, %139 ], [ %2, %86 ]
  %260 = phi i64 [ %3, %248 ], [ %3, %139 ], [ %3, %86 ]
  %261 = phi ptr [ %4, %248 ], [ %4, %139 ], [ %4, %86 ]
  %262 = phi i64 [ %0, %248 ], [ %99, %139 ], [ %67, %86 ]
  %263 = phi i64 [ %257, %248 ], [ %147, %139 ], [ %94, %86 ]
  %264 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f87"()
  %265 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %264, 0
  %266 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %265, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %266, ptr %8, align 8
  %267 = load { i128, [32 x i8] }, ptr %8, align 16
  %268 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %262, 0
  %269 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %268, i64 %263, 1
  %270 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %269, i64 %259, 2
  %271 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %270, i64 %260, 3
  %272 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %271, ptr %261, 4
  %273 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %272, { i128, [32 x i8] } %267, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %273

274:                                              ; preds = %148
  call void @puts(ptr @assert_msg_133)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @f70(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f70"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %19, { i128, [32 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %20
}

define void @_mlir_ciface_f70(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { {} }, { { ptr, i32, i32, i32 } } } %6, { { ptr, i32, i32, i32 } } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @f70(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { {} }, { { ptr, i32, i32, i32 } } } %6, { { ptr, i32, i32, i32 } } %7)
  store { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %9, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f71"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, i32 } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = alloca { i128, [32 x i8] }, i64 1, align 16
  %9 = alloca { i128, [64 x i8] }, i64 1, align 16
  %10 = alloca { i128, [32 x i8] }, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca { i1, [47 x i8] }, i64 1, align 16
  %15 = alloca i64, i64 1, align 8
  %16 = alloca i252, i64 1, align 16
  %17 = alloca { i128, [32 x i8] }, i64 1, align 16
  %18 = alloca { i128, [32 x i8] }, i64 1, align 16
  %19 = extractvalue { { ptr, i32, i32, i32 } } %6, 0
  %20 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %19)
  %21 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %20, 0
  %22 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %20, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %21)
  %23 = extractvalue { ptr, i32, i32, i32 } %22, 1
  %24 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %25 = sub i32 %24, %23
  %26 = icmp uge i32 %25, 1
  br i1 %26, label %27, label %128

27:                                               ; preds = %7
  %28 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %29 = load ptr, ptr %28, align 8
  %30 = zext i32 %23 to i64
  %31 = mul i64 %30, 32
  %32 = getelementptr inbounds i8, ptr %29, i64 %31
  %33 = add i32 %23, 1
  %34 = insertvalue { ptr, i32, i32, i32 } %22, i32 %33, 1
  %35 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %35, ptr %32, i64 32, i1 false)
  call void @"drop$27"({ ptr, i32, i32, i32 } %34)
  %36 = extractvalue { { {} }, i32 } %5, 1
  %37 = load i252, ptr %35, align 16
  call void @free(ptr %35)
  %38 = zext i32 %36 to i252
  %39 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %40 = call ptr %39()
  %41 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %41, align 4
  %42 = getelementptr inbounds i8, ptr %41, i32 4
  store i32 0, ptr %42, align 4
  %43 = getelementptr inbounds i8, ptr %41, i32 16
  %44 = call ptr @realloc(ptr null, i64 8)
  store ptr %43, ptr %44, align 8
  %45 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %44, 0
  %46 = insertvalue { ptr, i32, i32, i32 } %45, i32 8, 3
  %47 = load ptr, ptr %44, align 8
  store i252 %38, ptr %47, align 16
  %48 = insertvalue { ptr, i32, i32, i32 } %46, i32 1, 2
  %49 = getelementptr inbounds i8, ptr %47, i32 -12
  store i32 1, ptr %49, align 4
  %50 = load ptr, ptr %44, align 8
  %51 = getelementptr inbounds i8, ptr %50, i32 32
  store i252 %37, ptr %51, align 16
  %52 = insertvalue { ptr, i32, i32, i32 } %48, i32 2, 2
  %53 = getelementptr inbounds i8, ptr %50, i32 -12
  store i32 2, ptr %53, align 4
  %54 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %52)
  %55 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %54, 0
  %56 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %54, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %55)
  %57 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %56, 0
  %58 = call fastcc { i64, i64, i64, { i128, [64 x i8] } } @"impl$f49"(i64 %0, i64 %1, i64 %3, ptr %40, { i252, i252, i252 } zeroinitializer, { { ptr, i32, i32, i32 } } %57)
  %59 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %58, 0
  %60 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %58, 1
  %61 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %58, 2
  %62 = extractvalue { i64, i64, i64, { i128, [64 x i8] } } %58, 3
  store { i128, [64 x i8] } %62, ptr %9, align 16
  %63 = load i1, ptr %9, align 1
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %90
  ]

64:                                               ; preds = %27
  br i1 false, label %65, label %140

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %27
  %67 = load { i1, { { { ptr, i32, i32, i32 } }, i252 } }, ptr %9, align 16
  %68 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, i252 } } %67, 1
  %69 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 } }, i252 } %68, 1
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %69)
  %71 = add i64 %2, 3
  %72 = zext i252 %70 to i256
  store i256 422073521398876225481035229297186717153911541103484599068011287805644405767, ptr %11, align 16
  store i256 %72, ptr %12, align 16
  %73 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %73(ptr %13, ptr %11, ptr %12)
  %74 = load i256, ptr %13, align 16
  %75 = trunc i256 %74 to i252
  %76 = add i64 %59, 3
  %77 = sub i252 %75, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %78 = icmp ult i252 %75, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %79 = select i1 %78, i252 %75, i252 %77
  %80 = load ptr, ptr %4, align 8
  store i64 %60, ptr %15, align 8
  store i252 %79, ptr %16, align 16
  %81 = getelementptr inbounds ptr, ptr %4, i32 8
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %14, ptr %80, ptr %15, i32 0, ptr %16)
  %83 = load { i1, [47 x i8] }, ptr %14, align 1
  %84 = extractvalue { i1, [47 x i8] } %83, 0
  %85 = getelementptr inbounds i8, ptr %14, i32 16
  %86 = load i252, ptr %85, align 16
  %87 = getelementptr inbounds i8, ptr %14, i32 8
  %88 = load { ptr, i32, i32, i32 }, ptr %87, align 8
  %89 = load i64, ptr %15, align 8
  br i1 %84, label %115, label %101

90:                                               ; preds = %27
  %91 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %92 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %91, 1
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %10, align 8
  %94 = load { i128, [32 x i8] }, ptr %10, align 16
  %95 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %59, 0
  %96 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %95, i64 %60, 1
  %97 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %96, i64 %2, 2
  %98 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %97, i64 %61, 3
  %99 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %98, ptr %4, 4
  %100 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %99, { i128, [32 x i8] } %94, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %100

101:                                              ; preds = %66
  %102 = phi i64 [ %89, %66 ]
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 0)
  %106 = insertvalue { i252 } undef, i252 %86, 0
  %107 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %106, 1
  store { i1, { i252 } } %107, ptr %18, align 16
  %108 = load { i128, [32 x i8] }, ptr %18, align 16
  %109 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %76, 0
  %110 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %109, i64 %105, 1
  %111 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %110, i64 %71, 2
  %112 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %111, i64 %61, 3
  %113 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %112, ptr %4, 4
  %114 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %113, { i128, [32 x i8] } %108, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %114

115:                                              ; preds = %66
  %116 = phi {} [ undef, %66 ]
  %117 = phi { ptr, i32, i32, i32 } [ %88, %66 ]
  %118 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %116, 0
  %119 = insertvalue { {}, { ptr, i32, i32, i32 } } %118, { ptr, i32, i32, i32 } %117, 1
  %120 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %119, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %120, ptr %17, align 8
  %121 = load { i128, [32 x i8] }, ptr %17, align 16
  %122 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %76, 0
  %123 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %122, i64 %89, 1
  %124 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %123, i64 %71, 2
  %125 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %124, i64 %61, 3
  %126 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %125, ptr %4, 4
  %127 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %126, { i128, [32 x i8] } %121, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %127

128:                                              ; preds = %7
  %129 = phi { ptr, i32, i32, i32 } [ %22, %7 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %129)
  %130 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f87"()
  %131 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %130, 0
  %132 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %131, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %132, ptr %8, align 8
  %133 = load { i128, [32 x i8] }, ptr %8, align 16
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %0, 0
  %135 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %134, i64 %1, 1
  %136 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %135, i64 %2, 2
  %137 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %136, i64 %3, 3
  %138 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %137, ptr %4, 4
  %139 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %138, { i128, [32 x i8] } %133, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %139

140:                                              ; preds = %64
  call void @puts(ptr @assert_msg_134)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @f71(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, i32 } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f71"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, i32 } %5, { { ptr, i32, i32, i32 } } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %19, { i128, [32 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %20
}

define void @_mlir_ciface_f71(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { {} }, i32 } %6, { { ptr, i32, i32, i32 } } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } @f71(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { {} }, i32 } %6, { { ptr, i32, i32, i32 } } %7)
  store { i64, i64, i64, i64, ptr, { i128, [32 x i8] } } %9, ptr %0, align 16
  ret void
}

define private void @"drop$111"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$15"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$111"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$15"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$112"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$111"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$112"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$111"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$115"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$112"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$114"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$115"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$112"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$114"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f72"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [128 x i8] }, i64 1, align 16
  %5 = alloca { i128, [192 x i8] }, i64 1, align 16
  %6 = alloca { i128, [80 x i8] }, i64 1, align 16
  %7 = alloca { i128, [144 x i8] }, i64 1, align 16
  %8 = alloca { i128, [192 x i8] }, i64 1, align 16
  %9 = alloca { i128, [144 x i8] }, i64 1, align 16
  %10 = alloca { i128, [192 x i8] }, i64 1, align 16
  %11 = alloca { i128, [144 x i8] }, i64 1, align 16
  %12 = alloca { i128, [192 x i8] }, i64 1, align 16
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i128, [192 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i128, [192 x i8] }, i64 1, align 16
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i128, [144 x i8] }, i64 1, align 16
  %20 = alloca { i128, [192 x i8] }, i64 1, align 16
  %21 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f23"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %22 = extractvalue { i64, i64, { i128, [128 x i8] } } %21, 0
  %23 = extractvalue { i64, i64, { i128, [128 x i8] } } %21, 1
  %24 = extractvalue { i64, i64, { i128, [128 x i8] } } %21, 2
  store { i128, [128 x i8] } %24, ptr %4, align 16
  %25 = load i1, ptr %4, align 1
  switch i1 %25, label %26 [
    i1 false, label %28
    i1 true, label %34
  ]

26:                                               ; preds = %3
  br i1 false, label %27, label %325

27:                                               ; preds = %26
  unreachable

28:                                               ; preds = %3
  %29 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %4, align 16
  %30 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %29, 1
  %31 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %30, 0
  %32 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %30, 1
  store { i128, [80 x i8] } %32, ptr %6, align 16
  %33 = load i1, ptr %6, align 1
  switch i1 %33, label %42 [
    i1 false, label %44
    i1 true, label %52
  ]

34:                                               ; preds = %3
  %35 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %36 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %35, 1
  %37 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %36, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %37, ptr %5, align 8
  %38 = load { i128, [192 x i8] }, ptr %5, align 16
  %39 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %22, 0
  %40 = insertvalue { i64, i64, { i128, [192 x i8] } } %39, i64 %23, 1
  %41 = insertvalue { i64, i64, { i128, [192 x i8] } } %40, { i128, [192 x i8] } %38, 2
  ret { i64, i64, { i128, [192 x i8] } } %41

42:                                               ; preds = %28
  br i1 false, label %43, label %326

43:                                               ; preds = %42
  unreachable

44:                                               ; preds = %28
  %45 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %6, align 16
  %46 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %45, 1
  %47 = extractvalue { { ptr, i32, i32, i32 } } %31, 0
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %58, label %293

52:                                               ; preds = %28
  %53 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %54 = call ptr %53()
  %55 = load i64, ptr %54, align 8
  %56 = mul i64 %55, 10870
  %57 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %56)
  br label %313

58:                                               ; preds = %44
  %59 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %60 = load ptr, ptr %59, align 8
  %61 = zext i32 %48 to i64
  %62 = mul i64 %61, 32
  %63 = getelementptr inbounds i8, ptr %60, i64 %62
  %64 = add i32 %48, 1
  %65 = insertvalue { ptr, i32, i32, i32 } %47, i32 %64, 1
  %66 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %66, ptr %63, i64 32, i1 false)
  %67 = load i252, ptr %66, align 16
  call void @free(ptr %66)
  %68 = icmp ult i252 %67, 4294967296
  %69 = add i64 %22, 2
  %70 = add i64 %22, 3
  %71 = select i1 %68, i64 %69, i64 %70
  %72 = trunc i252 %67 to i32
  br i1 %68, label %73, label %286

73:                                               ; preds = %58
  %74 = phi { ptr, i32, i32, i32 } [ %65, %58 ]
  %75 = extractvalue { ptr, i32, i32, i32 } %74, 1
  %76 = extractvalue { ptr, i32, i32, i32 } %74, 2
  %77 = sub i32 %76, %75
  %78 = icmp uge i32 %77, 1
  br i1 %78, label %79, label %279

79:                                               ; preds = %73
  %80 = extractvalue { ptr, i32, i32, i32 } %74, 0
  %81 = load ptr, ptr %80, align 8
  %82 = zext i32 %75 to i64
  %83 = mul i64 %82, 32
  %84 = getelementptr inbounds i8, ptr %81, i64 %83
  %85 = add i32 %75, 1
  %86 = insertvalue { ptr, i32, i32, i32 } %74, i32 %85, 1
  %87 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %87, ptr %84, i64 32, i1 false)
  %88 = load i252, ptr %87, align 16
  call void @free(ptr %87)
  %89 = icmp ult i252 %88, 256
  %90 = add i64 %71, 2
  %91 = add i64 %71, 3
  %92 = select i1 %89, i64 %90, i64 %91
  %93 = trunc i252 %88 to i8
  br i1 %89, label %94, label %272

94:                                               ; preds = %79
  %95 = phi { ptr, i32, i32, i32 } [ %86, %79 ]
  %96 = extractvalue { ptr, i32, i32, i32 } %95, 1
  %97 = extractvalue { ptr, i32, i32, i32 } %95, 2
  %98 = sub i32 %97, %96
  %99 = icmp uge i32 %98, 1
  br i1 %99, label %100, label %265

100:                                              ; preds = %94
  %101 = extractvalue { ptr, i32, i32, i32 } %95, 0
  %102 = load ptr, ptr %101, align 8
  %103 = zext i32 %96 to i64
  %104 = mul i64 %103, 32
  %105 = getelementptr inbounds i8, ptr %102, i64 %104
  %106 = add i32 %96, 1
  %107 = insertvalue { ptr, i32, i32, i32 } %95, i32 %106, 1
  %108 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %108, ptr %105, i64 32, i1 false)
  %109 = load i252, ptr %108, align 16
  call void @free(ptr %108)
  %110 = icmp ult i252 %109, 256
  %111 = add i64 %92, 2
  %112 = add i64 %92, 3
  %113 = select i1 %110, i64 %111, i64 %112
  %114 = trunc i252 %109 to i8
  br i1 %110, label %115, label %258

115:                                              ; preds = %100
  %116 = phi { ptr, i32, i32, i32 } [ %107, %100 ]
  %117 = extractvalue { ptr, i32, i32, i32 } %116, 1
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %119 = sub i32 %118, %117
  %120 = icmp uge i32 %119, 1
  br i1 %120, label %121, label %238

121:                                              ; preds = %115
  %122 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %123 = load ptr, ptr %122, align 8
  %124 = zext i32 %117 to i64
  %125 = mul i64 %124, 32
  %126 = getelementptr inbounds i8, ptr %123, i64 %125
  %127 = add i32 %117, 1
  %128 = insertvalue { ptr, i32, i32, i32 } %116, i32 %127, 1
  %129 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %129, ptr %126, i64 32, i1 false)
  %130 = load i252, ptr %129, align 16
  call void @free(ptr %129)
  %131 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %128, 0
  %132 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f88"(i64 %113, i64 %23, { { ptr, i32, i32, i32 } } %131, { ptr, i32, i32, i32 } zeroinitializer, i252 %130)
  %133 = extractvalue { i64, i64, { i64, [56 x i8] } } %132, 0
  %134 = extractvalue { i64, i64, { i64, [56 x i8] } } %132, 1
  %135 = extractvalue { i64, i64, { i64, [56 x i8] } } %132, 2
  store { i64, [56 x i8] } %135, ptr %13, align 8
  %136 = load i1, ptr %13, align 1
  switch i1 %136, label %137 [
    i1 false, label %139
    i1 true, label %146
  ]

137:                                              ; preds = %121
  br i1 false, label %138, label %327

138:                                              ; preds = %137
  unreachable

139:                                              ; preds = %121
  %140 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %13, align 8
  %141 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %140, 1
  %142 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %141, 0
  %143 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %141, 1
  %144 = extractvalue { { ptr, i32, i32, i32 } } %142, 0
  store { i64, [24 x i8] } %143, ptr %15, align 8
  %145 = load i1, ptr %15, align 1
  switch i1 %145, label %154 [
    i1 false, label %156
    i1 true, label %163
  ]

146:                                              ; preds = %121
  %147 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %148 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %147, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  %149 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %148, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %149, ptr %14, align 8
  %150 = load { i128, [192 x i8] }, ptr %14, align 16
  %151 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %133, 0
  %152 = insertvalue { i64, i64, { i128, [192 x i8] } } %151, i64 %134, 1
  %153 = insertvalue { i64, i64, { i128, [192 x i8] } } %152, { i128, [192 x i8] } %150, 2
  ret { i64, i64, { i128, [192 x i8] } } %153

154:                                              ; preds = %139
  br i1 false, label %155, label %328

155:                                              ; preds = %154
  unreachable

156:                                              ; preds = %139
  %157 = load { i1, { ptr, i32, i32, i32 } }, ptr %15, align 8
  %158 = extractvalue { i1, { ptr, i32, i32, i32 } } %157, 1
  %159 = extractvalue { ptr, i32, i32, i32 } %144, 1
  %160 = extractvalue { ptr, i32, i32, i32 } %144, 2
  %161 = sub i32 %160, %159
  %162 = icmp uge i32 %161, 1
  br i1 %162, label %169, label %230

163:                                              ; preds = %139
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  %164 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %165 = call ptr %164()
  %166 = load i64, ptr %165, align 8
  %167 = mul i64 %166, 3750
  %168 = call i64 @llvm.uadd.sat.i64(i64 %134, i64 %167)
  br label %245

169:                                              ; preds = %156
  %170 = extractvalue { ptr, i32, i32, i32 } %144, 0
  %171 = load ptr, ptr %170, align 8
  %172 = zext i32 %159 to i64
  %173 = mul i64 %172, 32
  %174 = getelementptr inbounds i8, ptr %171, i64 %173
  %175 = add i32 %159, 1
  %176 = insertvalue { ptr, i32, i32, i32 } %144, i32 %175, 1
  %177 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %177, ptr %174, i64 32, i1 false)
  %178 = load i252, ptr %177, align 16
  call void @free(ptr %177)
  %179 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %176, 0
  %180 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f88"(i64 %133, i64 %134, { { ptr, i32, i32, i32 } } %179, { ptr, i32, i32, i32 } zeroinitializer, i252 %178)
  %181 = extractvalue { i64, i64, { i64, [56 x i8] } } %180, 0
  %182 = extractvalue { i64, i64, { i64, [56 x i8] } } %180, 1
  %183 = extractvalue { i64, i64, { i64, [56 x i8] } } %180, 2
  store { i64, [56 x i8] } %183, ptr %16, align 8
  %184 = load i1, ptr %16, align 1
  switch i1 %184, label %185 [
    i1 false, label %187
    i1 true, label %193
  ]

185:                                              ; preds = %169
  br i1 false, label %186, label %329

186:                                              ; preds = %185
  unreachable

187:                                              ; preds = %169
  %188 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %16, align 8
  %189 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %188, 1
  %190 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %189, 0
  %191 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %189, 1
  store { i64, [24 x i8] } %191, ptr %18, align 8
  %192 = load i1, ptr %18, align 1
  switch i1 %192, label %201 [
    i1 false, label %203
    i1 true, label %226
  ]

193:                                              ; preds = %169
  %194 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %195 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %194, 1
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  call void @"drop$15"({ ptr, i32, i32, i32 } %158)
  %196 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %195, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %196, ptr %17, align 8
  %197 = load { i128, [192 x i8] }, ptr %17, align 16
  %198 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %181, 0
  %199 = insertvalue { i64, i64, { i128, [192 x i8] } } %198, i64 %182, 1
  %200 = insertvalue { i64, i64, { i128, [192 x i8] } } %199, { i128, [192 x i8] } %197, 2
  ret { i64, i64, { i128, [192 x i8] } } %200

201:                                              ; preds = %187
  br i1 false, label %202, label %330

202:                                              ; preds = %201
  unreachable

203:                                              ; preds = %187
  %204 = load { i1, { ptr, i32, i32, i32 } }, ptr %18, align 8
  %205 = extractvalue { i1, { ptr, i32, i32, i32 } } %204, 1
  %206 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %207 = call ptr %206()
  %208 = load i64, ptr %207, align 8
  %209 = mul i64 %208, 500
  %210 = call i64 @llvm.uadd.sat.i64(i64 %182, i64 %209)
  %211 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %46, 0
  %212 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %211, i32 %72, 1
  %213 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %212, i8 %93, 2
  %214 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %213, i8 %114, 3
  %215 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %214, { ptr, i32, i32, i32 } %158, 4
  %216 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, { ptr, i32, i32, i32 } %205, 5
  %217 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %216, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %217, ptr %19, align 16
  %218 = load { i128, [144 x i8] }, ptr %19, align 16
  %219 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %190, 0
  %220 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %219, { i128, [144 x i8] } %218, 1
  %221 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %220, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %221, ptr %20, align 16
  %222 = load { i128, [192 x i8] }, ptr %20, align 16
  %223 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %181, 0
  %224 = insertvalue { i64, i64, { i128, [192 x i8] } } %223, i64 %210, 1
  %225 = insertvalue { i64, i64, { i128, [192 x i8] } } %224, { i128, [192 x i8] } %222, 2
  ret { i64, i64, { i128, [192 x i8] } } %225

226:                                              ; preds = %187
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  call void @"drop$15"({ ptr, i32, i32, i32 } %158)
  %227 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %228 = call ptr %227()
  %229 = call i64 @llvm.uadd.sat.i64(i64 %182, i64 0)
  br label %313

230:                                              ; preds = %156
  %231 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %156 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %231)
  call void @"drop$15"({ ptr, i32, i32, i32 } %158)
  %232 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %233 = call ptr %232()
  %234 = load i64, ptr %233, align 8
  %235 = mul i64 %234, 3270
  %236 = call i64 @llvm.uadd.sat.i64(i64 %134, i64 %235)
  %237 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %144, 0
  br label %313

238:                                              ; preds = %115
  %239 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %115 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %239)
  %240 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %241 = call ptr %240()
  %242 = load i64, ptr %241, align 8
  %243 = mul i64 %242, 7120
  %244 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %243)
  br label %245

245:                                              ; preds = %163, %238
  %246 = phi i64 [ %113, %238 ], [ %133, %163 ]
  %247 = phi i64 [ %244, %238 ], [ %168, %163 ]
  %248 = phi { ptr, i32, i32, i32 } [ %116, %238 ], [ %144, %163 ]
  %249 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %248, 0
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %11, align 1
  %250 = load { i128, [144 x i8] }, ptr %11, align 16
  %251 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %249, 0
  %252 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %251, { i128, [144 x i8] } %250, 1
  %253 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %252, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %253, ptr %12, align 16
  %254 = load { i128, [192 x i8] }, ptr %12, align 16
  %255 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %246, 0
  %256 = insertvalue { i64, i64, { i128, [192 x i8] } } %255, i64 %247, 1
  %257 = insertvalue { i64, i64, { i128, [192 x i8] } } %256, { i128, [192 x i8] } %254, 2
  ret { i64, i64, { i128, [192 x i8] } } %257

258:                                              ; preds = %100
  %259 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %100 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %259)
  %260 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %261 = call ptr %260()
  %262 = load i64, ptr %261, align 8
  %263 = mul i64 %262, 6850
  %264 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %263)
  br label %300

265:                                              ; preds = %94
  %266 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %94 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %266)
  %267 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %268 = call ptr %267()
  %269 = load i64, ptr %268, align 8
  %270 = mul i64 %269, 8050
  %271 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %270)
  br label %300

272:                                              ; preds = %79
  %273 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %79 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %273)
  %274 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %275 = call ptr %274()
  %276 = load i64, ptr %275, align 8
  %277 = mul i64 %276, 7880
  %278 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %277)
  br label %300

279:                                              ; preds = %73
  %280 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %73 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %280)
  %281 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %282 = call ptr %281()
  %283 = load i64, ptr %282, align 8
  %284 = mul i64 %283, 9080
  %285 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %284)
  br label %300

286:                                              ; preds = %58
  %287 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %58 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %287)
  %288 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %289 = call ptr %288()
  %290 = load i64, ptr %289, align 8
  %291 = mul i64 %290, 8910
  %292 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %291)
  br label %300

293:                                              ; preds = %44
  %294 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %44 ]
  call void @"drop$41"({ { ptr, i32, i32, i32 }, i252, i32 } %294)
  %295 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %296 = call ptr %295()
  %297 = load i64, ptr %296, align 8
  %298 = mul i64 %297, 10210
  %299 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %298)
  br label %300

300:                                              ; preds = %258, %265, %272, %279, %286, %293
  %301 = phi i64 [ %22, %293 ], [ %71, %286 ], [ %71, %279 ], [ %92, %272 ], [ %92, %265 ], [ %113, %258 ]
  %302 = phi i64 [ %299, %293 ], [ %292, %286 ], [ %285, %279 ], [ %278, %272 ], [ %271, %265 ], [ %264, %258 ]
  %303 = phi { ptr, i32, i32, i32 } [ %47, %293 ], [ %65, %286 ], [ %74, %279 ], [ %86, %272 ], [ %95, %265 ], [ %107, %258 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %304 = load { i128, [144 x i8] }, ptr %9, align 16
  %305 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %303, 0
  %306 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %305, 0
  %307 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %306, { i128, [144 x i8] } %304, 1
  %308 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %307, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %308, ptr %10, align 16
  %309 = load { i128, [192 x i8] }, ptr %10, align 16
  %310 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %301, 0
  %311 = insertvalue { i64, i64, { i128, [192 x i8] } } %310, i64 %302, 1
  %312 = insertvalue { i64, i64, { i128, [192 x i8] } } %311, { i128, [192 x i8] } %309, 2
  ret { i64, i64, { i128, [192 x i8] } } %312

313:                                              ; preds = %226, %230, %52
  %314 = phi i64 [ %133, %230 ], [ %181, %226 ], [ %22, %52 ]
  %315 = phi i64 [ %236, %230 ], [ %229, %226 ], [ %57, %52 ]
  %316 = phi { { ptr, i32, i32, i32 } } [ %237, %230 ], [ %190, %226 ], [ %31, %52 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %7, align 1
  %317 = load { i128, [144 x i8] }, ptr %7, align 16
  %318 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %316, 0
  %319 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %318, { i128, [144 x i8] } %317, 1
  %320 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %319, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %320, ptr %8, align 16
  %321 = load { i128, [192 x i8] }, ptr %8, align 16
  %322 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %314, 0
  %323 = insertvalue { i64, i64, { i128, [192 x i8] } } %322, i64 %315, 1
  %324 = insertvalue { i64, i64, { i128, [192 x i8] } } %323, { i128, [192 x i8] } %321, 2
  ret { i64, i64, { i128, [192 x i8] } } %324

325:                                              ; preds = %26
  call void @puts(ptr @assert_msg_135)
  call void @abort()
  unreachable

326:                                              ; preds = %42
  call void @puts(ptr @assert_msg_136)
  call void @abort()
  unreachable

327:                                              ; preds = %137
  call void @puts(ptr @assert_msg_137)
  call void @abort()
  unreachable

328:                                              ; preds = %154
  call void @puts(ptr @assert_msg_138)
  call void @abort()
  unreachable

329:                                              ; preds = %185
  call void @puts(ptr @assert_msg_139)
  call void @abort()
  unreachable

330:                                              ; preds = %201
  call void @puts(ptr @assert_msg_140)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [192 x i8] } } @f72(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f72"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [192 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [192 x i8] } } %9, { i128, [192 x i8] } %7, 2
  ret { i64, i64, { i128, [192 x i8] } } %10
}

define void @_mlir_ciface_f72(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [192 x i8] } } @f72(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [192 x i8] } } %5, ptr %0, align 16
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f73"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 39878429859757942499084499860145094553463)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f73() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f73"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f73(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f73()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f74"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 39878429859761676908720221312622923640695)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f74() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f74"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f74(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f74()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$104"({ i128, [144 x i8] } %0) {
  call void @"drop$103"({ i128, [144 x i8] } %0)
  ret void
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$104"({ i128, [144 x i8] } %0) {
  %2 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$103"({ i128, [144 x i8] } %0)
  %3 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %2, 0
  %4 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %2, 1
  %5 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %3, 0
  %6 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %5, { i128, [144 x i8] } %4, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %6
}

define private void @"drop$105"(ptr %0) {
  %2 = load { i128, [144 x i8] }, ptr %0, align 16
  call void @"drop$104"({ i128, [144 x i8] } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$105"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 160)
  %3 = load { i128, [144 x i8] }, ptr %0, align 16
  %4 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$104"({ i128, [144 x i8] } %3)
  %5 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %4, 0
  %6 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %4, 1
  store { i128, [144 x i8] } %5, ptr %0, align 16
  store { i128, [144 x i8] } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f75"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i128, [144 x i8] }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %55, %4
  %16 = phi i64 [ %49, %55 ], [ %0, %4 ]
  %17 = phi i64 [ %60, %55 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %61, %55 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %62, %55 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 15180
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %114

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %94

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 160
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 160)
  %43 = load { i128, [144 x i8] }, ptr %39, align 16
  %44 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$103"({ i128, [144 x i8] } %43)
  %45 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %44, 0
  %46 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %44, 1
  store { i128, [144 x i8] } %45, ptr %39, align 16
  store { i128, [144 x i8] } %46, ptr %42, align 16
  %47 = load { i128, [144 x i8] }, ptr %42, align 16
  call void @free(ptr %42)
  store { i128, [144 x i8] } %47, ptr %12, align 16
  %48 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f89"(i64 %20, i64 %26, ptr %12, { ptr, i32, i32, i32 } %19)
  %49 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 1
  %51 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 2
  store { i64, [24 x i8] } %51, ptr %13, align 8
  %52 = load i1, ptr %13, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %67
  ]

53:                                               ; preds = %34
  br i1 false, label %54, label %129

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %34
  %56 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %57 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %56, 1
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 0)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %62 = extractvalue { { ptr, i32, i32, i32 }, {} } %57, 0
  %63 = extractvalue { ptr, ptr, i64 } %8, 1
  %64 = load i64, ptr %63, align 8
  %65 = add i64 %64, 1
  %66 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %65, ptr %66, align 8
  br label %15

67:                                               ; preds = %34
  %68 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %69 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %68, 1
  call void @"drop$107"({ ptr, i32, i32, i32 } %41)
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %14, align 8
  %71 = load { i64, [24 x i8] }, ptr %14, align 8
  %72 = extractvalue { ptr, ptr, i64 } %8, 1
  %73 = load i64, ptr %72, align 8
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %73, 1
  %76 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %75, ptr %76, align 8
  br i1 %74, label %90, label %77

77:                                               ; preds = %77, %67, %94, %114
  %78 = phi i64 [ %20, %114 ], [ %20, %94 ], [ %78, %77 ], [ %49, %67 ]
  %79 = phi i64 [ %17, %114 ], [ %100, %94 ], [ %79, %77 ], [ %50, %67 ]
  %80 = phi { i64, [24 x i8] } [ %119, %114 ], [ %104, %94 ], [ %80, %77 ], [ %71, %67 ]
  %81 = extractvalue { ptr, ptr, i64 } %8, 1
  %82 = load i64, ptr %81, align 8
  %83 = icmp eq i64 %82, 0
  %84 = sub i64 %82, 1
  %85 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %84, ptr %85, align 8
  br i1 %83, label %86, label %77

86:                                               ; preds = %77
  %87 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %78, 0
  %88 = insertvalue { i64, i64, { i64, [24 x i8] } } %87, i64 %79, 1
  %89 = insertvalue { i64, i64, { i64, [24 x i8] } } %88, { i64, [24 x i8] } %80, 2
  ret { i64, i64, { i64, [24 x i8] } } %89

90:                                               ; preds = %67
  %91 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %49, 0
  %92 = insertvalue { i64, i64, { i64, [24 x i8] } } %91, i64 %50, 1
  %93 = insertvalue { i64, i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %71, 2
  ret { i64, i64, { i64, [24 x i8] } } %93

94:                                               ; preds = %27
  %95 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$107"({ ptr, i32, i32, i32 } %95)
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = load i64, ptr %97, align 8
  %99 = mul i64 %98, 15880
  %100 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %99)
  %101 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %19, 0
  %102 = insertvalue { { ptr, i32, i32, i32 }, {} } %101, {} undef, 1
  %103 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %102, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %103, ptr %11, align 8
  %104 = load { i64, [24 x i8] }, ptr %11, align 8
  %105 = extractvalue { ptr, ptr, i64 } %8, 1
  %106 = load i64, ptr %105, align 8
  %107 = icmp eq i64 %106, 0
  %108 = sub i64 %106, 1
  %109 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %108, ptr %109, align 8
  br i1 %107, label %110, label %77

110:                                              ; preds = %94
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, i64 %100, 1
  %113 = insertvalue { i64, i64, { i64, [24 x i8] } } %112, { i64, [24 x i8] } %104, 2
  ret { i64, i64, { i64, [24 x i8] } } %113

114:                                              ; preds = %15
  %115 = phi { ptr, i32, i32, i32 } [ %19, %15 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %115)
  call void @"drop$201"({ { ptr, i32, i32, i32 } } %18)
  %116 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %117 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %116, 0
  %118 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %117, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %118, ptr %10, align 8
  %119 = load { i64, [24 x i8] }, ptr %10, align 8
  %120 = extractvalue { ptr, ptr, i64 } %8, 1
  %121 = load i64, ptr %120, align 8
  %122 = icmp eq i64 %121, 0
  %123 = sub i64 %121, 1
  %124 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %123, ptr %124, align 8
  br i1 %122, label %125, label %77

125:                                              ; preds = %114
  %126 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %127 = insertvalue { i64, i64, { i64, [24 x i8] } } %126, i64 %17, 1
  %128 = insertvalue { i64, i64, { i64, [24 x i8] } } %127, { i64, [24 x i8] } %119, 2
  ret { i64, i64, { i64, [24 x i8] } } %128

129:                                              ; preds = %53
  call void @puts(ptr @assert_msg_141)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f75(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f75"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f75(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f75(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f76"(i64 %0, i64 %1, ptr %2, i252 %3, { { i3, [0 x i8] }, i32, i32, i252 } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i1, [31 x i8] }, i64 1, align 8
  %9 = alloca i64, i64 1, align 8
  %10 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %11 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = call fastcc { { { ptr, i32, i32, i32 } } } @"impl$f90"({ { i3, [0 x i8] }, i32, i32, i252 } %4)
  %15 = extractvalue { { { ptr, i32, i32, i32 } } } %14, 0
  %16 = insertvalue { i252, i252, i252 } { i252 1062799989286861497646673457769309433976004466846907043354399004328696077865, i252 457678164607650546261428908328985027973961829733116661231331606034355123914, i252 undef }, i252 %3, 2
  %17 = call ptr @realloc(ptr null, i64 96)
  store { i252, i252, i252 } %16, ptr %17, align 16
  %18 = call ptr @realloc(ptr null, i64 112)
  store { i32, i32 } { i32 1, i32 3 }, ptr %18, align 4
  %19 = getelementptr inbounds i8, ptr %18, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %19, ptr %17, i64 96, i1 false)
  call void @free(ptr %17)
  %20 = call ptr @realloc(ptr null, i64 8)
  store ptr %19, ptr %20, align 8
  %21 = insertvalue { ptr, i32, i32, i32 } undef, ptr %20, 0
  %22 = insertvalue { ptr, i32, i32, i32 } %21, i32 0, 1
  %23 = insertvalue { ptr, i32, i32, i32 } %22, i32 3, 2
  %24 = insertvalue { ptr, i32, i32, i32 } %23, i32 3, 3
  %25 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %15)
  %26 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %25, 0
  %27 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %25, 1
  %28 = extractvalue { { ptr, i32, i32, i32 } } %27, 0
  %29 = extractvalue { ptr, i32, i32, i32 } %28, 1
  %30 = extractvalue { ptr, i32, i32, i32 } %28, 2
  %31 = sub i32 %30, %29
  call void @"drop$27"({ ptr, i32, i32, i32 } %28)
  %32 = zext i32 %31 to i252
  %33 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %33, align 4
  %34 = getelementptr inbounds i8, ptr %33, i32 4
  store i32 0, ptr %34, align 4
  %35 = getelementptr inbounds i8, ptr %33, i32 16
  %36 = call ptr @realloc(ptr null, i64 8)
  store ptr %35, ptr %36, align 8
  %37 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %36, 0
  %38 = insertvalue { ptr, i32, i32, i32 } %37, i32 8, 3
  %39 = load ptr, ptr %36, align 8
  store i252 %32, ptr %39, align 16
  %40 = insertvalue { ptr, i32, i32, i32 } %38, i32 1, 2
  %41 = getelementptr inbounds i8, ptr %39, i32 -12
  store i32 1, ptr %41, align 4
  %42 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %26, { ptr, i32, i32, i32 } %40)
  %43 = extractvalue { i64, i64, { i64, [24 x i8] } } %42, 0
  %44 = extractvalue { i64, i64, { i64, [24 x i8] } } %42, 1
  %45 = extractvalue { i64, i64, { i64, [24 x i8] } } %42, 2
  store { i64, [24 x i8] } %45, ptr %6, align 8
  %46 = load i1, ptr %6, align 1
  switch i1 %46, label %47 [
    i1 false, label %49
    i1 true, label %66
  ]

47:                                               ; preds = %5
  br i1 false, label %48, label %96

48:                                               ; preds = %47
  unreachable

49:                                               ; preds = %5
  %50 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %51 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %50, 1
  %52 = extractvalue { { ptr, i32, i32, i32 }, {} } %51, 0
  %53 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %52)
  %54 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %53, 0
  %55 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %53, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %54)
  %56 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %24, 0
  %57 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %55, 0
  %58 = load ptr, ptr %2, align 8
  store i64 %44, ptr %9, align 8
  store { { ptr, i32, i32, i32 } } %56, ptr %10, align 8
  store { { ptr, i32, i32, i32 } } %57, ptr %11, align 8
  %59 = getelementptr inbounds ptr, ptr %2, i32 10
  %60 = load ptr, ptr %59, align 8
  call void %60(ptr %8, ptr %58, ptr %9, ptr %10, ptr %11)
  %61 = load { i1, [31 x i8] }, ptr %8, align 1
  %62 = extractvalue { i1, [31 x i8] } %61, 0
  %63 = getelementptr inbounds i8, ptr %8, i32 8
  %64 = load { ptr, i32, i32, i32 }, ptr %63, align 8
  %65 = load i64, ptr %9, align 8
  br i1 %62, label %85, label %75

66:                                               ; preds = %5
  %67 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %68 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %67, 1
  call void @"drop$27"({ ptr, i32, i32, i32 } %24)
  %69 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %68, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %69, ptr %7, align 8
  %70 = load { i64, [24 x i8] }, ptr %7, align 8
  %71 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %43, 0
  %72 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %71, i64 %44, 1
  %73 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %72, ptr %2, 2
  %74 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %73, { i64, [24 x i8] } %70, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %74

75:                                               ; preds = %49
  %76 = phi i64 [ %65, %49 ]
  %77 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %78 = call ptr %77()
  %79 = call i64 @llvm.uadd.sat.i64(i64 %76, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %13, align 1
  %80 = load { i64, [24 x i8] }, ptr %13, align 8
  %81 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %43, 0
  %82 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %81, i64 %79, 1
  %83 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %82, ptr %2, 2
  %84 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %83, { i64, [24 x i8] } %80, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %84

85:                                               ; preds = %49
  %86 = phi {} [ undef, %49 ]
  %87 = phi { ptr, i32, i32, i32 } [ %64, %49 ]
  %88 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %86, 0
  %89 = insertvalue { {}, { ptr, i32, i32, i32 } } %88, { ptr, i32, i32, i32 } %87, 1
  %90 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %89, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %90, ptr %12, align 8
  %91 = load { i64, [24 x i8] }, ptr %12, align 8
  %92 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %43, 0
  %93 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %92, i64 %65, 1
  %94 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %93, ptr %2, 2
  %95 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %94, { i64, [24 x i8] } %91, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %95

96:                                               ; preds = %47
  call void @puts(ptr @assert_msg_142)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f76(i64 %0, i64 %1, ptr %2, i252 %3, { { i3, [0 x i8] }, i32, i32, i252 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f76"(i64 %0, i64 %1, ptr %2, i252 %3, { { i3, [0 x i8] }, i32, i32, i252 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f76(ptr %0, i64 %1, i64 %2, ptr %3, i252 %4, { { i3, [0 x i8] }, i32, i32, i252 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f76(i64 %1, i64 %2, ptr %3, i252 %4, { { i3, [0 x i8] }, i32, i32, i252 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$101"({ { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 0
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } @"dup$101"({ { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %6, { i32, i32, i32, i32 } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %7, { i32, i32, i32, i32 } %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %11, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %10, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } } %12
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f77"(i64 %0, i64 %1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, 0
  %8 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, 1
  %9 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, 2
  %10 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, 3
  %11 = extractvalue { i3, [0 x i8] } %7, 0
  switch i3 %11, label %12 [
    i3 0, label %14
    i3 1, label %30
    i3 2, label %44
    i3 3, label %58
    i3 -4, label %72
    i3 -3, label %86
    i3 -2, label %100
  ]

12:                                               ; preds = %3
  br i1 false, label %13, label %208

13:                                               ; preds = %12
  unreachable

14:                                               ; preds = %3
  %15 = phi i64 [ %1, %3 ]
  %16 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %17 = call ptr %16()
  %18 = load i64, ptr %17, align 8
  %19 = mul i64 %18, 100
  %20 = call i64 @llvm.uadd.sat.i64(i64 %15, i64 %19)
  %21 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %21, align 4
  %22 = getelementptr inbounds i8, ptr %21, i32 4
  store i32 0, ptr %22, align 4
  %23 = getelementptr inbounds i8, ptr %21, i32 16
  %24 = call ptr @realloc(ptr null, i64 8)
  store ptr %23, ptr %24, align 8
  %25 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %24, 0
  %26 = insertvalue { ptr, i32, i32, i32 } %25, i32 8, 3
  %27 = load ptr, ptr %24, align 8
  store i252 0, ptr %27, align 16
  %28 = insertvalue { ptr, i32, i32, i32 } %26, i32 1, 2
  %29 = getelementptr inbounds i8, ptr %27, i32 -12
  store i32 1, ptr %29, align 4
  br label %116

30:                                               ; preds = %3
  %31 = phi i64 [ %1, %3 ]
  %32 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %33 = call ptr %32()
  %34 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 0)
  %35 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %35, align 4
  %36 = getelementptr inbounds i8, ptr %35, i32 4
  store i32 0, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %35, i32 16
  %38 = call ptr @realloc(ptr null, i64 8)
  store ptr %37, ptr %38, align 8
  %39 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %38, 0
  %40 = insertvalue { ptr, i32, i32, i32 } %39, i32 8, 3
  %41 = load ptr, ptr %38, align 8
  store i252 1, ptr %41, align 16
  %42 = insertvalue { ptr, i32, i32, i32 } %40, i32 1, 2
  %43 = getelementptr inbounds i8, ptr %41, i32 -12
  store i32 1, ptr %43, align 4
  br label %116

44:                                               ; preds = %3
  %45 = phi i64 [ %1, %3 ]
  %46 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %47 = call ptr %46()
  %48 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 0)
  %49 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %49, align 4
  %50 = getelementptr inbounds i8, ptr %49, i32 4
  store i32 0, ptr %50, align 4
  %51 = getelementptr inbounds i8, ptr %49, i32 16
  %52 = call ptr @realloc(ptr null, i64 8)
  store ptr %51, ptr %52, align 8
  %53 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %52, 0
  %54 = insertvalue { ptr, i32, i32, i32 } %53, i32 8, 3
  %55 = load ptr, ptr %52, align 8
  store i252 2, ptr %55, align 16
  %56 = insertvalue { ptr, i32, i32, i32 } %54, i32 1, 2
  %57 = getelementptr inbounds i8, ptr %55, i32 -12
  store i32 1, ptr %57, align 4
  br label %116

58:                                               ; preds = %3
  %59 = phi i64 [ %1, %3 ]
  %60 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %61 = call ptr %60()
  %62 = call i64 @llvm.uadd.sat.i64(i64 %59, i64 0)
  %63 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %63, align 4
  %64 = getelementptr inbounds i8, ptr %63, i32 4
  store i32 0, ptr %64, align 4
  %65 = getelementptr inbounds i8, ptr %63, i32 16
  %66 = call ptr @realloc(ptr null, i64 8)
  store ptr %65, ptr %66, align 8
  %67 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %66, 0
  %68 = insertvalue { ptr, i32, i32, i32 } %67, i32 8, 3
  %69 = load ptr, ptr %66, align 8
  store i252 3, ptr %69, align 16
  %70 = insertvalue { ptr, i32, i32, i32 } %68, i32 1, 2
  %71 = getelementptr inbounds i8, ptr %69, i32 -12
  store i32 1, ptr %71, align 4
  br label %116

72:                                               ; preds = %3
  %73 = phi i64 [ %1, %3 ]
  %74 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %75 = call ptr %74()
  %76 = call i64 @llvm.uadd.sat.i64(i64 %73, i64 0)
  %77 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %77, i32 4
  store i32 0, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %77, i32 16
  %80 = call ptr @realloc(ptr null, i64 8)
  store ptr %79, ptr %80, align 8
  %81 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %80, 0
  %82 = insertvalue { ptr, i32, i32, i32 } %81, i32 8, 3
  %83 = load ptr, ptr %80, align 8
  store i252 4, ptr %83, align 16
  %84 = insertvalue { ptr, i32, i32, i32 } %82, i32 1, 2
  %85 = getelementptr inbounds i8, ptr %83, i32 -12
  store i32 1, ptr %85, align 4
  br label %116

86:                                               ; preds = %3
  %87 = phi i64 [ %1, %3 ]
  %88 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %89 = call ptr %88()
  %90 = call i64 @llvm.uadd.sat.i64(i64 %87, i64 0)
  %91 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %91, align 4
  %92 = getelementptr inbounds i8, ptr %91, i32 4
  store i32 0, ptr %92, align 4
  %93 = getelementptr inbounds i8, ptr %91, i32 16
  %94 = call ptr @realloc(ptr null, i64 8)
  store ptr %93, ptr %94, align 8
  %95 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %94, 0
  %96 = insertvalue { ptr, i32, i32, i32 } %95, i32 8, 3
  %97 = load ptr, ptr %94, align 8
  store i252 5, ptr %97, align 16
  %98 = insertvalue { ptr, i32, i32, i32 } %96, i32 1, 2
  %99 = getelementptr inbounds i8, ptr %97, i32 -12
  store i32 1, ptr %99, align 4
  br label %116

100:                                              ; preds = %3
  %101 = phi i64 [ %1, %3 ]
  %102 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %103 = call ptr %102()
  %104 = load i64, ptr %103, align 8
  %105 = mul i64 %104, 100
  %106 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 %105)
  %107 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %107, align 4
  %108 = getelementptr inbounds i8, ptr %107, i32 4
  store i32 0, ptr %108, align 4
  %109 = getelementptr inbounds i8, ptr %107, i32 16
  %110 = call ptr @realloc(ptr null, i64 8)
  store ptr %109, ptr %110, align 8
  %111 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %110, 0
  %112 = insertvalue { ptr, i32, i32, i32 } %111, i32 8, 3
  %113 = load ptr, ptr %110, align 8
  store i252 6, ptr %113, align 16
  %114 = insertvalue { ptr, i32, i32, i32 } %112, i32 1, 2
  %115 = getelementptr inbounds i8, ptr %113, i32 -12
  store i32 1, ptr %115, align 4
  br label %116

116:                                              ; preds = %14, %30, %44, %58, %72, %86, %100
  %117 = phi i64 [ %0, %100 ], [ %0, %86 ], [ %0, %72 ], [ %0, %58 ], [ %0, %44 ], [ %0, %30 ], [ %0, %14 ]
  %118 = phi i32 [ %8, %100 ], [ %8, %86 ], [ %8, %72 ], [ %8, %58 ], [ %8, %44 ], [ %8, %30 ], [ %8, %14 ]
  %119 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %9, %100 ], [ %9, %86 ], [ %9, %72 ], [ %9, %58 ], [ %9, %44 ], [ %9, %30 ], [ %9, %14 ]
  %120 = phi { i32, i32, i32, i32 } [ %10, %100 ], [ %10, %86 ], [ %10, %72 ], [ %10, %58 ], [ %10, %44 ], [ %10, %30 ], [ %10, %14 ]
  %121 = phi i64 [ %106, %100 ], [ %90, %86 ], [ %76, %72 ], [ %62, %58 ], [ %48, %44 ], [ %34, %30 ], [ %20, %14 ]
  %122 = phi { ptr, i32, i32, i32 } [ %114, %100 ], [ %98, %86 ], [ %84, %72 ], [ %70, %58 ], [ %56, %44 ], [ %42, %30 ], [ %28, %14 ]
  %123 = zext i32 %118 to i252
  %124 = extractvalue { ptr, i32, i32, i32 } %122, 3
  %125 = icmp eq i32 %124, 0
  br i1 %125, label %126, label %140

126:                                              ; preds = %116
  %127 = shl i32 %124, 1
  %128 = call i32 @llvm.umin.i32(i32 %127, i32 1024)
  %129 = add i32 %128, %124
  %130 = call i32 @llvm.umax.i32(i32 %129, i32 8)
  %131 = zext i32 %130 to i64
  %132 = mul i64 %131, 32
  %133 = add i64 %132, 16
  %134 = call ptr @realloc(ptr null, i64 %133)
  store i32 1, ptr %134, align 4
  %135 = getelementptr inbounds i8, ptr %134, i32 4
  store i32 0, ptr %135, align 4
  %136 = getelementptr inbounds i8, ptr %134, i32 16
  %137 = call ptr @realloc(ptr null, i64 8)
  store ptr %136, ptr %137, align 8
  %138 = insertvalue { ptr, i32, i32, i32 } %122, ptr %137, 0
  %139 = insertvalue { ptr, i32, i32, i32 } %138, i32 %130, 3
  br label %161

140:                                              ; preds = %116
  %141 = extractvalue { ptr, i32, i32, i32 } %122, 2
  %142 = icmp ult i32 %141, %124
  br i1 %142, label %143, label %144

143:                                              ; preds = %140
  br label %158

144:                                              ; preds = %140
  %145 = shl i32 %124, 1
  %146 = call i32 @llvm.umin.i32(i32 %145, i32 1024)
  %147 = add i32 %146, %124
  %148 = call i32 @llvm.umax.i32(i32 %147, i32 8)
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 32
  %151 = add i64 %150, 16
  %152 = extractvalue { ptr, i32, i32, i32 } %122, 0
  %153 = load ptr, ptr %152, align 8
  %154 = getelementptr inbounds i8, ptr %153, i32 -16
  %155 = call ptr @realloc(ptr %154, i64 %151)
  %156 = getelementptr inbounds i8, ptr %155, i32 16
  store ptr %156, ptr %152, align 8
  %157 = insertvalue { ptr, i32, i32, i32 } %122, i32 %148, 3
  br label %158

158:                                              ; preds = %143, %144
  %159 = phi { ptr, i32, i32, i32 } [ %157, %144 ], [ %122, %143 ]
  br label %160

160:                                              ; preds = %158
  br label %161

161:                                              ; preds = %126, %160
  %162 = phi { ptr, i32, i32, i32 } [ %159, %160 ], [ %139, %126 ]
  br label %163

163:                                              ; preds = %161
  %164 = extractvalue { ptr, i32, i32, i32 } %162, 0
  %165 = load ptr, ptr %164, align 8
  %166 = extractvalue { ptr, i32, i32, i32 } %162, 2
  %167 = zext i32 %166 to i64
  %168 = mul i64 %167, 32
  %169 = getelementptr inbounds i8, ptr %165, i64 %168
  store i252 %123, ptr %169, align 16
  %170 = extractvalue { ptr, i32, i32, i32 } %162, 2
  %171 = add i32 %170, 1
  %172 = insertvalue { ptr, i32, i32, i32 } %162, i32 %171, 2
  %173 = getelementptr inbounds i8, ptr %165, i32 -12
  store i32 %171, ptr %173, align 4
  %174 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %119, 0
  %175 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %174, { i32, i32, i32, i32 } %120, 1
  %176 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f91"(i64 %117, i64 %121, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %175, { ptr, i32, i32, i32 } %172)
  %177 = extractvalue { i64, i64, { i64, [24 x i8] } } %176, 0
  %178 = extractvalue { i64, i64, { i64, [24 x i8] } } %176, 1
  %179 = extractvalue { i64, i64, { i64, [24 x i8] } } %176, 2
  store { i64, [24 x i8] } %179, ptr %4, align 8
  %180 = load i1, ptr %4, align 1
  switch i1 %180, label %181 [
    i1 false, label %183
    i1 true, label %200
  ]

181:                                              ; preds = %163
  br i1 false, label %182, label %209

182:                                              ; preds = %181
  unreachable

183:                                              ; preds = %163
  %184 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %4, align 8
  %185 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %184, 1
  %186 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %187 = call ptr %186()
  %188 = call i64 @llvm.uadd.sat.i64(i64 %178, i64 0)
  %189 = extractvalue { { ptr, i32, i32, i32 }, {} } %185, 0
  %190 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %189)
  %191 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %190, 0
  %192 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %190, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %191)
  %193 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %192, 0
  %194 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %193, 0
  %195 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %194, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %195, ptr %6, align 8
  %196 = load { i64, [24 x i8] }, ptr %6, align 8
  %197 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %177, 0
  %198 = insertvalue { i64, i64, { i64, [24 x i8] } } %197, i64 %188, 1
  %199 = insertvalue { i64, i64, { i64, [24 x i8] } } %198, { i64, [24 x i8] } %196, 2
  ret { i64, i64, { i64, [24 x i8] } } %199

200:                                              ; preds = %163
  %201 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %202 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %201, 1
  %203 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %202, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %203, ptr %5, align 8
  %204 = load { i64, [24 x i8] }, ptr %5, align 8
  %205 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %177, 0
  %206 = insertvalue { i64, i64, { i64, [24 x i8] } } %205, i64 %178, 1
  %207 = insertvalue { i64, i64, { i64, [24 x i8] } } %206, { i64, [24 x i8] } %204, 2
  ret { i64, i64, { i64, [24 x i8] } } %207

208:                                              ; preds = %12
  call void @puts(ptr @assert_msg_143)
  call void @abort()
  unreachable

209:                                              ; preds = %181
  call void @puts(ptr @assert_msg_144)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f77(i64 %0, i64 %1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f77"(i64 %0, i64 %1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, { i64, [24 x i8] } %7, 2
  ret { i64, i64, { i64, [24 x i8] } } %10
}

define void @_mlir_ciface_f77(ptr %0, i64 %1, i64 %2, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i64, [24 x i8] } } @f77(i64 %1, i64 %2, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %3)
  store { i64, i64, { i64, [24 x i8] } } %5, ptr %0, align 8
  ret void
}

define private void @"drop$98"(ptr %0) {
  %2 = load { i128, [144 x i8] }, ptr %0, align 16
  call void @"drop$103"({ i128, [144 x i8] } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$98"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 160)
  %3 = load { i128, [144 x i8] }, ptr %0, align 16
  %4 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$103"({ i128, [144 x i8] } %3)
  %5 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %4, 0
  %6 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %4, 1
  store { i128, [144 x i8] } %5, ptr %0, align 16
  store { i128, [144 x i8] } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [80 x i8] } } @"impl$f78"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3, i252 %4, { ptr, i32, i32, i32 } %5, { i252 } %6, { i3, [0 x i8] } %7, i32 %8) {
  %10 = alloca i64, i64 1, align 8
  %11 = insertvalue { ptr, ptr, i64 } undef, ptr %10, 0
  %12 = insertvalue { ptr, ptr, i64 } %11, ptr %10, 1
  %13 = insertvalue { ptr, ptr, i64 } %12, i64 0, 2
  %14 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 0, ptr %14, align 8
  %15 = alloca { i64, [80 x i8] }, i64 1, align 8
  %16 = alloca { i64, [80 x i8] }, i64 1, align 8
  %17 = alloca { i64, [80 x i8] }, i64 1, align 8
  br label %18

18:                                               ; preds = %161, %9
  %19 = phi i64 [ %57, %161 ], [ %0, %9 ]
  %20 = phi i64 [ %65, %161 ], [ %1, %9 ]
  %21 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %174, %161 ], [ %2, %9 ]
  %22 = phi { ptr, i32, i32, i32 } [ %115, %161 ], [ %3, %9 ]
  %23 = phi i252 [ %23, %161 ], [ %4, %9 ]
  %24 = phi { ptr, i32, i32, i32 } [ %170, %161 ], [ %5, %9 ]
  %25 = phi { i252 } [ %25, %161 ], [ %6, %9 ]
  %26 = phi { i3, [0 x i8] } [ %26, %161 ], [ %7, %9 ]
  %27 = phi i32 [ %27, %161 ], [ %8, %9 ]
  %28 = add i64 %19, 1
  %29 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %30 = call ptr %29()
  %31 = load i64, ptr %30, align 8
  %32 = mul i64 %31, 6040
  %33 = icmp uge i64 %20, %32
  %34 = call i64 @llvm.usub.sat.i64(i64 %20, i64 %32)
  br i1 %33, label %35, label %232

35:                                               ; preds = %18
  %36 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %21, %18 ]
  %37 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %36, 0
  %38 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %36, 1
  %39 = extractvalue { { ptr, i32, i32, i32 } } %37, 0
  %40 = extractvalue { ptr, i32, i32, i32 } %39, 1
  %41 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %42 = sub i32 %41, %40
  %43 = icmp uge i32 %42, 1
  br i1 %43, label %44, label %207

44:                                               ; preds = %35
  %45 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %46 = load ptr, ptr %45, align 8
  %47 = zext i32 %40 to i64
  %48 = mul i64 %47, 160
  %49 = getelementptr inbounds i8, ptr %46, i64 %48
  %50 = add i32 %40, 1
  %51 = insertvalue { ptr, i32, i32, i32 } %39, i32 %50, 1
  %52 = call ptr @realloc(ptr null, i64 160)
  %53 = load { i128, [144 x i8] }, ptr %49, align 16
  %54 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$103"({ i128, [144 x i8] } %53)
  %55 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %54, 0
  %56 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %54, 1
  store { i128, [144 x i8] } %55, ptr %49, align 16
  store { i128, [144 x i8] } %56, ptr %52, align 16
  %57 = add i64 %19, 2
  %58 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %38, i32 1)
  %59 = extractvalue { i32, i1 } %58, 0
  %60 = extractvalue { i32, i1 } %58, 1
  br i1 %60, label %192, label %61

61:                                               ; preds = %44
  %62 = phi i64 [ %34, %44 ]
  %63 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %64 = call ptr %63()
  %65 = call i64 @llvm.uadd.sat.i64(i64 %62, i64 0)
  %66 = load { i128, [144 x i8] }, ptr %52, align 16
  call void @free(ptr %52)
  %67 = extractvalue { ptr, i32, i32, i32 } %22, 3
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %69, label %83

69:                                               ; preds = %61
  %70 = shl i32 %67, 1
  %71 = call i32 @llvm.umin.i32(i32 %70, i32 1024)
  %72 = add i32 %71, %67
  %73 = call i32 @llvm.umax.i32(i32 %72, i32 8)
  %74 = zext i32 %73 to i64
  %75 = mul i64 %74, 160
  %76 = add i64 %75, 16
  %77 = call ptr @realloc(ptr null, i64 %76)
  store i32 1, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %77, i32 4
  store i32 0, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %77, i32 16
  %80 = call ptr @realloc(ptr null, i64 8)
  store ptr %79, ptr %80, align 8
  %81 = insertvalue { ptr, i32, i32, i32 } %22, ptr %80, 0
  %82 = insertvalue { ptr, i32, i32, i32 } %81, i32 %73, 3
  br label %104

83:                                               ; preds = %61
  %84 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %85 = icmp ult i32 %84, %67
  br i1 %85, label %86, label %87

86:                                               ; preds = %83
  br label %101

87:                                               ; preds = %83
  %88 = shl i32 %67, 1
  %89 = call i32 @llvm.umin.i32(i32 %88, i32 1024)
  %90 = add i32 %89, %67
  %91 = call i32 @llvm.umax.i32(i32 %90, i32 8)
  %92 = zext i32 %91 to i64
  %93 = mul i64 %92, 160
  %94 = add i64 %93, 16
  %95 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %96 = load ptr, ptr %95, align 8
  %97 = getelementptr inbounds i8, ptr %96, i32 -16
  %98 = call ptr @realloc(ptr %97, i64 %94)
  %99 = getelementptr inbounds i8, ptr %98, i32 16
  store ptr %99, ptr %95, align 8
  %100 = insertvalue { ptr, i32, i32, i32 } %22, i32 %91, 3
  br label %101

101:                                              ; preds = %86, %87
  %102 = phi { ptr, i32, i32, i32 } [ %100, %87 ], [ %22, %86 ]
  br label %103

103:                                              ; preds = %101
  br label %104

104:                                              ; preds = %69, %103
  %105 = phi { ptr, i32, i32, i32 } [ %102, %103 ], [ %82, %69 ]
  br label %106

106:                                              ; preds = %104
  %107 = extractvalue { ptr, i32, i32, i32 } %105, 0
  %108 = load ptr, ptr %107, align 8
  %109 = extractvalue { ptr, i32, i32, i32 } %105, 2
  %110 = zext i32 %109 to i64
  %111 = mul i64 %110, 160
  %112 = getelementptr inbounds i8, ptr %108, i64 %111
  store { i128, [144 x i8] } %66, ptr %112, align 16
  %113 = extractvalue { ptr, i32, i32, i32 } %105, 2
  %114 = add i32 %113, 1
  %115 = insertvalue { ptr, i32, i32, i32 } %105, i32 %114, 2
  %116 = getelementptr inbounds i8, ptr %108, i32 -12
  store i32 %114, ptr %116, align 4
  %117 = insertvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } undef, { i252 } %25, 0
  %118 = insertvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %117, { i3, [0 x i8] } %26, 1
  %119 = insertvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %118, i32 %27, 2
  %120 = insertvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %119, i252 %23, 3
  %121 = insertvalue { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %120, i32 %38, 4
  %122 = extractvalue { ptr, i32, i32, i32 } %24, 3
  %123 = icmp eq i32 %122, 0
  br i1 %123, label %124, label %138

124:                                              ; preds = %106
  %125 = shl i32 %122, 1
  %126 = call i32 @llvm.umin.i32(i32 %125, i32 1024)
  %127 = add i32 %126, %122
  %128 = call i32 @llvm.umax.i32(i32 %127, i32 8)
  %129 = zext i32 %128 to i64
  %130 = mul i64 %129, 96
  %131 = add i64 %130, 16
  %132 = call ptr @realloc(ptr null, i64 %131)
  store i32 1, ptr %132, align 4
  %133 = getelementptr inbounds i8, ptr %132, i32 4
  store i32 0, ptr %133, align 4
  %134 = getelementptr inbounds i8, ptr %132, i32 16
  %135 = call ptr @realloc(ptr null, i64 8)
  store ptr %134, ptr %135, align 8
  %136 = insertvalue { ptr, i32, i32, i32 } %24, ptr %135, 0
  %137 = insertvalue { ptr, i32, i32, i32 } %136, i32 %128, 3
  br label %159

138:                                              ; preds = %106
  %139 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %140 = icmp ult i32 %139, %122
  br i1 %140, label %141, label %142

141:                                              ; preds = %138
  br label %156

142:                                              ; preds = %138
  %143 = shl i32 %122, 1
  %144 = call i32 @llvm.umin.i32(i32 %143, i32 1024)
  %145 = add i32 %144, %122
  %146 = call i32 @llvm.umax.i32(i32 %145, i32 8)
  %147 = zext i32 %146 to i64
  %148 = mul i64 %147, 96
  %149 = add i64 %148, 16
  %150 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %151 = load ptr, ptr %150, align 8
  %152 = getelementptr inbounds i8, ptr %151, i32 -16
  %153 = call ptr @realloc(ptr %152, i64 %149)
  %154 = getelementptr inbounds i8, ptr %153, i32 16
  store ptr %154, ptr %150, align 8
  %155 = insertvalue { ptr, i32, i32, i32 } %24, i32 %146, 3
  br label %156

156:                                              ; preds = %141, %142
  %157 = phi { ptr, i32, i32, i32 } [ %155, %142 ], [ %24, %141 ]
  br label %158

158:                                              ; preds = %156
  br label %159

159:                                              ; preds = %124, %158
  %160 = phi { ptr, i32, i32, i32 } [ %157, %158 ], [ %137, %124 ]
  br label %161

161:                                              ; preds = %159
  %162 = extractvalue { ptr, i32, i32, i32 } %160, 0
  %163 = load ptr, ptr %162, align 8
  %164 = extractvalue { ptr, i32, i32, i32 } %160, 2
  %165 = zext i32 %164 to i64
  %166 = mul i64 %165, 96
  %167 = getelementptr inbounds i8, ptr %163, i64 %166
  store { { i252 }, { i3, [0 x i8] }, i32, i252, i32 } %121, ptr %167, align 16
  %168 = extractvalue { ptr, i32, i32, i32 } %160, 2
  %169 = add i32 %168, 1
  %170 = insertvalue { ptr, i32, i32, i32 } %160, i32 %169, 2
  %171 = getelementptr inbounds i8, ptr %163, i32 -12
  store i32 %169, ptr %171, align 4
  %172 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %51, 0
  %173 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %172, 0
  %174 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %173, i32 %59, 1
  %175 = extractvalue { ptr, ptr, i64 } %13, 1
  %176 = load i64, ptr %175, align 8
  %177 = add i64 %176, 1
  %178 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %177, ptr %178, align 8
  br label %18

179:                                              ; preds = %179, %192, %207, %232
  %180 = phi i64 [ %28, %232 ], [ %28, %207 ], [ %57, %192 ], [ %180, %179 ]
  %181 = phi i64 [ %20, %232 ], [ %213, %207 ], [ %34, %192 ], [ %181, %179 ]
  %182 = phi { i64, [80 x i8] } [ %237, %232 ], [ %222, %207 ], [ %197, %192 ], [ %182, %179 ]
  %183 = extractvalue { ptr, ptr, i64 } %13, 1
  %184 = load i64, ptr %183, align 8
  %185 = icmp eq i64 %184, 0
  %186 = sub i64 %184, 1
  %187 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %186, ptr %187, align 8
  br i1 %185, label %188, label %179

188:                                              ; preds = %179
  %189 = insertvalue { i64, i64, { i64, [80 x i8] } } undef, i64 %180, 0
  %190 = insertvalue { i64, i64, { i64, [80 x i8] } } %189, i64 %181, 1
  %191 = insertvalue { i64, i64, { i64, [80 x i8] } } %190, { i64, [80 x i8] } %182, 2
  ret { i64, i64, { i64, [80 x i8] } } %191

192:                                              ; preds = %44
  %193 = phi { ptr, i32, i32, i32 } [ %51, %44 ]
  call void @"drop$106"({ ptr, i32, i32, i32 } %193)
  call void @"drop$98"(ptr %52)
  call void @"drop$106"({ ptr, i32, i32, i32 } %22)
  call void @"drop$182"({ ptr, i32, i32, i32 } %24)
  %194 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f67"()
  %195 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %194, 0
  %196 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %195, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %196, ptr %17, align 8
  %197 = load { i64, [80 x i8] }, ptr %17, align 8
  %198 = extractvalue { ptr, ptr, i64 } %13, 1
  %199 = load i64, ptr %198, align 8
  %200 = icmp eq i64 %199, 0
  %201 = sub i64 %199, 1
  %202 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %201, ptr %202, align 8
  br i1 %200, label %203, label %179

203:                                              ; preds = %192
  %204 = insertvalue { i64, i64, { i64, [80 x i8] } } undef, i64 %57, 0
  %205 = insertvalue { i64, i64, { i64, [80 x i8] } } %204, i64 %34, 1
  %206 = insertvalue { i64, i64, { i64, [80 x i8] } } %205, { i64, [80 x i8] } %197, 2
  ret { i64, i64, { i64, [80 x i8] } } %206

207:                                              ; preds = %35
  %208 = phi i64 [ %34, %35 ]
  %209 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %210 = call ptr %209()
  %211 = load i64, ptr %210, align 8
  %212 = mul i64 %211, 6740
  %213 = call i64 @llvm.uadd.sat.i64(i64 %208, i64 %212)
  %214 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %39, 0
  %215 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %214, 0
  %216 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %215, i32 %38, 1
  %217 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, i32 } %216, 0
  %218 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %217, { ptr, i32, i32, i32 } %22, 1
  %219 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %218, { ptr, i32, i32, i32 } %24, 2
  %220 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %219, {} undef, 3
  %221 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } %220, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 }, {} } } %221, ptr %16, align 8
  %222 = load { i64, [80 x i8] }, ptr %16, align 8
  %223 = extractvalue { ptr, ptr, i64 } %13, 1
  %224 = load i64, ptr %223, align 8
  %225 = icmp eq i64 %224, 0
  %226 = sub i64 %224, 1
  %227 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %226, ptr %227, align 8
  br i1 %225, label %228, label %179

228:                                              ; preds = %207
  %229 = insertvalue { i64, i64, { i64, [80 x i8] } } undef, i64 %28, 0
  %230 = insertvalue { i64, i64, { i64, [80 x i8] } } %229, i64 %213, 1
  %231 = insertvalue { i64, i64, { i64, [80 x i8] } } %230, { i64, [80 x i8] } %222, 2
  ret { i64, i64, { i64, [80 x i8] } } %231

232:                                              ; preds = %18
  %233 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %21, %18 ]
  call void @"drop$181"({ { { ptr, i32, i32, i32 } }, i32 } %233)
  call void @"drop$106"({ ptr, i32, i32, i32 } %22)
  call void @"drop$182"({ ptr, i32, i32, i32 } %24)
  %234 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %235 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %234, 0
  %236 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %235, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %236, ptr %15, align 8
  %237 = load { i64, [80 x i8] }, ptr %15, align 8
  %238 = extractvalue { ptr, ptr, i64 } %13, 1
  %239 = load i64, ptr %238, align 8
  %240 = icmp eq i64 %239, 0
  %241 = sub i64 %239, 1
  %242 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %241, ptr %242, align 8
  br i1 %240, label %243, label %179

243:                                              ; preds = %232
  %244 = insertvalue { i64, i64, { i64, [80 x i8] } } undef, i64 %28, 0
  %245 = insertvalue { i64, i64, { i64, [80 x i8] } } %244, i64 %20, 1
  %246 = insertvalue { i64, i64, { i64, [80 x i8] } } %245, { i64, [80 x i8] } %237, 2
  ret { i64, i64, { i64, [80 x i8] } } %246
}

define private { i64, i64, { i64, [80 x i8] } } @f78(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3, i252 %4, { ptr, i32, i32, i32 } %5, { i252 } %6, { i3, [0 x i8] } %7, i32 %8) {
  %10 = call fastcc { i64, i64, { i64, [80 x i8] } } @"impl$f78"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3, i252 %4, { ptr, i32, i32, i32 } %5, { i252 } %6, { i3, [0 x i8] } %7, i32 %8)
  %11 = extractvalue { i64, i64, { i64, [80 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, { i64, [80 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, { i64, [80 x i8] } } %10, 2
  %14 = insertvalue { i64, i64, { i64, [80 x i8] } } undef, i64 %11, 0
  %15 = insertvalue { i64, i64, { i64, [80 x i8] } } %14, i64 %12, 1
  %16 = insertvalue { i64, i64, { i64, [80 x i8] } } %15, { i64, [80 x i8] } %13, 2
  ret { i64, i64, { i64, [80 x i8] } } %16
}

define void @_mlir_ciface_f78(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 } }, i32 } %3, { ptr, i32, i32, i32 } %4, i252 %5, { ptr, i32, i32, i32 } %6, { i252 } %7, { i3, [0 x i8] } %8, i32 %9) {
  %11 = call { i64, i64, { i64, [80 x i8] } } @f78(i64 %1, i64 %2, { { { ptr, i32, i32, i32 } }, i32 } %3, { ptr, i32, i32, i32 } %4, i252 %5, { ptr, i32, i32, i32 } %6, { i252 } %7, { i3, [0 x i8] } %8, i32 %9)
  store { i64, i64, { i64, [80 x i8] } } %11, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i128, [32 x i8] } } @"impl$f79"(i64 %0, i32 %1) {
  %3 = alloca { i128, [32 x i8] }, i64 1, align 16
  %4 = alloca { i128, [32 x i8] }, i64 1, align 16
  %5 = alloca { i128, [32 x i8] }, i64 1, align 16
  %6 = add i64 %0, 1
  %7 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %1, i32 16)
  %8 = extractvalue { i32, i1 } %7, 0
  %9 = extractvalue { i32, i1 } %7, 1
  br i1 %9, label %34, label %10

10:                                               ; preds = %2
  %11 = phi i64 [ %6, %2 ]
  %12 = phi i32 [ %8, %2 ]
  %13 = icmp ult i32 %12, 16
  %14 = add i64 %11, 1
  %15 = trunc i32 %12 to i4
  br i1 %13, label %16, label %53

16:                                               ; preds = %10
  %17 = phi i4 [ %15, %10 ]
  switch i4 %17, label %18 [
    i4 0, label %20
    i4 1, label %63
    i4 2, label %66
    i4 3, label %69
    i4 4, label %72
    i4 5, label %75
    i4 6, label %78
    i4 7, label %81
    i4 -8, label %84
    i4 -7, label %87
    i4 -6, label %90
    i4 -5, label %93
    i4 -4, label %96
    i4 -3, label %99
    i4 -2, label %102
    i4 -1, label %105
  ]

18:                                               ; preds = %16
  br i1 false, label %19, label %62

19:                                               ; preds = %18
  unreachable

20:                                               ; preds = %63, %66, %69, %72, %75, %78, %81, %84, %87, %90, %93, %96, %99, %102, %105, %16
  %21 = phi i64 [ %106, %105 ], [ %103, %102 ], [ %100, %99 ], [ %97, %96 ], [ %94, %93 ], [ %91, %90 ], [ %88, %87 ], [ %85, %84 ], [ %82, %81 ], [ %79, %78 ], [ %76, %75 ], [ %73, %72 ], [ %70, %69 ], [ %67, %66 ], [ %64, %63 ], [ %14, %16 ]
  %22 = phi i128 [ %107, %105 ], [ %104, %102 ], [ %101, %99 ], [ %98, %96 ], [ %95, %93 ], [ %92, %90 ], [ %89, %87 ], [ %86, %84 ], [ %83, %81 ], [ %80, %78 ], [ %77, %75 ], [ %74, %72 ], [ %71, %69 ], [ %68, %66 ], [ %65, %63 ], [ 1, %16 ]
  %23 = zext i128 %22 to i512
  %24 = mul i512 %23, 340282366920938463463374607431768211456
  %25 = urem i512 %24, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %26 = icmp uge i512 %24, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %27 = select i1 %26, i512 %25, i512 %24
  %28 = trunc i512 %27 to i252
  %29 = insertvalue { i252 } undef, i252 %28, 0
  %30 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %29, 1
  store { i1, { i252 } } %30, ptr %5, align 16
  %31 = load { i128, [32 x i8] }, ptr %5, align 16
  %32 = insertvalue { i64, { i128, [32 x i8] } } undef, i64 %21, 0
  %33 = insertvalue { i64, { i128, [32 x i8] } } %32, { i128, [32 x i8] } %31, 1
  ret { i64, { i128, [32 x i8] } } %33

34:                                               ; preds = %2
  %35 = phi i64 [ %6, %2 ]
  %36 = phi i32 [ %1, %2 ]
  %37 = icmp ult i32 %36, 16
  %38 = add i64 %35, 1
  %39 = trunc i32 %36 to i4
  br i1 %37, label %40, label %53

40:                                               ; preds = %34
  %41 = phi i4 [ %39, %34 ]
  switch i4 %41, label %42 [
    i4 0, label %44
    i4 1, label %108
    i4 2, label %111
    i4 3, label %114
    i4 4, label %117
    i4 5, label %120
    i4 6, label %123
    i4 7, label %126
    i4 -8, label %129
    i4 -7, label %132
    i4 -6, label %135
    i4 -5, label %138
    i4 -4, label %141
    i4 -3, label %144
    i4 -2, label %147
    i4 -1, label %150
  ]

42:                                               ; preds = %40
  br i1 false, label %43, label %61

43:                                               ; preds = %42
  unreachable

44:                                               ; preds = %108, %111, %114, %117, %120, %123, %126, %129, %132, %135, %138, %141, %144, %147, %150, %40
  %45 = phi i64 [ %151, %150 ], [ %148, %147 ], [ %145, %144 ], [ %142, %141 ], [ %139, %138 ], [ %136, %135 ], [ %133, %132 ], [ %130, %129 ], [ %127, %126 ], [ %124, %123 ], [ %121, %120 ], [ %118, %117 ], [ %115, %114 ], [ %112, %111 ], [ %109, %108 ], [ %38, %40 ]
  %46 = phi i128 [ %152, %150 ], [ %149, %147 ], [ %146, %144 ], [ %143, %141 ], [ %140, %138 ], [ %137, %135 ], [ %134, %132 ], [ %131, %129 ], [ %128, %126 ], [ %125, %123 ], [ %122, %120 ], [ %119, %117 ], [ %116, %114 ], [ %113, %111 ], [ %110, %108 ], [ 1, %40 ]
  %47 = zext i128 %46 to i252
  %48 = insertvalue { i252 } undef, i252 %47, 0
  %49 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %48, 1
  store { i1, { i252 } } %49, ptr %4, align 16
  %50 = load { i128, [32 x i8] }, ptr %4, align 16
  %51 = insertvalue { i64, { i128, [32 x i8] } } undef, i64 %45, 0
  %52 = insertvalue { i64, { i128, [32 x i8] } } %51, { i128, [32 x i8] } %50, 1
  ret { i64, { i128, [32 x i8] } } %52

53:                                               ; preds = %34, %10
  %54 = phi i64 [ %38, %34 ], [ %14, %10 ]
  %55 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f92"()
  %56 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %55, 0
  %57 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %56, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %57, ptr %3, align 8
  %58 = load { i128, [32 x i8] }, ptr %3, align 16
  %59 = insertvalue { i64, { i128, [32 x i8] } } undef, i64 %54, 0
  %60 = insertvalue { i64, { i128, [32 x i8] } } %59, { i128, [32 x i8] } %58, 1
  ret { i64, { i128, [32 x i8] } } %60

61:                                               ; preds = %42
  call void @puts(ptr @assert_msg_145)
  call void @abort()
  unreachable

62:                                               ; preds = %18
  call void @puts(ptr @assert_msg_146)
  call void @abort()
  unreachable

63:                                               ; preds = %16
  %64 = phi i64 [ %14, %16 ]
  %65 = phi i128 [ 256, %16 ]
  br label %20

66:                                               ; preds = %16
  %67 = phi i64 [ %14, %16 ]
  %68 = phi i128 [ 65536, %16 ]
  br label %20

69:                                               ; preds = %16
  %70 = phi i64 [ %14, %16 ]
  %71 = phi i128 [ 16777216, %16 ]
  br label %20

72:                                               ; preds = %16
  %73 = phi i64 [ %14, %16 ]
  %74 = phi i128 [ 4294967296, %16 ]
  br label %20

75:                                               ; preds = %16
  %76 = phi i64 [ %14, %16 ]
  %77 = phi i128 [ 1099511627776, %16 ]
  br label %20

78:                                               ; preds = %16
  %79 = phi i64 [ %14, %16 ]
  %80 = phi i128 [ 281474976710656, %16 ]
  br label %20

81:                                               ; preds = %16
  %82 = phi i64 [ %14, %16 ]
  %83 = phi i128 [ 72057594037927936, %16 ]
  br label %20

84:                                               ; preds = %16
  %85 = phi i64 [ %14, %16 ]
  %86 = phi i128 [ 18446744073709551616, %16 ]
  br label %20

87:                                               ; preds = %16
  %88 = phi i64 [ %14, %16 ]
  %89 = phi i128 [ 4722366482869645213696, %16 ]
  br label %20

90:                                               ; preds = %16
  %91 = phi i64 [ %14, %16 ]
  %92 = phi i128 [ 1208925819614629174706176, %16 ]
  br label %20

93:                                               ; preds = %16
  %94 = phi i64 [ %14, %16 ]
  %95 = phi i128 [ 309485009821345068724781056, %16 ]
  br label %20

96:                                               ; preds = %16
  %97 = phi i64 [ %14, %16 ]
  %98 = phi i128 [ 79228162514264337593543950336, %16 ]
  br label %20

99:                                               ; preds = %16
  %100 = phi i64 [ %14, %16 ]
  %101 = phi i128 [ 20282409603651670423947251286016, %16 ]
  br label %20

102:                                              ; preds = %16
  %103 = phi i64 [ %14, %16 ]
  %104 = phi i128 [ 5192296858534827628530496329220096, %16 ]
  br label %20

105:                                              ; preds = %16
  %106 = phi i64 [ %14, %16 ]
  %107 = phi i128 [ 1329227995784915872903807060280344576, %16 ]
  br label %20

108:                                              ; preds = %40
  %109 = phi i64 [ %38, %40 ]
  %110 = phi i128 [ 256, %40 ]
  br label %44

111:                                              ; preds = %40
  %112 = phi i64 [ %38, %40 ]
  %113 = phi i128 [ 65536, %40 ]
  br label %44

114:                                              ; preds = %40
  %115 = phi i64 [ %38, %40 ]
  %116 = phi i128 [ 16777216, %40 ]
  br label %44

117:                                              ; preds = %40
  %118 = phi i64 [ %38, %40 ]
  %119 = phi i128 [ 4294967296, %40 ]
  br label %44

120:                                              ; preds = %40
  %121 = phi i64 [ %38, %40 ]
  %122 = phi i128 [ 1099511627776, %40 ]
  br label %44

123:                                              ; preds = %40
  %124 = phi i64 [ %38, %40 ]
  %125 = phi i128 [ 281474976710656, %40 ]
  br label %44

126:                                              ; preds = %40
  %127 = phi i64 [ %38, %40 ]
  %128 = phi i128 [ 72057594037927936, %40 ]
  br label %44

129:                                              ; preds = %40
  %130 = phi i64 [ %38, %40 ]
  %131 = phi i128 [ 18446744073709551616, %40 ]
  br label %44

132:                                              ; preds = %40
  %133 = phi i64 [ %38, %40 ]
  %134 = phi i128 [ 4722366482869645213696, %40 ]
  br label %44

135:                                              ; preds = %40
  %136 = phi i64 [ %38, %40 ]
  %137 = phi i128 [ 1208925819614629174706176, %40 ]
  br label %44

138:                                              ; preds = %40
  %139 = phi i64 [ %38, %40 ]
  %140 = phi i128 [ 309485009821345068724781056, %40 ]
  br label %44

141:                                              ; preds = %40
  %142 = phi i64 [ %38, %40 ]
  %143 = phi i128 [ 79228162514264337593543950336, %40 ]
  br label %44

144:                                              ; preds = %40
  %145 = phi i64 [ %38, %40 ]
  %146 = phi i128 [ 20282409603651670423947251286016, %40 ]
  br label %44

147:                                              ; preds = %40
  %148 = phi i64 [ %38, %40 ]
  %149 = phi i128 [ 5192296858534827628530496329220096, %40 ]
  br label %44

150:                                              ; preds = %40
  %151 = phi i64 [ %38, %40 ]
  %152 = phi i128 [ 1329227995784915872903807060280344576, %40 ]
  br label %44
}

define private { i64, { i128, [32 x i8] } } @f79(i64 %0, i32 %1) {
  %3 = call fastcc { i64, { i128, [32 x i8] } } @"impl$f79"(i64 %0, i32 %1)
  %4 = extractvalue { i64, { i128, [32 x i8] } } %3, 0
  %5 = extractvalue { i64, { i128, [32 x i8] } } %3, 1
  %6 = insertvalue { i64, { i128, [32 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i128, [32 x i8] } } %6, { i128, [32 x i8] } %5, 1
  ret { i64, { i128, [32 x i8] } } %7
}

define void @_mlir_ciface_f79(ptr %0, i64 %1, i32 %2) {
  %4 = call { i64, { i128, [32 x i8] } } @f79(i64 %1, i32 %2)
  store { i64, { i128, [32 x i8] } } %4, ptr %0, align 16
  ret void
}

define private fastcc { i64, { i128, [48 x i8] } } @"impl$f80"(i64 %0, i32 %1) {
  %3 = alloca { i128, [48 x i8] }, i64 1, align 16
  %4 = alloca { i128, [48 x i8] }, i64 1, align 16
  %5 = alloca { i128, [48 x i8] }, i64 1, align 16
  %6 = alloca { i128, [48 x i8] }, i64 1, align 16
  %7 = alloca { i128, [48 x i8] }, i64 1, align 16
  %8 = alloca { i128, [48 x i8] }, i64 1, align 16
  %9 = alloca { i128, [48 x i8] }, i64 1, align 16
  %10 = alloca { i128, [48 x i8] }, i64 1, align 16
  %11 = alloca { i128, [48 x i8] }, i64 1, align 16
  %12 = alloca { i128, [48 x i8] }, i64 1, align 16
  %13 = alloca { i128, [48 x i8] }, i64 1, align 16
  %14 = alloca { i128, [48 x i8] }, i64 1, align 16
  %15 = alloca { i128, [48 x i8] }, i64 1, align 16
  %16 = alloca { i128, [48 x i8] }, i64 1, align 16
  %17 = alloca { i128, [48 x i8] }, i64 1, align 16
  %18 = alloca { i128, [48 x i8] }, i64 1, align 16
  %19 = alloca { i128, [48 x i8] }, i64 1, align 16
  %20 = alloca { i128, [48 x i8] }, i64 1, align 16
  %21 = alloca { i128, [48 x i8] }, i64 1, align 16
  %22 = alloca { i128, [48 x i8] }, i64 1, align 16
  %23 = alloca { i128, [48 x i8] }, i64 1, align 16
  %24 = alloca { i128, [48 x i8] }, i64 1, align 16
  %25 = alloca { i128, [48 x i8] }, i64 1, align 16
  %26 = alloca { i128, [48 x i8] }, i64 1, align 16
  %27 = alloca { i128, [48 x i8] }, i64 1, align 16
  %28 = alloca { i128, [48 x i8] }, i64 1, align 16
  %29 = alloca { i128, [48 x i8] }, i64 1, align 16
  %30 = alloca { i128, [48 x i8] }, i64 1, align 16
  %31 = alloca { i128, [48 x i8] }, i64 1, align 16
  %32 = alloca { i128, [48 x i8] }, i64 1, align 16
  %33 = alloca { i128, [48 x i8] }, i64 1, align 16
  %34 = icmp ult i32 %1, 31
  %35 = add i64 %0, 1
  %36 = trunc i32 %1 to i5
  br i1 %34, label %37, label %278

37:                                               ; preds = %2
  %38 = phi i5 [ %36, %2 ]
  switch i5 %38, label %39 [
    i5 0, label %278
    i5 1, label %41
    i5 2, label %50
    i5 3, label %59
    i5 4, label %68
    i5 5, label %77
    i5 6, label %86
    i5 7, label %95
    i5 8, label %104
    i5 9, label %113
    i5 10, label %122
    i5 11, label %131
    i5 12, label %140
    i5 13, label %149
    i5 14, label %158
    i5 15, label %167
    i5 -16, label %176
    i5 -15, label %180
    i5 -14, label %187
    i5 -13, label %194
    i5 -12, label %201
    i5 -11, label %208
    i5 -10, label %215
    i5 -9, label %222
    i5 -8, label %229
    i5 -7, label %236
    i5 -6, label %243
    i5 -5, label %250
    i5 -4, label %257
    i5 -3, label %264
    i5 -2, label %271
  ]

39:                                               ; preds = %37
  br i1 false, label %40, label %283

40:                                               ; preds = %39
  unreachable

41:                                               ; preds = %37
  %42 = phi i128 [ 256, %37 ]
  %43 = phi i252 [ 1329227995784915872903807060280344576, %37 ]
  %44 = insertvalue { i128, i252 } undef, i128 %42, 0
  %45 = insertvalue { i128, i252 } %44, i252 %43, 1
  %46 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %45, 1
  store { i2, { i128, i252 } } %46, ptr %33, align 16
  %47 = load { i128, [48 x i8] }, ptr %33, align 16
  %48 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %49 = insertvalue { i64, { i128, [48 x i8] } } %48, { i128, [48 x i8] } %47, 1
  ret { i64, { i128, [48 x i8] } } %49

50:                                               ; preds = %37
  %51 = phi i128 [ 65536, %37 ]
  %52 = phi i252 [ 5192296858534827628530496329220096, %37 ]
  %53 = insertvalue { i128, i252 } undef, i128 %51, 0
  %54 = insertvalue { i128, i252 } %53, i252 %52, 1
  %55 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %54, 1
  store { i2, { i128, i252 } } %55, ptr %32, align 16
  %56 = load { i128, [48 x i8] }, ptr %32, align 16
  %57 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %58 = insertvalue { i64, { i128, [48 x i8] } } %57, { i128, [48 x i8] } %56, 1
  ret { i64, { i128, [48 x i8] } } %58

59:                                               ; preds = %37
  %60 = phi i128 [ 16777216, %37 ]
  %61 = phi i252 [ 20282409603651670423947251286016, %37 ]
  %62 = insertvalue { i128, i252 } undef, i128 %60, 0
  %63 = insertvalue { i128, i252 } %62, i252 %61, 1
  %64 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %63, 1
  store { i2, { i128, i252 } } %64, ptr %31, align 16
  %65 = load { i128, [48 x i8] }, ptr %31, align 16
  %66 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %67 = insertvalue { i64, { i128, [48 x i8] } } %66, { i128, [48 x i8] } %65, 1
  ret { i64, { i128, [48 x i8] } } %67

68:                                               ; preds = %37
  %69 = phi i128 [ 4294967296, %37 ]
  %70 = phi i252 [ 79228162514264337593543950336, %37 ]
  %71 = insertvalue { i128, i252 } undef, i128 %69, 0
  %72 = insertvalue { i128, i252 } %71, i252 %70, 1
  %73 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %72, 1
  store { i2, { i128, i252 } } %73, ptr %30, align 16
  %74 = load { i128, [48 x i8] }, ptr %30, align 16
  %75 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %76 = insertvalue { i64, { i128, [48 x i8] } } %75, { i128, [48 x i8] } %74, 1
  ret { i64, { i128, [48 x i8] } } %76

77:                                               ; preds = %37
  %78 = phi i128 [ 1099511627776, %37 ]
  %79 = phi i252 [ 309485009821345068724781056, %37 ]
  %80 = insertvalue { i128, i252 } undef, i128 %78, 0
  %81 = insertvalue { i128, i252 } %80, i252 %79, 1
  %82 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %81, 1
  store { i2, { i128, i252 } } %82, ptr %29, align 16
  %83 = load { i128, [48 x i8] }, ptr %29, align 16
  %84 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %85 = insertvalue { i64, { i128, [48 x i8] } } %84, { i128, [48 x i8] } %83, 1
  ret { i64, { i128, [48 x i8] } } %85

86:                                               ; preds = %37
  %87 = phi i128 [ 281474976710656, %37 ]
  %88 = phi i252 [ 1208925819614629174706176, %37 ]
  %89 = insertvalue { i128, i252 } undef, i128 %87, 0
  %90 = insertvalue { i128, i252 } %89, i252 %88, 1
  %91 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %90, 1
  store { i2, { i128, i252 } } %91, ptr %28, align 16
  %92 = load { i128, [48 x i8] }, ptr %28, align 16
  %93 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %94 = insertvalue { i64, { i128, [48 x i8] } } %93, { i128, [48 x i8] } %92, 1
  ret { i64, { i128, [48 x i8] } } %94

95:                                               ; preds = %37
  %96 = phi i128 [ 72057594037927936, %37 ]
  %97 = phi i252 [ 4722366482869645213696, %37 ]
  %98 = insertvalue { i128, i252 } undef, i128 %96, 0
  %99 = insertvalue { i128, i252 } %98, i252 %97, 1
  %100 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %99, 1
  store { i2, { i128, i252 } } %100, ptr %27, align 16
  %101 = load { i128, [48 x i8] }, ptr %27, align 16
  %102 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %103 = insertvalue { i64, { i128, [48 x i8] } } %102, { i128, [48 x i8] } %101, 1
  ret { i64, { i128, [48 x i8] } } %103

104:                                              ; preds = %37
  %105 = phi i128 [ 18446744073709551616, %37 ]
  %106 = phi i252 [ 18446744073709551616, %37 ]
  %107 = insertvalue { i128, i252 } undef, i128 %105, 0
  %108 = insertvalue { i128, i252 } %107, i252 %106, 1
  %109 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %108, 1
  store { i2, { i128, i252 } } %109, ptr %26, align 16
  %110 = load { i128, [48 x i8] }, ptr %26, align 16
  %111 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %112 = insertvalue { i64, { i128, [48 x i8] } } %111, { i128, [48 x i8] } %110, 1
  ret { i64, { i128, [48 x i8] } } %112

113:                                              ; preds = %37
  %114 = phi i128 [ 4722366482869645213696, %37 ]
  %115 = phi i252 [ 72057594037927936, %37 ]
  %116 = insertvalue { i128, i252 } undef, i128 %114, 0
  %117 = insertvalue { i128, i252 } %116, i252 %115, 1
  %118 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %117, 1
  store { i2, { i128, i252 } } %118, ptr %25, align 16
  %119 = load { i128, [48 x i8] }, ptr %25, align 16
  %120 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %121 = insertvalue { i64, { i128, [48 x i8] } } %120, { i128, [48 x i8] } %119, 1
  ret { i64, { i128, [48 x i8] } } %121

122:                                              ; preds = %37
  %123 = phi i128 [ 1208925819614629174706176, %37 ]
  %124 = phi i252 [ 281474976710656, %37 ]
  %125 = insertvalue { i128, i252 } undef, i128 %123, 0
  %126 = insertvalue { i128, i252 } %125, i252 %124, 1
  %127 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %126, 1
  store { i2, { i128, i252 } } %127, ptr %24, align 16
  %128 = load { i128, [48 x i8] }, ptr %24, align 16
  %129 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %130 = insertvalue { i64, { i128, [48 x i8] } } %129, { i128, [48 x i8] } %128, 1
  ret { i64, { i128, [48 x i8] } } %130

131:                                              ; preds = %37
  %132 = phi i128 [ 309485009821345068724781056, %37 ]
  %133 = phi i252 [ 1099511627776, %37 ]
  %134 = insertvalue { i128, i252 } undef, i128 %132, 0
  %135 = insertvalue { i128, i252 } %134, i252 %133, 1
  %136 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %135, 1
  store { i2, { i128, i252 } } %136, ptr %23, align 16
  %137 = load { i128, [48 x i8] }, ptr %23, align 16
  %138 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %139 = insertvalue { i64, { i128, [48 x i8] } } %138, { i128, [48 x i8] } %137, 1
  ret { i64, { i128, [48 x i8] } } %139

140:                                              ; preds = %37
  %141 = phi i128 [ 79228162514264337593543950336, %37 ]
  %142 = phi i252 [ 4294967296, %37 ]
  %143 = insertvalue { i128, i252 } undef, i128 %141, 0
  %144 = insertvalue { i128, i252 } %143, i252 %142, 1
  %145 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %144, 1
  store { i2, { i128, i252 } } %145, ptr %22, align 16
  %146 = load { i128, [48 x i8] }, ptr %22, align 16
  %147 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %148 = insertvalue { i64, { i128, [48 x i8] } } %147, { i128, [48 x i8] } %146, 1
  ret { i64, { i128, [48 x i8] } } %148

149:                                              ; preds = %37
  %150 = phi i128 [ 20282409603651670423947251286016, %37 ]
  %151 = phi i252 [ 16777216, %37 ]
  %152 = insertvalue { i128, i252 } undef, i128 %150, 0
  %153 = insertvalue { i128, i252 } %152, i252 %151, 1
  %154 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %153, 1
  store { i2, { i128, i252 } } %154, ptr %21, align 16
  %155 = load { i128, [48 x i8] }, ptr %21, align 16
  %156 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %157 = insertvalue { i64, { i128, [48 x i8] } } %156, { i128, [48 x i8] } %155, 1
  ret { i64, { i128, [48 x i8] } } %157

158:                                              ; preds = %37
  %159 = phi i128 [ 5192296858534827628530496329220096, %37 ]
  %160 = phi i252 [ 65536, %37 ]
  %161 = insertvalue { i128, i252 } undef, i128 %159, 0
  %162 = insertvalue { i128, i252 } %161, i252 %160, 1
  %163 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %162, 1
  store { i2, { i128, i252 } } %163, ptr %20, align 16
  %164 = load { i128, [48 x i8] }, ptr %20, align 16
  %165 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %166 = insertvalue { i64, { i128, [48 x i8] } } %165, { i128, [48 x i8] } %164, 1
  ret { i64, { i128, [48 x i8] } } %166

167:                                              ; preds = %37
  %168 = phi i128 [ 1329227995784915872903807060280344576, %37 ]
  %169 = phi i252 [ 256, %37 ]
  %170 = insertvalue { i128, i252 } undef, i128 %168, 0
  %171 = insertvalue { i128, i252 } %170, i252 %169, 1
  %172 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %171, 1
  store { i2, { i128, i252 } } %172, ptr %19, align 16
  %173 = load { i128, [48 x i8] }, ptr %19, align 16
  %174 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %175 = insertvalue { i64, { i128, [48 x i8] } } %174, { i128, [48 x i8] } %173, 1
  ret { i64, { i128, [48 x i8] } } %175

176:                                              ; preds = %37
  store { i2, [0 x i8] } { i2 0, [0 x i8] undef }, ptr %18, align 1
  %177 = load { i128, [48 x i8] }, ptr %18, align 16
  %178 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %179 = insertvalue { i64, { i128, [48 x i8] } } %178, { i128, [48 x i8] } %177, 1
  ret { i64, { i128, [48 x i8] } } %179

180:                                              ; preds = %37
  %181 = phi i128 [ 256, %37 ]
  %182 = insertvalue { i128 } undef, i128 %181, 0
  %183 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %182, 1
  store { i2, { i128 } } %183, ptr %17, align 16
  %184 = load { i128, [48 x i8] }, ptr %17, align 16
  %185 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %186 = insertvalue { i64, { i128, [48 x i8] } } %185, { i128, [48 x i8] } %184, 1
  ret { i64, { i128, [48 x i8] } } %186

187:                                              ; preds = %37
  %188 = phi i128 [ 65536, %37 ]
  %189 = insertvalue { i128 } undef, i128 %188, 0
  %190 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %189, 1
  store { i2, { i128 } } %190, ptr %16, align 16
  %191 = load { i128, [48 x i8] }, ptr %16, align 16
  %192 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %193 = insertvalue { i64, { i128, [48 x i8] } } %192, { i128, [48 x i8] } %191, 1
  ret { i64, { i128, [48 x i8] } } %193

194:                                              ; preds = %37
  %195 = phi i128 [ 16777216, %37 ]
  %196 = insertvalue { i128 } undef, i128 %195, 0
  %197 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %196, 1
  store { i2, { i128 } } %197, ptr %15, align 16
  %198 = load { i128, [48 x i8] }, ptr %15, align 16
  %199 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %200 = insertvalue { i64, { i128, [48 x i8] } } %199, { i128, [48 x i8] } %198, 1
  ret { i64, { i128, [48 x i8] } } %200

201:                                              ; preds = %37
  %202 = phi i128 [ 4294967296, %37 ]
  %203 = insertvalue { i128 } undef, i128 %202, 0
  %204 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %203, 1
  store { i2, { i128 } } %204, ptr %14, align 16
  %205 = load { i128, [48 x i8] }, ptr %14, align 16
  %206 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %207 = insertvalue { i64, { i128, [48 x i8] } } %206, { i128, [48 x i8] } %205, 1
  ret { i64, { i128, [48 x i8] } } %207

208:                                              ; preds = %37
  %209 = phi i128 [ 1099511627776, %37 ]
  %210 = insertvalue { i128 } undef, i128 %209, 0
  %211 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %210, 1
  store { i2, { i128 } } %211, ptr %13, align 16
  %212 = load { i128, [48 x i8] }, ptr %13, align 16
  %213 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %214 = insertvalue { i64, { i128, [48 x i8] } } %213, { i128, [48 x i8] } %212, 1
  ret { i64, { i128, [48 x i8] } } %214

215:                                              ; preds = %37
  %216 = phi i128 [ 281474976710656, %37 ]
  %217 = insertvalue { i128 } undef, i128 %216, 0
  %218 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %217, 1
  store { i2, { i128 } } %218, ptr %12, align 16
  %219 = load { i128, [48 x i8] }, ptr %12, align 16
  %220 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %221 = insertvalue { i64, { i128, [48 x i8] } } %220, { i128, [48 x i8] } %219, 1
  ret { i64, { i128, [48 x i8] } } %221

222:                                              ; preds = %37
  %223 = phi i128 [ 72057594037927936, %37 ]
  %224 = insertvalue { i128 } undef, i128 %223, 0
  %225 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %224, 1
  store { i2, { i128 } } %225, ptr %11, align 16
  %226 = load { i128, [48 x i8] }, ptr %11, align 16
  %227 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %228 = insertvalue { i64, { i128, [48 x i8] } } %227, { i128, [48 x i8] } %226, 1
  ret { i64, { i128, [48 x i8] } } %228

229:                                              ; preds = %37
  %230 = phi i128 [ 18446744073709551616, %37 ]
  %231 = insertvalue { i128 } undef, i128 %230, 0
  %232 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %231, 1
  store { i2, { i128 } } %232, ptr %10, align 16
  %233 = load { i128, [48 x i8] }, ptr %10, align 16
  %234 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %235 = insertvalue { i64, { i128, [48 x i8] } } %234, { i128, [48 x i8] } %233, 1
  ret { i64, { i128, [48 x i8] } } %235

236:                                              ; preds = %37
  %237 = phi i128 [ 4722366482869645213696, %37 ]
  %238 = insertvalue { i128 } undef, i128 %237, 0
  %239 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %238, 1
  store { i2, { i128 } } %239, ptr %9, align 16
  %240 = load { i128, [48 x i8] }, ptr %9, align 16
  %241 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %242 = insertvalue { i64, { i128, [48 x i8] } } %241, { i128, [48 x i8] } %240, 1
  ret { i64, { i128, [48 x i8] } } %242

243:                                              ; preds = %37
  %244 = phi i128 [ 1208925819614629174706176, %37 ]
  %245 = insertvalue { i128 } undef, i128 %244, 0
  %246 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %245, 1
  store { i2, { i128 } } %246, ptr %8, align 16
  %247 = load { i128, [48 x i8] }, ptr %8, align 16
  %248 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %249 = insertvalue { i64, { i128, [48 x i8] } } %248, { i128, [48 x i8] } %247, 1
  ret { i64, { i128, [48 x i8] } } %249

250:                                              ; preds = %37
  %251 = phi i128 [ 309485009821345068724781056, %37 ]
  %252 = insertvalue { i128 } undef, i128 %251, 0
  %253 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %252, 1
  store { i2, { i128 } } %253, ptr %7, align 16
  %254 = load { i128, [48 x i8] }, ptr %7, align 16
  %255 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %256 = insertvalue { i64, { i128, [48 x i8] } } %255, { i128, [48 x i8] } %254, 1
  ret { i64, { i128, [48 x i8] } } %256

257:                                              ; preds = %37
  %258 = phi i128 [ 79228162514264337593543950336, %37 ]
  %259 = insertvalue { i128 } undef, i128 %258, 0
  %260 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %259, 1
  store { i2, { i128 } } %260, ptr %6, align 16
  %261 = load { i128, [48 x i8] }, ptr %6, align 16
  %262 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %263 = insertvalue { i64, { i128, [48 x i8] } } %262, { i128, [48 x i8] } %261, 1
  ret { i64, { i128, [48 x i8] } } %263

264:                                              ; preds = %37
  %265 = phi i128 [ 20282409603651670423947251286016, %37 ]
  %266 = insertvalue { i128 } undef, i128 %265, 0
  %267 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %266, 1
  store { i2, { i128 } } %267, ptr %5, align 16
  %268 = load { i128, [48 x i8] }, ptr %5, align 16
  %269 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %270 = insertvalue { i64, { i128, [48 x i8] } } %269, { i128, [48 x i8] } %268, 1
  ret { i64, { i128, [48 x i8] } } %270

271:                                              ; preds = %37
  %272 = phi i128 [ 5192296858534827628530496329220096, %37 ]
  %273 = insertvalue { i128 } undef, i128 %272, 0
  %274 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %273, 1
  store { i2, { i128 } } %274, ptr %4, align 16
  %275 = load { i128, [48 x i8] }, ptr %4, align 16
  %276 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %277 = insertvalue { i64, { i128, [48 x i8] } } %276, { i128, [48 x i8] } %275, 1
  ret { i64, { i128, [48 x i8] } } %277

278:                                              ; preds = %37, %2
  %279 = phi i64 [ %35, %37 ], [ %35, %2 ]
  store { i2, [0 x i8] } { i2 -1, [0 x i8] undef }, ptr %3, align 1
  %280 = load { i128, [48 x i8] }, ptr %3, align 16
  %281 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %279, 0
  %282 = insertvalue { i64, { i128, [48 x i8] } } %281, { i128, [48 x i8] } %280, 1
  ret { i64, { i128, [48 x i8] } } %282

283:                                              ; preds = %39
  call void @puts(ptr @assert_msg_147)
  call void @abort()
  unreachable
}

define private { i64, { i128, [48 x i8] } } @f80(i64 %0, i32 %1) {
  %3 = call fastcc { i64, { i128, [48 x i8] } } @"impl$f80"(i64 %0, i32 %1)
  %4 = extractvalue { i64, { i128, [48 x i8] } } %3, 0
  %5 = extractvalue { i64, { i128, [48 x i8] } } %3, 1
  %6 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i128, [48 x i8] } } %6, { i128, [48 x i8] } %5, 1
  ret { i64, { i128, [48 x i8] } } %7
}

define void @_mlir_ciface_f80(ptr %0, i64 %1, i32 %2) {
  %4 = call { i64, { i128, [48 x i8] } } @f80(i64 %1, i32 %2)
  store { i64, { i128, [48 x i8] } } %4, ptr %0, align 16
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f81"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 1995392260568499387643902728889710)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f81() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f81"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f81(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f81()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f82"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 155785504329508738615720351733824384887)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f82() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f82"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f82(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f82()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$49"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$49"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %12

12:                                               ; preds = %84, %4
  %13 = phi i64 [ %17, %84 ], [ %0, %4 ]
  %14 = phi i64 [ %42, %84 ], [ %1, %4 ]
  %15 = phi { { ptr, i32, i32, i32 } } [ %95, %84 ], [ %2, %4 ]
  %16 = phi { ptr, i32, i32, i32 } [ %93, %84 ], [ %3, %4 ]
  %17 = add i64 %13, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 1570
  %22 = icmp uge i64 %14, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %14, i64 %21)
  br i1 %22, label %24, label %133

24:                                               ; preds = %12
  %25 = phi { { ptr, i32, i32, i32 } } [ %15, %12 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %113

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 0)
  %43 = load i248, ptr %39, align 16
  call void @free(ptr %39)
  %44 = zext i248 %43 to i252
  %45 = extractvalue { ptr, i32, i32, i32 } %16, 3
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %47, label %61

47:                                               ; preds = %31
  %48 = shl i32 %45, 1
  %49 = call i32 @llvm.umin.i32(i32 %48, i32 1024)
  %50 = add i32 %49, %45
  %51 = call i32 @llvm.umax.i32(i32 %50, i32 8)
  %52 = zext i32 %51 to i64
  %53 = mul i64 %52, 32
  %54 = add i64 %53, 16
  %55 = call ptr @realloc(ptr null, i64 %54)
  store i32 1, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %55, i32 4
  store i32 0, ptr %56, align 4
  %57 = getelementptr inbounds i8, ptr %55, i32 16
  %58 = call ptr @realloc(ptr null, i64 8)
  store ptr %57, ptr %58, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } %16, ptr %58, 0
  %60 = insertvalue { ptr, i32, i32, i32 } %59, i32 %51, 3
  br label %82

61:                                               ; preds = %31
  %62 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %63 = icmp ult i32 %62, %45
  br i1 %63, label %64, label %65

64:                                               ; preds = %61
  br label %79

65:                                               ; preds = %61
  %66 = shl i32 %45, 1
  %67 = call i32 @llvm.umin.i32(i32 %66, i32 1024)
  %68 = add i32 %67, %45
  %69 = call i32 @llvm.umax.i32(i32 %68, i32 8)
  %70 = zext i32 %69 to i64
  %71 = mul i64 %70, 32
  %72 = add i64 %71, 16
  %73 = extractvalue { ptr, i32, i32, i32 } %16, 0
  %74 = load ptr, ptr %73, align 8
  %75 = getelementptr inbounds i8, ptr %74, i32 -16
  %76 = call ptr @realloc(ptr %75, i64 %72)
  %77 = getelementptr inbounds i8, ptr %76, i32 16
  store ptr %77, ptr %73, align 8
  %78 = insertvalue { ptr, i32, i32, i32 } %16, i32 %69, 3
  br label %79

79:                                               ; preds = %64, %65
  %80 = phi { ptr, i32, i32, i32 } [ %78, %65 ], [ %16, %64 ]
  br label %81

81:                                               ; preds = %79
  br label %82

82:                                               ; preds = %47, %81
  %83 = phi { ptr, i32, i32, i32 } [ %80, %81 ], [ %60, %47 ]
  br label %84

84:                                               ; preds = %82
  %85 = extractvalue { ptr, i32, i32, i32 } %83, 0
  %86 = load ptr, ptr %85, align 8
  %87 = extractvalue { ptr, i32, i32, i32 } %83, 2
  %88 = zext i32 %87 to i64
  %89 = mul i64 %88, 32
  %90 = getelementptr inbounds i8, ptr %86, i64 %89
  store i252 %44, ptr %90, align 16
  %91 = extractvalue { ptr, i32, i32, i32 } %83, 2
  %92 = add i32 %91, 1
  %93 = insertvalue { ptr, i32, i32, i32 } %83, i32 %92, 2
  %94 = getelementptr inbounds i8, ptr %86, i32 -12
  store i32 %92, ptr %94, align 4
  %95 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %38, 0
  %96 = extractvalue { ptr, ptr, i64 } %8, 1
  %97 = load i64, ptr %96, align 8
  %98 = add i64 %97, 1
  %99 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %98, ptr %99, align 8
  br label %12

100:                                              ; preds = %100, %113, %133
  %101 = phi i64 [ %17, %133 ], [ %17, %113 ], [ %101, %100 ]
  %102 = phi i64 [ %14, %133 ], [ %119, %113 ], [ %102, %100 ]
  %103 = phi { i64, [24 x i8] } [ %138, %133 ], [ %123, %113 ], [ %103, %100 ]
  %104 = extractvalue { ptr, ptr, i64 } %8, 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %105, 1
  %108 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %107, ptr %108, align 8
  br i1 %106, label %109, label %100

109:                                              ; preds = %100
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %101, 0
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, i64 %102, 1
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %103, 2
  ret { i64, i64, { i64, [24 x i8] } } %112

113:                                              ; preds = %24
  %114 = phi { ptr, i32, i32, i32 } [ %26, %24 ]
  call void @"drop$163"({ ptr, i32, i32, i32 } %114)
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 2270
  %119 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %118)
  %120 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %16, 0
  %121 = insertvalue { { ptr, i32, i32, i32 }, {} } %120, {} undef, 1
  %122 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %121, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %122, ptr %11, align 8
  %123 = load { i64, [24 x i8] }, ptr %11, align 8
  %124 = extractvalue { ptr, ptr, i64 } %8, 1
  %125 = load i64, ptr %124, align 8
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %125, 1
  %128 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %127, ptr %128, align 8
  br i1 %126, label %129, label %100

129:                                              ; preds = %113
  %130 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %131 = insertvalue { i64, i64, { i64, [24 x i8] } } %130, i64 %119, 1
  %132 = insertvalue { i64, i64, { i64, [24 x i8] } } %131, { i64, [24 x i8] } %123, 2
  ret { i64, i64, { i64, [24 x i8] } } %132

133:                                              ; preds = %12
  %134 = phi { ptr, i32, i32, i32 } [ %16, %12 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %134)
  call void @"drop$164"({ { ptr, i32, i32, i32 } } %15)
  %135 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %136 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %135, 0
  %137 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %136, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %137, ptr %10, align 8
  %138 = load { i64, [24 x i8] }, ptr %10, align 8
  %139 = extractvalue { ptr, ptr, i64 } %8, 1
  %140 = load i64, ptr %139, align 8
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %140, 1
  %143 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %142, ptr %143, align 8
  br i1 %141, label %144, label %100

144:                                              ; preds = %133
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %146 = insertvalue { i64, i64, { i64, [24 x i8] } } %145, i64 %14, 1
  %147 = insertvalue { i64, i64, { i64, [24 x i8] } } %146, { i64, [24 x i8] } %138, 2
  ret { i64, i64, { i64, [24 x i8] } } %147
}

define private { i64, i64, { i64, [24 x i8] } } @f83(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f83(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f83(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, 1
  %12 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %10)
  %13 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 1
  %15 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %14, 0
  %16 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %15)
  %17 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %16, 0
  %18 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %16, 1
  %19 = extractvalue { ptr, i32, i32, i32 } %18, 1
  %20 = extractvalue { ptr, i32, i32, i32 } %18, 2
  %21 = sub i32 %20, %19
  call void @"drop$163"({ ptr, i32, i32, i32 } %18)
  %22 = zext i32 %21 to i252
  %23 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %39

25:                                               ; preds = %4
  %26 = shl i32 %23, 1
  %27 = call i32 @llvm.umin.i32(i32 %26, i32 1024)
  %28 = add i32 %27, %23
  %29 = call i32 @llvm.umax.i32(i32 %28, i32 8)
  %30 = zext i32 %29 to i64
  %31 = mul i64 %30, 32
  %32 = add i64 %31, 16
  %33 = call ptr @realloc(ptr null, i64 %32)
  store i32 1, ptr %33, align 4
  %34 = getelementptr inbounds i8, ptr %33, i32 4
  store i32 0, ptr %34, align 4
  %35 = getelementptr inbounds i8, ptr %33, i32 16
  %36 = call ptr @realloc(ptr null, i64 8)
  store ptr %35, ptr %36, align 8
  %37 = insertvalue { ptr, i32, i32, i32 } %3, ptr %36, 0
  %38 = insertvalue { ptr, i32, i32, i32 } %37, i32 %29, 3
  br label %60

39:                                               ; preds = %4
  %40 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %41 = icmp ult i32 %40, %23
  br i1 %41, label %42, label %43

42:                                               ; preds = %39
  br label %57

43:                                               ; preds = %39
  %44 = shl i32 %23, 1
  %45 = call i32 @llvm.umin.i32(i32 %44, i32 1024)
  %46 = add i32 %45, %23
  %47 = call i32 @llvm.umax.i32(i32 %46, i32 8)
  %48 = zext i32 %47 to i64
  %49 = mul i64 %48, 32
  %50 = add i64 %49, 16
  %51 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr inbounds i8, ptr %52, i32 -16
  %54 = call ptr @realloc(ptr %53, i64 %50)
  %55 = getelementptr inbounds i8, ptr %54, i32 16
  store ptr %55, ptr %51, align 8
  %56 = insertvalue { ptr, i32, i32, i32 } %3, i32 %47, 3
  br label %57

57:                                               ; preds = %42, %43
  %58 = phi { ptr, i32, i32, i32 } [ %56, %43 ], [ %3, %42 ]
  br label %59

59:                                               ; preds = %57
  br label %60

60:                                               ; preds = %25, %59
  %61 = phi { ptr, i32, i32, i32 } [ %58, %59 ], [ %38, %25 ]
  br label %62

62:                                               ; preds = %60
  %63 = extractvalue { ptr, i32, i32, i32 } %61, 0
  %64 = load ptr, ptr %63, align 8
  %65 = extractvalue { ptr, i32, i32, i32 } %61, 2
  %66 = zext i32 %65 to i64
  %67 = mul i64 %66, 32
  %68 = getelementptr inbounds i8, ptr %64, i64 %67
  store i252 %22, ptr %68, align 16
  %69 = extractvalue { ptr, i32, i32, i32 } %61, 2
  %70 = add i32 %69, 1
  %71 = insertvalue { ptr, i32, i32, i32 } %61, i32 %70, 2
  %72 = getelementptr inbounds i8, ptr %64, i32 -12
  store i32 %70, ptr %72, align 4
  %73 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %17, 0
  %74 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %73, { ptr, i32, i32, i32 } %71)
  %75 = extractvalue { i64, i64, { i64, [24 x i8] } } %74, 0
  %76 = extractvalue { i64, i64, { i64, [24 x i8] } } %74, 1
  %77 = extractvalue { i64, i64, { i64, [24 x i8] } } %74, 2
  store { i64, [24 x i8] } %77, ptr %5, align 8
  %78 = load i1, ptr %5, align 1
  switch i1 %78, label %79 [
    i1 false, label %81
    i1 true, label %258
  ]

79:                                               ; preds = %62
  br i1 false, label %80, label %397

80:                                               ; preds = %79
  unreachable

81:                                               ; preds = %62
  %82 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %83 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %82, 1
  %84 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %13)
  %85 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %84, 0
  %86 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %84, 1
  %87 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %86, 0
  %88 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %86, 2
  call void @"drop$163"({ ptr, i32, i32, i32 } %87)
  %89 = zext i32 %88 to i252
  %90 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %11)
  %91 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %90, 0
  %92 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %90, 1
  %93 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %92, 0
  %94 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %93)
  %95 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %94, 0
  %96 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %94, 1
  %97 = extractvalue { ptr, i32, i32, i32 } %96, 1
  %98 = extractvalue { ptr, i32, i32, i32 } %96, 2
  %99 = sub i32 %98, %97
  call void @"drop$163"({ ptr, i32, i32, i32 } %96)
  %100 = zext i32 %99 to i252
  %101 = extractvalue { { ptr, i32, i32, i32 }, {} } %83, 0
  %102 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %85, 0
  %103 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %85, 1
  call void @"drop$163"({ ptr, i32, i32, i32 } %102)
  %104 = extractvalue { ptr, i32, i32, i32 } %101, 3
  %105 = icmp eq i32 %104, 0
  br i1 %105, label %106, label %120

106:                                              ; preds = %81
  %107 = shl i32 %104, 1
  %108 = call i32 @llvm.umin.i32(i32 %107, i32 1024)
  %109 = add i32 %108, %104
  %110 = call i32 @llvm.umax.i32(i32 %109, i32 8)
  %111 = zext i32 %110 to i64
  %112 = mul i64 %111, 32
  %113 = add i64 %112, 16
  %114 = call ptr @realloc(ptr null, i64 %113)
  store i32 1, ptr %114, align 4
  %115 = getelementptr inbounds i8, ptr %114, i32 4
  store i32 0, ptr %115, align 4
  %116 = getelementptr inbounds i8, ptr %114, i32 16
  %117 = call ptr @realloc(ptr null, i64 8)
  store ptr %116, ptr %117, align 8
  %118 = insertvalue { ptr, i32, i32, i32 } %101, ptr %117, 0
  %119 = insertvalue { ptr, i32, i32, i32 } %118, i32 %110, 3
  br label %141

120:                                              ; preds = %81
  %121 = extractvalue { ptr, i32, i32, i32 } %101, 2
  %122 = icmp ult i32 %121, %104
  br i1 %122, label %123, label %124

123:                                              ; preds = %120
  br label %138

124:                                              ; preds = %120
  %125 = shl i32 %104, 1
  %126 = call i32 @llvm.umin.i32(i32 %125, i32 1024)
  %127 = add i32 %126, %104
  %128 = call i32 @llvm.umax.i32(i32 %127, i32 8)
  %129 = zext i32 %128 to i64
  %130 = mul i64 %129, 32
  %131 = add i64 %130, 16
  %132 = extractvalue { ptr, i32, i32, i32 } %101, 0
  %133 = load ptr, ptr %132, align 8
  %134 = getelementptr inbounds i8, ptr %133, i32 -16
  %135 = call ptr @realloc(ptr %134, i64 %131)
  %136 = getelementptr inbounds i8, ptr %135, i32 16
  store ptr %136, ptr %132, align 8
  %137 = insertvalue { ptr, i32, i32, i32 } %101, i32 %128, 3
  br label %138

138:                                              ; preds = %123, %124
  %139 = phi { ptr, i32, i32, i32 } [ %137, %124 ], [ %101, %123 ]
  br label %140

140:                                              ; preds = %138
  br label %141

141:                                              ; preds = %106, %140
  %142 = phi { ptr, i32, i32, i32 } [ %139, %140 ], [ %119, %106 ]
  br label %143

143:                                              ; preds = %141
  %144 = extractvalue { ptr, i32, i32, i32 } %142, 0
  %145 = load ptr, ptr %144, align 8
  %146 = extractvalue { ptr, i32, i32, i32 } %142, 2
  %147 = zext i32 %146 to i64
  %148 = mul i64 %147, 32
  %149 = getelementptr inbounds i8, ptr %145, i64 %148
  store i252 %103, ptr %149, align 16
  %150 = extractvalue { ptr, i32, i32, i32 } %142, 2
  %151 = add i32 %150, 1
  %152 = insertvalue { ptr, i32, i32, i32 } %142, i32 %151, 2
  %153 = getelementptr inbounds i8, ptr %145, i32 -12
  store i32 %151, ptr %153, align 4
  %154 = extractvalue { ptr, i32, i32, i32 } %142, 3
  %155 = icmp eq i32 %154, 0
  br i1 %155, label %156, label %170

156:                                              ; preds = %143
  %157 = shl i32 %154, 1
  %158 = call i32 @llvm.umin.i32(i32 %157, i32 1024)
  %159 = add i32 %158, %154
  %160 = call i32 @llvm.umax.i32(i32 %159, i32 8)
  %161 = zext i32 %160 to i64
  %162 = mul i64 %161, 32
  %163 = add i64 %162, 16
  %164 = call ptr @realloc(ptr null, i64 %163)
  store i32 1, ptr %164, align 4
  %165 = getelementptr inbounds i8, ptr %164, i32 4
  store i32 0, ptr %165, align 4
  %166 = getelementptr inbounds i8, ptr %164, i32 16
  %167 = call ptr @realloc(ptr null, i64 8)
  store ptr %166, ptr %167, align 8
  %168 = insertvalue { ptr, i32, i32, i32 } %152, ptr %167, 0
  %169 = insertvalue { ptr, i32, i32, i32 } %168, i32 %160, 3
  br label %190

170:                                              ; preds = %143
  %171 = icmp ult i32 %151, %154
  br i1 %171, label %172, label %173

172:                                              ; preds = %170
  br label %187

173:                                              ; preds = %170
  %174 = shl i32 %154, 1
  %175 = call i32 @llvm.umin.i32(i32 %174, i32 1024)
  %176 = add i32 %175, %154
  %177 = call i32 @llvm.umax.i32(i32 %176, i32 8)
  %178 = zext i32 %177 to i64
  %179 = mul i64 %178, 32
  %180 = add i64 %179, 16
  %181 = extractvalue { ptr, i32, i32, i32 } %142, 0
  %182 = load ptr, ptr %181, align 8
  %183 = getelementptr inbounds i8, ptr %182, i32 -16
  %184 = call ptr @realloc(ptr %183, i64 %180)
  %185 = getelementptr inbounds i8, ptr %184, i32 16
  store ptr %185, ptr %181, align 8
  %186 = insertvalue { ptr, i32, i32, i32 } %152, i32 %177, 3
  br label %187

187:                                              ; preds = %172, %173
  %188 = phi { ptr, i32, i32, i32 } [ %186, %173 ], [ %152, %172 ]
  br label %189

189:                                              ; preds = %187
  br label %190

190:                                              ; preds = %156, %189
  %191 = phi { ptr, i32, i32, i32 } [ %188, %189 ], [ %169, %156 ]
  br label %192

192:                                              ; preds = %190
  %193 = extractvalue { ptr, i32, i32, i32 } %191, 0
  %194 = load ptr, ptr %193, align 8
  %195 = extractvalue { ptr, i32, i32, i32 } %191, 2
  %196 = zext i32 %195 to i64
  %197 = mul i64 %196, 32
  %198 = getelementptr inbounds i8, ptr %194, i64 %197
  store i252 %89, ptr %198, align 16
  %199 = extractvalue { ptr, i32, i32, i32 } %191, 2
  %200 = add i32 %199, 1
  %201 = insertvalue { ptr, i32, i32, i32 } %191, i32 %200, 2
  %202 = getelementptr inbounds i8, ptr %194, i32 -12
  store i32 %200, ptr %202, align 4
  %203 = extractvalue { ptr, i32, i32, i32 } %191, 3
  %204 = icmp eq i32 %203, 0
  br i1 %204, label %205, label %219

205:                                              ; preds = %192
  %206 = shl i32 %203, 1
  %207 = call i32 @llvm.umin.i32(i32 %206, i32 1024)
  %208 = add i32 %207, %203
  %209 = call i32 @llvm.umax.i32(i32 %208, i32 8)
  %210 = zext i32 %209 to i64
  %211 = mul i64 %210, 32
  %212 = add i64 %211, 16
  %213 = call ptr @realloc(ptr null, i64 %212)
  store i32 1, ptr %213, align 4
  %214 = getelementptr inbounds i8, ptr %213, i32 4
  store i32 0, ptr %214, align 4
  %215 = getelementptr inbounds i8, ptr %213, i32 16
  %216 = call ptr @realloc(ptr null, i64 8)
  store ptr %215, ptr %216, align 8
  %217 = insertvalue { ptr, i32, i32, i32 } %201, ptr %216, 0
  %218 = insertvalue { ptr, i32, i32, i32 } %217, i32 %209, 3
  br label %239

219:                                              ; preds = %192
  %220 = icmp ult i32 %200, %203
  br i1 %220, label %221, label %222

221:                                              ; preds = %219
  br label %236

222:                                              ; preds = %219
  %223 = shl i32 %203, 1
  %224 = call i32 @llvm.umin.i32(i32 %223, i32 1024)
  %225 = add i32 %224, %203
  %226 = call i32 @llvm.umax.i32(i32 %225, i32 8)
  %227 = zext i32 %226 to i64
  %228 = mul i64 %227, 32
  %229 = add i64 %228, 16
  %230 = extractvalue { ptr, i32, i32, i32 } %191, 0
  %231 = load ptr, ptr %230, align 8
  %232 = getelementptr inbounds i8, ptr %231, i32 -16
  %233 = call ptr @realloc(ptr %232, i64 %229)
  %234 = getelementptr inbounds i8, ptr %233, i32 16
  store ptr %234, ptr %230, align 8
  %235 = insertvalue { ptr, i32, i32, i32 } %201, i32 %226, 3
  br label %236

236:                                              ; preds = %221, %222
  %237 = phi { ptr, i32, i32, i32 } [ %235, %222 ], [ %201, %221 ]
  br label %238

238:                                              ; preds = %236
  br label %239

239:                                              ; preds = %205, %238
  %240 = phi { ptr, i32, i32, i32 } [ %237, %238 ], [ %218, %205 ]
  br label %241

241:                                              ; preds = %239
  %242 = extractvalue { ptr, i32, i32, i32 } %240, 0
  %243 = load ptr, ptr %242, align 8
  %244 = extractvalue { ptr, i32, i32, i32 } %240, 2
  %245 = zext i32 %244 to i64
  %246 = mul i64 %245, 32
  %247 = getelementptr inbounds i8, ptr %243, i64 %246
  store i252 %100, ptr %247, align 16
  %248 = extractvalue { ptr, i32, i32, i32 } %240, 2
  %249 = add i32 %248, 1
  %250 = insertvalue { ptr, i32, i32, i32 } %240, i32 %249, 2
  %251 = getelementptr inbounds i8, ptr %243, i32 -12
  store i32 %249, ptr %251, align 4
  %252 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %95, 0
  %253 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %75, i64 %76, { { ptr, i32, i32, i32 } } %252, { ptr, i32, i32, i32 } %250)
  %254 = extractvalue { i64, i64, { i64, [24 x i8] } } %253, 0
  %255 = extractvalue { i64, i64, { i64, [24 x i8] } } %253, 1
  %256 = extractvalue { i64, i64, { i64, [24 x i8] } } %253, 2
  store { i64, [24 x i8] } %256, ptr %7, align 8
  %257 = load i1, ptr %7, align 1
  switch i1 %257, label %266 [
    i1 false, label %268
    i1 true, label %389
  ]

258:                                              ; preds = %62
  %259 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %260 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %259, 1
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %11)
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %13)
  %261 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %260, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %261, ptr %6, align 8
  %262 = load { i64, [24 x i8] }, ptr %6, align 8
  %263 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %75, 0
  %264 = insertvalue { i64, i64, { i64, [24 x i8] } } %263, i64 %76, 1
  %265 = insertvalue { i64, i64, { i64, [24 x i8] } } %264, { i64, [24 x i8] } %262, 2
  ret { i64, i64, { i64, [24 x i8] } } %265

266:                                              ; preds = %241
  br i1 false, label %267, label %398

267:                                              ; preds = %266
  unreachable

268:                                              ; preds = %241
  %269 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %7, align 8
  %270 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %269, 1
  %271 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %272 = call ptr %271()
  %273 = call i64 @llvm.uadd.sat.i64(i64 %255, i64 0)
  %274 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %91)
  %275 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %274, 0
  %276 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %274, 1
  %277 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %276, 0
  %278 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %276, 2
  call void @"drop$163"({ ptr, i32, i32, i32 } %277)
  %279 = zext i32 %278 to i252
  %280 = extractvalue { { ptr, i32, i32, i32 }, {} } %270, 0
  %281 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %275, 0
  %282 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %275, 1
  call void @"drop$163"({ ptr, i32, i32, i32 } %281)
  %283 = extractvalue { ptr, i32, i32, i32 } %280, 3
  %284 = icmp eq i32 %283, 0
  br i1 %284, label %285, label %299

285:                                              ; preds = %268
  %286 = shl i32 %283, 1
  %287 = call i32 @llvm.umin.i32(i32 %286, i32 1024)
  %288 = add i32 %287, %283
  %289 = call i32 @llvm.umax.i32(i32 %288, i32 8)
  %290 = zext i32 %289 to i64
  %291 = mul i64 %290, 32
  %292 = add i64 %291, 16
  %293 = call ptr @realloc(ptr null, i64 %292)
  store i32 1, ptr %293, align 4
  %294 = getelementptr inbounds i8, ptr %293, i32 4
  store i32 0, ptr %294, align 4
  %295 = getelementptr inbounds i8, ptr %293, i32 16
  %296 = call ptr @realloc(ptr null, i64 8)
  store ptr %295, ptr %296, align 8
  %297 = insertvalue { ptr, i32, i32, i32 } %280, ptr %296, 0
  %298 = insertvalue { ptr, i32, i32, i32 } %297, i32 %289, 3
  br label %320

299:                                              ; preds = %268
  %300 = extractvalue { ptr, i32, i32, i32 } %280, 2
  %301 = icmp ult i32 %300, %283
  br i1 %301, label %302, label %303

302:                                              ; preds = %299
  br label %317

303:                                              ; preds = %299
  %304 = shl i32 %283, 1
  %305 = call i32 @llvm.umin.i32(i32 %304, i32 1024)
  %306 = add i32 %305, %283
  %307 = call i32 @llvm.umax.i32(i32 %306, i32 8)
  %308 = zext i32 %307 to i64
  %309 = mul i64 %308, 32
  %310 = add i64 %309, 16
  %311 = extractvalue { ptr, i32, i32, i32 } %280, 0
  %312 = load ptr, ptr %311, align 8
  %313 = getelementptr inbounds i8, ptr %312, i32 -16
  %314 = call ptr @realloc(ptr %313, i64 %310)
  %315 = getelementptr inbounds i8, ptr %314, i32 16
  store ptr %315, ptr %311, align 8
  %316 = insertvalue { ptr, i32, i32, i32 } %280, i32 %307, 3
  br label %317

317:                                              ; preds = %302, %303
  %318 = phi { ptr, i32, i32, i32 } [ %316, %303 ], [ %280, %302 ]
  br label %319

319:                                              ; preds = %317
  br label %320

320:                                              ; preds = %285, %319
  %321 = phi { ptr, i32, i32, i32 } [ %318, %319 ], [ %298, %285 ]
  br label %322

322:                                              ; preds = %320
  %323 = extractvalue { ptr, i32, i32, i32 } %321, 0
  %324 = load ptr, ptr %323, align 8
  %325 = extractvalue { ptr, i32, i32, i32 } %321, 2
  %326 = zext i32 %325 to i64
  %327 = mul i64 %326, 32
  %328 = getelementptr inbounds i8, ptr %324, i64 %327
  store i252 %282, ptr %328, align 16
  %329 = extractvalue { ptr, i32, i32, i32 } %321, 2
  %330 = add i32 %329, 1
  %331 = insertvalue { ptr, i32, i32, i32 } %321, i32 %330, 2
  %332 = getelementptr inbounds i8, ptr %324, i32 -12
  store i32 %330, ptr %332, align 4
  %333 = extractvalue { ptr, i32, i32, i32 } %321, 3
  %334 = icmp eq i32 %333, 0
  br i1 %334, label %335, label %349

335:                                              ; preds = %322
  %336 = shl i32 %333, 1
  %337 = call i32 @llvm.umin.i32(i32 %336, i32 1024)
  %338 = add i32 %337, %333
  %339 = call i32 @llvm.umax.i32(i32 %338, i32 8)
  %340 = zext i32 %339 to i64
  %341 = mul i64 %340, 32
  %342 = add i64 %341, 16
  %343 = call ptr @realloc(ptr null, i64 %342)
  store i32 1, ptr %343, align 4
  %344 = getelementptr inbounds i8, ptr %343, i32 4
  store i32 0, ptr %344, align 4
  %345 = getelementptr inbounds i8, ptr %343, i32 16
  %346 = call ptr @realloc(ptr null, i64 8)
  store ptr %345, ptr %346, align 8
  %347 = insertvalue { ptr, i32, i32, i32 } %331, ptr %346, 0
  %348 = insertvalue { ptr, i32, i32, i32 } %347, i32 %339, 3
  br label %369

349:                                              ; preds = %322
  %350 = icmp ult i32 %330, %333
  br i1 %350, label %351, label %352

351:                                              ; preds = %349
  br label %366

352:                                              ; preds = %349
  %353 = shl i32 %333, 1
  %354 = call i32 @llvm.umin.i32(i32 %353, i32 1024)
  %355 = add i32 %354, %333
  %356 = call i32 @llvm.umax.i32(i32 %355, i32 8)
  %357 = zext i32 %356 to i64
  %358 = mul i64 %357, 32
  %359 = add i64 %358, 16
  %360 = extractvalue { ptr, i32, i32, i32 } %321, 0
  %361 = load ptr, ptr %360, align 8
  %362 = getelementptr inbounds i8, ptr %361, i32 -16
  %363 = call ptr @realloc(ptr %362, i64 %359)
  %364 = getelementptr inbounds i8, ptr %363, i32 16
  store ptr %364, ptr %360, align 8
  %365 = insertvalue { ptr, i32, i32, i32 } %331, i32 %356, 3
  br label %366

366:                                              ; preds = %351, %352
  %367 = phi { ptr, i32, i32, i32 } [ %365, %352 ], [ %331, %351 ]
  br label %368

368:                                              ; preds = %366
  br label %369

369:                                              ; preds = %335, %368
  %370 = phi { ptr, i32, i32, i32 } [ %367, %368 ], [ %348, %335 ]
  br label %371

371:                                              ; preds = %369
  %372 = extractvalue { ptr, i32, i32, i32 } %370, 0
  %373 = load ptr, ptr %372, align 8
  %374 = extractvalue { ptr, i32, i32, i32 } %370, 2
  %375 = zext i32 %374 to i64
  %376 = mul i64 %375, 32
  %377 = getelementptr inbounds i8, ptr %373, i64 %376
  store i252 %279, ptr %377, align 16
  %378 = extractvalue { ptr, i32, i32, i32 } %370, 2
  %379 = add i32 %378, 1
  %380 = insertvalue { ptr, i32, i32, i32 } %370, i32 %379, 2
  %381 = getelementptr inbounds i8, ptr %373, i32 -12
  store i32 %379, ptr %381, align 4
  %382 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %380, 0
  %383 = insertvalue { { ptr, i32, i32, i32 }, {} } %382, {} undef, 1
  %384 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %383, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %384, ptr %9, align 8
  %385 = load { i64, [24 x i8] }, ptr %9, align 8
  %386 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %254, 0
  %387 = insertvalue { i64, i64, { i64, [24 x i8] } } %386, i64 %273, 1
  %388 = insertvalue { i64, i64, { i64, [24 x i8] } } %387, { i64, [24 x i8] } %385, 2
  ret { i64, i64, { i64, [24 x i8] } } %388

389:                                              ; preds = %241
  %390 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %391 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %390, 1
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %91)
  %392 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %391, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %392, ptr %8, align 8
  %393 = load { i64, [24 x i8] }, ptr %8, align 8
  %394 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %254, 0
  %395 = insertvalue { i64, i64, { i64, [24 x i8] } } %394, i64 %255, 1
  %396 = insertvalue { i64, i64, { i64, [24 x i8] } } %395, { i64, [24 x i8] } %393, 2
  ret { i64, i64, { i64, [24 x i8] } } %396

397:                                              ; preds = %79
  call void @puts(ptr @assert_msg_148)
  call void @abort()
  unreachable

398:                                              ; preds = %266
  call void @puts(ptr @assert_msg_149)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f84(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f84(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f84(i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f85"(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  %10 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %9, 0
  %11 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %9, 1
  %12 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %11, 1
  %13 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %11, 2
  call void @"drop$31"({ { ptr, i32, i32, i32 } } %13)
  %14 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %12)
  %15 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %14, 0
  %16 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %14, 1
  %17 = extractvalue { { ptr, i32, i32, i32 } } %16, 0
  %18 = extractvalue { ptr, i32, i32, i32 } %17, 1
  %19 = extractvalue { ptr, i32, i32, i32 } %17, 2
  %20 = sub i32 %19, %18
  call void @"drop$27"({ ptr, i32, i32, i32 } %17)
  %21 = zext i32 %20 to i252
  %22 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10)
  %23 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %22, 0
  %24 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %22, 1
  %25 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %24, 0
  %26 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %24, 1
  %27 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %24, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %26)
  call void @"drop$31"({ { ptr, i32, i32, i32 } } %27)
  %28 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %28, align 4
  %29 = getelementptr inbounds i8, ptr %28, i32 4
  store i32 0, ptr %29, align 4
  %30 = getelementptr inbounds i8, ptr %28, i32 16
  %31 = call ptr @realloc(ptr null, i64 8)
  store ptr %30, ptr %31, align 8
  %32 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %31, 0
  %33 = insertvalue { ptr, i32, i32, i32 } %32, i32 8, 3
  %34 = load ptr, ptr %31, align 8
  store i252 %25, ptr %34, align 16
  %35 = insertvalue { ptr, i32, i32, i32 } %33, i32 1, 2
  %36 = getelementptr inbounds i8, ptr %34, i32 -12
  store i32 1, ptr %36, align 4
  %37 = load ptr, ptr %31, align 8
  %38 = getelementptr inbounds i8, ptr %37, i32 32
  store i252 %21, ptr %38, align 16
  %39 = insertvalue { ptr, i32, i32, i32 } %35, i32 2, 2
  %40 = getelementptr inbounds i8, ptr %37, i32 -12
  store i32 2, ptr %40, align 4
  %41 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %15, { ptr, i32, i32, i32 } %39)
  %42 = extractvalue { i64, i64, { i64, [24 x i8] } } %41, 0
  %43 = extractvalue { i64, i64, { i64, [24 x i8] } } %41, 1
  %44 = extractvalue { i64, i64, { i64, [24 x i8] } } %41, 2
  store { i64, [24 x i8] } %44, ptr %4, align 8
  %45 = load i1, ptr %4, align 1
  switch i1 %45, label %46 [
    i1 false, label %48
    i1 true, label %117
  ]

46:                                               ; preds = %3
  br i1 false, label %47, label %152

47:                                               ; preds = %46
  unreachable

48:                                               ; preds = %3
  %49 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %4, align 8
  %50 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %49, 1
  %51 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %23, 1
  %52 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %23, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %51)
  %53 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$31"({ { ptr, i32, i32, i32 } } %52)
  %54 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %53, 0
  %55 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %53, 1
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  call void @"drop$30"({ ptr, i32, i32, i32 } %56)
  %60 = zext i32 %59 to i252
  %61 = extractvalue { { ptr, i32, i32, i32 }, {} } %50, 0
  %62 = extractvalue { ptr, i32, i32, i32 } %61, 3
  %63 = icmp eq i32 %62, 0
  br i1 %63, label %64, label %78

64:                                               ; preds = %48
  %65 = shl i32 %62, 1
  %66 = call i32 @llvm.umin.i32(i32 %65, i32 1024)
  %67 = add i32 %66, %62
  %68 = call i32 @llvm.umax.i32(i32 %67, i32 8)
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = add i64 %70, 16
  %72 = call ptr @realloc(ptr null, i64 %71)
  store i32 1, ptr %72, align 4
  %73 = getelementptr inbounds i8, ptr %72, i32 4
  store i32 0, ptr %73, align 4
  %74 = getelementptr inbounds i8, ptr %72, i32 16
  %75 = call ptr @realloc(ptr null, i64 8)
  store ptr %74, ptr %75, align 8
  %76 = insertvalue { ptr, i32, i32, i32 } %61, ptr %75, 0
  %77 = insertvalue { ptr, i32, i32, i32 } %76, i32 %68, 3
  br label %99

78:                                               ; preds = %48
  %79 = extractvalue { ptr, i32, i32, i32 } %61, 2
  %80 = icmp ult i32 %79, %62
  br i1 %80, label %81, label %82

81:                                               ; preds = %78
  br label %96

82:                                               ; preds = %78
  %83 = shl i32 %62, 1
  %84 = call i32 @llvm.umin.i32(i32 %83, i32 1024)
  %85 = add i32 %84, %62
  %86 = call i32 @llvm.umax.i32(i32 %85, i32 8)
  %87 = zext i32 %86 to i64
  %88 = mul i64 %87, 32
  %89 = add i64 %88, 16
  %90 = extractvalue { ptr, i32, i32, i32 } %61, 0
  %91 = load ptr, ptr %90, align 8
  %92 = getelementptr inbounds i8, ptr %91, i32 -16
  %93 = call ptr @realloc(ptr %92, i64 %89)
  %94 = getelementptr inbounds i8, ptr %93, i32 16
  store ptr %94, ptr %90, align 8
  %95 = insertvalue { ptr, i32, i32, i32 } %61, i32 %86, 3
  br label %96

96:                                               ; preds = %81, %82
  %97 = phi { ptr, i32, i32, i32 } [ %95, %82 ], [ %61, %81 ]
  br label %98

98:                                               ; preds = %96
  br label %99

99:                                               ; preds = %64, %98
  %100 = phi { ptr, i32, i32, i32 } [ %97, %98 ], [ %77, %64 ]
  br label %101

101:                                              ; preds = %99
  %102 = extractvalue { ptr, i32, i32, i32 } %100, 0
  %103 = load ptr, ptr %102, align 8
  %104 = extractvalue { ptr, i32, i32, i32 } %100, 2
  %105 = zext i32 %104 to i64
  %106 = mul i64 %105, 32
  %107 = getelementptr inbounds i8, ptr %103, i64 %106
  store i252 %60, ptr %107, align 16
  %108 = extractvalue { ptr, i32, i32, i32 } %100, 2
  %109 = add i32 %108, 1
  %110 = insertvalue { ptr, i32, i32, i32 } %100, i32 %109, 2
  %111 = getelementptr inbounds i8, ptr %103, i32 -12
  store i32 %109, ptr %111, align 4
  %112 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f93"(i64 %42, i64 %43, { { ptr, i32, i32, i32 } } %54, { ptr, i32, i32, i32 } %110)
  %113 = extractvalue { i64, i64, { i64, [24 x i8] } } %112, 0
  %114 = extractvalue { i64, i64, { i64, [24 x i8] } } %112, 1
  %115 = extractvalue { i64, i64, { i64, [24 x i8] } } %112, 2
  store { i64, [24 x i8] } %115, ptr %6, align 8
  %116 = load i1, ptr %6, align 1
  switch i1 %116, label %125 [
    i1 false, label %127
    i1 true, label %144
  ]

117:                                              ; preds = %3
  %118 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %119 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %118, 1
  call void @"drop$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %23)
  %120 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %119, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %120, ptr %5, align 8
  %121 = load { i64, [24 x i8] }, ptr %5, align 8
  %122 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %42, 0
  %123 = insertvalue { i64, i64, { i64, [24 x i8] } } %122, i64 %43, 1
  %124 = insertvalue { i64, i64, { i64, [24 x i8] } } %123, { i64, [24 x i8] } %121, 2
  ret { i64, i64, { i64, [24 x i8] } } %124

125:                                              ; preds = %101
  br i1 false, label %126, label %153

126:                                              ; preds = %125
  unreachable

127:                                              ; preds = %101
  %128 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %129 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %128, 1
  %130 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %131 = call ptr %130()
  %132 = call i64 @llvm.uadd.sat.i64(i64 %114, i64 0)
  %133 = extractvalue { { ptr, i32, i32, i32 }, {} } %129, 0
  %134 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %133)
  %135 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %134, 0
  %136 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %134, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %135)
  %137 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %136, 0
  %138 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %137, 0
  %139 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %138, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %139, ptr %8, align 8
  %140 = load { i64, [24 x i8] }, ptr %8, align 8
  %141 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %113, 0
  %142 = insertvalue { i64, i64, { i64, [24 x i8] } } %141, i64 %132, 1
  %143 = insertvalue { i64, i64, { i64, [24 x i8] } } %142, { i64, [24 x i8] } %140, 2
  ret { i64, i64, { i64, [24 x i8] } } %143

144:                                              ; preds = %101
  %145 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %146 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %145, 1
  %147 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %146, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %147, ptr %7, align 8
  %148 = load { i64, [24 x i8] }, ptr %7, align 8
  %149 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %113, 0
  %150 = insertvalue { i64, i64, { i64, [24 x i8] } } %149, i64 %114, 1
  %151 = insertvalue { i64, i64, { i64, [24 x i8] } } %150, { i64, [24 x i8] } %148, 2
  ret { i64, i64, { i64, [24 x i8] } } %151

152:                                              ; preds = %46
  call void @puts(ptr @assert_msg_150)
  call void @abort()
  unreachable

153:                                              ; preds = %125
  call void @puts(ptr @assert_msg_151)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f85(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2) {
  %4 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f85"(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  %5 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, { i64, [24 x i8] } %7, 2
  ret { i64, i64, { i64, [24 x i8] } } %10
}

define void @_mlir_ciface_f85(ptr %0, i64 %1, i64 %2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3) {
  %5 = call { i64, i64, { i64, [24 x i8] } } @f85(i64 %1, i64 %2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3)
  store { i64, i64, { i64, [24 x i8] } } %5, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f86"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 1637577033762547024928219503506405592178450804)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f86() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f86"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f86(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f86()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f87"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 1637570914057682275393755530660268060279989363)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f87() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f87"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f87(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f87()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f88"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i32, [20 x i8] }, i64 1, align 4
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %17

17:                                               ; preds = %158, %5
  %18 = phi i64 [ %105, %158 ], [ %0, %5 ]
  %19 = phi i64 [ %116, %158 ], [ %1, %5 ]
  %20 = phi { { ptr, i32, i32, i32 } } [ %106, %158 ], [ %2, %5 ]
  %21 = phi { ptr, i32, i32, i32 } [ %167, %158 ], [ %3, %5 ]
  %22 = phi i252 [ %174, %158 ], [ %4, %5 ]
  %23 = add i64 %18, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = load i64, ptr %25, align 8
  %27 = mul i64 %26, 10710
  %28 = icmp uge i64 %19, %27
  %29 = call i64 @llvm.usub.sat.i64(i64 %19, i64 %27)
  br i1 %28, label %30, label %232

30:                                               ; preds = %17
  %31 = phi i252 [ %22, %17 ]
  %32 = icmp eq i252 %31, 0
  br i1 %32, label %33, label %55

33:                                               ; preds = %30
  %34 = phi i64 [ %29, %30 ]
  %35 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %36 = call ptr %35()
  %37 = load i64, ptr %36, align 8
  %38 = mul i64 %37, 11610
  %39 = call i64 @llvm.uadd.sat.i64(i64 %34, i64 %38)
  %40 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %21, 1
  store { i1, { ptr, i32, i32, i32 } } %40, ptr %15, align 8
  %41 = load { i64, [24 x i8] }, ptr %15, align 8
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %20, 0
  %43 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, { i64, [24 x i8] } %41, 1
  %44 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %43, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %44, ptr %16, align 8
  %45 = load { i64, [56 x i8] }, ptr %16, align 8
  %46 = extractvalue { ptr, ptr, i64 } %9, 1
  %47 = load i64, ptr %46, align 8
  %48 = icmp eq i64 %47, 0
  %49 = sub i64 %47, 1
  %50 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %49, ptr %50, align 8
  br i1 %48, label %51, label %186

51:                                               ; preds = %33
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %23, 0
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, i64 %39, 1
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } %53, { i64, [56 x i8] } %45, 2
  ret { i64, i64, { i64, [56 x i8] } } %54

55:                                               ; preds = %30
  %56 = phi { { ptr, i32, i32, i32 } } [ %20, %30 ]
  %57 = extractvalue { { ptr, i32, i32, i32 } } %56, 0
  %58 = extractvalue { ptr, i32, i32, i32 } %57, 1
  %59 = extractvalue { ptr, i32, i32, i32 } %57, 2
  %60 = sub i32 %59, %58
  %61 = icmp uge i32 %60, 1
  br i1 %61, label %62, label %206

62:                                               ; preds = %55
  %63 = extractvalue { ptr, i32, i32, i32 } %57, 0
  %64 = load ptr, ptr %63, align 8
  %65 = zext i32 %58 to i64
  %66 = mul i64 %65, 32
  %67 = getelementptr inbounds i8, ptr %64, i64 %66
  %68 = add i32 %58, 1
  %69 = insertvalue { ptr, i32, i32, i32 } %57, i32 %68, 1
  %70 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %70, ptr %67, i64 32, i1 false)
  %71 = load i252, ptr %70, align 16
  call void @free(ptr %70)
  %72 = icmp eq i252 %71, 0
  br i1 %72, label %73, label %78

73:                                               ; preds = %62
  %74 = phi i64 [ %29, %62 ]
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %74, i64 0)
  br label %96

78:                                               ; preds = %62
  %79 = phi i252 [ %71, %62 ]
  %80 = phi i252 [ 1, %62 ]
  %81 = zext i252 %79 to i256
  %82 = zext i252 %80 to i256
  %83 = sub i256 %81, %82
  %84 = add i256 %83, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %85 = icmp ult i256 %81, %82
  %86 = select i1 %85, i256 %84, i256 %83
  %87 = trunc i256 %86 to i252
  %88 = icmp eq i252 %87, 0
  br i1 %88, label %89, label %199

89:                                               ; preds = %78
  %90 = phi i64 [ %29, %78 ]
  %91 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %92 = call ptr %91()
  %93 = load i64, ptr %92, align 8
  %94 = mul i64 %93, 10
  %95 = call i64 @llvm.uadd.sat.i64(i64 %90, i64 %94)
  br label %96

96:                                               ; preds = %73, %89
  %97 = phi { ptr, i32, i32, i32 } [ %21, %89 ], [ %21, %73 ]
  %98 = phi i252 [ %31, %89 ], [ %31, %73 ]
  %99 = phi i64 [ %23, %89 ], [ %23, %73 ]
  %100 = phi { ptr, i32, i32, i32 } [ %69, %89 ], [ %69, %73 ]
  %101 = phi i64 [ %95, %89 ], [ %77, %73 ]
  %102 = phi { i1, [0 x i8] } [ { i1 true, [0 x i8] undef }, %89 ], [ { i1 false, [0 x i8] undef }, %73 ]
  %103 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %100, 0
  %104 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @"impl$f94"(i64 %99, { { ptr, i32, i32, i32 } } %103)
  %105 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %104, 0
  %106 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %104, 1
  %107 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %104, 2
  store { i32, [20 x i8] } %107, ptr %14, align 4
  %108 = load i1, ptr %14, align 1
  switch i1 %108, label %109 [
    i1 false, label %111
    i1 true, label %179
  ]

109:                                              ; preds = %96
  br i1 false, label %110, label %247

110:                                              ; preds = %109
  unreachable

111:                                              ; preds = %96
  %112 = load { i1, { i32, [16 x i8] } }, ptr %14, align 4
  %113 = extractvalue { i1, { i32, [16 x i8] } } %112, 1
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 0)
  %117 = insertvalue { { i1, [0 x i8] }, { i32, [16 x i8] } } undef, { i1, [0 x i8] } %102, 0
  %118 = insertvalue { { i1, [0 x i8] }, { i32, [16 x i8] } } %117, { i32, [16 x i8] } %113, 1
  %119 = extractvalue { ptr, i32, i32, i32 } %97, 3
  %120 = icmp eq i32 %119, 0
  br i1 %120, label %121, label %135

121:                                              ; preds = %111
  %122 = shl i32 %119, 1
  %123 = call i32 @llvm.umin.i32(i32 %122, i32 1024)
  %124 = add i32 %123, %119
  %125 = call i32 @llvm.umax.i32(i32 %124, i32 8)
  %126 = zext i32 %125 to i64
  %127 = mul i64 %126, 24
  %128 = add i64 %127, 8
  %129 = call ptr @realloc(ptr null, i64 %128)
  store i32 1, ptr %129, align 4
  %130 = getelementptr inbounds i8, ptr %129, i32 4
  store i32 0, ptr %130, align 4
  %131 = getelementptr inbounds i8, ptr %129, i32 8
  %132 = call ptr @realloc(ptr null, i64 8)
  store ptr %131, ptr %132, align 8
  %133 = insertvalue { ptr, i32, i32, i32 } %97, ptr %132, 0
  %134 = insertvalue { ptr, i32, i32, i32 } %133, i32 %125, 3
  br label %156

135:                                              ; preds = %111
  %136 = extractvalue { ptr, i32, i32, i32 } %97, 2
  %137 = icmp ult i32 %136, %119
  br i1 %137, label %138, label %139

138:                                              ; preds = %135
  br label %153

139:                                              ; preds = %135
  %140 = shl i32 %119, 1
  %141 = call i32 @llvm.umin.i32(i32 %140, i32 1024)
  %142 = add i32 %141, %119
  %143 = call i32 @llvm.umax.i32(i32 %142, i32 8)
  %144 = zext i32 %143 to i64
  %145 = mul i64 %144, 24
  %146 = add i64 %145, 8
  %147 = extractvalue { ptr, i32, i32, i32 } %97, 0
  %148 = load ptr, ptr %147, align 8
  %149 = getelementptr inbounds i8, ptr %148, i32 -8
  %150 = call ptr @realloc(ptr %149, i64 %146)
  %151 = getelementptr inbounds i8, ptr %150, i32 8
  store ptr %151, ptr %147, align 8
  %152 = insertvalue { ptr, i32, i32, i32 } %97, i32 %143, 3
  br label %153

153:                                              ; preds = %138, %139
  %154 = phi { ptr, i32, i32, i32 } [ %152, %139 ], [ %97, %138 ]
  br label %155

155:                                              ; preds = %153
  br label %156

156:                                              ; preds = %121, %155
  %157 = phi { ptr, i32, i32, i32 } [ %154, %155 ], [ %134, %121 ]
  br label %158

158:                                              ; preds = %156
  %159 = extractvalue { ptr, i32, i32, i32 } %157, 0
  %160 = load ptr, ptr %159, align 8
  %161 = extractvalue { ptr, i32, i32, i32 } %157, 2
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 24
  %164 = getelementptr inbounds i8, ptr %160, i64 %163
  store { { i1, [0 x i8] }, { i32, [16 x i8] } } %118, ptr %164, align 4
  %165 = extractvalue { ptr, i32, i32, i32 } %157, 2
  %166 = add i32 %165, 1
  %167 = insertvalue { ptr, i32, i32, i32 } %157, i32 %166, 2
  %168 = getelementptr inbounds i8, ptr %160, i32 -4
  store i32 %166, ptr %168, align 4
  %169 = zext i252 %98 to i256
  %170 = sub i256 %169, 1
  %171 = add i256 %169, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %172 = icmp ult i256 %169, 1
  %173 = select i1 %172, i256 %171, i256 %170
  %174 = trunc i256 %173 to i252
  %175 = extractvalue { ptr, ptr, i64 } %9, 1
  %176 = load i64, ptr %175, align 8
  %177 = add i64 %176, 1
  %178 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %177, ptr %178, align 8
  br label %17

179:                                              ; preds = %96
  call void @"drop$15"({ ptr, i32, i32, i32 } %97)
  %180 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %181 = call ptr %180()
  %182 = load i64, ptr %181, align 8
  %183 = mul i64 %182, 2970
  %184 = call i64 @llvm.uadd.sat.i64(i64 %101, i64 %183)
  %185 = extractvalue { { ptr, i32, i32, i32 } } %106, 0
  br label %213

186:                                              ; preds = %186, %33, %213, %232
  %187 = phi i64 [ %23, %232 ], [ %214, %213 ], [ %187, %186 ], [ %23, %33 ]
  %188 = phi i64 [ %19, %232 ], [ %215, %213 ], [ %188, %186 ], [ %39, %33 ]
  %189 = phi { i64, [56 x i8] } [ %237, %232 ], [ %222, %213 ], [ %189, %186 ], [ %45, %33 ]
  %190 = extractvalue { ptr, ptr, i64 } %9, 1
  %191 = load i64, ptr %190, align 8
  %192 = icmp eq i64 %191, 0
  %193 = sub i64 %191, 1
  %194 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %193, ptr %194, align 8
  br i1 %192, label %195, label %186

195:                                              ; preds = %186
  %196 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %187, 0
  %197 = insertvalue { i64, i64, { i64, [56 x i8] } } %196, i64 %188, 1
  %198 = insertvalue { i64, i64, { i64, [56 x i8] } } %197, { i64, [56 x i8] } %189, 2
  ret { i64, i64, { i64, [56 x i8] } } %198

199:                                              ; preds = %78
  %200 = phi { ptr, i32, i32, i32 } [ %21, %78 ]
  call void @"drop$15"({ ptr, i32, i32, i32 } %200)
  %201 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %202 = call ptr %201()
  %203 = load i64, ptr %202, align 8
  %204 = mul i64 %203, 10210
  %205 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %204)
  br label %213

206:                                              ; preds = %55
  %207 = phi { ptr, i32, i32, i32 } [ %21, %55 ]
  call void @"drop$15"({ ptr, i32, i32, i32 } %207)
  %208 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %209 = call ptr %208()
  %210 = load i64, ptr %209, align 8
  %211 = mul i64 %210, 10490
  %212 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %211)
  br label %213

213:                                              ; preds = %179, %199, %206
  %214 = phi i64 [ %23, %206 ], [ %23, %199 ], [ %105, %179 ]
  %215 = phi i64 [ %212, %206 ], [ %205, %199 ], [ %184, %179 ]
  %216 = phi { ptr, i32, i32, i32 } [ %57, %206 ], [ %69, %199 ], [ %185, %179 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %217 = load { i64, [24 x i8] }, ptr %12, align 8
  %218 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %216, 0
  %219 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %218, 0
  %220 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %219, { i64, [24 x i8] } %217, 1
  %221 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %220, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %221, ptr %13, align 8
  %222 = load { i64, [56 x i8] }, ptr %13, align 8
  %223 = extractvalue { ptr, ptr, i64 } %9, 1
  %224 = load i64, ptr %223, align 8
  %225 = icmp eq i64 %224, 0
  %226 = sub i64 %224, 1
  %227 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %226, ptr %227, align 8
  br i1 %225, label %228, label %186

228:                                              ; preds = %213
  %229 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %214, 0
  %230 = insertvalue { i64, i64, { i64, [56 x i8] } } %229, i64 %215, 1
  %231 = insertvalue { i64, i64, { i64, [56 x i8] } } %230, { i64, [56 x i8] } %222, 2
  ret { i64, i64, { i64, [56 x i8] } } %231

232:                                              ; preds = %17
  %233 = phi { ptr, i32, i32, i32 } [ %21, %17 ]
  call void @"drop$15"({ ptr, i32, i32, i32 } %233)
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %20)
  %234 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %235 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %234, 0
  %236 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %235, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %236, ptr %11, align 8
  %237 = load { i64, [56 x i8] }, ptr %11, align 8
  %238 = extractvalue { ptr, ptr, i64 } %9, 1
  %239 = load i64, ptr %238, align 8
  %240 = icmp eq i64 %239, 0
  %241 = sub i64 %239, 1
  %242 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %241, ptr %242, align 8
  br i1 %240, label %243, label %186

243:                                              ; preds = %232
  %244 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %23, 0
  %245 = insertvalue { i64, i64, { i64, [56 x i8] } } %244, i64 %19, 1
  %246 = insertvalue { i64, i64, { i64, [56 x i8] } } %245, { i64, [56 x i8] } %237, 2
  ret { i64, i64, { i64, [56 x i8] } } %246

247:                                              ; preds = %109
  call void @puts(ptr @assert_msg_152)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f88(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f88"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f88(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f88(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  call void @"drop$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$42"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0)
  %3 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %2, 0
  %4 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %2, 1
  %5 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %6 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f89"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i128, [144 x i8] }, i64 1, align 16
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = load { i128, [144 x i8] }, ptr %2, align 16
  store { i128, [144 x i8] } %10, ptr %5, align 16
  %11 = load i2, ptr %5, align 1
  switch i2 %11, label %12 [
    i2 0, label %14
    i2 1, label %128
    i2 -2, label %247
  ]

12:                                               ; preds = %4
  br i1 false, label %13, label %443

13:                                               ; preds = %12
  unreachable

14:                                               ; preds = %4
  %15 = load { i2, i252 }, ptr %5, align 16
  %16 = extractvalue { i2, i252 } %15, 1
  %17 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %18 = call ptr %17()
  %19 = load i64, ptr %18, align 8
  %20 = mul i64 %19, 10710
  %21 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %20)
  %22 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %38

24:                                               ; preds = %14
  %25 = shl i32 %22, 1
  %26 = call i32 @llvm.umin.i32(i32 %25, i32 1024)
  %27 = add i32 %26, %22
  %28 = call i32 @llvm.umax.i32(i32 %27, i32 8)
  %29 = zext i32 %28 to i64
  %30 = mul i64 %29, 32
  %31 = add i64 %30, 16
  %32 = call ptr @realloc(ptr null, i64 %31)
  store i32 1, ptr %32, align 4
  %33 = getelementptr inbounds i8, ptr %32, i32 4
  store i32 0, ptr %33, align 4
  %34 = getelementptr inbounds i8, ptr %32, i32 16
  %35 = call ptr @realloc(ptr null, i64 8)
  store ptr %34, ptr %35, align 8
  %36 = insertvalue { ptr, i32, i32, i32 } %3, ptr %35, 0
  %37 = insertvalue { ptr, i32, i32, i32 } %36, i32 %28, 3
  br label %59

38:                                               ; preds = %14
  %39 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %40 = icmp ult i32 %39, %22
  br i1 %40, label %41, label %42

41:                                               ; preds = %38
  br label %56

42:                                               ; preds = %38
  %43 = shl i32 %22, 1
  %44 = call i32 @llvm.umin.i32(i32 %43, i32 1024)
  %45 = add i32 %44, %22
  %46 = call i32 @llvm.umax.i32(i32 %45, i32 8)
  %47 = zext i32 %46 to i64
  %48 = mul i64 %47, 32
  %49 = add i64 %48, 16
  %50 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr inbounds i8, ptr %51, i32 -16
  %53 = call ptr @realloc(ptr %52, i64 %49)
  %54 = getelementptr inbounds i8, ptr %53, i32 16
  store ptr %54, ptr %50, align 8
  %55 = insertvalue { ptr, i32, i32, i32 } %3, i32 %46, 3
  br label %56

56:                                               ; preds = %41, %42
  %57 = phi { ptr, i32, i32, i32 } [ %55, %42 ], [ %3, %41 ]
  br label %58

58:                                               ; preds = %56
  br label %59

59:                                               ; preds = %24, %58
  %60 = phi { ptr, i32, i32, i32 } [ %57, %58 ], [ %37, %24 ]
  br label %61

61:                                               ; preds = %59
  %62 = extractvalue { ptr, i32, i32, i32 } %60, 0
  %63 = load ptr, ptr %62, align 8
  %64 = extractvalue { ptr, i32, i32, i32 } %60, 2
  %65 = zext i32 %64 to i64
  %66 = mul i64 %65, 32
  %67 = getelementptr inbounds i8, ptr %63, i64 %66
  store i252 0, ptr %67, align 16
  %68 = extractvalue { ptr, i32, i32, i32 } %60, 2
  %69 = add i32 %68, 1
  %70 = insertvalue { ptr, i32, i32, i32 } %60, i32 %69, 2
  %71 = getelementptr inbounds i8, ptr %63, i32 -12
  store i32 %69, ptr %71, align 4
  %72 = extractvalue { ptr, i32, i32, i32 } %60, 3
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %74, label %88

74:                                               ; preds = %61
  %75 = shl i32 %72, 1
  %76 = call i32 @llvm.umin.i32(i32 %75, i32 1024)
  %77 = add i32 %76, %72
  %78 = call i32 @llvm.umax.i32(i32 %77, i32 8)
  %79 = zext i32 %78 to i64
  %80 = mul i64 %79, 32
  %81 = add i64 %80, 16
  %82 = call ptr @realloc(ptr null, i64 %81)
  store i32 1, ptr %82, align 4
  %83 = getelementptr inbounds i8, ptr %82, i32 4
  store i32 0, ptr %83, align 4
  %84 = getelementptr inbounds i8, ptr %82, i32 16
  %85 = call ptr @realloc(ptr null, i64 8)
  store ptr %84, ptr %85, align 8
  %86 = insertvalue { ptr, i32, i32, i32 } %70, ptr %85, 0
  %87 = insertvalue { ptr, i32, i32, i32 } %86, i32 %78, 3
  br label %108

88:                                               ; preds = %61
  %89 = icmp ult i32 %69, %72
  br i1 %89, label %90, label %91

90:                                               ; preds = %88
  br label %105

91:                                               ; preds = %88
  %92 = shl i32 %72, 1
  %93 = call i32 @llvm.umin.i32(i32 %92, i32 1024)
  %94 = add i32 %93, %72
  %95 = call i32 @llvm.umax.i32(i32 %94, i32 8)
  %96 = zext i32 %95 to i64
  %97 = mul i64 %96, 32
  %98 = add i64 %97, 16
  %99 = extractvalue { ptr, i32, i32, i32 } %60, 0
  %100 = load ptr, ptr %99, align 8
  %101 = getelementptr inbounds i8, ptr %100, i32 -16
  %102 = call ptr @realloc(ptr %101, i64 %98)
  %103 = getelementptr inbounds i8, ptr %102, i32 16
  store ptr %103, ptr %99, align 8
  %104 = insertvalue { ptr, i32, i32, i32 } %70, i32 %95, 3
  br label %105

105:                                              ; preds = %90, %91
  %106 = phi { ptr, i32, i32, i32 } [ %104, %91 ], [ %70, %90 ]
  br label %107

107:                                              ; preds = %105
  br label %108

108:                                              ; preds = %74, %107
  %109 = phi { ptr, i32, i32, i32 } [ %106, %107 ], [ %87, %74 ]
  br label %110

110:                                              ; preds = %108
  %111 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %112 = load ptr, ptr %111, align 8
  %113 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %114 = zext i32 %113 to i64
  %115 = mul i64 %114, 32
  %116 = getelementptr inbounds i8, ptr %112, i64 %115
  store i252 %16, ptr %116, align 16
  %117 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %118 = add i32 %117, 1
  %119 = insertvalue { ptr, i32, i32, i32 } %109, i32 %118, 2
  %120 = getelementptr inbounds i8, ptr %112, i32 -12
  store i32 %118, ptr %120, align 4
  %121 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %119, 0
  %122 = insertvalue { { ptr, i32, i32, i32 }, {} } %121, {} undef, 1
  %123 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %122, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %123, ptr %9, align 8
  %124 = load { i64, [24 x i8] }, ptr %9, align 8
  %125 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %0, 0
  %126 = insertvalue { i64, i64, { i64, [24 x i8] } } %125, i64 %21, 1
  %127 = insertvalue { i64, i64, { i64, [24 x i8] } } %126, { i64, [24 x i8] } %124, 2
  ret { i64, i64, { i64, [24 x i8] } } %127

128:                                              ; preds = %4
  %129 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %5, align 16
  %130 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %129, 1
  %131 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %130)
  %132 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %131, 0
  %133 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %131, 1
  %134 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %133, 0
  %135 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %134)
  %136 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %135, 0
  %137 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %135, 1
  %138 = extractvalue { ptr, i32, i32, i32 } %137, 1
  %139 = extractvalue { ptr, i32, i32, i32 } %137, 2
  %140 = sub i32 %139, %138
  call void @"drop$163"({ ptr, i32, i32, i32 } %137)
  %141 = zext i32 %140 to i252
  %142 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %143 = icmp eq i32 %142, 0
  br i1 %143, label %144, label %158

144:                                              ; preds = %128
  %145 = shl i32 %142, 1
  %146 = call i32 @llvm.umin.i32(i32 %145, i32 1024)
  %147 = add i32 %146, %142
  %148 = call i32 @llvm.umax.i32(i32 %147, i32 8)
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 32
  %151 = add i64 %150, 16
  %152 = call ptr @realloc(ptr null, i64 %151)
  store i32 1, ptr %152, align 4
  %153 = getelementptr inbounds i8, ptr %152, i32 4
  store i32 0, ptr %153, align 4
  %154 = getelementptr inbounds i8, ptr %152, i32 16
  %155 = call ptr @realloc(ptr null, i64 8)
  store ptr %154, ptr %155, align 8
  %156 = insertvalue { ptr, i32, i32, i32 } %3, ptr %155, 0
  %157 = insertvalue { ptr, i32, i32, i32 } %156, i32 %148, 3
  br label %179

158:                                              ; preds = %128
  %159 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %160 = icmp ult i32 %159, %142
  br i1 %160, label %161, label %162

161:                                              ; preds = %158
  br label %176

162:                                              ; preds = %158
  %163 = shl i32 %142, 1
  %164 = call i32 @llvm.umin.i32(i32 %163, i32 1024)
  %165 = add i32 %164, %142
  %166 = call i32 @llvm.umax.i32(i32 %165, i32 8)
  %167 = zext i32 %166 to i64
  %168 = mul i64 %167, 32
  %169 = add i64 %168, 16
  %170 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %171 = load ptr, ptr %170, align 8
  %172 = getelementptr inbounds i8, ptr %171, i32 -16
  %173 = call ptr @realloc(ptr %172, i64 %169)
  %174 = getelementptr inbounds i8, ptr %173, i32 16
  store ptr %174, ptr %170, align 8
  %175 = insertvalue { ptr, i32, i32, i32 } %3, i32 %166, 3
  br label %176

176:                                              ; preds = %161, %162
  %177 = phi { ptr, i32, i32, i32 } [ %175, %162 ], [ %3, %161 ]
  br label %178

178:                                              ; preds = %176
  br label %179

179:                                              ; preds = %144, %178
  %180 = phi { ptr, i32, i32, i32 } [ %177, %178 ], [ %157, %144 ]
  br label %181

181:                                              ; preds = %179
  %182 = extractvalue { ptr, i32, i32, i32 } %180, 0
  %183 = load ptr, ptr %182, align 8
  %184 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %185 = zext i32 %184 to i64
  %186 = mul i64 %185, 32
  %187 = getelementptr inbounds i8, ptr %183, i64 %186
  store i252 1, ptr %187, align 16
  %188 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %189 = add i32 %188, 1
  %190 = insertvalue { ptr, i32, i32, i32 } %180, i32 %189, 2
  %191 = getelementptr inbounds i8, ptr %183, i32 -12
  store i32 %189, ptr %191, align 4
  %192 = extractvalue { ptr, i32, i32, i32 } %180, 3
  %193 = icmp eq i32 %192, 0
  br i1 %193, label %194, label %208

194:                                              ; preds = %181
  %195 = shl i32 %192, 1
  %196 = call i32 @llvm.umin.i32(i32 %195, i32 1024)
  %197 = add i32 %196, %192
  %198 = call i32 @llvm.umax.i32(i32 %197, i32 8)
  %199 = zext i32 %198 to i64
  %200 = mul i64 %199, 32
  %201 = add i64 %200, 16
  %202 = call ptr @realloc(ptr null, i64 %201)
  store i32 1, ptr %202, align 4
  %203 = getelementptr inbounds i8, ptr %202, i32 4
  store i32 0, ptr %203, align 4
  %204 = getelementptr inbounds i8, ptr %202, i32 16
  %205 = call ptr @realloc(ptr null, i64 8)
  store ptr %204, ptr %205, align 8
  %206 = insertvalue { ptr, i32, i32, i32 } %190, ptr %205, 0
  %207 = insertvalue { ptr, i32, i32, i32 } %206, i32 %198, 3
  br label %228

208:                                              ; preds = %181
  %209 = icmp ult i32 %189, %192
  br i1 %209, label %210, label %211

210:                                              ; preds = %208
  br label %225

211:                                              ; preds = %208
  %212 = shl i32 %192, 1
  %213 = call i32 @llvm.umin.i32(i32 %212, i32 1024)
  %214 = add i32 %213, %192
  %215 = call i32 @llvm.umax.i32(i32 %214, i32 8)
  %216 = zext i32 %215 to i64
  %217 = mul i64 %216, 32
  %218 = add i64 %217, 16
  %219 = extractvalue { ptr, i32, i32, i32 } %180, 0
  %220 = load ptr, ptr %219, align 8
  %221 = getelementptr inbounds i8, ptr %220, i32 -16
  %222 = call ptr @realloc(ptr %221, i64 %218)
  %223 = getelementptr inbounds i8, ptr %222, i32 16
  store ptr %223, ptr %219, align 8
  %224 = insertvalue { ptr, i32, i32, i32 } %190, i32 %215, 3
  br label %225

225:                                              ; preds = %210, %211
  %226 = phi { ptr, i32, i32, i32 } [ %224, %211 ], [ %190, %210 ]
  br label %227

227:                                              ; preds = %225
  br label %228

228:                                              ; preds = %194, %227
  %229 = phi { ptr, i32, i32, i32 } [ %226, %227 ], [ %207, %194 ]
  br label %230

230:                                              ; preds = %228
  %231 = extractvalue { ptr, i32, i32, i32 } %229, 0
  %232 = load ptr, ptr %231, align 8
  %233 = extractvalue { ptr, i32, i32, i32 } %229, 2
  %234 = zext i32 %233 to i64
  %235 = mul i64 %234, 32
  %236 = getelementptr inbounds i8, ptr %232, i64 %235
  store i252 %141, ptr %236, align 16
  %237 = extractvalue { ptr, i32, i32, i32 } %229, 2
  %238 = add i32 %237, 1
  %239 = insertvalue { ptr, i32, i32, i32 } %229, i32 %238, 2
  %240 = getelementptr inbounds i8, ptr %232, i32 -12
  store i32 %238, ptr %240, align 4
  %241 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %136, 0
  %242 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %241, { ptr, i32, i32, i32 } %239)
  %243 = extractvalue { i64, i64, { i64, [24 x i8] } } %242, 0
  %244 = extractvalue { i64, i64, { i64, [24 x i8] } } %242, 1
  %245 = extractvalue { i64, i64, { i64, [24 x i8] } } %242, 2
  store { i64, [24 x i8] } %245, ptr %6, align 8
  %246 = load i1, ptr %6, align 1
  switch i1 %246, label %310 [
    i1 false, label %312
    i1 true, label %435
  ]

247:                                              ; preds = %4
  %248 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %5, align 16
  %249 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %248, 1
  %250 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %251 = call ptr %250()
  %252 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %253 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %254 = icmp eq i32 %253, 0
  br i1 %254, label %255, label %269

255:                                              ; preds = %247
  %256 = shl i32 %253, 1
  %257 = call i32 @llvm.umin.i32(i32 %256, i32 1024)
  %258 = add i32 %257, %253
  %259 = call i32 @llvm.umax.i32(i32 %258, i32 8)
  %260 = zext i32 %259 to i64
  %261 = mul i64 %260, 32
  %262 = add i64 %261, 16
  %263 = call ptr @realloc(ptr null, i64 %262)
  store i32 1, ptr %263, align 4
  %264 = getelementptr inbounds i8, ptr %263, i32 4
  store i32 0, ptr %264, align 4
  %265 = getelementptr inbounds i8, ptr %263, i32 16
  %266 = call ptr @realloc(ptr null, i64 8)
  store ptr %265, ptr %266, align 8
  %267 = insertvalue { ptr, i32, i32, i32 } %3, ptr %266, 0
  %268 = insertvalue { ptr, i32, i32, i32 } %267, i32 %259, 3
  br label %290

269:                                              ; preds = %247
  %270 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %271 = icmp ult i32 %270, %253
  br i1 %271, label %272, label %273

272:                                              ; preds = %269
  br label %287

273:                                              ; preds = %269
  %274 = shl i32 %253, 1
  %275 = call i32 @llvm.umin.i32(i32 %274, i32 1024)
  %276 = add i32 %275, %253
  %277 = call i32 @llvm.umax.i32(i32 %276, i32 8)
  %278 = zext i32 %277 to i64
  %279 = mul i64 %278, 32
  %280 = add i64 %279, 16
  %281 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %282 = load ptr, ptr %281, align 8
  %283 = getelementptr inbounds i8, ptr %282, i32 -16
  %284 = call ptr @realloc(ptr %283, i64 %280)
  %285 = getelementptr inbounds i8, ptr %284, i32 16
  store ptr %285, ptr %281, align 8
  %286 = insertvalue { ptr, i32, i32, i32 } %3, i32 %277, 3
  br label %287

287:                                              ; preds = %272, %273
  %288 = phi { ptr, i32, i32, i32 } [ %286, %273 ], [ %3, %272 ]
  br label %289

289:                                              ; preds = %287
  br label %290

290:                                              ; preds = %255, %289
  %291 = phi { ptr, i32, i32, i32 } [ %288, %289 ], [ %268, %255 ]
  br label %292

292:                                              ; preds = %290
  %293 = extractvalue { ptr, i32, i32, i32 } %291, 0
  %294 = load ptr, ptr %293, align 8
  %295 = extractvalue { ptr, i32, i32, i32 } %291, 2
  %296 = zext i32 %295 to i64
  %297 = mul i64 %296, 32
  %298 = getelementptr inbounds i8, ptr %294, i64 %297
  store i252 2, ptr %298, align 16
  %299 = extractvalue { ptr, i32, i32, i32 } %291, 2
  %300 = add i32 %299, 1
  %301 = insertvalue { ptr, i32, i32, i32 } %291, i32 %300, 2
  %302 = getelementptr inbounds i8, ptr %294, i32 -12
  store i32 %300, ptr %302, align 4
  %303 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f95"(i64 %0, i64 %252, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %249, { ptr, i32, i32, i32 } %301)
  %304 = extractvalue { i64, i64, { i64, [24 x i8] } } %303, 0
  %305 = extractvalue { i64, i64, { i64, [24 x i8] } } %303, 1
  %306 = extractvalue { i64, i64, { i64, [24 x i8] } } %303, 2
  %307 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %304, 0
  %308 = insertvalue { i64, i64, { i64, [24 x i8] } } %307, i64 %305, 1
  %309 = insertvalue { i64, i64, { i64, [24 x i8] } } %308, { i64, [24 x i8] } %306, 2
  ret { i64, i64, { i64, [24 x i8] } } %309

310:                                              ; preds = %230
  br i1 false, label %311, label %444

311:                                              ; preds = %310
  unreachable

312:                                              ; preds = %230
  %313 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %314 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %313, 1
  %315 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %316 = call ptr %315()
  %317 = load i64, ptr %316, align 8
  %318 = mul i64 %317, 7540
  %319 = call i64 @llvm.uadd.sat.i64(i64 %244, i64 %318)
  %320 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %132)
  %321 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %320, 0
  %322 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %320, 1
  %323 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %322, 0
  %324 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %322, 2
  call void @"drop$163"({ ptr, i32, i32, i32 } %323)
  %325 = zext i32 %324 to i252
  %326 = extractvalue { { ptr, i32, i32, i32 }, {} } %314, 0
  %327 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %321, 0
  %328 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %321, 1
  call void @"drop$163"({ ptr, i32, i32, i32 } %327)
  %329 = extractvalue { ptr, i32, i32, i32 } %326, 3
  %330 = icmp eq i32 %329, 0
  br i1 %330, label %331, label %345

331:                                              ; preds = %312
  %332 = shl i32 %329, 1
  %333 = call i32 @llvm.umin.i32(i32 %332, i32 1024)
  %334 = add i32 %333, %329
  %335 = call i32 @llvm.umax.i32(i32 %334, i32 8)
  %336 = zext i32 %335 to i64
  %337 = mul i64 %336, 32
  %338 = add i64 %337, 16
  %339 = call ptr @realloc(ptr null, i64 %338)
  store i32 1, ptr %339, align 4
  %340 = getelementptr inbounds i8, ptr %339, i32 4
  store i32 0, ptr %340, align 4
  %341 = getelementptr inbounds i8, ptr %339, i32 16
  %342 = call ptr @realloc(ptr null, i64 8)
  store ptr %341, ptr %342, align 8
  %343 = insertvalue { ptr, i32, i32, i32 } %326, ptr %342, 0
  %344 = insertvalue { ptr, i32, i32, i32 } %343, i32 %335, 3
  br label %366

345:                                              ; preds = %312
  %346 = extractvalue { ptr, i32, i32, i32 } %326, 2
  %347 = icmp ult i32 %346, %329
  br i1 %347, label %348, label %349

348:                                              ; preds = %345
  br label %363

349:                                              ; preds = %345
  %350 = shl i32 %329, 1
  %351 = call i32 @llvm.umin.i32(i32 %350, i32 1024)
  %352 = add i32 %351, %329
  %353 = call i32 @llvm.umax.i32(i32 %352, i32 8)
  %354 = zext i32 %353 to i64
  %355 = mul i64 %354, 32
  %356 = add i64 %355, 16
  %357 = extractvalue { ptr, i32, i32, i32 } %326, 0
  %358 = load ptr, ptr %357, align 8
  %359 = getelementptr inbounds i8, ptr %358, i32 -16
  %360 = call ptr @realloc(ptr %359, i64 %356)
  %361 = getelementptr inbounds i8, ptr %360, i32 16
  store ptr %361, ptr %357, align 8
  %362 = insertvalue { ptr, i32, i32, i32 } %326, i32 %353, 3
  br label %363

363:                                              ; preds = %348, %349
  %364 = phi { ptr, i32, i32, i32 } [ %362, %349 ], [ %326, %348 ]
  br label %365

365:                                              ; preds = %363
  br label %366

366:                                              ; preds = %331, %365
  %367 = phi { ptr, i32, i32, i32 } [ %364, %365 ], [ %344, %331 ]
  br label %368

368:                                              ; preds = %366
  %369 = extractvalue { ptr, i32, i32, i32 } %367, 0
  %370 = load ptr, ptr %369, align 8
  %371 = extractvalue { ptr, i32, i32, i32 } %367, 2
  %372 = zext i32 %371 to i64
  %373 = mul i64 %372, 32
  %374 = getelementptr inbounds i8, ptr %370, i64 %373
  store i252 %328, ptr %374, align 16
  %375 = extractvalue { ptr, i32, i32, i32 } %367, 2
  %376 = add i32 %375, 1
  %377 = insertvalue { ptr, i32, i32, i32 } %367, i32 %376, 2
  %378 = getelementptr inbounds i8, ptr %370, i32 -12
  store i32 %376, ptr %378, align 4
  %379 = extractvalue { ptr, i32, i32, i32 } %367, 3
  %380 = icmp eq i32 %379, 0
  br i1 %380, label %381, label %395

381:                                              ; preds = %368
  %382 = shl i32 %379, 1
  %383 = call i32 @llvm.umin.i32(i32 %382, i32 1024)
  %384 = add i32 %383, %379
  %385 = call i32 @llvm.umax.i32(i32 %384, i32 8)
  %386 = zext i32 %385 to i64
  %387 = mul i64 %386, 32
  %388 = add i64 %387, 16
  %389 = call ptr @realloc(ptr null, i64 %388)
  store i32 1, ptr %389, align 4
  %390 = getelementptr inbounds i8, ptr %389, i32 4
  store i32 0, ptr %390, align 4
  %391 = getelementptr inbounds i8, ptr %389, i32 16
  %392 = call ptr @realloc(ptr null, i64 8)
  store ptr %391, ptr %392, align 8
  %393 = insertvalue { ptr, i32, i32, i32 } %377, ptr %392, 0
  %394 = insertvalue { ptr, i32, i32, i32 } %393, i32 %385, 3
  br label %415

395:                                              ; preds = %368
  %396 = icmp ult i32 %376, %379
  br i1 %396, label %397, label %398

397:                                              ; preds = %395
  br label %412

398:                                              ; preds = %395
  %399 = shl i32 %379, 1
  %400 = call i32 @llvm.umin.i32(i32 %399, i32 1024)
  %401 = add i32 %400, %379
  %402 = call i32 @llvm.umax.i32(i32 %401, i32 8)
  %403 = zext i32 %402 to i64
  %404 = mul i64 %403, 32
  %405 = add i64 %404, 16
  %406 = extractvalue { ptr, i32, i32, i32 } %367, 0
  %407 = load ptr, ptr %406, align 8
  %408 = getelementptr inbounds i8, ptr %407, i32 -16
  %409 = call ptr @realloc(ptr %408, i64 %405)
  %410 = getelementptr inbounds i8, ptr %409, i32 16
  store ptr %410, ptr %406, align 8
  %411 = insertvalue { ptr, i32, i32, i32 } %377, i32 %402, 3
  br label %412

412:                                              ; preds = %397, %398
  %413 = phi { ptr, i32, i32, i32 } [ %411, %398 ], [ %377, %397 ]
  br label %414

414:                                              ; preds = %412
  br label %415

415:                                              ; preds = %381, %414
  %416 = phi { ptr, i32, i32, i32 } [ %413, %414 ], [ %394, %381 ]
  br label %417

417:                                              ; preds = %415
  %418 = extractvalue { ptr, i32, i32, i32 } %416, 0
  %419 = load ptr, ptr %418, align 8
  %420 = extractvalue { ptr, i32, i32, i32 } %416, 2
  %421 = zext i32 %420 to i64
  %422 = mul i64 %421, 32
  %423 = getelementptr inbounds i8, ptr %419, i64 %422
  store i252 %325, ptr %423, align 16
  %424 = extractvalue { ptr, i32, i32, i32 } %416, 2
  %425 = add i32 %424, 1
  %426 = insertvalue { ptr, i32, i32, i32 } %416, i32 %425, 2
  %427 = getelementptr inbounds i8, ptr %419, i32 -12
  store i32 %425, ptr %427, align 4
  %428 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %426, 0
  %429 = insertvalue { { ptr, i32, i32, i32 }, {} } %428, {} undef, 1
  %430 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %429, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %430, ptr %8, align 8
  %431 = load { i64, [24 x i8] }, ptr %8, align 8
  %432 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %243, 0
  %433 = insertvalue { i64, i64, { i64, [24 x i8] } } %432, i64 %319, 1
  %434 = insertvalue { i64, i64, { i64, [24 x i8] } } %433, { i64, [24 x i8] } %431, 2
  ret { i64, i64, { i64, [24 x i8] } } %434

435:                                              ; preds = %230
  %436 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %437 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %436, 1
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %132)
  %438 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %437, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %438, ptr %7, align 8
  %439 = load { i64, [24 x i8] }, ptr %7, align 8
  %440 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %243, 0
  %441 = insertvalue { i64, i64, { i64, [24 x i8] } } %440, i64 %244, 1
  %442 = insertvalue { i64, i64, { i64, [24 x i8] } } %441, { i64, [24 x i8] } %439, 2
  ret { i64, i64, { i64, [24 x i8] } } %442

443:                                              ; preds = %12
  call void @puts(ptr @assert_msg_153)
  call void @abort()
  unreachable

444:                                              ; preds = %310
  call void @puts(ptr @assert_msg_154)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f89(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f89"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f89(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f89(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { { { ptr, i32, i32, i32 } } } @"impl$f90"({ { i3, [0 x i8] }, i32, i32, i252 } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %0, 0
  %3 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %0, 1
  %4 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %0, 2
  %5 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %0, 3
  %6 = extractvalue { i3, [0 x i8] } %2, 0
  switch i3 %6, label %7 [
    i3 0, label %9
    i3 1, label %62
    i3 2, label %115
    i3 3, label %168
    i3 -4, label %221
    i3 -3, label %274
    i3 -2, label %327
  ]

7:                                                ; preds = %1
  br i1 false, label %8, label %540

8:                                                ; preds = %7
  unreachable

9:                                                ; preds = %1
  %10 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %11 = phi i252 [ 0, %1 ]
  %12 = extractvalue { ptr, i32, i32, i32 } %10, 3
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %14, label %28

14:                                               ; preds = %9
  %15 = shl i32 %12, 1
  %16 = call i32 @llvm.umin.i32(i32 %15, i32 1024)
  %17 = add i32 %16, %12
  %18 = call i32 @llvm.umax.i32(i32 %17, i32 8)
  %19 = zext i32 %18 to i64
  %20 = mul i64 %19, 32
  %21 = add i64 %20, 16
  %22 = call ptr @realloc(ptr null, i64 %21)
  store i32 1, ptr %22, align 4
  %23 = getelementptr inbounds i8, ptr %22, i32 4
  store i32 0, ptr %23, align 4
  %24 = getelementptr inbounds i8, ptr %22, i32 16
  %25 = call ptr @realloc(ptr null, i64 8)
  store ptr %24, ptr %25, align 8
  %26 = insertvalue { ptr, i32, i32, i32 } %10, ptr %25, 0
  %27 = insertvalue { ptr, i32, i32, i32 } %26, i32 %18, 3
  br label %49

28:                                               ; preds = %9
  %29 = extractvalue { ptr, i32, i32, i32 } %10, 2
  %30 = icmp ult i32 %29, %12
  br i1 %30, label %31, label %32

31:                                               ; preds = %28
  br label %46

32:                                               ; preds = %28
  %33 = shl i32 %12, 1
  %34 = call i32 @llvm.umin.i32(i32 %33, i32 1024)
  %35 = add i32 %34, %12
  %36 = call i32 @llvm.umax.i32(i32 %35, i32 8)
  %37 = zext i32 %36 to i64
  %38 = mul i64 %37, 32
  %39 = add i64 %38, 16
  %40 = extractvalue { ptr, i32, i32, i32 } %10, 0
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr inbounds i8, ptr %41, i32 -16
  %43 = call ptr @realloc(ptr %42, i64 %39)
  %44 = getelementptr inbounds i8, ptr %43, i32 16
  store ptr %44, ptr %40, align 8
  %45 = insertvalue { ptr, i32, i32, i32 } %10, i32 %36, 3
  br label %46

46:                                               ; preds = %31, %32
  %47 = phi { ptr, i32, i32, i32 } [ %45, %32 ], [ %10, %31 ]
  br label %48

48:                                               ; preds = %46
  br label %49

49:                                               ; preds = %14, %48
  %50 = phi { ptr, i32, i32, i32 } [ %47, %48 ], [ %27, %14 ]
  br label %51

51:                                               ; preds = %49
  %52 = extractvalue { ptr, i32, i32, i32 } %50, 0
  %53 = load ptr, ptr %52, align 8
  %54 = extractvalue { ptr, i32, i32, i32 } %50, 2
  %55 = zext i32 %54 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %53, i64 %56
  store i252 %11, ptr %57, align 16
  %58 = extractvalue { ptr, i32, i32, i32 } %50, 2
  %59 = add i32 %58, 1
  %60 = insertvalue { ptr, i32, i32, i32 } %50, i32 %59, 2
  %61 = getelementptr inbounds i8, ptr %53, i32 -12
  store i32 %59, ptr %61, align 4
  br label %380

62:                                               ; preds = %1
  %63 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %64 = phi i252 [ 1, %1 ]
  %65 = extractvalue { ptr, i32, i32, i32 } %63, 3
  %66 = icmp eq i32 %65, 0
  br i1 %66, label %67, label %81

67:                                               ; preds = %62
  %68 = shl i32 %65, 1
  %69 = call i32 @llvm.umin.i32(i32 %68, i32 1024)
  %70 = add i32 %69, %65
  %71 = call i32 @llvm.umax.i32(i32 %70, i32 8)
  %72 = zext i32 %71 to i64
  %73 = mul i64 %72, 32
  %74 = add i64 %73, 16
  %75 = call ptr @realloc(ptr null, i64 %74)
  store i32 1, ptr %75, align 4
  %76 = getelementptr inbounds i8, ptr %75, i32 4
  store i32 0, ptr %76, align 4
  %77 = getelementptr inbounds i8, ptr %75, i32 16
  %78 = call ptr @realloc(ptr null, i64 8)
  store ptr %77, ptr %78, align 8
  %79 = insertvalue { ptr, i32, i32, i32 } %63, ptr %78, 0
  %80 = insertvalue { ptr, i32, i32, i32 } %79, i32 %71, 3
  br label %102

81:                                               ; preds = %62
  %82 = extractvalue { ptr, i32, i32, i32 } %63, 2
  %83 = icmp ult i32 %82, %65
  br i1 %83, label %84, label %85

84:                                               ; preds = %81
  br label %99

85:                                               ; preds = %81
  %86 = shl i32 %65, 1
  %87 = call i32 @llvm.umin.i32(i32 %86, i32 1024)
  %88 = add i32 %87, %65
  %89 = call i32 @llvm.umax.i32(i32 %88, i32 8)
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 32
  %92 = add i64 %91, 16
  %93 = extractvalue { ptr, i32, i32, i32 } %63, 0
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr inbounds i8, ptr %94, i32 -16
  %96 = call ptr @realloc(ptr %95, i64 %92)
  %97 = getelementptr inbounds i8, ptr %96, i32 16
  store ptr %97, ptr %93, align 8
  %98 = insertvalue { ptr, i32, i32, i32 } %63, i32 %89, 3
  br label %99

99:                                               ; preds = %84, %85
  %100 = phi { ptr, i32, i32, i32 } [ %98, %85 ], [ %63, %84 ]
  br label %101

101:                                              ; preds = %99
  br label %102

102:                                              ; preds = %67, %101
  %103 = phi { ptr, i32, i32, i32 } [ %100, %101 ], [ %80, %67 ]
  br label %104

104:                                              ; preds = %102
  %105 = extractvalue { ptr, i32, i32, i32 } %103, 0
  %106 = load ptr, ptr %105, align 8
  %107 = extractvalue { ptr, i32, i32, i32 } %103, 2
  %108 = zext i32 %107 to i64
  %109 = mul i64 %108, 32
  %110 = getelementptr inbounds i8, ptr %106, i64 %109
  store i252 %64, ptr %110, align 16
  %111 = extractvalue { ptr, i32, i32, i32 } %103, 2
  %112 = add i32 %111, 1
  %113 = insertvalue { ptr, i32, i32, i32 } %103, i32 %112, 2
  %114 = getelementptr inbounds i8, ptr %106, i32 -12
  store i32 %112, ptr %114, align 4
  br label %380

115:                                              ; preds = %1
  %116 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %117 = phi i252 [ 2, %1 ]
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 3
  %119 = icmp eq i32 %118, 0
  br i1 %119, label %120, label %134

120:                                              ; preds = %115
  %121 = shl i32 %118, 1
  %122 = call i32 @llvm.umin.i32(i32 %121, i32 1024)
  %123 = add i32 %122, %118
  %124 = call i32 @llvm.umax.i32(i32 %123, i32 8)
  %125 = zext i32 %124 to i64
  %126 = mul i64 %125, 32
  %127 = add i64 %126, 16
  %128 = call ptr @realloc(ptr null, i64 %127)
  store i32 1, ptr %128, align 4
  %129 = getelementptr inbounds i8, ptr %128, i32 4
  store i32 0, ptr %129, align 4
  %130 = getelementptr inbounds i8, ptr %128, i32 16
  %131 = call ptr @realloc(ptr null, i64 8)
  store ptr %130, ptr %131, align 8
  %132 = insertvalue { ptr, i32, i32, i32 } %116, ptr %131, 0
  %133 = insertvalue { ptr, i32, i32, i32 } %132, i32 %124, 3
  br label %155

134:                                              ; preds = %115
  %135 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %136 = icmp ult i32 %135, %118
  br i1 %136, label %137, label %138

137:                                              ; preds = %134
  br label %152

138:                                              ; preds = %134
  %139 = shl i32 %118, 1
  %140 = call i32 @llvm.umin.i32(i32 %139, i32 1024)
  %141 = add i32 %140, %118
  %142 = call i32 @llvm.umax.i32(i32 %141, i32 8)
  %143 = zext i32 %142 to i64
  %144 = mul i64 %143, 32
  %145 = add i64 %144, 16
  %146 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr inbounds i8, ptr %147, i32 -16
  %149 = call ptr @realloc(ptr %148, i64 %145)
  %150 = getelementptr inbounds i8, ptr %149, i32 16
  store ptr %150, ptr %146, align 8
  %151 = insertvalue { ptr, i32, i32, i32 } %116, i32 %142, 3
  br label %152

152:                                              ; preds = %137, %138
  %153 = phi { ptr, i32, i32, i32 } [ %151, %138 ], [ %116, %137 ]
  br label %154

154:                                              ; preds = %152
  br label %155

155:                                              ; preds = %120, %154
  %156 = phi { ptr, i32, i32, i32 } [ %153, %154 ], [ %133, %120 ]
  br label %157

157:                                              ; preds = %155
  %158 = extractvalue { ptr, i32, i32, i32 } %156, 0
  %159 = load ptr, ptr %158, align 8
  %160 = extractvalue { ptr, i32, i32, i32 } %156, 2
  %161 = zext i32 %160 to i64
  %162 = mul i64 %161, 32
  %163 = getelementptr inbounds i8, ptr %159, i64 %162
  store i252 %117, ptr %163, align 16
  %164 = extractvalue { ptr, i32, i32, i32 } %156, 2
  %165 = add i32 %164, 1
  %166 = insertvalue { ptr, i32, i32, i32 } %156, i32 %165, 2
  %167 = getelementptr inbounds i8, ptr %159, i32 -12
  store i32 %165, ptr %167, align 4
  br label %380

168:                                              ; preds = %1
  %169 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %170 = phi i252 [ 3, %1 ]
  %171 = extractvalue { ptr, i32, i32, i32 } %169, 3
  %172 = icmp eq i32 %171, 0
  br i1 %172, label %173, label %187

173:                                              ; preds = %168
  %174 = shl i32 %171, 1
  %175 = call i32 @llvm.umin.i32(i32 %174, i32 1024)
  %176 = add i32 %175, %171
  %177 = call i32 @llvm.umax.i32(i32 %176, i32 8)
  %178 = zext i32 %177 to i64
  %179 = mul i64 %178, 32
  %180 = add i64 %179, 16
  %181 = call ptr @realloc(ptr null, i64 %180)
  store i32 1, ptr %181, align 4
  %182 = getelementptr inbounds i8, ptr %181, i32 4
  store i32 0, ptr %182, align 4
  %183 = getelementptr inbounds i8, ptr %181, i32 16
  %184 = call ptr @realloc(ptr null, i64 8)
  store ptr %183, ptr %184, align 8
  %185 = insertvalue { ptr, i32, i32, i32 } %169, ptr %184, 0
  %186 = insertvalue { ptr, i32, i32, i32 } %185, i32 %177, 3
  br label %208

187:                                              ; preds = %168
  %188 = extractvalue { ptr, i32, i32, i32 } %169, 2
  %189 = icmp ult i32 %188, %171
  br i1 %189, label %190, label %191

190:                                              ; preds = %187
  br label %205

191:                                              ; preds = %187
  %192 = shl i32 %171, 1
  %193 = call i32 @llvm.umin.i32(i32 %192, i32 1024)
  %194 = add i32 %193, %171
  %195 = call i32 @llvm.umax.i32(i32 %194, i32 8)
  %196 = zext i32 %195 to i64
  %197 = mul i64 %196, 32
  %198 = add i64 %197, 16
  %199 = extractvalue { ptr, i32, i32, i32 } %169, 0
  %200 = load ptr, ptr %199, align 8
  %201 = getelementptr inbounds i8, ptr %200, i32 -16
  %202 = call ptr @realloc(ptr %201, i64 %198)
  %203 = getelementptr inbounds i8, ptr %202, i32 16
  store ptr %203, ptr %199, align 8
  %204 = insertvalue { ptr, i32, i32, i32 } %169, i32 %195, 3
  br label %205

205:                                              ; preds = %190, %191
  %206 = phi { ptr, i32, i32, i32 } [ %204, %191 ], [ %169, %190 ]
  br label %207

207:                                              ; preds = %205
  br label %208

208:                                              ; preds = %173, %207
  %209 = phi { ptr, i32, i32, i32 } [ %206, %207 ], [ %186, %173 ]
  br label %210

210:                                              ; preds = %208
  %211 = extractvalue { ptr, i32, i32, i32 } %209, 0
  %212 = load ptr, ptr %211, align 8
  %213 = extractvalue { ptr, i32, i32, i32 } %209, 2
  %214 = zext i32 %213 to i64
  %215 = mul i64 %214, 32
  %216 = getelementptr inbounds i8, ptr %212, i64 %215
  store i252 %170, ptr %216, align 16
  %217 = extractvalue { ptr, i32, i32, i32 } %209, 2
  %218 = add i32 %217, 1
  %219 = insertvalue { ptr, i32, i32, i32 } %209, i32 %218, 2
  %220 = getelementptr inbounds i8, ptr %212, i32 -12
  store i32 %218, ptr %220, align 4
  br label %380

221:                                              ; preds = %1
  %222 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %223 = phi i252 [ 4, %1 ]
  %224 = extractvalue { ptr, i32, i32, i32 } %222, 3
  %225 = icmp eq i32 %224, 0
  br i1 %225, label %226, label %240

226:                                              ; preds = %221
  %227 = shl i32 %224, 1
  %228 = call i32 @llvm.umin.i32(i32 %227, i32 1024)
  %229 = add i32 %228, %224
  %230 = call i32 @llvm.umax.i32(i32 %229, i32 8)
  %231 = zext i32 %230 to i64
  %232 = mul i64 %231, 32
  %233 = add i64 %232, 16
  %234 = call ptr @realloc(ptr null, i64 %233)
  store i32 1, ptr %234, align 4
  %235 = getelementptr inbounds i8, ptr %234, i32 4
  store i32 0, ptr %235, align 4
  %236 = getelementptr inbounds i8, ptr %234, i32 16
  %237 = call ptr @realloc(ptr null, i64 8)
  store ptr %236, ptr %237, align 8
  %238 = insertvalue { ptr, i32, i32, i32 } %222, ptr %237, 0
  %239 = insertvalue { ptr, i32, i32, i32 } %238, i32 %230, 3
  br label %261

240:                                              ; preds = %221
  %241 = extractvalue { ptr, i32, i32, i32 } %222, 2
  %242 = icmp ult i32 %241, %224
  br i1 %242, label %243, label %244

243:                                              ; preds = %240
  br label %258

244:                                              ; preds = %240
  %245 = shl i32 %224, 1
  %246 = call i32 @llvm.umin.i32(i32 %245, i32 1024)
  %247 = add i32 %246, %224
  %248 = call i32 @llvm.umax.i32(i32 %247, i32 8)
  %249 = zext i32 %248 to i64
  %250 = mul i64 %249, 32
  %251 = add i64 %250, 16
  %252 = extractvalue { ptr, i32, i32, i32 } %222, 0
  %253 = load ptr, ptr %252, align 8
  %254 = getelementptr inbounds i8, ptr %253, i32 -16
  %255 = call ptr @realloc(ptr %254, i64 %251)
  %256 = getelementptr inbounds i8, ptr %255, i32 16
  store ptr %256, ptr %252, align 8
  %257 = insertvalue { ptr, i32, i32, i32 } %222, i32 %248, 3
  br label %258

258:                                              ; preds = %243, %244
  %259 = phi { ptr, i32, i32, i32 } [ %257, %244 ], [ %222, %243 ]
  br label %260

260:                                              ; preds = %258
  br label %261

261:                                              ; preds = %226, %260
  %262 = phi { ptr, i32, i32, i32 } [ %259, %260 ], [ %239, %226 ]
  br label %263

263:                                              ; preds = %261
  %264 = extractvalue { ptr, i32, i32, i32 } %262, 0
  %265 = load ptr, ptr %264, align 8
  %266 = extractvalue { ptr, i32, i32, i32 } %262, 2
  %267 = zext i32 %266 to i64
  %268 = mul i64 %267, 32
  %269 = getelementptr inbounds i8, ptr %265, i64 %268
  store i252 %223, ptr %269, align 16
  %270 = extractvalue { ptr, i32, i32, i32 } %262, 2
  %271 = add i32 %270, 1
  %272 = insertvalue { ptr, i32, i32, i32 } %262, i32 %271, 2
  %273 = getelementptr inbounds i8, ptr %265, i32 -12
  store i32 %271, ptr %273, align 4
  br label %380

274:                                              ; preds = %1
  %275 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %276 = phi i252 [ 5, %1 ]
  %277 = extractvalue { ptr, i32, i32, i32 } %275, 3
  %278 = icmp eq i32 %277, 0
  br i1 %278, label %279, label %293

279:                                              ; preds = %274
  %280 = shl i32 %277, 1
  %281 = call i32 @llvm.umin.i32(i32 %280, i32 1024)
  %282 = add i32 %281, %277
  %283 = call i32 @llvm.umax.i32(i32 %282, i32 8)
  %284 = zext i32 %283 to i64
  %285 = mul i64 %284, 32
  %286 = add i64 %285, 16
  %287 = call ptr @realloc(ptr null, i64 %286)
  store i32 1, ptr %287, align 4
  %288 = getelementptr inbounds i8, ptr %287, i32 4
  store i32 0, ptr %288, align 4
  %289 = getelementptr inbounds i8, ptr %287, i32 16
  %290 = call ptr @realloc(ptr null, i64 8)
  store ptr %289, ptr %290, align 8
  %291 = insertvalue { ptr, i32, i32, i32 } %275, ptr %290, 0
  %292 = insertvalue { ptr, i32, i32, i32 } %291, i32 %283, 3
  br label %314

293:                                              ; preds = %274
  %294 = extractvalue { ptr, i32, i32, i32 } %275, 2
  %295 = icmp ult i32 %294, %277
  br i1 %295, label %296, label %297

296:                                              ; preds = %293
  br label %311

297:                                              ; preds = %293
  %298 = shl i32 %277, 1
  %299 = call i32 @llvm.umin.i32(i32 %298, i32 1024)
  %300 = add i32 %299, %277
  %301 = call i32 @llvm.umax.i32(i32 %300, i32 8)
  %302 = zext i32 %301 to i64
  %303 = mul i64 %302, 32
  %304 = add i64 %303, 16
  %305 = extractvalue { ptr, i32, i32, i32 } %275, 0
  %306 = load ptr, ptr %305, align 8
  %307 = getelementptr inbounds i8, ptr %306, i32 -16
  %308 = call ptr @realloc(ptr %307, i64 %304)
  %309 = getelementptr inbounds i8, ptr %308, i32 16
  store ptr %309, ptr %305, align 8
  %310 = insertvalue { ptr, i32, i32, i32 } %275, i32 %301, 3
  br label %311

311:                                              ; preds = %296, %297
  %312 = phi { ptr, i32, i32, i32 } [ %310, %297 ], [ %275, %296 ]
  br label %313

313:                                              ; preds = %311
  br label %314

314:                                              ; preds = %279, %313
  %315 = phi { ptr, i32, i32, i32 } [ %312, %313 ], [ %292, %279 ]
  br label %316

316:                                              ; preds = %314
  %317 = extractvalue { ptr, i32, i32, i32 } %315, 0
  %318 = load ptr, ptr %317, align 8
  %319 = extractvalue { ptr, i32, i32, i32 } %315, 2
  %320 = zext i32 %319 to i64
  %321 = mul i64 %320, 32
  %322 = getelementptr inbounds i8, ptr %318, i64 %321
  store i252 %276, ptr %322, align 16
  %323 = extractvalue { ptr, i32, i32, i32 } %315, 2
  %324 = add i32 %323, 1
  %325 = insertvalue { ptr, i32, i32, i32 } %315, i32 %324, 2
  %326 = getelementptr inbounds i8, ptr %318, i32 -12
  store i32 %324, ptr %326, align 4
  br label %380

327:                                              ; preds = %1
  %328 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %1 ]
  %329 = phi i252 [ 6, %1 ]
  %330 = extractvalue { ptr, i32, i32, i32 } %328, 3
  %331 = icmp eq i32 %330, 0
  br i1 %331, label %332, label %346

332:                                              ; preds = %327
  %333 = shl i32 %330, 1
  %334 = call i32 @llvm.umin.i32(i32 %333, i32 1024)
  %335 = add i32 %334, %330
  %336 = call i32 @llvm.umax.i32(i32 %335, i32 8)
  %337 = zext i32 %336 to i64
  %338 = mul i64 %337, 32
  %339 = add i64 %338, 16
  %340 = call ptr @realloc(ptr null, i64 %339)
  store i32 1, ptr %340, align 4
  %341 = getelementptr inbounds i8, ptr %340, i32 4
  store i32 0, ptr %341, align 4
  %342 = getelementptr inbounds i8, ptr %340, i32 16
  %343 = call ptr @realloc(ptr null, i64 8)
  store ptr %342, ptr %343, align 8
  %344 = insertvalue { ptr, i32, i32, i32 } %328, ptr %343, 0
  %345 = insertvalue { ptr, i32, i32, i32 } %344, i32 %336, 3
  br label %367

346:                                              ; preds = %327
  %347 = extractvalue { ptr, i32, i32, i32 } %328, 2
  %348 = icmp ult i32 %347, %330
  br i1 %348, label %349, label %350

349:                                              ; preds = %346
  br label %364

350:                                              ; preds = %346
  %351 = shl i32 %330, 1
  %352 = call i32 @llvm.umin.i32(i32 %351, i32 1024)
  %353 = add i32 %352, %330
  %354 = call i32 @llvm.umax.i32(i32 %353, i32 8)
  %355 = zext i32 %354 to i64
  %356 = mul i64 %355, 32
  %357 = add i64 %356, 16
  %358 = extractvalue { ptr, i32, i32, i32 } %328, 0
  %359 = load ptr, ptr %358, align 8
  %360 = getelementptr inbounds i8, ptr %359, i32 -16
  %361 = call ptr @realloc(ptr %360, i64 %357)
  %362 = getelementptr inbounds i8, ptr %361, i32 16
  store ptr %362, ptr %358, align 8
  %363 = insertvalue { ptr, i32, i32, i32 } %328, i32 %354, 3
  br label %364

364:                                              ; preds = %349, %350
  %365 = phi { ptr, i32, i32, i32 } [ %363, %350 ], [ %328, %349 ]
  br label %366

366:                                              ; preds = %364
  br label %367

367:                                              ; preds = %332, %366
  %368 = phi { ptr, i32, i32, i32 } [ %365, %366 ], [ %345, %332 ]
  br label %369

369:                                              ; preds = %367
  %370 = extractvalue { ptr, i32, i32, i32 } %368, 0
  %371 = load ptr, ptr %370, align 8
  %372 = extractvalue { ptr, i32, i32, i32 } %368, 2
  %373 = zext i32 %372 to i64
  %374 = mul i64 %373, 32
  %375 = getelementptr inbounds i8, ptr %371, i64 %374
  store i252 %329, ptr %375, align 16
  %376 = extractvalue { ptr, i32, i32, i32 } %368, 2
  %377 = add i32 %376, 1
  %378 = insertvalue { ptr, i32, i32, i32 } %368, i32 %377, 2
  %379 = getelementptr inbounds i8, ptr %371, i32 -12
  store i32 %377, ptr %379, align 4
  br label %380

380:                                              ; preds = %51, %104, %157, %210, %263, %316, %369
  %381 = phi i32 [ %3, %369 ], [ %3, %316 ], [ %3, %263 ], [ %3, %210 ], [ %3, %157 ], [ %3, %104 ], [ %3, %51 ]
  %382 = phi i32 [ %4, %369 ], [ %4, %316 ], [ %4, %263 ], [ %4, %210 ], [ %4, %157 ], [ %4, %104 ], [ %4, %51 ]
  %383 = phi i252 [ %5, %369 ], [ %5, %316 ], [ %5, %263 ], [ %5, %210 ], [ %5, %157 ], [ %5, %104 ], [ %5, %51 ]
  %384 = phi { ptr, i32, i32, i32 } [ %378, %369 ], [ %325, %316 ], [ %272, %263 ], [ %219, %210 ], [ %166, %157 ], [ %113, %104 ], [ %60, %51 ]
  %385 = zext i32 %381 to i252
  %386 = zext i32 %382 to i252
  %387 = extractvalue { ptr, i32, i32, i32 } %384, 3
  %388 = icmp eq i32 %387, 0
  br i1 %388, label %389, label %403

389:                                              ; preds = %380
  %390 = shl i32 %387, 1
  %391 = call i32 @llvm.umin.i32(i32 %390, i32 1024)
  %392 = add i32 %391, %387
  %393 = call i32 @llvm.umax.i32(i32 %392, i32 8)
  %394 = zext i32 %393 to i64
  %395 = mul i64 %394, 32
  %396 = add i64 %395, 16
  %397 = call ptr @realloc(ptr null, i64 %396)
  store i32 1, ptr %397, align 4
  %398 = getelementptr inbounds i8, ptr %397, i32 4
  store i32 0, ptr %398, align 4
  %399 = getelementptr inbounds i8, ptr %397, i32 16
  %400 = call ptr @realloc(ptr null, i64 8)
  store ptr %399, ptr %400, align 8
  %401 = insertvalue { ptr, i32, i32, i32 } %384, ptr %400, 0
  %402 = insertvalue { ptr, i32, i32, i32 } %401, i32 %393, 3
  br label %424

403:                                              ; preds = %380
  %404 = extractvalue { ptr, i32, i32, i32 } %384, 2
  %405 = icmp ult i32 %404, %387
  br i1 %405, label %406, label %407

406:                                              ; preds = %403
  br label %421

407:                                              ; preds = %403
  %408 = shl i32 %387, 1
  %409 = call i32 @llvm.umin.i32(i32 %408, i32 1024)
  %410 = add i32 %409, %387
  %411 = call i32 @llvm.umax.i32(i32 %410, i32 8)
  %412 = zext i32 %411 to i64
  %413 = mul i64 %412, 32
  %414 = add i64 %413, 16
  %415 = extractvalue { ptr, i32, i32, i32 } %384, 0
  %416 = load ptr, ptr %415, align 8
  %417 = getelementptr inbounds i8, ptr %416, i32 -16
  %418 = call ptr @realloc(ptr %417, i64 %414)
  %419 = getelementptr inbounds i8, ptr %418, i32 16
  store ptr %419, ptr %415, align 8
  %420 = insertvalue { ptr, i32, i32, i32 } %384, i32 %411, 3
  br label %421

421:                                              ; preds = %406, %407
  %422 = phi { ptr, i32, i32, i32 } [ %420, %407 ], [ %384, %406 ]
  br label %423

423:                                              ; preds = %421
  br label %424

424:                                              ; preds = %389, %423
  %425 = phi { ptr, i32, i32, i32 } [ %422, %423 ], [ %402, %389 ]
  br label %426

426:                                              ; preds = %424
  %427 = extractvalue { ptr, i32, i32, i32 } %425, 0
  %428 = load ptr, ptr %427, align 8
  %429 = extractvalue { ptr, i32, i32, i32 } %425, 2
  %430 = zext i32 %429 to i64
  %431 = mul i64 %430, 32
  %432 = getelementptr inbounds i8, ptr %428, i64 %431
  store i252 %385, ptr %432, align 16
  %433 = extractvalue { ptr, i32, i32, i32 } %425, 2
  %434 = add i32 %433, 1
  %435 = insertvalue { ptr, i32, i32, i32 } %425, i32 %434, 2
  %436 = getelementptr inbounds i8, ptr %428, i32 -12
  store i32 %434, ptr %436, align 4
  %437 = extractvalue { ptr, i32, i32, i32 } %425, 3
  %438 = icmp eq i32 %437, 0
  br i1 %438, label %439, label %453

439:                                              ; preds = %426
  %440 = shl i32 %437, 1
  %441 = call i32 @llvm.umin.i32(i32 %440, i32 1024)
  %442 = add i32 %441, %437
  %443 = call i32 @llvm.umax.i32(i32 %442, i32 8)
  %444 = zext i32 %443 to i64
  %445 = mul i64 %444, 32
  %446 = add i64 %445, 16
  %447 = call ptr @realloc(ptr null, i64 %446)
  store i32 1, ptr %447, align 4
  %448 = getelementptr inbounds i8, ptr %447, i32 4
  store i32 0, ptr %448, align 4
  %449 = getelementptr inbounds i8, ptr %447, i32 16
  %450 = call ptr @realloc(ptr null, i64 8)
  store ptr %449, ptr %450, align 8
  %451 = insertvalue { ptr, i32, i32, i32 } %435, ptr %450, 0
  %452 = insertvalue { ptr, i32, i32, i32 } %451, i32 %443, 3
  br label %473

453:                                              ; preds = %426
  %454 = icmp ult i32 %434, %437
  br i1 %454, label %455, label %456

455:                                              ; preds = %453
  br label %470

456:                                              ; preds = %453
  %457 = shl i32 %437, 1
  %458 = call i32 @llvm.umin.i32(i32 %457, i32 1024)
  %459 = add i32 %458, %437
  %460 = call i32 @llvm.umax.i32(i32 %459, i32 8)
  %461 = zext i32 %460 to i64
  %462 = mul i64 %461, 32
  %463 = add i64 %462, 16
  %464 = extractvalue { ptr, i32, i32, i32 } %425, 0
  %465 = load ptr, ptr %464, align 8
  %466 = getelementptr inbounds i8, ptr %465, i32 -16
  %467 = call ptr @realloc(ptr %466, i64 %463)
  %468 = getelementptr inbounds i8, ptr %467, i32 16
  store ptr %468, ptr %464, align 8
  %469 = insertvalue { ptr, i32, i32, i32 } %435, i32 %460, 3
  br label %470

470:                                              ; preds = %455, %456
  %471 = phi { ptr, i32, i32, i32 } [ %469, %456 ], [ %435, %455 ]
  br label %472

472:                                              ; preds = %470
  br label %473

473:                                              ; preds = %439, %472
  %474 = phi { ptr, i32, i32, i32 } [ %471, %472 ], [ %452, %439 ]
  br label %475

475:                                              ; preds = %473
  %476 = extractvalue { ptr, i32, i32, i32 } %474, 0
  %477 = load ptr, ptr %476, align 8
  %478 = extractvalue { ptr, i32, i32, i32 } %474, 2
  %479 = zext i32 %478 to i64
  %480 = mul i64 %479, 32
  %481 = getelementptr inbounds i8, ptr %477, i64 %480
  store i252 %386, ptr %481, align 16
  %482 = extractvalue { ptr, i32, i32, i32 } %474, 2
  %483 = add i32 %482, 1
  %484 = insertvalue { ptr, i32, i32, i32 } %474, i32 %483, 2
  %485 = getelementptr inbounds i8, ptr %477, i32 -12
  store i32 %483, ptr %485, align 4
  %486 = extractvalue { ptr, i32, i32, i32 } %474, 3
  %487 = icmp eq i32 %486, 0
  br i1 %487, label %488, label %502

488:                                              ; preds = %475
  %489 = shl i32 %486, 1
  %490 = call i32 @llvm.umin.i32(i32 %489, i32 1024)
  %491 = add i32 %490, %486
  %492 = call i32 @llvm.umax.i32(i32 %491, i32 8)
  %493 = zext i32 %492 to i64
  %494 = mul i64 %493, 32
  %495 = add i64 %494, 16
  %496 = call ptr @realloc(ptr null, i64 %495)
  store i32 1, ptr %496, align 4
  %497 = getelementptr inbounds i8, ptr %496, i32 4
  store i32 0, ptr %497, align 4
  %498 = getelementptr inbounds i8, ptr %496, i32 16
  %499 = call ptr @realloc(ptr null, i64 8)
  store ptr %498, ptr %499, align 8
  %500 = insertvalue { ptr, i32, i32, i32 } %484, ptr %499, 0
  %501 = insertvalue { ptr, i32, i32, i32 } %500, i32 %492, 3
  br label %522

502:                                              ; preds = %475
  %503 = icmp ult i32 %483, %486
  br i1 %503, label %504, label %505

504:                                              ; preds = %502
  br label %519

505:                                              ; preds = %502
  %506 = shl i32 %486, 1
  %507 = call i32 @llvm.umin.i32(i32 %506, i32 1024)
  %508 = add i32 %507, %486
  %509 = call i32 @llvm.umax.i32(i32 %508, i32 8)
  %510 = zext i32 %509 to i64
  %511 = mul i64 %510, 32
  %512 = add i64 %511, 16
  %513 = extractvalue { ptr, i32, i32, i32 } %474, 0
  %514 = load ptr, ptr %513, align 8
  %515 = getelementptr inbounds i8, ptr %514, i32 -16
  %516 = call ptr @realloc(ptr %515, i64 %512)
  %517 = getelementptr inbounds i8, ptr %516, i32 16
  store ptr %517, ptr %513, align 8
  %518 = insertvalue { ptr, i32, i32, i32 } %484, i32 %509, 3
  br label %519

519:                                              ; preds = %504, %505
  %520 = phi { ptr, i32, i32, i32 } [ %518, %505 ], [ %484, %504 ]
  br label %521

521:                                              ; preds = %519
  br label %522

522:                                              ; preds = %488, %521
  %523 = phi { ptr, i32, i32, i32 } [ %520, %521 ], [ %501, %488 ]
  br label %524

524:                                              ; preds = %522
  %525 = extractvalue { ptr, i32, i32, i32 } %523, 0
  %526 = load ptr, ptr %525, align 8
  %527 = extractvalue { ptr, i32, i32, i32 } %523, 2
  %528 = zext i32 %527 to i64
  %529 = mul i64 %528, 32
  %530 = getelementptr inbounds i8, ptr %526, i64 %529
  store i252 %383, ptr %530, align 16
  %531 = extractvalue { ptr, i32, i32, i32 } %523, 2
  %532 = add i32 %531, 1
  %533 = insertvalue { ptr, i32, i32, i32 } %523, i32 %532, 2
  %534 = getelementptr inbounds i8, ptr %526, i32 -12
  store i32 %532, ptr %534, align 4
  %535 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$26"({ ptr, i32, i32, i32 } %533)
  %536 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %535, 0
  %537 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %535, 1
  call void @"drop$26"({ ptr, i32, i32, i32 } %536)
  %538 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %537, 0
  %539 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %538, 0
  ret { { { ptr, i32, i32, i32 } } } %539

540:                                              ; preds = %7
  call void @puts(ptr @assert_msg_155)
  call void @abort()
  unreachable
}

define private { { ptr, i32, i32, i32 } } @f90({ { i3, [0 x i8] }, i32, i32, i252 } %0) {
  %2 = call fastcc { { { ptr, i32, i32, i32 } } } @"impl$f90"({ { i3, [0 x i8] }, i32, i32, i252 } %0)
  %3 = extractvalue { { { ptr, i32, i32, i32 } } } %2, 0
  ret { { ptr, i32, i32, i32 } } %3
}

define void @_mlir_ciface_f90(ptr %0, { { i3, [0 x i8] }, i32, i32, i252 } %1) {
  %3 = call { { ptr, i32, i32, i32 } } @f90({ { i3, [0 x i8] }, i32, i32, i252 } %1)
  store { { ptr, i32, i32, i32 } } %3, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f91"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, 1
  %10 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %8)
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %10, 0
  %12 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %10, 1
  %13 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %12, 0
  %14 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %13)
  %15 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %14, 0
  %16 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %14, 1
  %17 = extractvalue { ptr, i32, i32, i32 } %16, 1
  %18 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %19 = sub i32 %18, %17
  call void @"drop$163"({ ptr, i32, i32, i32 } %16)
  %20 = zext i32 %19 to i252
  %21 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %37

23:                                               ; preds = %4
  %24 = shl i32 %21, 1
  %25 = call i32 @llvm.umin.i32(i32 %24, i32 1024)
  %26 = add i32 %25, %21
  %27 = call i32 @llvm.umax.i32(i32 %26, i32 8)
  %28 = zext i32 %27 to i64
  %29 = mul i64 %28, 32
  %30 = add i64 %29, 16
  %31 = call ptr @realloc(ptr null, i64 %30)
  store i32 1, ptr %31, align 4
  %32 = getelementptr inbounds i8, ptr %31, i32 4
  store i32 0, ptr %32, align 4
  %33 = getelementptr inbounds i8, ptr %31, i32 16
  %34 = call ptr @realloc(ptr null, i64 8)
  store ptr %33, ptr %34, align 8
  %35 = insertvalue { ptr, i32, i32, i32 } %3, ptr %34, 0
  %36 = insertvalue { ptr, i32, i32, i32 } %35, i32 %27, 3
  br label %58

37:                                               ; preds = %4
  %38 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %39 = icmp ult i32 %38, %21
  br i1 %39, label %40, label %41

40:                                               ; preds = %37
  br label %55

41:                                               ; preds = %37
  %42 = shl i32 %21, 1
  %43 = call i32 @llvm.umin.i32(i32 %42, i32 1024)
  %44 = add i32 %43, %21
  %45 = call i32 @llvm.umax.i32(i32 %44, i32 8)
  %46 = zext i32 %45 to i64
  %47 = mul i64 %46, 32
  %48 = add i64 %47, 16
  %49 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %50 = load ptr, ptr %49, align 8
  %51 = getelementptr inbounds i8, ptr %50, i32 -16
  %52 = call ptr @realloc(ptr %51, i64 %48)
  %53 = getelementptr inbounds i8, ptr %52, i32 16
  store ptr %53, ptr %49, align 8
  %54 = insertvalue { ptr, i32, i32, i32 } %3, i32 %45, 3
  br label %55

55:                                               ; preds = %40, %41
  %56 = phi { ptr, i32, i32, i32 } [ %54, %41 ], [ %3, %40 ]
  br label %57

57:                                               ; preds = %55
  br label %58

58:                                               ; preds = %23, %57
  %59 = phi { ptr, i32, i32, i32 } [ %56, %57 ], [ %36, %23 ]
  br label %60

60:                                               ; preds = %58
  %61 = extractvalue { ptr, i32, i32, i32 } %59, 0
  %62 = load ptr, ptr %61, align 8
  %63 = extractvalue { ptr, i32, i32, i32 } %59, 2
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %62, i64 %65
  store i252 %20, ptr %66, align 16
  %67 = extractvalue { ptr, i32, i32, i32 } %59, 2
  %68 = add i32 %67, 1
  %69 = insertvalue { ptr, i32, i32, i32 } %59, i32 %68, 2
  %70 = getelementptr inbounds i8, ptr %62, i32 -12
  store i32 %68, ptr %70, align 4
  %71 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %15, 0
  %72 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %71, { ptr, i32, i32, i32 } %69)
  %73 = extractvalue { i64, i64, { i64, [24 x i8] } } %72, 0
  %74 = extractvalue { i64, i64, { i64, [24 x i8] } } %72, 1
  %75 = extractvalue { i64, i64, { i64, [24 x i8] } } %72, 2
  store { i64, [24 x i8] } %75, ptr %5, align 8
  %76 = load i1, ptr %5, align 1
  switch i1 %76, label %77 [
    i1 false, label %79
    i1 true, label %404
  ]

77:                                               ; preds = %60
  br i1 false, label %78, label %412

78:                                               ; preds = %77
  unreachable

79:                                               ; preds = %60
  %80 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %81 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %80, 1
  %82 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %83 = call ptr %82()
  %84 = call i64 @llvm.uadd.sat.i64(i64 %74, i64 0)
  %85 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %11)
  %86 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %85, 0
  %87 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %85, 1
  %88 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %87, 0
  %89 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %87, 2
  call void @"drop$163"({ ptr, i32, i32, i32 } %88)
  %90 = zext i32 %89 to i252
  %91 = extractvalue { i32, i32, i32, i32 } %9, 0
  %92 = zext i32 %91 to i252
  %93 = extractvalue { i32, i32, i32, i32 } %9, 1
  %94 = zext i32 %93 to i252
  %95 = extractvalue { i32, i32, i32, i32 } %9, 2
  %96 = zext i32 %95 to i252
  %97 = extractvalue { i32, i32, i32, i32 } %9, 3
  %98 = zext i32 %97 to i252
  %99 = extractvalue { { ptr, i32, i32, i32 }, {} } %81, 0
  %100 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %86, 0
  %101 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %86, 1
  call void @"drop$163"({ ptr, i32, i32, i32 } %100)
  %102 = extractvalue { ptr, i32, i32, i32 } %99, 3
  %103 = icmp eq i32 %102, 0
  br i1 %103, label %104, label %118

104:                                              ; preds = %79
  %105 = shl i32 %102, 1
  %106 = call i32 @llvm.umin.i32(i32 %105, i32 1024)
  %107 = add i32 %106, %102
  %108 = call i32 @llvm.umax.i32(i32 %107, i32 8)
  %109 = zext i32 %108 to i64
  %110 = mul i64 %109, 32
  %111 = add i64 %110, 16
  %112 = call ptr @realloc(ptr null, i64 %111)
  store i32 1, ptr %112, align 4
  %113 = getelementptr inbounds i8, ptr %112, i32 4
  store i32 0, ptr %113, align 4
  %114 = getelementptr inbounds i8, ptr %112, i32 16
  %115 = call ptr @realloc(ptr null, i64 8)
  store ptr %114, ptr %115, align 8
  %116 = insertvalue { ptr, i32, i32, i32 } %99, ptr %115, 0
  %117 = insertvalue { ptr, i32, i32, i32 } %116, i32 %108, 3
  br label %139

118:                                              ; preds = %79
  %119 = extractvalue { ptr, i32, i32, i32 } %99, 2
  %120 = icmp ult i32 %119, %102
  br i1 %120, label %121, label %122

121:                                              ; preds = %118
  br label %136

122:                                              ; preds = %118
  %123 = shl i32 %102, 1
  %124 = call i32 @llvm.umin.i32(i32 %123, i32 1024)
  %125 = add i32 %124, %102
  %126 = call i32 @llvm.umax.i32(i32 %125, i32 8)
  %127 = zext i32 %126 to i64
  %128 = mul i64 %127, 32
  %129 = add i64 %128, 16
  %130 = extractvalue { ptr, i32, i32, i32 } %99, 0
  %131 = load ptr, ptr %130, align 8
  %132 = getelementptr inbounds i8, ptr %131, i32 -16
  %133 = call ptr @realloc(ptr %132, i64 %129)
  %134 = getelementptr inbounds i8, ptr %133, i32 16
  store ptr %134, ptr %130, align 8
  %135 = insertvalue { ptr, i32, i32, i32 } %99, i32 %126, 3
  br label %136

136:                                              ; preds = %121, %122
  %137 = phi { ptr, i32, i32, i32 } [ %135, %122 ], [ %99, %121 ]
  br label %138

138:                                              ; preds = %136
  br label %139

139:                                              ; preds = %104, %138
  %140 = phi { ptr, i32, i32, i32 } [ %137, %138 ], [ %117, %104 ]
  br label %141

141:                                              ; preds = %139
  %142 = extractvalue { ptr, i32, i32, i32 } %140, 0
  %143 = load ptr, ptr %142, align 8
  %144 = extractvalue { ptr, i32, i32, i32 } %140, 2
  %145 = zext i32 %144 to i64
  %146 = mul i64 %145, 32
  %147 = getelementptr inbounds i8, ptr %143, i64 %146
  store i252 %101, ptr %147, align 16
  %148 = extractvalue { ptr, i32, i32, i32 } %140, 2
  %149 = add i32 %148, 1
  %150 = insertvalue { ptr, i32, i32, i32 } %140, i32 %149, 2
  %151 = getelementptr inbounds i8, ptr %143, i32 -12
  store i32 %149, ptr %151, align 4
  %152 = extractvalue { ptr, i32, i32, i32 } %140, 3
  %153 = icmp eq i32 %152, 0
  br i1 %153, label %154, label %168

154:                                              ; preds = %141
  %155 = shl i32 %152, 1
  %156 = call i32 @llvm.umin.i32(i32 %155, i32 1024)
  %157 = add i32 %156, %152
  %158 = call i32 @llvm.umax.i32(i32 %157, i32 8)
  %159 = zext i32 %158 to i64
  %160 = mul i64 %159, 32
  %161 = add i64 %160, 16
  %162 = call ptr @realloc(ptr null, i64 %161)
  store i32 1, ptr %162, align 4
  %163 = getelementptr inbounds i8, ptr %162, i32 4
  store i32 0, ptr %163, align 4
  %164 = getelementptr inbounds i8, ptr %162, i32 16
  %165 = call ptr @realloc(ptr null, i64 8)
  store ptr %164, ptr %165, align 8
  %166 = insertvalue { ptr, i32, i32, i32 } %150, ptr %165, 0
  %167 = insertvalue { ptr, i32, i32, i32 } %166, i32 %158, 3
  br label %188

168:                                              ; preds = %141
  %169 = icmp ult i32 %149, %152
  br i1 %169, label %170, label %171

170:                                              ; preds = %168
  br label %185

171:                                              ; preds = %168
  %172 = shl i32 %152, 1
  %173 = call i32 @llvm.umin.i32(i32 %172, i32 1024)
  %174 = add i32 %173, %152
  %175 = call i32 @llvm.umax.i32(i32 %174, i32 8)
  %176 = zext i32 %175 to i64
  %177 = mul i64 %176, 32
  %178 = add i64 %177, 16
  %179 = extractvalue { ptr, i32, i32, i32 } %140, 0
  %180 = load ptr, ptr %179, align 8
  %181 = getelementptr inbounds i8, ptr %180, i32 -16
  %182 = call ptr @realloc(ptr %181, i64 %178)
  %183 = getelementptr inbounds i8, ptr %182, i32 16
  store ptr %183, ptr %179, align 8
  %184 = insertvalue { ptr, i32, i32, i32 } %150, i32 %175, 3
  br label %185

185:                                              ; preds = %170, %171
  %186 = phi { ptr, i32, i32, i32 } [ %184, %171 ], [ %150, %170 ]
  br label %187

187:                                              ; preds = %185
  br label %188

188:                                              ; preds = %154, %187
  %189 = phi { ptr, i32, i32, i32 } [ %186, %187 ], [ %167, %154 ]
  br label %190

190:                                              ; preds = %188
  %191 = extractvalue { ptr, i32, i32, i32 } %189, 0
  %192 = load ptr, ptr %191, align 8
  %193 = extractvalue { ptr, i32, i32, i32 } %189, 2
  %194 = zext i32 %193 to i64
  %195 = mul i64 %194, 32
  %196 = getelementptr inbounds i8, ptr %192, i64 %195
  store i252 %90, ptr %196, align 16
  %197 = extractvalue { ptr, i32, i32, i32 } %189, 2
  %198 = add i32 %197, 1
  %199 = insertvalue { ptr, i32, i32, i32 } %189, i32 %198, 2
  %200 = getelementptr inbounds i8, ptr %192, i32 -12
  store i32 %198, ptr %200, align 4
  %201 = extractvalue { ptr, i32, i32, i32 } %189, 3
  %202 = icmp eq i32 %201, 0
  br i1 %202, label %203, label %217

203:                                              ; preds = %190
  %204 = shl i32 %201, 1
  %205 = call i32 @llvm.umin.i32(i32 %204, i32 1024)
  %206 = add i32 %205, %201
  %207 = call i32 @llvm.umax.i32(i32 %206, i32 8)
  %208 = zext i32 %207 to i64
  %209 = mul i64 %208, 32
  %210 = add i64 %209, 16
  %211 = call ptr @realloc(ptr null, i64 %210)
  store i32 1, ptr %211, align 4
  %212 = getelementptr inbounds i8, ptr %211, i32 4
  store i32 0, ptr %212, align 4
  %213 = getelementptr inbounds i8, ptr %211, i32 16
  %214 = call ptr @realloc(ptr null, i64 8)
  store ptr %213, ptr %214, align 8
  %215 = insertvalue { ptr, i32, i32, i32 } %199, ptr %214, 0
  %216 = insertvalue { ptr, i32, i32, i32 } %215, i32 %207, 3
  br label %237

217:                                              ; preds = %190
  %218 = icmp ult i32 %198, %201
  br i1 %218, label %219, label %220

219:                                              ; preds = %217
  br label %234

220:                                              ; preds = %217
  %221 = shl i32 %201, 1
  %222 = call i32 @llvm.umin.i32(i32 %221, i32 1024)
  %223 = add i32 %222, %201
  %224 = call i32 @llvm.umax.i32(i32 %223, i32 8)
  %225 = zext i32 %224 to i64
  %226 = mul i64 %225, 32
  %227 = add i64 %226, 16
  %228 = extractvalue { ptr, i32, i32, i32 } %189, 0
  %229 = load ptr, ptr %228, align 8
  %230 = getelementptr inbounds i8, ptr %229, i32 -16
  %231 = call ptr @realloc(ptr %230, i64 %227)
  %232 = getelementptr inbounds i8, ptr %231, i32 16
  store ptr %232, ptr %228, align 8
  %233 = insertvalue { ptr, i32, i32, i32 } %199, i32 %224, 3
  br label %234

234:                                              ; preds = %219, %220
  %235 = phi { ptr, i32, i32, i32 } [ %233, %220 ], [ %199, %219 ]
  br label %236

236:                                              ; preds = %234
  br label %237

237:                                              ; preds = %203, %236
  %238 = phi { ptr, i32, i32, i32 } [ %235, %236 ], [ %216, %203 ]
  br label %239

239:                                              ; preds = %237
  %240 = extractvalue { ptr, i32, i32, i32 } %238, 0
  %241 = load ptr, ptr %240, align 8
  %242 = extractvalue { ptr, i32, i32, i32 } %238, 2
  %243 = zext i32 %242 to i64
  %244 = mul i64 %243, 32
  %245 = getelementptr inbounds i8, ptr %241, i64 %244
  store i252 %92, ptr %245, align 16
  %246 = extractvalue { ptr, i32, i32, i32 } %238, 2
  %247 = add i32 %246, 1
  %248 = insertvalue { ptr, i32, i32, i32 } %238, i32 %247, 2
  %249 = getelementptr inbounds i8, ptr %241, i32 -12
  store i32 %247, ptr %249, align 4
  %250 = extractvalue { ptr, i32, i32, i32 } %238, 3
  %251 = icmp eq i32 %250, 0
  br i1 %251, label %252, label %266

252:                                              ; preds = %239
  %253 = shl i32 %250, 1
  %254 = call i32 @llvm.umin.i32(i32 %253, i32 1024)
  %255 = add i32 %254, %250
  %256 = call i32 @llvm.umax.i32(i32 %255, i32 8)
  %257 = zext i32 %256 to i64
  %258 = mul i64 %257, 32
  %259 = add i64 %258, 16
  %260 = call ptr @realloc(ptr null, i64 %259)
  store i32 1, ptr %260, align 4
  %261 = getelementptr inbounds i8, ptr %260, i32 4
  store i32 0, ptr %261, align 4
  %262 = getelementptr inbounds i8, ptr %260, i32 16
  %263 = call ptr @realloc(ptr null, i64 8)
  store ptr %262, ptr %263, align 8
  %264 = insertvalue { ptr, i32, i32, i32 } %248, ptr %263, 0
  %265 = insertvalue { ptr, i32, i32, i32 } %264, i32 %256, 3
  br label %286

266:                                              ; preds = %239
  %267 = icmp ult i32 %247, %250
  br i1 %267, label %268, label %269

268:                                              ; preds = %266
  br label %283

269:                                              ; preds = %266
  %270 = shl i32 %250, 1
  %271 = call i32 @llvm.umin.i32(i32 %270, i32 1024)
  %272 = add i32 %271, %250
  %273 = call i32 @llvm.umax.i32(i32 %272, i32 8)
  %274 = zext i32 %273 to i64
  %275 = mul i64 %274, 32
  %276 = add i64 %275, 16
  %277 = extractvalue { ptr, i32, i32, i32 } %238, 0
  %278 = load ptr, ptr %277, align 8
  %279 = getelementptr inbounds i8, ptr %278, i32 -16
  %280 = call ptr @realloc(ptr %279, i64 %276)
  %281 = getelementptr inbounds i8, ptr %280, i32 16
  store ptr %281, ptr %277, align 8
  %282 = insertvalue { ptr, i32, i32, i32 } %248, i32 %273, 3
  br label %283

283:                                              ; preds = %268, %269
  %284 = phi { ptr, i32, i32, i32 } [ %282, %269 ], [ %248, %268 ]
  br label %285

285:                                              ; preds = %283
  br label %286

286:                                              ; preds = %252, %285
  %287 = phi { ptr, i32, i32, i32 } [ %284, %285 ], [ %265, %252 ]
  br label %288

288:                                              ; preds = %286
  %289 = extractvalue { ptr, i32, i32, i32 } %287, 0
  %290 = load ptr, ptr %289, align 8
  %291 = extractvalue { ptr, i32, i32, i32 } %287, 2
  %292 = zext i32 %291 to i64
  %293 = mul i64 %292, 32
  %294 = getelementptr inbounds i8, ptr %290, i64 %293
  store i252 %94, ptr %294, align 16
  %295 = extractvalue { ptr, i32, i32, i32 } %287, 2
  %296 = add i32 %295, 1
  %297 = insertvalue { ptr, i32, i32, i32 } %287, i32 %296, 2
  %298 = getelementptr inbounds i8, ptr %290, i32 -12
  store i32 %296, ptr %298, align 4
  %299 = extractvalue { ptr, i32, i32, i32 } %287, 3
  %300 = icmp eq i32 %299, 0
  br i1 %300, label %301, label %315

301:                                              ; preds = %288
  %302 = shl i32 %299, 1
  %303 = call i32 @llvm.umin.i32(i32 %302, i32 1024)
  %304 = add i32 %303, %299
  %305 = call i32 @llvm.umax.i32(i32 %304, i32 8)
  %306 = zext i32 %305 to i64
  %307 = mul i64 %306, 32
  %308 = add i64 %307, 16
  %309 = call ptr @realloc(ptr null, i64 %308)
  store i32 1, ptr %309, align 4
  %310 = getelementptr inbounds i8, ptr %309, i32 4
  store i32 0, ptr %310, align 4
  %311 = getelementptr inbounds i8, ptr %309, i32 16
  %312 = call ptr @realloc(ptr null, i64 8)
  store ptr %311, ptr %312, align 8
  %313 = insertvalue { ptr, i32, i32, i32 } %297, ptr %312, 0
  %314 = insertvalue { ptr, i32, i32, i32 } %313, i32 %305, 3
  br label %335

315:                                              ; preds = %288
  %316 = icmp ult i32 %296, %299
  br i1 %316, label %317, label %318

317:                                              ; preds = %315
  br label %332

318:                                              ; preds = %315
  %319 = shl i32 %299, 1
  %320 = call i32 @llvm.umin.i32(i32 %319, i32 1024)
  %321 = add i32 %320, %299
  %322 = call i32 @llvm.umax.i32(i32 %321, i32 8)
  %323 = zext i32 %322 to i64
  %324 = mul i64 %323, 32
  %325 = add i64 %324, 16
  %326 = extractvalue { ptr, i32, i32, i32 } %287, 0
  %327 = load ptr, ptr %326, align 8
  %328 = getelementptr inbounds i8, ptr %327, i32 -16
  %329 = call ptr @realloc(ptr %328, i64 %325)
  %330 = getelementptr inbounds i8, ptr %329, i32 16
  store ptr %330, ptr %326, align 8
  %331 = insertvalue { ptr, i32, i32, i32 } %297, i32 %322, 3
  br label %332

332:                                              ; preds = %317, %318
  %333 = phi { ptr, i32, i32, i32 } [ %331, %318 ], [ %297, %317 ]
  br label %334

334:                                              ; preds = %332
  br label %335

335:                                              ; preds = %301, %334
  %336 = phi { ptr, i32, i32, i32 } [ %333, %334 ], [ %314, %301 ]
  br label %337

337:                                              ; preds = %335
  %338 = extractvalue { ptr, i32, i32, i32 } %336, 0
  %339 = load ptr, ptr %338, align 8
  %340 = extractvalue { ptr, i32, i32, i32 } %336, 2
  %341 = zext i32 %340 to i64
  %342 = mul i64 %341, 32
  %343 = getelementptr inbounds i8, ptr %339, i64 %342
  store i252 %96, ptr %343, align 16
  %344 = extractvalue { ptr, i32, i32, i32 } %336, 2
  %345 = add i32 %344, 1
  %346 = insertvalue { ptr, i32, i32, i32 } %336, i32 %345, 2
  %347 = getelementptr inbounds i8, ptr %339, i32 -12
  store i32 %345, ptr %347, align 4
  %348 = extractvalue { ptr, i32, i32, i32 } %336, 3
  %349 = icmp eq i32 %348, 0
  br i1 %349, label %350, label %364

350:                                              ; preds = %337
  %351 = shl i32 %348, 1
  %352 = call i32 @llvm.umin.i32(i32 %351, i32 1024)
  %353 = add i32 %352, %348
  %354 = call i32 @llvm.umax.i32(i32 %353, i32 8)
  %355 = zext i32 %354 to i64
  %356 = mul i64 %355, 32
  %357 = add i64 %356, 16
  %358 = call ptr @realloc(ptr null, i64 %357)
  store i32 1, ptr %358, align 4
  %359 = getelementptr inbounds i8, ptr %358, i32 4
  store i32 0, ptr %359, align 4
  %360 = getelementptr inbounds i8, ptr %358, i32 16
  %361 = call ptr @realloc(ptr null, i64 8)
  store ptr %360, ptr %361, align 8
  %362 = insertvalue { ptr, i32, i32, i32 } %346, ptr %361, 0
  %363 = insertvalue { ptr, i32, i32, i32 } %362, i32 %354, 3
  br label %384

364:                                              ; preds = %337
  %365 = icmp ult i32 %345, %348
  br i1 %365, label %366, label %367

366:                                              ; preds = %364
  br label %381

367:                                              ; preds = %364
  %368 = shl i32 %348, 1
  %369 = call i32 @llvm.umin.i32(i32 %368, i32 1024)
  %370 = add i32 %369, %348
  %371 = call i32 @llvm.umax.i32(i32 %370, i32 8)
  %372 = zext i32 %371 to i64
  %373 = mul i64 %372, 32
  %374 = add i64 %373, 16
  %375 = extractvalue { ptr, i32, i32, i32 } %336, 0
  %376 = load ptr, ptr %375, align 8
  %377 = getelementptr inbounds i8, ptr %376, i32 -16
  %378 = call ptr @realloc(ptr %377, i64 %374)
  %379 = getelementptr inbounds i8, ptr %378, i32 16
  store ptr %379, ptr %375, align 8
  %380 = insertvalue { ptr, i32, i32, i32 } %346, i32 %371, 3
  br label %381

381:                                              ; preds = %366, %367
  %382 = phi { ptr, i32, i32, i32 } [ %380, %367 ], [ %346, %366 ]
  br label %383

383:                                              ; preds = %381
  br label %384

384:                                              ; preds = %350, %383
  %385 = phi { ptr, i32, i32, i32 } [ %382, %383 ], [ %363, %350 ]
  br label %386

386:                                              ; preds = %384
  %387 = extractvalue { ptr, i32, i32, i32 } %385, 0
  %388 = load ptr, ptr %387, align 8
  %389 = extractvalue { ptr, i32, i32, i32 } %385, 2
  %390 = zext i32 %389 to i64
  %391 = mul i64 %390, 32
  %392 = getelementptr inbounds i8, ptr %388, i64 %391
  store i252 %98, ptr %392, align 16
  %393 = extractvalue { ptr, i32, i32, i32 } %385, 2
  %394 = add i32 %393, 1
  %395 = insertvalue { ptr, i32, i32, i32 } %385, i32 %394, 2
  %396 = getelementptr inbounds i8, ptr %388, i32 -12
  store i32 %394, ptr %396, align 4
  %397 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %395, 0
  %398 = insertvalue { { ptr, i32, i32, i32 }, {} } %397, {} undef, 1
  %399 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %398, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %399, ptr %7, align 8
  %400 = load { i64, [24 x i8] }, ptr %7, align 8
  %401 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %73, 0
  %402 = insertvalue { i64, i64, { i64, [24 x i8] } } %401, i64 %84, 1
  %403 = insertvalue { i64, i64, { i64, [24 x i8] } } %402, { i64, [24 x i8] } %400, 2
  ret { i64, i64, { i64, [24 x i8] } } %403

404:                                              ; preds = %60
  %405 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %406 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %405, 1
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %11)
  %407 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %406, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %407, ptr %6, align 8
  %408 = load { i64, [24 x i8] }, ptr %6, align 8
  %409 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %73, 0
  %410 = insertvalue { i64, i64, { i64, [24 x i8] } } %409, i64 %74, 1
  %411 = insertvalue { i64, i64, { i64, [24 x i8] } } %410, { i64, [24 x i8] } %408, 2
  ret { i64, i64, { i64, [24 x i8] } } %411

412:                                              ; preds = %77
  call void @puts(ptr @assert_msg_156)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f91(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f91"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f91(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f91(i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, { i32, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f92"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f35"(i252 573087285299505011920718992710461799)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f92() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f92"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f92(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f92()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$24"(ptr %0) {
  %2 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %0, align 16
  call void @"drop$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$24"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 160)
  %3 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %0, align 16
  %4 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %3)
  %5 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %4, 0
  %6 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %4, 1
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %5, ptr %0, align 16
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f93"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %17

17:                                               ; preds = %198, %4
  %18 = phi i64 [ %182, %198 ], [ %0, %4 ]
  %19 = phi i64 [ %203, %198 ], [ %1, %4 ]
  %20 = phi { { ptr, i32, i32, i32 } } [ %204, %198 ], [ %2, %4 ]
  %21 = phi { ptr, i32, i32, i32 } [ %205, %198 ], [ %3, %4 ]
  %22 = add i64 %18, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 13590
  %27 = icmp uge i64 %19, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %19, i64 %26)
  br i1 %27, label %29, label %261

29:                                               ; preds = %17
  %30 = phi { { ptr, i32, i32, i32 } } [ %20, %17 ]
  %31 = extractvalue { { ptr, i32, i32, i32 } } %30, 0
  %32 = extractvalue { ptr, i32, i32, i32 } %31, 1
  %33 = extractvalue { ptr, i32, i32, i32 } %31, 2
  %34 = sub i32 %33, %32
  %35 = icmp uge i32 %34, 1
  br i1 %35, label %36, label %241

36:                                               ; preds = %29
  %37 = extractvalue { ptr, i32, i32, i32 } %31, 0
  %38 = load ptr, ptr %37, align 8
  %39 = zext i32 %32 to i64
  %40 = mul i64 %39, 160
  %41 = getelementptr inbounds i8, ptr %38, i64 %40
  %42 = add i32 %32, 1
  %43 = insertvalue { ptr, i32, i32, i32 } %31, i32 %42, 1
  %44 = call ptr @realloc(ptr null, i64 160)
  %45 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %41, align 16
  %46 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %45)
  %47 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %46, 0
  %48 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %46, 1
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %47, ptr %41, align 16
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %48, ptr %44, align 16
  %49 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %44, align 16
  call void @free(ptr %44)
  %50 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %49)
  %51 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %50, 0
  %52 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %50, 1
  %53 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %52, 1
  %54 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %52, 2
  call void @"drop$35"({ i128, [80 x i8] } %54)
  %55 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %53)
  %56 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %55, 0
  %57 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %55, 1
  %58 = extractvalue { { ptr, i32, i32, i32 } } %57, 0
  %59 = extractvalue { ptr, i32, i32, i32 } %58, 1
  %60 = extractvalue { ptr, i32, i32, i32 } %58, 2
  %61 = sub i32 %60, %59
  call void @"drop$27"({ ptr, i32, i32, i32 } %58)
  %62 = zext i32 %61 to i252
  %63 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %51)
  %64 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %63, 0
  %65 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %63, 1
  %66 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %65, 0
  %67 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %65, 1
  %68 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %65, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %67)
  call void @"drop$35"({ i128, [80 x i8] } %68)
  %69 = extractvalue { ptr, i32, i32, i32 } %21, 3
  %70 = icmp eq i32 %69, 0
  br i1 %70, label %71, label %85

71:                                               ; preds = %36
  %72 = shl i32 %69, 1
  %73 = call i32 @llvm.umin.i32(i32 %72, i32 1024)
  %74 = add i32 %73, %69
  %75 = call i32 @llvm.umax.i32(i32 %74, i32 8)
  %76 = zext i32 %75 to i64
  %77 = mul i64 %76, 32
  %78 = add i64 %77, 16
  %79 = call ptr @realloc(ptr null, i64 %78)
  store i32 1, ptr %79, align 4
  %80 = getelementptr inbounds i8, ptr %79, i32 4
  store i32 0, ptr %80, align 4
  %81 = getelementptr inbounds i8, ptr %79, i32 16
  %82 = call ptr @realloc(ptr null, i64 8)
  store ptr %81, ptr %82, align 8
  %83 = insertvalue { ptr, i32, i32, i32 } %21, ptr %82, 0
  %84 = insertvalue { ptr, i32, i32, i32 } %83, i32 %75, 3
  br label %106

85:                                               ; preds = %36
  %86 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %87 = icmp ult i32 %86, %69
  br i1 %87, label %88, label %89

88:                                               ; preds = %85
  br label %103

89:                                               ; preds = %85
  %90 = shl i32 %69, 1
  %91 = call i32 @llvm.umin.i32(i32 %90, i32 1024)
  %92 = add i32 %91, %69
  %93 = call i32 @llvm.umax.i32(i32 %92, i32 8)
  %94 = zext i32 %93 to i64
  %95 = mul i64 %94, 32
  %96 = add i64 %95, 16
  %97 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr inbounds i8, ptr %98, i32 -16
  %100 = call ptr @realloc(ptr %99, i64 %96)
  %101 = getelementptr inbounds i8, ptr %100, i32 16
  store ptr %101, ptr %97, align 8
  %102 = insertvalue { ptr, i32, i32, i32 } %21, i32 %93, 3
  br label %103

103:                                              ; preds = %88, %89
  %104 = phi { ptr, i32, i32, i32 } [ %102, %89 ], [ %21, %88 ]
  br label %105

105:                                              ; preds = %103
  br label %106

106:                                              ; preds = %71, %105
  %107 = phi { ptr, i32, i32, i32 } [ %104, %105 ], [ %84, %71 ]
  br label %108

108:                                              ; preds = %106
  %109 = extractvalue { ptr, i32, i32, i32 } %107, 0
  %110 = load ptr, ptr %109, align 8
  %111 = extractvalue { ptr, i32, i32, i32 } %107, 2
  %112 = zext i32 %111 to i64
  %113 = mul i64 %112, 32
  %114 = getelementptr inbounds i8, ptr %110, i64 %113
  store i252 %66, ptr %114, align 16
  %115 = extractvalue { ptr, i32, i32, i32 } %107, 2
  %116 = add i32 %115, 1
  %117 = insertvalue { ptr, i32, i32, i32 } %107, i32 %116, 2
  %118 = getelementptr inbounds i8, ptr %110, i32 -12
  store i32 %116, ptr %118, align 4
  %119 = extractvalue { ptr, i32, i32, i32 } %107, 3
  %120 = icmp eq i32 %119, 0
  br i1 %120, label %121, label %135

121:                                              ; preds = %108
  %122 = shl i32 %119, 1
  %123 = call i32 @llvm.umin.i32(i32 %122, i32 1024)
  %124 = add i32 %123, %119
  %125 = call i32 @llvm.umax.i32(i32 %124, i32 8)
  %126 = zext i32 %125 to i64
  %127 = mul i64 %126, 32
  %128 = add i64 %127, 16
  %129 = call ptr @realloc(ptr null, i64 %128)
  store i32 1, ptr %129, align 4
  %130 = getelementptr inbounds i8, ptr %129, i32 4
  store i32 0, ptr %130, align 4
  %131 = getelementptr inbounds i8, ptr %129, i32 16
  %132 = call ptr @realloc(ptr null, i64 8)
  store ptr %131, ptr %132, align 8
  %133 = insertvalue { ptr, i32, i32, i32 } %117, ptr %132, 0
  %134 = insertvalue { ptr, i32, i32, i32 } %133, i32 %125, 3
  br label %155

135:                                              ; preds = %108
  %136 = icmp ult i32 %116, %119
  br i1 %136, label %137, label %138

137:                                              ; preds = %135
  br label %152

138:                                              ; preds = %135
  %139 = shl i32 %119, 1
  %140 = call i32 @llvm.umin.i32(i32 %139, i32 1024)
  %141 = add i32 %140, %119
  %142 = call i32 @llvm.umax.i32(i32 %141, i32 8)
  %143 = zext i32 %142 to i64
  %144 = mul i64 %143, 32
  %145 = add i64 %144, 16
  %146 = extractvalue { ptr, i32, i32, i32 } %107, 0
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr inbounds i8, ptr %147, i32 -16
  %149 = call ptr @realloc(ptr %148, i64 %145)
  %150 = getelementptr inbounds i8, ptr %149, i32 16
  store ptr %150, ptr %146, align 8
  %151 = insertvalue { ptr, i32, i32, i32 } %117, i32 %142, 3
  br label %152

152:                                              ; preds = %137, %138
  %153 = phi { ptr, i32, i32, i32 } [ %151, %138 ], [ %117, %137 ]
  br label %154

154:                                              ; preds = %152
  br label %155

155:                                              ; preds = %121, %154
  %156 = phi { ptr, i32, i32, i32 } [ %153, %154 ], [ %134, %121 ]
  br label %157

157:                                              ; preds = %155
  %158 = extractvalue { ptr, i32, i32, i32 } %156, 0
  %159 = load ptr, ptr %158, align 8
  %160 = extractvalue { ptr, i32, i32, i32 } %156, 2
  %161 = zext i32 %160 to i64
  %162 = mul i64 %161, 32
  %163 = getelementptr inbounds i8, ptr %159, i64 %162
  store i252 %62, ptr %163, align 16
  %164 = extractvalue { ptr, i32, i32, i32 } %156, 2
  %165 = add i32 %164, 1
  %166 = insertvalue { ptr, i32, i32, i32 } %156, i32 %165, 2
  %167 = getelementptr inbounds i8, ptr %159, i32 -12
  store i32 %165, ptr %167, align 4
  %168 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %22, i64 %28, { { ptr, i32, i32, i32 } } %56, { ptr, i32, i32, i32 } %166)
  %169 = extractvalue { i64, i64, { i64, [24 x i8] } } %168, 0
  %170 = extractvalue { i64, i64, { i64, [24 x i8] } } %168, 1
  %171 = extractvalue { i64, i64, { i64, [24 x i8] } } %168, 2
  store { i64, [24 x i8] } %171, ptr %12, align 8
  %172 = load i1, ptr %12, align 1
  switch i1 %172, label %173 [
    i1 false, label %175
    i1 true, label %186
  ]

173:                                              ; preds = %157
  br i1 false, label %174, label %276

174:                                              ; preds = %173
  unreachable

175:                                              ; preds = %157
  %176 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %12, align 8
  %177 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %176, 1
  %178 = extractvalue { { ptr, i32, i32, i32 }, {} } %177, 0
  %179 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %64, 1
  %180 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %64, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %179)
  store { i128, [80 x i8] } %180, ptr %14, align 16
  %181 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %169, i64 %170, ptr %14, { ptr, i32, i32, i32 } %178)
  %182 = extractvalue { i64, i64, { i64, [24 x i8] } } %181, 0
  %183 = extractvalue { i64, i64, { i64, [24 x i8] } } %181, 1
  %184 = extractvalue { i64, i64, { i64, [24 x i8] } } %181, 2
  store { i64, [24 x i8] } %184, ptr %15, align 8
  %185 = load i1, ptr %15, align 1
  switch i1 %185, label %196 [
    i1 false, label %198
    i1 true, label %210
  ]

186:                                              ; preds = %157
  %187 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %188 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %187, 1
  call void @"drop$30"({ ptr, i32, i32, i32 } %43)
  call void @"drop$36"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %64)
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %13, align 8
  %190 = load { i64, [24 x i8] }, ptr %13, align 8
  %191 = extractvalue { ptr, ptr, i64 } %8, 1
  %192 = load i64, ptr %191, align 8
  %193 = icmp eq i64 %192, 0
  %194 = sub i64 %192, 1
  %195 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %194, ptr %195, align 8
  br i1 %193, label %237, label %220

196:                                              ; preds = %175
  br i1 false, label %197, label %277

197:                                              ; preds = %196
  unreachable

198:                                              ; preds = %175
  %199 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %15, align 8
  %200 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %199, 1
  %201 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %202 = call ptr %201()
  %203 = call i64 @llvm.uadd.sat.i64(i64 %183, i64 0)
  %204 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %43, 0
  %205 = extractvalue { { ptr, i32, i32, i32 }, {} } %200, 0
  %206 = extractvalue { ptr, ptr, i64 } %8, 1
  %207 = load i64, ptr %206, align 8
  %208 = add i64 %207, 1
  %209 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %208, ptr %209, align 8
  br label %17

210:                                              ; preds = %175
  %211 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %212 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %211, 1
  call void @"drop$30"({ ptr, i32, i32, i32 } %43)
  %213 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %212, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %213, ptr %16, align 8
  %214 = load { i64, [24 x i8] }, ptr %16, align 8
  %215 = extractvalue { ptr, ptr, i64 } %8, 1
  %216 = load i64, ptr %215, align 8
  %217 = icmp eq i64 %216, 0
  %218 = sub i64 %216, 1
  %219 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %218, ptr %219, align 8
  br i1 %217, label %233, label %220

220:                                              ; preds = %220, %210, %186, %241, %261
  %221 = phi i64 [ %22, %261 ], [ %22, %241 ], [ %221, %220 ], [ %182, %210 ], [ %169, %186 ]
  %222 = phi i64 [ %19, %261 ], [ %247, %241 ], [ %222, %220 ], [ %183, %210 ], [ %170, %186 ]
  %223 = phi { i64, [24 x i8] } [ %266, %261 ], [ %251, %241 ], [ %223, %220 ], [ %214, %210 ], [ %190, %186 ]
  %224 = extractvalue { ptr, ptr, i64 } %8, 1
  %225 = load i64, ptr %224, align 8
  %226 = icmp eq i64 %225, 0
  %227 = sub i64 %225, 1
  %228 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %227, ptr %228, align 8
  br i1 %226, label %229, label %220

229:                                              ; preds = %220
  %230 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %221, 0
  %231 = insertvalue { i64, i64, { i64, [24 x i8] } } %230, i64 %222, 1
  %232 = insertvalue { i64, i64, { i64, [24 x i8] } } %231, { i64, [24 x i8] } %223, 2
  ret { i64, i64, { i64, [24 x i8] } } %232

233:                                              ; preds = %210
  %234 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %182, 0
  %235 = insertvalue { i64, i64, { i64, [24 x i8] } } %234, i64 %183, 1
  %236 = insertvalue { i64, i64, { i64, [24 x i8] } } %235, { i64, [24 x i8] } %214, 2
  ret { i64, i64, { i64, [24 x i8] } } %236

237:                                              ; preds = %186
  %238 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %169, 0
  %239 = insertvalue { i64, i64, { i64, [24 x i8] } } %238, i64 %170, 1
  %240 = insertvalue { i64, i64, { i64, [24 x i8] } } %239, { i64, [24 x i8] } %190, 2
  ret { i64, i64, { i64, [24 x i8] } } %240

241:                                              ; preds = %29
  %242 = phi { ptr, i32, i32, i32 } [ %31, %29 ]
  call void @"drop$30"({ ptr, i32, i32, i32 } %242)
  %243 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %244 = call ptr %243()
  %245 = load i64, ptr %244, align 8
  %246 = mul i64 %245, 14290
  %247 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %246)
  %248 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %21, 0
  %249 = insertvalue { { ptr, i32, i32, i32 }, {} } %248, {} undef, 1
  %250 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %249, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %250, ptr %11, align 8
  %251 = load { i64, [24 x i8] }, ptr %11, align 8
  %252 = extractvalue { ptr, ptr, i64 } %8, 1
  %253 = load i64, ptr %252, align 8
  %254 = icmp eq i64 %253, 0
  %255 = sub i64 %253, 1
  %256 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %255, ptr %256, align 8
  br i1 %254, label %257, label %220

257:                                              ; preds = %241
  %258 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %22, 0
  %259 = insertvalue { i64, i64, { i64, [24 x i8] } } %258, i64 %247, 1
  %260 = insertvalue { i64, i64, { i64, [24 x i8] } } %259, { i64, [24 x i8] } %251, 2
  ret { i64, i64, { i64, [24 x i8] } } %260

261:                                              ; preds = %17
  %262 = phi { ptr, i32, i32, i32 } [ %21, %17 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %262)
  call void @"drop$31"({ { ptr, i32, i32, i32 } } %20)
  %263 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %264 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %263, 0
  %265 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %264, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %265, ptr %10, align 8
  %266 = load { i64, [24 x i8] }, ptr %10, align 8
  %267 = extractvalue { ptr, ptr, i64 } %8, 1
  %268 = load i64, ptr %267, align 8
  %269 = icmp eq i64 %268, 0
  %270 = sub i64 %268, 1
  %271 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %270, ptr %271, align 8
  br i1 %269, label %272, label %220

272:                                              ; preds = %261
  %273 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %22, 0
  %274 = insertvalue { i64, i64, { i64, [24 x i8] } } %273, i64 %19, 1
  %275 = insertvalue { i64, i64, { i64, [24 x i8] } } %274, { i64, [24 x i8] } %266, 2
  ret { i64, i64, { i64, [24 x i8] } } %275

276:                                              ; preds = %173
  call void @puts(ptr @assert_msg_157)
  call void @abort()
  unreachable

277:                                              ; preds = %196
  call void @puts(ptr @assert_msg_158)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f93(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f93"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f93(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f93(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @"impl$f94"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [20 x i8] }, i64 1, align 4
  %4 = alloca { i32, [20 x i8] }, i64 1, align 4
  %5 = alloca { i32, [16 x i8] }, i64 1, align 4
  %6 = alloca { i32, [20 x i8] }, i64 1, align 4
  %7 = alloca { i32, [16 x i8] }, i64 1, align 4
  %8 = alloca { i32, [20 x i8] }, i64 1, align 4
  %9 = alloca { i32, [8 x i8] }, i64 1, align 4
  %10 = alloca { i32, [20 x i8] }, i64 1, align 4
  %11 = alloca { i32, [16 x i8] }, i64 1, align 4
  %12 = alloca { i32, [20 x i8] }, i64 1, align 4
  %13 = alloca { i32, [16 x i8] }, i64 1, align 4
  %14 = alloca { i32, [20 x i8] }, i64 1, align 4
  %15 = alloca { i32, [16 x i8] }, i64 1, align 4
  %16 = alloca { i32, [20 x i8] }, i64 1, align 4
  %17 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %18 = extractvalue { ptr, i32, i32, i32 } %17, 1
  %19 = extractvalue { ptr, i32, i32, i32 } %17, 2
  %20 = sub i32 %19, %18
  %21 = icmp uge i32 %20, 1
  br i1 %21, label %22, label %364

22:                                               ; preds = %2
  %23 = extractvalue { ptr, i32, i32, i32 } %17, 0
  %24 = load ptr, ptr %23, align 8
  %25 = zext i32 %18 to i64
  %26 = mul i64 %25, 32
  %27 = getelementptr inbounds i8, ptr %24, i64 %26
  %28 = add i32 %18, 1
  %29 = insertvalue { ptr, i32, i32, i32 } %17, i32 %28, 1
  %30 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %30, ptr %27, i64 32, i1 false)
  %31 = load i252, ptr %30, align 16
  call void @free(ptr %30)
  %32 = icmp eq i252 %31, 0
  br i1 %32, label %33, label %73

33:                                               ; preds = %22
  %34 = phi { ptr, i32, i32, i32 } [ %29, %22 ]
  %35 = extractvalue { ptr, i32, i32, i32 } %34, 1
  %36 = extractvalue { ptr, i32, i32, i32 } %34, 2
  %37 = sub i32 %36, %35
  %38 = icmp uge i32 %37, 1
  br i1 %38, label %39, label %364

39:                                               ; preds = %33
  %40 = extractvalue { ptr, i32, i32, i32 } %34, 0
  %41 = load ptr, ptr %40, align 8
  %42 = zext i32 %35 to i64
  %43 = mul i64 %42, 32
  %44 = getelementptr inbounds i8, ptr %41, i64 %43
  %45 = add i32 %35, 1
  %46 = insertvalue { ptr, i32, i32, i32 } %34, i32 %45, 1
  %47 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %47, ptr %44, i64 32, i1 false)
  %48 = load i252, ptr %47, align 16
  call void @free(ptr %47)
  %49 = icmp sge i252 %48, -3618502788666131000275863779947924135206266826270938552493006944360846065663
  %50 = icmp slt i252 %48, 2147483648
  %51 = and i1 %49, %50
  %52 = icmp slt i252 %48, 0
  br i1 %52, label %53, label %55

53:                                               ; preds = %39
  %54 = sub i252 %48, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %56

55:                                               ; preds = %39
  br label %56

56:                                               ; preds = %53, %55
  %57 = phi i252 [ %48, %55 ], [ %54, %53 ]
  br label %58

58:                                               ; preds = %56
  %59 = add i64 %0, 2
  %60 = add i64 %0, 3
  %61 = select i1 %51, i64 %59, i64 %60
  %62 = trunc i252 %57 to i32
  br i1 %51, label %63, label %364

63:                                               ; preds = %58
  %64 = phi { ptr, i32, i32, i32 } [ %46, %58 ]
  %65 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %64, 0
  %66 = insertvalue { i3, i32 } { i3 0, i32 undef }, i32 %62, 1
  store { i3, i32 } %66, ptr %15, align 4
  %67 = load { i32, [16 x i8] }, ptr %15, align 4
  %68 = insertvalue { i1, { i32, [16 x i8] } } { i1 false, { i32, [16 x i8] } undef }, { i32, [16 x i8] } %67, 1
  store { i1, { i32, [16 x i8] } } %68, ptr %16, align 4
  %69 = load { i32, [20 x i8] }, ptr %16, align 4
  %70 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %61, 0
  %71 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %70, { { ptr, i32, i32, i32 } } %65, 1
  %72 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %71, { i32, [20 x i8] } %69, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %72

73:                                               ; preds = %22
  %74 = phi i252 [ %31, %22 ]
  %75 = zext i252 %74 to i256
  %76 = sub i256 %75, 1
  %77 = add i256 %75, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %78 = icmp ult i256 %75, 1
  %79 = select i1 %78, i256 %77, i256 %76
  %80 = trunc i256 %79 to i252
  %81 = icmp eq i252 %80, 0
  br i1 %81, label %82, label %216

82:                                               ; preds = %73
  %83 = phi { ptr, i32, i32, i32 } [ %29, %73 ]
  %84 = extractvalue { ptr, i32, i32, i32 } %83, 1
  %85 = extractvalue { ptr, i32, i32, i32 } %83, 2
  %86 = sub i32 %85, %84
  %87 = icmp uge i32 %86, 1
  br i1 %87, label %88, label %364

88:                                               ; preds = %82
  %89 = extractvalue { ptr, i32, i32, i32 } %83, 0
  %90 = load ptr, ptr %89, align 8
  %91 = zext i32 %84 to i64
  %92 = mul i64 %91, 32
  %93 = getelementptr inbounds i8, ptr %90, i64 %92
  %94 = add i32 %84, 1
  %95 = insertvalue { ptr, i32, i32, i32 } %83, i32 %94, 1
  %96 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %96, ptr %93, i64 32, i1 false)
  %97 = load i252, ptr %96, align 16
  call void @free(ptr %96)
  %98 = icmp sge i252 %97, -3618502788666131000275863779947924135206266826270938552493006944360846065663
  %99 = icmp slt i252 %97, 2147483648
  %100 = and i1 %98, %99
  %101 = icmp slt i252 %97, 0
  br i1 %101, label %102, label %104

102:                                              ; preds = %88
  %103 = sub i252 %97, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %105

104:                                              ; preds = %88
  br label %105

105:                                              ; preds = %102, %104
  %106 = phi i252 [ %97, %104 ], [ %103, %102 ]
  br label %107

107:                                              ; preds = %105
  %108 = add i64 %0, 2
  %109 = add i64 %0, 3
  %110 = select i1 %100, i64 %108, i64 %109
  %111 = trunc i252 %106 to i32
  br i1 %100, label %112, label %364

112:                                              ; preds = %107
  %113 = phi { ptr, i32, i32, i32 } [ %95, %107 ]
  %114 = extractvalue { ptr, i32, i32, i32 } %113, 1
  %115 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %116 = sub i32 %115, %114
  %117 = icmp uge i32 %116, 1
  br i1 %117, label %118, label %364

118:                                              ; preds = %112
  %119 = extractvalue { ptr, i32, i32, i32 } %113, 0
  %120 = load ptr, ptr %119, align 8
  %121 = zext i32 %114 to i64
  %122 = mul i64 %121, 32
  %123 = getelementptr inbounds i8, ptr %120, i64 %122
  %124 = add i32 %114, 1
  %125 = insertvalue { ptr, i32, i32, i32 } %113, i32 %124, 1
  %126 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %126, ptr %123, i64 32, i1 false)
  %127 = load i252, ptr %126, align 16
  call void @free(ptr %126)
  %128 = icmp sge i252 %127, -3618502788666131000275863779947924135206266826270938552493006944360846065663
  %129 = icmp slt i252 %127, 2147483648
  %130 = and i1 %128, %129
  %131 = icmp slt i252 %127, 0
  br i1 %131, label %132, label %134

132:                                              ; preds = %118
  %133 = sub i252 %127, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %135

134:                                              ; preds = %118
  br label %135

135:                                              ; preds = %132, %134
  %136 = phi i252 [ %127, %134 ], [ %133, %132 ]
  br label %137

137:                                              ; preds = %135
  %138 = add i64 %110, 2
  %139 = add i64 %110, 3
  %140 = select i1 %130, i64 %138, i64 %139
  %141 = trunc i252 %136 to i32
  br i1 %130, label %142, label %364

142:                                              ; preds = %137
  %143 = phi { ptr, i32, i32, i32 } [ %125, %137 ]
  %144 = extractvalue { ptr, i32, i32, i32 } %143, 1
  %145 = extractvalue { ptr, i32, i32, i32 } %143, 2
  %146 = sub i32 %145, %144
  %147 = icmp uge i32 %146, 1
  br i1 %147, label %148, label %364

148:                                              ; preds = %142
  %149 = extractvalue { ptr, i32, i32, i32 } %143, 0
  %150 = load ptr, ptr %149, align 8
  %151 = zext i32 %144 to i64
  %152 = mul i64 %151, 32
  %153 = getelementptr inbounds i8, ptr %150, i64 %152
  %154 = add i32 %144, 1
  %155 = insertvalue { ptr, i32, i32, i32 } %143, i32 %154, 1
  %156 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %156, ptr %153, i64 32, i1 false)
  %157 = load i252, ptr %156, align 16
  call void @free(ptr %156)
  %158 = icmp sge i252 %157, -3618502788666131000275863779947924135206266826270938552493006944360846065663
  %159 = icmp slt i252 %157, 2147483648
  %160 = and i1 %158, %159
  %161 = icmp slt i252 %157, 0
  br i1 %161, label %162, label %164

162:                                              ; preds = %148
  %163 = sub i252 %157, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %165

164:                                              ; preds = %148
  br label %165

165:                                              ; preds = %162, %164
  %166 = phi i252 [ %157, %164 ], [ %163, %162 ]
  br label %167

167:                                              ; preds = %165
  %168 = add i64 %140, 2
  %169 = add i64 %140, 3
  %170 = select i1 %160, i64 %168, i64 %169
  %171 = trunc i252 %166 to i32
  br i1 %160, label %172, label %364

172:                                              ; preds = %167
  %173 = phi { ptr, i32, i32, i32 } [ %155, %167 ]
  %174 = extractvalue { ptr, i32, i32, i32 } %173, 1
  %175 = extractvalue { ptr, i32, i32, i32 } %173, 2
  %176 = sub i32 %175, %174
  %177 = icmp uge i32 %176, 1
  br i1 %177, label %178, label %364

178:                                              ; preds = %172
  %179 = extractvalue { ptr, i32, i32, i32 } %173, 0
  %180 = load ptr, ptr %179, align 8
  %181 = zext i32 %174 to i64
  %182 = mul i64 %181, 32
  %183 = getelementptr inbounds i8, ptr %180, i64 %182
  %184 = add i32 %174, 1
  %185 = insertvalue { ptr, i32, i32, i32 } %173, i32 %184, 1
  %186 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %186, ptr %183, i64 32, i1 false)
  %187 = load i252, ptr %186, align 16
  call void @free(ptr %186)
  %188 = icmp sge i252 %187, -3618502788666131000275863779947924135206266826270938552493006944360846065663
  %189 = icmp slt i252 %187, 2147483648
  %190 = and i1 %188, %189
  %191 = icmp slt i252 %187, 0
  br i1 %191, label %192, label %194

192:                                              ; preds = %178
  %193 = sub i252 %187, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %195

194:                                              ; preds = %178
  br label %195

195:                                              ; preds = %192, %194
  %196 = phi i252 [ %187, %194 ], [ %193, %192 ]
  br label %197

197:                                              ; preds = %195
  %198 = add i64 %170, 2
  %199 = add i64 %170, 3
  %200 = select i1 %190, i64 %198, i64 %199
  %201 = trunc i252 %196 to i32
  br i1 %190, label %202, label %364

202:                                              ; preds = %197
  %203 = phi { ptr, i32, i32, i32 } [ %185, %197 ]
  %204 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %203, 0
  %205 = insertvalue { i32, i32, i32, i32 } undef, i32 %111, 0
  %206 = insertvalue { i32, i32, i32, i32 } %205, i32 %141, 1
  %207 = insertvalue { i32, i32, i32, i32 } %206, i32 %171, 2
  %208 = insertvalue { i32, i32, i32, i32 } %207, i32 %201, 3
  %209 = insertvalue { i3, { i32, i32, i32, i32 } } { i3 1, { i32, i32, i32, i32 } undef }, { i32, i32, i32, i32 } %208, 1
  store { i3, { i32, i32, i32, i32 } } %209, ptr %13, align 4
  %210 = load { i32, [16 x i8] }, ptr %13, align 4
  %211 = insertvalue { i1, { i32, [16 x i8] } } { i1 false, { i32, [16 x i8] } undef }, { i32, [16 x i8] } %210, 1
  store { i1, { i32, [16 x i8] } } %211, ptr %14, align 4
  %212 = load { i32, [20 x i8] }, ptr %14, align 4
  %213 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %200, 0
  %214 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %213, { { ptr, i32, i32, i32 } } %204, 1
  %215 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %214, { i32, [20 x i8] } %212, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %215

216:                                              ; preds = %73
  %217 = phi { ptr, i32, i32, i32 } [ %29, %73 ]
  %218 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$27"({ ptr, i32, i32, i32 } %217)
  %219 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %218, 0
  %220 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %218, 1
  %221 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %220, 0
  %222 = zext i252 %74 to i256
  %223 = sub i256 %222, 2
  %224 = add i256 %222, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %225 = icmp ult i256 %222, 2
  %226 = select i1 %225, i256 %224, i256 %223
  %227 = trunc i256 %226 to i252
  %228 = icmp eq i252 %227, 0
  br i1 %228, label %229, label %253

229:                                              ; preds = %216
  %230 = phi { ptr, i32, i32, i32 } [ %219, %216 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %230)
  %231 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f97"(i64 %0, { { ptr, i32, i32, i32 } } %221)
  %232 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %231, 0
  %233 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %231, 1
  %234 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %231, 2
  store { i32, [8 x i8] } %234, ptr %9, align 4
  %235 = load i1, ptr %9, align 1
  switch i1 %235, label %236 [
    i1 false, label %238
    i1 true, label %248
  ]

236:                                              ; preds = %229
  br i1 false, label %237, label %372

237:                                              ; preds = %236
  unreachable

238:                                              ; preds = %229
  %239 = load { i1, { { i2, [0 x i8] }, i32 } }, ptr %9, align 4
  %240 = extractvalue { i1, { { i2, [0 x i8] }, i32 } } %239, 1
  %241 = insertvalue { i3, { { i2, [0 x i8] }, i32 } } { i3 2, { { i2, [0 x i8] }, i32 } undef }, { { i2, [0 x i8] }, i32 } %240, 1
  store { i3, { { i2, [0 x i8] }, i32 } } %241, ptr %11, align 4
  %242 = load { i32, [16 x i8] }, ptr %11, align 4
  %243 = insertvalue { i1, { i32, [16 x i8] } } { i1 false, { i32, [16 x i8] } undef }, { i32, [16 x i8] } %242, 1
  store { i1, { i32, [16 x i8] } } %243, ptr %12, align 4
  %244 = load { i32, [20 x i8] }, ptr %12, align 4
  %245 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %232, 0
  %246 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %245, { { ptr, i32, i32, i32 } } %233, 1
  %247 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %246, { i32, [20 x i8] } %244, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %247

248:                                              ; preds = %229
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %10, align 1
  %249 = load { i32, [20 x i8] }, ptr %10, align 4
  %250 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %232, 0
  %251 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %250, { { ptr, i32, i32, i32 } } %233, 1
  %252 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %251, { i32, [20 x i8] } %249, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %252

253:                                              ; preds = %216
  %254 = phi i252 [ %74, %216 ]
  %255 = zext i252 %254 to i256
  %256 = sub i256 %255, 3
  %257 = add i256 %255, 3618502788666131213697322783095070105623107215331596699973092056135872020478
  %258 = icmp ult i256 %255, 3
  %259 = select i1 %258, i256 %257, i256 %256
  %260 = trunc i256 %259 to i252
  %261 = icmp eq i252 %260, 0
  br i1 %261, label %262, label %316

262:                                              ; preds = %253
  %263 = phi { { ptr, i32, i32, i32 } } [ %221, %253 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %263)
  %264 = extractvalue { ptr, i32, i32, i32 } %219, 1
  %265 = extractvalue { ptr, i32, i32, i32 } %219, 2
  %266 = sub i32 %265, %264
  %267 = icmp uge i32 %266, 1
  br i1 %267, label %268, label %364

268:                                              ; preds = %262
  %269 = extractvalue { ptr, i32, i32, i32 } %219, 0
  %270 = load ptr, ptr %269, align 8
  %271 = zext i32 %264 to i64
  %272 = mul i64 %271, 32
  %273 = getelementptr inbounds i8, ptr %270, i64 %272
  %274 = add i32 %264, 1
  %275 = insertvalue { ptr, i32, i32, i32 } %219, i32 %274, 1
  %276 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %276, ptr %273, i64 32, i1 false)
  %277 = load i252, ptr %276, align 16
  call void @free(ptr %276)
  %278 = icmp ult i252 %277, 256
  %279 = add i64 %0, 2
  %280 = add i64 %0, 3
  %281 = select i1 %278, i64 %279, i64 %280
  %282 = trunc i252 %277 to i8
  br i1 %278, label %283, label %364

283:                                              ; preds = %268
  %284 = phi { ptr, i32, i32, i32 } [ %275, %268 ]
  %285 = extractvalue { ptr, i32, i32, i32 } %284, 1
  %286 = extractvalue { ptr, i32, i32, i32 } %284, 2
  %287 = sub i32 %286, %285
  %288 = icmp uge i32 %287, 1
  br i1 %288, label %289, label %364

289:                                              ; preds = %283
  %290 = extractvalue { ptr, i32, i32, i32 } %284, 0
  %291 = load ptr, ptr %290, align 8
  %292 = zext i32 %285 to i64
  %293 = mul i64 %292, 32
  %294 = getelementptr inbounds i8, ptr %291, i64 %293
  %295 = add i32 %285, 1
  %296 = insertvalue { ptr, i32, i32, i32 } %284, i32 %295, 1
  %297 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %297, ptr %294, i64 32, i1 false)
  %298 = load i252, ptr %297, align 16
  call void @free(ptr %297)
  %299 = icmp ult i252 %298, 4294967296
  %300 = add i64 %281, 2
  %301 = add i64 %281, 3
  %302 = select i1 %299, i64 %300, i64 %301
  %303 = trunc i252 %298 to i32
  br i1 %299, label %304, label %364

304:                                              ; preds = %289
  %305 = phi { ptr, i32, i32, i32 } [ %296, %289 ]
  %306 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %305, 0
  %307 = insertvalue { i8, i32 } undef, i8 %282, 0
  %308 = insertvalue { i8, i32 } %307, i32 %303, 1
  %309 = insertvalue { i3, { i8, i32 } } { i3 3, { i8, i32 } undef }, { i8, i32 } %308, 1
  store { i3, { i8, i32 } } %309, ptr %7, align 4
  %310 = load { i32, [16 x i8] }, ptr %7, align 4
  %311 = insertvalue { i1, { i32, [16 x i8] } } { i1 false, { i32, [16 x i8] } undef }, { i32, [16 x i8] } %310, 1
  store { i1, { i32, [16 x i8] } } %311, ptr %8, align 4
  %312 = load { i32, [20 x i8] }, ptr %8, align 4
  %313 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %302, 0
  %314 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %313, { { ptr, i32, i32, i32 } } %306, 1
  %315 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %314, { i32, [20 x i8] } %312, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %315

316:                                              ; preds = %253
  %317 = phi i252 [ %254, %253 ]
  %318 = phi i252 [ 4, %253 ]
  %319 = zext i252 %317 to i256
  %320 = zext i252 %318 to i256
  %321 = sub i256 %319, %320
  %322 = add i256 %321, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %323 = icmp ult i256 %319, %320
  %324 = select i1 %323, i256 %322, i256 %321
  %325 = trunc i256 %324 to i252
  %326 = icmp eq i252 %325, 0
  br i1 %326, label %327, label %358

327:                                              ; preds = %316
  %328 = phi { { ptr, i32, i32, i32 } } [ %221, %316 ]
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %328)
  %329 = extractvalue { ptr, i32, i32, i32 } %219, 1
  %330 = extractvalue { ptr, i32, i32, i32 } %219, 2
  %331 = sub i32 %330, %329
  %332 = icmp uge i32 %331, 1
  br i1 %332, label %333, label %364

333:                                              ; preds = %327
  %334 = extractvalue { ptr, i32, i32, i32 } %219, 0
  %335 = load ptr, ptr %334, align 8
  %336 = zext i32 %329 to i64
  %337 = mul i64 %336, 32
  %338 = getelementptr inbounds i8, ptr %335, i64 %337
  %339 = add i32 %329, 1
  %340 = insertvalue { ptr, i32, i32, i32 } %219, i32 %339, 1
  %341 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %341, ptr %338, i64 32, i1 false)
  %342 = load i252, ptr %341, align 16
  call void @free(ptr %341)
  %343 = icmp ult i252 %342, 256
  %344 = add i64 %0, 2
  %345 = add i64 %0, 3
  %346 = select i1 %343, i64 %344, i64 %345
  %347 = trunc i252 %342 to i8
  br i1 %343, label %348, label %364

348:                                              ; preds = %333
  %349 = phi { ptr, i32, i32, i32 } [ %340, %333 ]
  %350 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %349, 0
  %351 = insertvalue { i3, i8 } { i3 -4, i8 undef }, i8 %347, 1
  store { i3, i8 } %351, ptr %5, align 1
  %352 = load { i32, [16 x i8] }, ptr %5, align 4
  %353 = insertvalue { i1, { i32, [16 x i8] } } { i1 false, { i32, [16 x i8] } undef }, { i32, [16 x i8] } %352, 1
  store { i1, { i32, [16 x i8] } } %353, ptr %6, align 4
  %354 = load { i32, [20 x i8] }, ptr %6, align 4
  %355 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %346, 0
  %356 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %355, { { ptr, i32, i32, i32 } } %350, 1
  %357 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %356, { i32, [20 x i8] } %354, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %357

358:                                              ; preds = %316
  %359 = phi { ptr, i32, i32, i32 } [ %219, %316 ]
  call void @"drop$27"({ ptr, i32, i32, i32 } %359)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %360 = load { i32, [20 x i8] }, ptr %4, align 4
  %361 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %0, 0
  %362 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %361, { { ptr, i32, i32, i32 } } %221, 1
  %363 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %362, { i32, [20 x i8] } %360, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %363

364:                                              ; preds = %58, %33, %197, %172, %167, %142, %137, %112, %107, %82, %289, %283, %268, %262, %333, %327, %2
  %365 = phi i64 [ %346, %333 ], [ %0, %327 ], [ %302, %289 ], [ %281, %283 ], [ %281, %268 ], [ %0, %262 ], [ %200, %197 ], [ %170, %172 ], [ %170, %167 ], [ %140, %142 ], [ %140, %137 ], [ %110, %112 ], [ %110, %107 ], [ %0, %82 ], [ %61, %58 ], [ %0, %33 ], [ %0, %2 ]
  %366 = phi { ptr, i32, i32, i32 } [ %340, %333 ], [ %219, %327 ], [ %296, %289 ], [ %284, %283 ], [ %275, %268 ], [ %219, %262 ], [ %185, %197 ], [ %173, %172 ], [ %155, %167 ], [ %143, %142 ], [ %125, %137 ], [ %113, %112 ], [ %95, %107 ], [ %83, %82 ], [ %46, %58 ], [ %34, %33 ], [ %17, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %367 = load { i32, [20 x i8] }, ptr %3, align 4
  %368 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %366, 0
  %369 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %365, 0
  %370 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %369, { { ptr, i32, i32, i32 } } %368, 1
  %371 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %370, { i32, [20 x i8] } %367, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %371

372:                                              ; preds = %236
  call void @puts(ptr @assert_msg_159)
  call void @abort()
  unreachable
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @f94(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @"impl$f94"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %8, { i32, [20 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %9
}

define void @_mlir_ciface_f94(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @f94(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$16"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$15"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$16"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$15"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$17"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$16"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$17"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$16"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f95"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  %10 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %9, 0
  %11 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %9, 1
  %12 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %11, 0
  %13 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %11, 4
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %11, 5
  call void @"drop$16"({ ptr, i32, i32, i32 } %13)
  call void @"drop$16"({ ptr, i32, i32, i32 } %14)
  %15 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %12)
  %16 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %15, 0
  %17 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %15, 1
  %18 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %17, 0
  %19 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$163"({ ptr, i32, i32, i32 } %18)
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 0
  %21 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 1
  %22 = extractvalue { ptr, i32, i32, i32 } %21, 1
  %23 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %24 = sub i32 %23, %22
  call void @"drop$163"({ ptr, i32, i32, i32 } %21)
  %25 = zext i32 %24 to i252
  %26 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %42

28:                                               ; preds = %4
  %29 = shl i32 %26, 1
  %30 = call i32 @llvm.umin.i32(i32 %29, i32 1024)
  %31 = add i32 %30, %26
  %32 = call i32 @llvm.umax.i32(i32 %31, i32 8)
  %33 = zext i32 %32 to i64
  %34 = mul i64 %33, 32
  %35 = add i64 %34, 16
  %36 = call ptr @realloc(ptr null, i64 %35)
  store i32 1, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %36, i32 4
  store i32 0, ptr %37, align 4
  %38 = getelementptr inbounds i8, ptr %36, i32 16
  %39 = call ptr @realloc(ptr null, i64 8)
  store ptr %38, ptr %39, align 8
  %40 = insertvalue { ptr, i32, i32, i32 } %3, ptr %39, 0
  %41 = insertvalue { ptr, i32, i32, i32 } %40, i32 %32, 3
  br label %63

42:                                               ; preds = %4
  %43 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %44 = icmp ult i32 %43, %26
  br i1 %44, label %45, label %46

45:                                               ; preds = %42
  br label %60

46:                                               ; preds = %42
  %47 = shl i32 %26, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %26
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %55, i32 -16
  %57 = call ptr @realloc(ptr %56, i64 %53)
  %58 = getelementptr inbounds i8, ptr %57, i32 16
  store ptr %58, ptr %54, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } %3, i32 %50, 3
  br label %60

60:                                               ; preds = %45, %46
  %61 = phi { ptr, i32, i32, i32 } [ %59, %46 ], [ %3, %45 ]
  br label %62

62:                                               ; preds = %60
  br label %63

63:                                               ; preds = %28, %62
  %64 = phi { ptr, i32, i32, i32 } [ %61, %62 ], [ %41, %28 ]
  br label %65

65:                                               ; preds = %63
  %66 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %67 = load ptr, ptr %66, align 8
  %68 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = getelementptr inbounds i8, ptr %67, i64 %70
  store i252 %25, ptr %71, align 16
  %72 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %73 = add i32 %72, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %64, i32 %73, 2
  %75 = getelementptr inbounds i8, ptr %67, i32 -12
  store i32 %73, ptr %75, align 4
  %76 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %20, 0
  %77 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f83"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %76, { ptr, i32, i32, i32 } %74)
  %78 = extractvalue { i64, i64, { i64, [24 x i8] } } %77, 0
  %79 = extractvalue { i64, i64, { i64, [24 x i8] } } %77, 1
  %80 = extractvalue { i64, i64, { i64, [24 x i8] } } %77, 2
  store { i64, [24 x i8] } %80, ptr %5, align 8
  %81 = load i1, ptr %5, align 1
  switch i1 %81, label %82 [
    i1 false, label %84
    i1 true, label %434
  ]

82:                                               ; preds = %65
  br i1 false, label %83, label %527

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %65
  %85 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %86 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %85, 1
  %87 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$99"({ { ptr, i32, i32, i32 }, i252, i32 } %16)
  %88 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %87, 0
  %89 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %87, 1
  %90 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %89, 0
  %91 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %89, 2
  call void @"drop$163"({ ptr, i32, i32, i32 } %90)
  %92 = zext i32 %91 to i252
  %93 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10)
  %94 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %93, 0
  %95 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %93, 1
  %96 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 0
  %97 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 1
  %98 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 4
  %99 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 5
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %96)
  call void @"drop$16"({ ptr, i32, i32, i32 } %98)
  call void @"drop$16"({ ptr, i32, i32, i32 } %99)
  %100 = zext i32 %97 to i252
  %101 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %94)
  %102 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %101, 0
  %103 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %101, 1
  %104 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 0
  %105 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 2
  %106 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 4
  %107 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 5
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %104)
  call void @"drop$16"({ ptr, i32, i32, i32 } %106)
  call void @"drop$16"({ ptr, i32, i32, i32 } %107)
  %108 = zext i8 %105 to i252
  %109 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %102)
  %110 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %109, 0
  %111 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %109, 1
  %112 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %111, 0
  %113 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %111, 3
  %114 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %111, 4
  %115 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %111, 5
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %112)
  call void @"drop$16"({ ptr, i32, i32, i32 } %114)
  call void @"drop$16"({ ptr, i32, i32, i32 } %115)
  %116 = zext i8 %113 to i252
  %117 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %110)
  %118 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %117, 0
  %119 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %117, 1
  %120 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %119, 0
  %121 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %119, 4
  %122 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %119, 5
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %120)
  call void @"drop$16"({ ptr, i32, i32, i32 } %122)
  %123 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$16"({ ptr, i32, i32, i32 } %121)
  %124 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %123, 0
  %125 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %123, 1
  %126 = extractvalue { ptr, i32, i32, i32 } %125, 1
  %127 = extractvalue { ptr, i32, i32, i32 } %125, 2
  %128 = sub i32 %127, %126
  call void @"drop$16"({ ptr, i32, i32, i32 } %125)
  %129 = zext i32 %128 to i252
  %130 = extractvalue { { ptr, i32, i32, i32 }, {} } %86, 0
  %131 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %88, 0
  %132 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %88, 1
  call void @"drop$163"({ ptr, i32, i32, i32 } %131)
  %133 = extractvalue { ptr, i32, i32, i32 } %130, 3
  %134 = icmp eq i32 %133, 0
  br i1 %134, label %135, label %149

135:                                              ; preds = %84
  %136 = shl i32 %133, 1
  %137 = call i32 @llvm.umin.i32(i32 %136, i32 1024)
  %138 = add i32 %137, %133
  %139 = call i32 @llvm.umax.i32(i32 %138, i32 8)
  %140 = zext i32 %139 to i64
  %141 = mul i64 %140, 32
  %142 = add i64 %141, 16
  %143 = call ptr @realloc(ptr null, i64 %142)
  store i32 1, ptr %143, align 4
  %144 = getelementptr inbounds i8, ptr %143, i32 4
  store i32 0, ptr %144, align 4
  %145 = getelementptr inbounds i8, ptr %143, i32 16
  %146 = call ptr @realloc(ptr null, i64 8)
  store ptr %145, ptr %146, align 8
  %147 = insertvalue { ptr, i32, i32, i32 } %130, ptr %146, 0
  %148 = insertvalue { ptr, i32, i32, i32 } %147, i32 %139, 3
  br label %170

149:                                              ; preds = %84
  %150 = extractvalue { ptr, i32, i32, i32 } %130, 2
  %151 = icmp ult i32 %150, %133
  br i1 %151, label %152, label %153

152:                                              ; preds = %149
  br label %167

153:                                              ; preds = %149
  %154 = shl i32 %133, 1
  %155 = call i32 @llvm.umin.i32(i32 %154, i32 1024)
  %156 = add i32 %155, %133
  %157 = call i32 @llvm.umax.i32(i32 %156, i32 8)
  %158 = zext i32 %157 to i64
  %159 = mul i64 %158, 32
  %160 = add i64 %159, 16
  %161 = extractvalue { ptr, i32, i32, i32 } %130, 0
  %162 = load ptr, ptr %161, align 8
  %163 = getelementptr inbounds i8, ptr %162, i32 -16
  %164 = call ptr @realloc(ptr %163, i64 %160)
  %165 = getelementptr inbounds i8, ptr %164, i32 16
  store ptr %165, ptr %161, align 8
  %166 = insertvalue { ptr, i32, i32, i32 } %130, i32 %157, 3
  br label %167

167:                                              ; preds = %152, %153
  %168 = phi { ptr, i32, i32, i32 } [ %166, %153 ], [ %130, %152 ]
  br label %169

169:                                              ; preds = %167
  br label %170

170:                                              ; preds = %135, %169
  %171 = phi { ptr, i32, i32, i32 } [ %168, %169 ], [ %148, %135 ]
  br label %172

172:                                              ; preds = %170
  %173 = extractvalue { ptr, i32, i32, i32 } %171, 0
  %174 = load ptr, ptr %173, align 8
  %175 = extractvalue { ptr, i32, i32, i32 } %171, 2
  %176 = zext i32 %175 to i64
  %177 = mul i64 %176, 32
  %178 = getelementptr inbounds i8, ptr %174, i64 %177
  store i252 %132, ptr %178, align 16
  %179 = extractvalue { ptr, i32, i32, i32 } %171, 2
  %180 = add i32 %179, 1
  %181 = insertvalue { ptr, i32, i32, i32 } %171, i32 %180, 2
  %182 = getelementptr inbounds i8, ptr %174, i32 -12
  store i32 %180, ptr %182, align 4
  %183 = extractvalue { ptr, i32, i32, i32 } %171, 3
  %184 = icmp eq i32 %183, 0
  br i1 %184, label %185, label %199

185:                                              ; preds = %172
  %186 = shl i32 %183, 1
  %187 = call i32 @llvm.umin.i32(i32 %186, i32 1024)
  %188 = add i32 %187, %183
  %189 = call i32 @llvm.umax.i32(i32 %188, i32 8)
  %190 = zext i32 %189 to i64
  %191 = mul i64 %190, 32
  %192 = add i64 %191, 16
  %193 = call ptr @realloc(ptr null, i64 %192)
  store i32 1, ptr %193, align 4
  %194 = getelementptr inbounds i8, ptr %193, i32 4
  store i32 0, ptr %194, align 4
  %195 = getelementptr inbounds i8, ptr %193, i32 16
  %196 = call ptr @realloc(ptr null, i64 8)
  store ptr %195, ptr %196, align 8
  %197 = insertvalue { ptr, i32, i32, i32 } %181, ptr %196, 0
  %198 = insertvalue { ptr, i32, i32, i32 } %197, i32 %189, 3
  br label %219

199:                                              ; preds = %172
  %200 = icmp ult i32 %180, %183
  br i1 %200, label %201, label %202

201:                                              ; preds = %199
  br label %216

202:                                              ; preds = %199
  %203 = shl i32 %183, 1
  %204 = call i32 @llvm.umin.i32(i32 %203, i32 1024)
  %205 = add i32 %204, %183
  %206 = call i32 @llvm.umax.i32(i32 %205, i32 8)
  %207 = zext i32 %206 to i64
  %208 = mul i64 %207, 32
  %209 = add i64 %208, 16
  %210 = extractvalue { ptr, i32, i32, i32 } %171, 0
  %211 = load ptr, ptr %210, align 8
  %212 = getelementptr inbounds i8, ptr %211, i32 -16
  %213 = call ptr @realloc(ptr %212, i64 %209)
  %214 = getelementptr inbounds i8, ptr %213, i32 16
  store ptr %214, ptr %210, align 8
  %215 = insertvalue { ptr, i32, i32, i32 } %181, i32 %206, 3
  br label %216

216:                                              ; preds = %201, %202
  %217 = phi { ptr, i32, i32, i32 } [ %215, %202 ], [ %181, %201 ]
  br label %218

218:                                              ; preds = %216
  br label %219

219:                                              ; preds = %185, %218
  %220 = phi { ptr, i32, i32, i32 } [ %217, %218 ], [ %198, %185 ]
  br label %221

221:                                              ; preds = %219
  %222 = extractvalue { ptr, i32, i32, i32 } %220, 0
  %223 = load ptr, ptr %222, align 8
  %224 = extractvalue { ptr, i32, i32, i32 } %220, 2
  %225 = zext i32 %224 to i64
  %226 = mul i64 %225, 32
  %227 = getelementptr inbounds i8, ptr %223, i64 %226
  store i252 %92, ptr %227, align 16
  %228 = extractvalue { ptr, i32, i32, i32 } %220, 2
  %229 = add i32 %228, 1
  %230 = insertvalue { ptr, i32, i32, i32 } %220, i32 %229, 2
  %231 = getelementptr inbounds i8, ptr %223, i32 -12
  store i32 %229, ptr %231, align 4
  %232 = extractvalue { ptr, i32, i32, i32 } %220, 3
  %233 = icmp eq i32 %232, 0
  br i1 %233, label %234, label %248

234:                                              ; preds = %221
  %235 = shl i32 %232, 1
  %236 = call i32 @llvm.umin.i32(i32 %235, i32 1024)
  %237 = add i32 %236, %232
  %238 = call i32 @llvm.umax.i32(i32 %237, i32 8)
  %239 = zext i32 %238 to i64
  %240 = mul i64 %239, 32
  %241 = add i64 %240, 16
  %242 = call ptr @realloc(ptr null, i64 %241)
  store i32 1, ptr %242, align 4
  %243 = getelementptr inbounds i8, ptr %242, i32 4
  store i32 0, ptr %243, align 4
  %244 = getelementptr inbounds i8, ptr %242, i32 16
  %245 = call ptr @realloc(ptr null, i64 8)
  store ptr %244, ptr %245, align 8
  %246 = insertvalue { ptr, i32, i32, i32 } %230, ptr %245, 0
  %247 = insertvalue { ptr, i32, i32, i32 } %246, i32 %238, 3
  br label %268

248:                                              ; preds = %221
  %249 = icmp ult i32 %229, %232
  br i1 %249, label %250, label %251

250:                                              ; preds = %248
  br label %265

251:                                              ; preds = %248
  %252 = shl i32 %232, 1
  %253 = call i32 @llvm.umin.i32(i32 %252, i32 1024)
  %254 = add i32 %253, %232
  %255 = call i32 @llvm.umax.i32(i32 %254, i32 8)
  %256 = zext i32 %255 to i64
  %257 = mul i64 %256, 32
  %258 = add i64 %257, 16
  %259 = extractvalue { ptr, i32, i32, i32 } %220, 0
  %260 = load ptr, ptr %259, align 8
  %261 = getelementptr inbounds i8, ptr %260, i32 -16
  %262 = call ptr @realloc(ptr %261, i64 %258)
  %263 = getelementptr inbounds i8, ptr %262, i32 16
  store ptr %263, ptr %259, align 8
  %264 = insertvalue { ptr, i32, i32, i32 } %230, i32 %255, 3
  br label %265

265:                                              ; preds = %250, %251
  %266 = phi { ptr, i32, i32, i32 } [ %264, %251 ], [ %230, %250 ]
  br label %267

267:                                              ; preds = %265
  br label %268

268:                                              ; preds = %234, %267
  %269 = phi { ptr, i32, i32, i32 } [ %266, %267 ], [ %247, %234 ]
  br label %270

270:                                              ; preds = %268
  %271 = extractvalue { ptr, i32, i32, i32 } %269, 0
  %272 = load ptr, ptr %271, align 8
  %273 = extractvalue { ptr, i32, i32, i32 } %269, 2
  %274 = zext i32 %273 to i64
  %275 = mul i64 %274, 32
  %276 = getelementptr inbounds i8, ptr %272, i64 %275
  store i252 %100, ptr %276, align 16
  %277 = extractvalue { ptr, i32, i32, i32 } %269, 2
  %278 = add i32 %277, 1
  %279 = insertvalue { ptr, i32, i32, i32 } %269, i32 %278, 2
  %280 = getelementptr inbounds i8, ptr %272, i32 -12
  store i32 %278, ptr %280, align 4
  %281 = extractvalue { ptr, i32, i32, i32 } %269, 3
  %282 = icmp eq i32 %281, 0
  br i1 %282, label %283, label %297

283:                                              ; preds = %270
  %284 = shl i32 %281, 1
  %285 = call i32 @llvm.umin.i32(i32 %284, i32 1024)
  %286 = add i32 %285, %281
  %287 = call i32 @llvm.umax.i32(i32 %286, i32 8)
  %288 = zext i32 %287 to i64
  %289 = mul i64 %288, 32
  %290 = add i64 %289, 16
  %291 = call ptr @realloc(ptr null, i64 %290)
  store i32 1, ptr %291, align 4
  %292 = getelementptr inbounds i8, ptr %291, i32 4
  store i32 0, ptr %292, align 4
  %293 = getelementptr inbounds i8, ptr %291, i32 16
  %294 = call ptr @realloc(ptr null, i64 8)
  store ptr %293, ptr %294, align 8
  %295 = insertvalue { ptr, i32, i32, i32 } %279, ptr %294, 0
  %296 = insertvalue { ptr, i32, i32, i32 } %295, i32 %287, 3
  br label %317

297:                                              ; preds = %270
  %298 = icmp ult i32 %278, %281
  br i1 %298, label %299, label %300

299:                                              ; preds = %297
  br label %314

300:                                              ; preds = %297
  %301 = shl i32 %281, 1
  %302 = call i32 @llvm.umin.i32(i32 %301, i32 1024)
  %303 = add i32 %302, %281
  %304 = call i32 @llvm.umax.i32(i32 %303, i32 8)
  %305 = zext i32 %304 to i64
  %306 = mul i64 %305, 32
  %307 = add i64 %306, 16
  %308 = extractvalue { ptr, i32, i32, i32 } %269, 0
  %309 = load ptr, ptr %308, align 8
  %310 = getelementptr inbounds i8, ptr %309, i32 -16
  %311 = call ptr @realloc(ptr %310, i64 %307)
  %312 = getelementptr inbounds i8, ptr %311, i32 16
  store ptr %312, ptr %308, align 8
  %313 = insertvalue { ptr, i32, i32, i32 } %279, i32 %304, 3
  br label %314

314:                                              ; preds = %299, %300
  %315 = phi { ptr, i32, i32, i32 } [ %313, %300 ], [ %279, %299 ]
  br label %316

316:                                              ; preds = %314
  br label %317

317:                                              ; preds = %283, %316
  %318 = phi { ptr, i32, i32, i32 } [ %315, %316 ], [ %296, %283 ]
  br label %319

319:                                              ; preds = %317
  %320 = extractvalue { ptr, i32, i32, i32 } %318, 0
  %321 = load ptr, ptr %320, align 8
  %322 = extractvalue { ptr, i32, i32, i32 } %318, 2
  %323 = zext i32 %322 to i64
  %324 = mul i64 %323, 32
  %325 = getelementptr inbounds i8, ptr %321, i64 %324
  store i252 %108, ptr %325, align 16
  %326 = extractvalue { ptr, i32, i32, i32 } %318, 2
  %327 = add i32 %326, 1
  %328 = insertvalue { ptr, i32, i32, i32 } %318, i32 %327, 2
  %329 = getelementptr inbounds i8, ptr %321, i32 -12
  store i32 %327, ptr %329, align 4
  %330 = extractvalue { ptr, i32, i32, i32 } %318, 3
  %331 = icmp eq i32 %330, 0
  br i1 %331, label %332, label %346

332:                                              ; preds = %319
  %333 = shl i32 %330, 1
  %334 = call i32 @llvm.umin.i32(i32 %333, i32 1024)
  %335 = add i32 %334, %330
  %336 = call i32 @llvm.umax.i32(i32 %335, i32 8)
  %337 = zext i32 %336 to i64
  %338 = mul i64 %337, 32
  %339 = add i64 %338, 16
  %340 = call ptr @realloc(ptr null, i64 %339)
  store i32 1, ptr %340, align 4
  %341 = getelementptr inbounds i8, ptr %340, i32 4
  store i32 0, ptr %341, align 4
  %342 = getelementptr inbounds i8, ptr %340, i32 16
  %343 = call ptr @realloc(ptr null, i64 8)
  store ptr %342, ptr %343, align 8
  %344 = insertvalue { ptr, i32, i32, i32 } %328, ptr %343, 0
  %345 = insertvalue { ptr, i32, i32, i32 } %344, i32 %336, 3
  br label %366

346:                                              ; preds = %319
  %347 = icmp ult i32 %327, %330
  br i1 %347, label %348, label %349

348:                                              ; preds = %346
  br label %363

349:                                              ; preds = %346
  %350 = shl i32 %330, 1
  %351 = call i32 @llvm.umin.i32(i32 %350, i32 1024)
  %352 = add i32 %351, %330
  %353 = call i32 @llvm.umax.i32(i32 %352, i32 8)
  %354 = zext i32 %353 to i64
  %355 = mul i64 %354, 32
  %356 = add i64 %355, 16
  %357 = extractvalue { ptr, i32, i32, i32 } %318, 0
  %358 = load ptr, ptr %357, align 8
  %359 = getelementptr inbounds i8, ptr %358, i32 -16
  %360 = call ptr @realloc(ptr %359, i64 %356)
  %361 = getelementptr inbounds i8, ptr %360, i32 16
  store ptr %361, ptr %357, align 8
  %362 = insertvalue { ptr, i32, i32, i32 } %328, i32 %353, 3
  br label %363

363:                                              ; preds = %348, %349
  %364 = phi { ptr, i32, i32, i32 } [ %362, %349 ], [ %328, %348 ]
  br label %365

365:                                              ; preds = %363
  br label %366

366:                                              ; preds = %332, %365
  %367 = phi { ptr, i32, i32, i32 } [ %364, %365 ], [ %345, %332 ]
  br label %368

368:                                              ; preds = %366
  %369 = extractvalue { ptr, i32, i32, i32 } %367, 0
  %370 = load ptr, ptr %369, align 8
  %371 = extractvalue { ptr, i32, i32, i32 } %367, 2
  %372 = zext i32 %371 to i64
  %373 = mul i64 %372, 32
  %374 = getelementptr inbounds i8, ptr %370, i64 %373
  store i252 %116, ptr %374, align 16
  %375 = extractvalue { ptr, i32, i32, i32 } %367, 2
  %376 = add i32 %375, 1
  %377 = insertvalue { ptr, i32, i32, i32 } %367, i32 %376, 2
  %378 = getelementptr inbounds i8, ptr %370, i32 -12
  store i32 %376, ptr %378, align 4
  %379 = extractvalue { ptr, i32, i32, i32 } %367, 3
  %380 = icmp eq i32 %379, 0
  br i1 %380, label %381, label %395

381:                                              ; preds = %368
  %382 = shl i32 %379, 1
  %383 = call i32 @llvm.umin.i32(i32 %382, i32 1024)
  %384 = add i32 %383, %379
  %385 = call i32 @llvm.umax.i32(i32 %384, i32 8)
  %386 = zext i32 %385 to i64
  %387 = mul i64 %386, 32
  %388 = add i64 %387, 16
  %389 = call ptr @realloc(ptr null, i64 %388)
  store i32 1, ptr %389, align 4
  %390 = getelementptr inbounds i8, ptr %389, i32 4
  store i32 0, ptr %390, align 4
  %391 = getelementptr inbounds i8, ptr %389, i32 16
  %392 = call ptr @realloc(ptr null, i64 8)
  store ptr %391, ptr %392, align 8
  %393 = insertvalue { ptr, i32, i32, i32 } %377, ptr %392, 0
  %394 = insertvalue { ptr, i32, i32, i32 } %393, i32 %385, 3
  br label %415

395:                                              ; preds = %368
  %396 = icmp ult i32 %376, %379
  br i1 %396, label %397, label %398

397:                                              ; preds = %395
  br label %412

398:                                              ; preds = %395
  %399 = shl i32 %379, 1
  %400 = call i32 @llvm.umin.i32(i32 %399, i32 1024)
  %401 = add i32 %400, %379
  %402 = call i32 @llvm.umax.i32(i32 %401, i32 8)
  %403 = zext i32 %402 to i64
  %404 = mul i64 %403, 32
  %405 = add i64 %404, 16
  %406 = extractvalue { ptr, i32, i32, i32 } %367, 0
  %407 = load ptr, ptr %406, align 8
  %408 = getelementptr inbounds i8, ptr %407, i32 -16
  %409 = call ptr @realloc(ptr %408, i64 %405)
  %410 = getelementptr inbounds i8, ptr %409, i32 16
  store ptr %410, ptr %406, align 8
  %411 = insertvalue { ptr, i32, i32, i32 } %377, i32 %402, 3
  br label %412

412:                                              ; preds = %397, %398
  %413 = phi { ptr, i32, i32, i32 } [ %411, %398 ], [ %377, %397 ]
  br label %414

414:                                              ; preds = %412
  br label %415

415:                                              ; preds = %381, %414
  %416 = phi { ptr, i32, i32, i32 } [ %413, %414 ], [ %394, %381 ]
  br label %417

417:                                              ; preds = %415
  %418 = extractvalue { ptr, i32, i32, i32 } %416, 0
  %419 = load ptr, ptr %418, align 8
  %420 = extractvalue { ptr, i32, i32, i32 } %416, 2
  %421 = zext i32 %420 to i64
  %422 = mul i64 %421, 32
  %423 = getelementptr inbounds i8, ptr %419, i64 %422
  store i252 %129, ptr %423, align 16
  %424 = extractvalue { ptr, i32, i32, i32 } %416, 2
  %425 = add i32 %424, 1
  %426 = insertvalue { ptr, i32, i32, i32 } %416, i32 %425, 2
  %427 = getelementptr inbounds i8, ptr %419, i32 -12
  store i32 %425, ptr %427, align 4
  %428 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %124, 0
  %429 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f98"(i64 %78, i64 %79, { { ptr, i32, i32, i32 } } %428, { ptr, i32, i32, i32 } %426)
  %430 = extractvalue { i64, i64, { i64, [24 x i8] } } %429, 0
  %431 = extractvalue { i64, i64, { i64, [24 x i8] } } %429, 1
  %432 = extractvalue { i64, i64, { i64, [24 x i8] } } %429, 2
  store { i64, [24 x i8] } %432, ptr %7, align 8
  %433 = load i1, ptr %7, align 1
  switch i1 %433, label %442 [
    i1 false, label %444
    i1 true, label %519
  ]

434:                                              ; preds = %65
  %435 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %436 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %435, 1
  call void @"drop$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10)
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %16)
  %437 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %436, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %437, ptr %6, align 8
  %438 = load { i64, [24 x i8] }, ptr %6, align 8
  %439 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %78, 0
  %440 = insertvalue { i64, i64, { i64, [24 x i8] } } %439, i64 %79, 1
  %441 = insertvalue { i64, i64, { i64, [24 x i8] } } %440, { i64, [24 x i8] } %438, 2
  ret { i64, i64, { i64, [24 x i8] } } %441

442:                                              ; preds = %417
  br i1 false, label %443, label %528

443:                                              ; preds = %442
  unreachable

444:                                              ; preds = %417
  %445 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %7, align 8
  %446 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %445, 1
  %447 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %448 = call ptr %447()
  %449 = call i64 @llvm.uadd.sat.i64(i64 %431, i64 0)
  %450 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %118, 0
  %451 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %118, 4
  %452 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %118, 5
  call void @"drop$99"({ { ptr, i32, i32, i32 }, i252, i32 } %450)
  call void @"drop$16"({ ptr, i32, i32, i32 } %451)
  %453 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$16"({ ptr, i32, i32, i32 } %452)
  %454 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %453, 0
  %455 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %453, 1
  %456 = extractvalue { ptr, i32, i32, i32 } %455, 1
  %457 = extractvalue { ptr, i32, i32, i32 } %455, 2
  %458 = sub i32 %457, %456
  call void @"drop$16"({ ptr, i32, i32, i32 } %455)
  %459 = zext i32 %458 to i252
  %460 = extractvalue { { ptr, i32, i32, i32 }, {} } %446, 0
  %461 = extractvalue { ptr, i32, i32, i32 } %460, 3
  %462 = icmp eq i32 %461, 0
  br i1 %462, label %463, label %477

463:                                              ; preds = %444
  %464 = shl i32 %461, 1
  %465 = call i32 @llvm.umin.i32(i32 %464, i32 1024)
  %466 = add i32 %465, %461
  %467 = call i32 @llvm.umax.i32(i32 %466, i32 8)
  %468 = zext i32 %467 to i64
  %469 = mul i64 %468, 32
  %470 = add i64 %469, 16
  %471 = call ptr @realloc(ptr null, i64 %470)
  store i32 1, ptr %471, align 4
  %472 = getelementptr inbounds i8, ptr %471, i32 4
  store i32 0, ptr %472, align 4
  %473 = getelementptr inbounds i8, ptr %471, i32 16
  %474 = call ptr @realloc(ptr null, i64 8)
  store ptr %473, ptr %474, align 8
  %475 = insertvalue { ptr, i32, i32, i32 } %460, ptr %474, 0
  %476 = insertvalue { ptr, i32, i32, i32 } %475, i32 %467, 3
  br label %498

477:                                              ; preds = %444
  %478 = extractvalue { ptr, i32, i32, i32 } %460, 2
  %479 = icmp ult i32 %478, %461
  br i1 %479, label %480, label %481

480:                                              ; preds = %477
  br label %495

481:                                              ; preds = %477
  %482 = shl i32 %461, 1
  %483 = call i32 @llvm.umin.i32(i32 %482, i32 1024)
  %484 = add i32 %483, %461
  %485 = call i32 @llvm.umax.i32(i32 %484, i32 8)
  %486 = zext i32 %485 to i64
  %487 = mul i64 %486, 32
  %488 = add i64 %487, 16
  %489 = extractvalue { ptr, i32, i32, i32 } %460, 0
  %490 = load ptr, ptr %489, align 8
  %491 = getelementptr inbounds i8, ptr %490, i32 -16
  %492 = call ptr @realloc(ptr %491, i64 %488)
  %493 = getelementptr inbounds i8, ptr %492, i32 16
  store ptr %493, ptr %489, align 8
  %494 = insertvalue { ptr, i32, i32, i32 } %460, i32 %485, 3
  br label %495

495:                                              ; preds = %480, %481
  %496 = phi { ptr, i32, i32, i32 } [ %494, %481 ], [ %460, %480 ]
  br label %497

497:                                              ; preds = %495
  br label %498

498:                                              ; preds = %463, %497
  %499 = phi { ptr, i32, i32, i32 } [ %496, %497 ], [ %476, %463 ]
  br label %500

500:                                              ; preds = %498
  %501 = extractvalue { ptr, i32, i32, i32 } %499, 0
  %502 = load ptr, ptr %501, align 8
  %503 = extractvalue { ptr, i32, i32, i32 } %499, 2
  %504 = zext i32 %503 to i64
  %505 = mul i64 %504, 32
  %506 = getelementptr inbounds i8, ptr %502, i64 %505
  store i252 %459, ptr %506, align 16
  %507 = extractvalue { ptr, i32, i32, i32 } %499, 2
  %508 = add i32 %507, 1
  %509 = insertvalue { ptr, i32, i32, i32 } %499, i32 %508, 2
  %510 = getelementptr inbounds i8, ptr %502, i32 -12
  store i32 %508, ptr %510, align 4
  %511 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %454, 0
  %512 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f98"(i64 %430, i64 %449, { { ptr, i32, i32, i32 } } %511, { ptr, i32, i32, i32 } %509)
  %513 = extractvalue { i64, i64, { i64, [24 x i8] } } %512, 0
  %514 = extractvalue { i64, i64, { i64, [24 x i8] } } %512, 1
  %515 = extractvalue { i64, i64, { i64, [24 x i8] } } %512, 2
  %516 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %513, 0
  %517 = insertvalue { i64, i64, { i64, [24 x i8] } } %516, i64 %514, 1
  %518 = insertvalue { i64, i64, { i64, [24 x i8] } } %517, { i64, [24 x i8] } %515, 2
  ret { i64, i64, { i64, [24 x i8] } } %518

519:                                              ; preds = %417
  %520 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %521 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %520, 1
  call void @"drop$43"({ { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %118)
  %522 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %521, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %522, ptr %8, align 8
  %523 = load { i64, [24 x i8] }, ptr %8, align 8
  %524 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %430, 0
  %525 = insertvalue { i64, i64, { i64, [24 x i8] } } %524, i64 %431, 1
  %526 = insertvalue { i64, i64, { i64, [24 x i8] } } %525, { i64, [24 x i8] } %523, 2
  ret { i64, i64, { i64, [24 x i8] } } %526

527:                                              ; preds = %82
  call void @puts(ptr @assert_msg_160)
  call void @abort()
  unreachable

528:                                              ; preds = %442
  call void @puts(ptr @assert_msg_161)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f95(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f95"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f95(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f95(i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, i32, i8, i8, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = load { i128, [80 x i8] }, ptr %2, align 16
  store { i128, [80 x i8] } %14, ptr %5, align 16
  %15 = load i3, ptr %5, align 1
  switch i3 %15, label %16 [
    i3 0, label %18
    i3 1, label %125
    i3 2, label %300
    i3 3, label %475
    i3 -4, label %597
    i3 -3, label %719
    i3 -2, label %775
  ]

16:                                               ; preds = %4
  br i1 false, label %17, label %1150

17:                                               ; preds = %16
  unreachable

18:                                               ; preds = %4
  %19 = load { i3, i252 }, ptr %5, align 16
  %20 = extractvalue { i3, i252 } %19, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 5350
  %25 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %24)
  %26 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %42

28:                                               ; preds = %18
  %29 = shl i32 %26, 1
  %30 = call i32 @llvm.umin.i32(i32 %29, i32 1024)
  %31 = add i32 %30, %26
  %32 = call i32 @llvm.umax.i32(i32 %31, i32 8)
  %33 = zext i32 %32 to i64
  %34 = mul i64 %33, 32
  %35 = add i64 %34, 16
  %36 = call ptr @realloc(ptr null, i64 %35)
  store i32 1, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %36, i32 4
  store i32 0, ptr %37, align 4
  %38 = getelementptr inbounds i8, ptr %36, i32 16
  %39 = call ptr @realloc(ptr null, i64 8)
  store ptr %38, ptr %39, align 8
  %40 = insertvalue { ptr, i32, i32, i32 } %3, ptr %39, 0
  %41 = insertvalue { ptr, i32, i32, i32 } %40, i32 %32, 3
  br label %63

42:                                               ; preds = %18
  %43 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %44 = icmp ult i32 %43, %26
  br i1 %44, label %45, label %46

45:                                               ; preds = %42
  br label %60

46:                                               ; preds = %42
  %47 = shl i32 %26, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %26
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %55, i32 -16
  %57 = call ptr @realloc(ptr %56, i64 %53)
  %58 = getelementptr inbounds i8, ptr %57, i32 16
  store ptr %58, ptr %54, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } %3, i32 %50, 3
  br label %60

60:                                               ; preds = %45, %46
  %61 = phi { ptr, i32, i32, i32 } [ %59, %46 ], [ %3, %45 ]
  br label %62

62:                                               ; preds = %60
  br label %63

63:                                               ; preds = %28, %62
  %64 = phi { ptr, i32, i32, i32 } [ %61, %62 ], [ %41, %28 ]
  br label %65

65:                                               ; preds = %63
  %66 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %67 = load ptr, ptr %66, align 8
  %68 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = getelementptr inbounds i8, ptr %67, i64 %70
  store i252 0, ptr %71, align 16
  %72 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %73 = add i32 %72, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %64, i32 %73, 2
  %75 = getelementptr inbounds i8, ptr %67, i32 -12
  store i32 %73, ptr %75, align 4
  %76 = extractvalue { ptr, i32, i32, i32 } %64, 3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %78, label %92

78:                                               ; preds = %65
  %79 = shl i32 %76, 1
  %80 = call i32 @llvm.umin.i32(i32 %79, i32 1024)
  %81 = add i32 %80, %76
  %82 = call i32 @llvm.umax.i32(i32 %81, i32 8)
  %83 = zext i32 %82 to i64
  %84 = mul i64 %83, 32
  %85 = add i64 %84, 16
  %86 = call ptr @realloc(ptr null, i64 %85)
  store i32 1, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %86, i32 4
  store i32 0, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %86, i32 16
  %89 = call ptr @realloc(ptr null, i64 8)
  store ptr %88, ptr %89, align 8
  %90 = insertvalue { ptr, i32, i32, i32 } %74, ptr %89, 0
  %91 = insertvalue { ptr, i32, i32, i32 } %90, i32 %82, 3
  br label %112

92:                                               ; preds = %65
  %93 = icmp ult i32 %73, %76
  br i1 %93, label %94, label %95

94:                                               ; preds = %92
  br label %109

95:                                               ; preds = %92
  %96 = shl i32 %76, 1
  %97 = call i32 @llvm.umin.i32(i32 %96, i32 1024)
  %98 = add i32 %97, %76
  %99 = call i32 @llvm.umax.i32(i32 %98, i32 8)
  %100 = zext i32 %99 to i64
  %101 = mul i64 %100, 32
  %102 = add i64 %101, 16
  %103 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %104 = load ptr, ptr %103, align 8
  %105 = getelementptr inbounds i8, ptr %104, i32 -16
  %106 = call ptr @realloc(ptr %105, i64 %102)
  %107 = getelementptr inbounds i8, ptr %106, i32 16
  store ptr %107, ptr %103, align 8
  %108 = insertvalue { ptr, i32, i32, i32 } %74, i32 %99, 3
  br label %109

109:                                              ; preds = %94, %95
  %110 = phi { ptr, i32, i32, i32 } [ %108, %95 ], [ %74, %94 ]
  br label %111

111:                                              ; preds = %109
  br label %112

112:                                              ; preds = %78, %111
  %113 = phi { ptr, i32, i32, i32 } [ %110, %111 ], [ %91, %78 ]
  br label %114

114:                                              ; preds = %112
  %115 = extractvalue { ptr, i32, i32, i32 } %113, 0
  %116 = load ptr, ptr %115, align 8
  %117 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %118 = zext i32 %117 to i64
  %119 = mul i64 %118, 32
  %120 = getelementptr inbounds i8, ptr %116, i64 %119
  store i252 %20, ptr %120, align 16
  %121 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %122 = add i32 %121, 1
  %123 = insertvalue { ptr, i32, i32, i32 } %113, i32 %122, 2
  %124 = getelementptr inbounds i8, ptr %116, i32 -12
  store i32 %122, ptr %124, align 4
  br label %1062

125:                                              ; preds = %4
  %126 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %5, align 16
  %127 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %126, 1
  %128 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %127)
  %129 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %128, 0
  %130 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %128, 1
  %131 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %130, 1
  %132 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %130, 2
  call void @"drop$31"({ { ptr, i32, i32, i32 } } %132)
  %133 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %131)
  %134 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %133, 0
  %135 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %133, 1
  %136 = extractvalue { { ptr, i32, i32, i32 } } %135, 0
  %137 = extractvalue { ptr, i32, i32, i32 } %136, 1
  %138 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %139 = sub i32 %138, %137
  call void @"drop$27"({ ptr, i32, i32, i32 } %136)
  %140 = zext i32 %139 to i252
  %141 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %142 = icmp eq i32 %141, 0
  br i1 %142, label %143, label %157

143:                                              ; preds = %125
  %144 = shl i32 %141, 1
  %145 = call i32 @llvm.umin.i32(i32 %144, i32 1024)
  %146 = add i32 %145, %141
  %147 = call i32 @llvm.umax.i32(i32 %146, i32 8)
  %148 = zext i32 %147 to i64
  %149 = mul i64 %148, 32
  %150 = add i64 %149, 16
  %151 = call ptr @realloc(ptr null, i64 %150)
  store i32 1, ptr %151, align 4
  %152 = getelementptr inbounds i8, ptr %151, i32 4
  store i32 0, ptr %152, align 4
  %153 = getelementptr inbounds i8, ptr %151, i32 16
  %154 = call ptr @realloc(ptr null, i64 8)
  store ptr %153, ptr %154, align 8
  %155 = insertvalue { ptr, i32, i32, i32 } %3, ptr %154, 0
  %156 = insertvalue { ptr, i32, i32, i32 } %155, i32 %147, 3
  br label %178

157:                                              ; preds = %125
  %158 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %159 = icmp ult i32 %158, %141
  br i1 %159, label %160, label %161

160:                                              ; preds = %157
  br label %175

161:                                              ; preds = %157
  %162 = shl i32 %141, 1
  %163 = call i32 @llvm.umin.i32(i32 %162, i32 1024)
  %164 = add i32 %163, %141
  %165 = call i32 @llvm.umax.i32(i32 %164, i32 8)
  %166 = zext i32 %165 to i64
  %167 = mul i64 %166, 32
  %168 = add i64 %167, 16
  %169 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %170 = load ptr, ptr %169, align 8
  %171 = getelementptr inbounds i8, ptr %170, i32 -16
  %172 = call ptr @realloc(ptr %171, i64 %168)
  %173 = getelementptr inbounds i8, ptr %172, i32 16
  store ptr %173, ptr %169, align 8
  %174 = insertvalue { ptr, i32, i32, i32 } %3, i32 %165, 3
  br label %175

175:                                              ; preds = %160, %161
  %176 = phi { ptr, i32, i32, i32 } [ %174, %161 ], [ %3, %160 ]
  br label %177

177:                                              ; preds = %175
  br label %178

178:                                              ; preds = %143, %177
  %179 = phi { ptr, i32, i32, i32 } [ %176, %177 ], [ %156, %143 ]
  br label %180

180:                                              ; preds = %178
  %181 = extractvalue { ptr, i32, i32, i32 } %179, 0
  %182 = load ptr, ptr %181, align 8
  %183 = extractvalue { ptr, i32, i32, i32 } %179, 2
  %184 = zext i32 %183 to i64
  %185 = mul i64 %184, 32
  %186 = getelementptr inbounds i8, ptr %182, i64 %185
  store i252 1, ptr %186, align 16
  %187 = extractvalue { ptr, i32, i32, i32 } %179, 2
  %188 = add i32 %187, 1
  %189 = insertvalue { ptr, i32, i32, i32 } %179, i32 %188, 2
  %190 = getelementptr inbounds i8, ptr %182, i32 -12
  store i32 %188, ptr %190, align 4
  %191 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %129)
  %192 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %191, 0
  %193 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %191, 1
  %194 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %193, 0
  %195 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %193, 1
  %196 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %193, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %195)
  call void @"drop$31"({ { ptr, i32, i32, i32 } } %196)
  %197 = extractvalue { ptr, i32, i32, i32 } %179, 3
  %198 = icmp eq i32 %197, 0
  br i1 %198, label %199, label %213

199:                                              ; preds = %180
  %200 = shl i32 %197, 1
  %201 = call i32 @llvm.umin.i32(i32 %200, i32 1024)
  %202 = add i32 %201, %197
  %203 = call i32 @llvm.umax.i32(i32 %202, i32 8)
  %204 = zext i32 %203 to i64
  %205 = mul i64 %204, 32
  %206 = add i64 %205, 16
  %207 = call ptr @realloc(ptr null, i64 %206)
  store i32 1, ptr %207, align 4
  %208 = getelementptr inbounds i8, ptr %207, i32 4
  store i32 0, ptr %208, align 4
  %209 = getelementptr inbounds i8, ptr %207, i32 16
  %210 = call ptr @realloc(ptr null, i64 8)
  store ptr %209, ptr %210, align 8
  %211 = insertvalue { ptr, i32, i32, i32 } %189, ptr %210, 0
  %212 = insertvalue { ptr, i32, i32, i32 } %211, i32 %203, 3
  br label %233

213:                                              ; preds = %180
  %214 = icmp ult i32 %188, %197
  br i1 %214, label %215, label %216

215:                                              ; preds = %213
  br label %230

216:                                              ; preds = %213
  %217 = shl i32 %197, 1
  %218 = call i32 @llvm.umin.i32(i32 %217, i32 1024)
  %219 = add i32 %218, %197
  %220 = call i32 @llvm.umax.i32(i32 %219, i32 8)
  %221 = zext i32 %220 to i64
  %222 = mul i64 %221, 32
  %223 = add i64 %222, 16
  %224 = extractvalue { ptr, i32, i32, i32 } %179, 0
  %225 = load ptr, ptr %224, align 8
  %226 = getelementptr inbounds i8, ptr %225, i32 -16
  %227 = call ptr @realloc(ptr %226, i64 %223)
  %228 = getelementptr inbounds i8, ptr %227, i32 16
  store ptr %228, ptr %224, align 8
  %229 = insertvalue { ptr, i32, i32, i32 } %189, i32 %220, 3
  br label %230

230:                                              ; preds = %215, %216
  %231 = phi { ptr, i32, i32, i32 } [ %229, %216 ], [ %189, %215 ]
  br label %232

232:                                              ; preds = %230
  br label %233

233:                                              ; preds = %199, %232
  %234 = phi { ptr, i32, i32, i32 } [ %231, %232 ], [ %212, %199 ]
  br label %235

235:                                              ; preds = %233
  %236 = extractvalue { ptr, i32, i32, i32 } %234, 0
  %237 = load ptr, ptr %236, align 8
  %238 = extractvalue { ptr, i32, i32, i32 } %234, 2
  %239 = zext i32 %238 to i64
  %240 = mul i64 %239, 32
  %241 = getelementptr inbounds i8, ptr %237, i64 %240
  store i252 %194, ptr %241, align 16
  %242 = extractvalue { ptr, i32, i32, i32 } %234, 2
  %243 = add i32 %242, 1
  %244 = insertvalue { ptr, i32, i32, i32 } %234, i32 %243, 2
  %245 = getelementptr inbounds i8, ptr %237, i32 -12
  store i32 %243, ptr %245, align 4
  %246 = extractvalue { ptr, i32, i32, i32 } %234, 3
  %247 = icmp eq i32 %246, 0
  br i1 %247, label %248, label %262

248:                                              ; preds = %235
  %249 = shl i32 %246, 1
  %250 = call i32 @llvm.umin.i32(i32 %249, i32 1024)
  %251 = add i32 %250, %246
  %252 = call i32 @llvm.umax.i32(i32 %251, i32 8)
  %253 = zext i32 %252 to i64
  %254 = mul i64 %253, 32
  %255 = add i64 %254, 16
  %256 = call ptr @realloc(ptr null, i64 %255)
  store i32 1, ptr %256, align 4
  %257 = getelementptr inbounds i8, ptr %256, i32 4
  store i32 0, ptr %257, align 4
  %258 = getelementptr inbounds i8, ptr %256, i32 16
  %259 = call ptr @realloc(ptr null, i64 8)
  store ptr %258, ptr %259, align 8
  %260 = insertvalue { ptr, i32, i32, i32 } %244, ptr %259, 0
  %261 = insertvalue { ptr, i32, i32, i32 } %260, i32 %252, 3
  br label %282

262:                                              ; preds = %235
  %263 = icmp ult i32 %243, %246
  br i1 %263, label %264, label %265

264:                                              ; preds = %262
  br label %279

265:                                              ; preds = %262
  %266 = shl i32 %246, 1
  %267 = call i32 @llvm.umin.i32(i32 %266, i32 1024)
  %268 = add i32 %267, %246
  %269 = call i32 @llvm.umax.i32(i32 %268, i32 8)
  %270 = zext i32 %269 to i64
  %271 = mul i64 %270, 32
  %272 = add i64 %271, 16
  %273 = extractvalue { ptr, i32, i32, i32 } %234, 0
  %274 = load ptr, ptr %273, align 8
  %275 = getelementptr inbounds i8, ptr %274, i32 -16
  %276 = call ptr @realloc(ptr %275, i64 %272)
  %277 = getelementptr inbounds i8, ptr %276, i32 16
  store ptr %277, ptr %273, align 8
  %278 = insertvalue { ptr, i32, i32, i32 } %244, i32 %269, 3
  br label %279

279:                                              ; preds = %264, %265
  %280 = phi { ptr, i32, i32, i32 } [ %278, %265 ], [ %244, %264 ]
  br label %281

281:                                              ; preds = %279
  br label %282

282:                                              ; preds = %248, %281
  %283 = phi { ptr, i32, i32, i32 } [ %280, %281 ], [ %261, %248 ]
  br label %284

284:                                              ; preds = %282
  %285 = extractvalue { ptr, i32, i32, i32 } %283, 0
  %286 = load ptr, ptr %285, align 8
  %287 = extractvalue { ptr, i32, i32, i32 } %283, 2
  %288 = zext i32 %287 to i64
  %289 = mul i64 %288, 32
  %290 = getelementptr inbounds i8, ptr %286, i64 %289
  store i252 %140, ptr %290, align 16
  %291 = extractvalue { ptr, i32, i32, i32 } %283, 2
  %292 = add i32 %291, 1
  %293 = insertvalue { ptr, i32, i32, i32 } %283, i32 %292, 2
  %294 = getelementptr inbounds i8, ptr %286, i32 -12
  store i32 %292, ptr %294, align 4
  %295 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %134, { ptr, i32, i32, i32 } %293)
  %296 = extractvalue { i64, i64, { i64, [24 x i8] } } %295, 0
  %297 = extractvalue { i64, i64, { i64, [24 x i8] } } %295, 1
  %298 = extractvalue { i64, i64, { i64, [24 x i8] } } %295, 2
  store { i64, [24 x i8] } %298, ptr %12, align 8
  %299 = load i1, ptr %12, align 1
  switch i1 %299, label %892 [
    i1 false, label %894
    i1 true, label %968
  ]

300:                                              ; preds = %4
  %301 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %5, align 16
  %302 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %301, 1
  %303 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %302)
  %304 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %303, 0
  %305 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %303, 1
  %306 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %305, 1
  %307 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %305, 2
  call void @"drop$33"({ { ptr, i32, i32, i32 } } %307)
  %308 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$28"({ { ptr, i32, i32, i32 } } %306)
  %309 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %308, 0
  %310 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %308, 1
  %311 = extractvalue { { ptr, i32, i32, i32 } } %310, 0
  %312 = extractvalue { ptr, i32, i32, i32 } %311, 1
  %313 = extractvalue { ptr, i32, i32, i32 } %311, 2
  %314 = sub i32 %313, %312
  call void @"drop$27"({ ptr, i32, i32, i32 } %311)
  %315 = zext i32 %314 to i252
  %316 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %317 = icmp eq i32 %316, 0
  br i1 %317, label %318, label %332

318:                                              ; preds = %300
  %319 = shl i32 %316, 1
  %320 = call i32 @llvm.umin.i32(i32 %319, i32 1024)
  %321 = add i32 %320, %316
  %322 = call i32 @llvm.umax.i32(i32 %321, i32 8)
  %323 = zext i32 %322 to i64
  %324 = mul i64 %323, 32
  %325 = add i64 %324, 16
  %326 = call ptr @realloc(ptr null, i64 %325)
  store i32 1, ptr %326, align 4
  %327 = getelementptr inbounds i8, ptr %326, i32 4
  store i32 0, ptr %327, align 4
  %328 = getelementptr inbounds i8, ptr %326, i32 16
  %329 = call ptr @realloc(ptr null, i64 8)
  store ptr %328, ptr %329, align 8
  %330 = insertvalue { ptr, i32, i32, i32 } %3, ptr %329, 0
  %331 = insertvalue { ptr, i32, i32, i32 } %330, i32 %322, 3
  br label %353

332:                                              ; preds = %300
  %333 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %334 = icmp ult i32 %333, %316
  br i1 %334, label %335, label %336

335:                                              ; preds = %332
  br label %350

336:                                              ; preds = %332
  %337 = shl i32 %316, 1
  %338 = call i32 @llvm.umin.i32(i32 %337, i32 1024)
  %339 = add i32 %338, %316
  %340 = call i32 @llvm.umax.i32(i32 %339, i32 8)
  %341 = zext i32 %340 to i64
  %342 = mul i64 %341, 32
  %343 = add i64 %342, 16
  %344 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %345 = load ptr, ptr %344, align 8
  %346 = getelementptr inbounds i8, ptr %345, i32 -16
  %347 = call ptr @realloc(ptr %346, i64 %343)
  %348 = getelementptr inbounds i8, ptr %347, i32 16
  store ptr %348, ptr %344, align 8
  %349 = insertvalue { ptr, i32, i32, i32 } %3, i32 %340, 3
  br label %350

350:                                              ; preds = %335, %336
  %351 = phi { ptr, i32, i32, i32 } [ %349, %336 ], [ %3, %335 ]
  br label %352

352:                                              ; preds = %350
  br label %353

353:                                              ; preds = %318, %352
  %354 = phi { ptr, i32, i32, i32 } [ %351, %352 ], [ %331, %318 ]
  br label %355

355:                                              ; preds = %353
  %356 = extractvalue { ptr, i32, i32, i32 } %354, 0
  %357 = load ptr, ptr %356, align 8
  %358 = extractvalue { ptr, i32, i32, i32 } %354, 2
  %359 = zext i32 %358 to i64
  %360 = mul i64 %359, 32
  %361 = getelementptr inbounds i8, ptr %357, i64 %360
  store i252 2, ptr %361, align 16
  %362 = extractvalue { ptr, i32, i32, i32 } %354, 2
  %363 = add i32 %362, 1
  %364 = insertvalue { ptr, i32, i32, i32 } %354, i32 %363, 2
  %365 = getelementptr inbounds i8, ptr %357, i32 -12
  store i32 %363, ptr %365, align 4
  %366 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %304)
  %367 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %366, 0
  %368 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %366, 1
  %369 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %368, 0
  %370 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %368, 1
  %371 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %368, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %370)
  call void @"drop$33"({ { ptr, i32, i32, i32 } } %371)
  %372 = extractvalue { ptr, i32, i32, i32 } %354, 3
  %373 = icmp eq i32 %372, 0
  br i1 %373, label %374, label %388

374:                                              ; preds = %355
  %375 = shl i32 %372, 1
  %376 = call i32 @llvm.umin.i32(i32 %375, i32 1024)
  %377 = add i32 %376, %372
  %378 = call i32 @llvm.umax.i32(i32 %377, i32 8)
  %379 = zext i32 %378 to i64
  %380 = mul i64 %379, 32
  %381 = add i64 %380, 16
  %382 = call ptr @realloc(ptr null, i64 %381)
  store i32 1, ptr %382, align 4
  %383 = getelementptr inbounds i8, ptr %382, i32 4
  store i32 0, ptr %383, align 4
  %384 = getelementptr inbounds i8, ptr %382, i32 16
  %385 = call ptr @realloc(ptr null, i64 8)
  store ptr %384, ptr %385, align 8
  %386 = insertvalue { ptr, i32, i32, i32 } %364, ptr %385, 0
  %387 = insertvalue { ptr, i32, i32, i32 } %386, i32 %378, 3
  br label %408

388:                                              ; preds = %355
  %389 = icmp ult i32 %363, %372
  br i1 %389, label %390, label %391

390:                                              ; preds = %388
  br label %405

391:                                              ; preds = %388
  %392 = shl i32 %372, 1
  %393 = call i32 @llvm.umin.i32(i32 %392, i32 1024)
  %394 = add i32 %393, %372
  %395 = call i32 @llvm.umax.i32(i32 %394, i32 8)
  %396 = zext i32 %395 to i64
  %397 = mul i64 %396, 32
  %398 = add i64 %397, 16
  %399 = extractvalue { ptr, i32, i32, i32 } %354, 0
  %400 = load ptr, ptr %399, align 8
  %401 = getelementptr inbounds i8, ptr %400, i32 -16
  %402 = call ptr @realloc(ptr %401, i64 %398)
  %403 = getelementptr inbounds i8, ptr %402, i32 16
  store ptr %403, ptr %399, align 8
  %404 = insertvalue { ptr, i32, i32, i32 } %364, i32 %395, 3
  br label %405

405:                                              ; preds = %390, %391
  %406 = phi { ptr, i32, i32, i32 } [ %404, %391 ], [ %364, %390 ]
  br label %407

407:                                              ; preds = %405
  br label %408

408:                                              ; preds = %374, %407
  %409 = phi { ptr, i32, i32, i32 } [ %406, %407 ], [ %387, %374 ]
  br label %410

410:                                              ; preds = %408
  %411 = extractvalue { ptr, i32, i32, i32 } %409, 0
  %412 = load ptr, ptr %411, align 8
  %413 = extractvalue { ptr, i32, i32, i32 } %409, 2
  %414 = zext i32 %413 to i64
  %415 = mul i64 %414, 32
  %416 = getelementptr inbounds i8, ptr %412, i64 %415
  store i252 %369, ptr %416, align 16
  %417 = extractvalue { ptr, i32, i32, i32 } %409, 2
  %418 = add i32 %417, 1
  %419 = insertvalue { ptr, i32, i32, i32 } %409, i32 %418, 2
  %420 = getelementptr inbounds i8, ptr %412, i32 -12
  store i32 %418, ptr %420, align 4
  %421 = extractvalue { ptr, i32, i32, i32 } %409, 3
  %422 = icmp eq i32 %421, 0
  br i1 %422, label %423, label %437

423:                                              ; preds = %410
  %424 = shl i32 %421, 1
  %425 = call i32 @llvm.umin.i32(i32 %424, i32 1024)
  %426 = add i32 %425, %421
  %427 = call i32 @llvm.umax.i32(i32 %426, i32 8)
  %428 = zext i32 %427 to i64
  %429 = mul i64 %428, 32
  %430 = add i64 %429, 16
  %431 = call ptr @realloc(ptr null, i64 %430)
  store i32 1, ptr %431, align 4
  %432 = getelementptr inbounds i8, ptr %431, i32 4
  store i32 0, ptr %432, align 4
  %433 = getelementptr inbounds i8, ptr %431, i32 16
  %434 = call ptr @realloc(ptr null, i64 8)
  store ptr %433, ptr %434, align 8
  %435 = insertvalue { ptr, i32, i32, i32 } %419, ptr %434, 0
  %436 = insertvalue { ptr, i32, i32, i32 } %435, i32 %427, 3
  br label %457

437:                                              ; preds = %410
  %438 = icmp ult i32 %418, %421
  br i1 %438, label %439, label %440

439:                                              ; preds = %437
  br label %454

440:                                              ; preds = %437
  %441 = shl i32 %421, 1
  %442 = call i32 @llvm.umin.i32(i32 %441, i32 1024)
  %443 = add i32 %442, %421
  %444 = call i32 @llvm.umax.i32(i32 %443, i32 8)
  %445 = zext i32 %444 to i64
  %446 = mul i64 %445, 32
  %447 = add i64 %446, 16
  %448 = extractvalue { ptr, i32, i32, i32 } %409, 0
  %449 = load ptr, ptr %448, align 8
  %450 = getelementptr inbounds i8, ptr %449, i32 -16
  %451 = call ptr @realloc(ptr %450, i64 %447)
  %452 = getelementptr inbounds i8, ptr %451, i32 16
  store ptr %452, ptr %448, align 8
  %453 = insertvalue { ptr, i32, i32, i32 } %419, i32 %444, 3
  br label %454

454:                                              ; preds = %439, %440
  %455 = phi { ptr, i32, i32, i32 } [ %453, %440 ], [ %419, %439 ]
  br label %456

456:                                              ; preds = %454
  br label %457

457:                                              ; preds = %423, %456
  %458 = phi { ptr, i32, i32, i32 } [ %455, %456 ], [ %436, %423 ]
  br label %459

459:                                              ; preds = %457
  %460 = extractvalue { ptr, i32, i32, i32 } %458, 0
  %461 = load ptr, ptr %460, align 8
  %462 = extractvalue { ptr, i32, i32, i32 } %458, 2
  %463 = zext i32 %462 to i64
  %464 = mul i64 %463, 32
  %465 = getelementptr inbounds i8, ptr %461, i64 %464
  store i252 %315, ptr %465, align 16
  %466 = extractvalue { ptr, i32, i32, i32 } %458, 2
  %467 = add i32 %466, 1
  %468 = insertvalue { ptr, i32, i32, i32 } %458, i32 %467, 2
  %469 = getelementptr inbounds i8, ptr %461, i32 -12
  store i32 %467, ptr %469, align 4
  %470 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %309, { ptr, i32, i32, i32 } %468)
  %471 = extractvalue { i64, i64, { i64, [24 x i8] } } %470, 0
  %472 = extractvalue { i64, i64, { i64, [24 x i8] } } %470, 1
  %473 = extractvalue { i64, i64, { i64, [24 x i8] } } %470, 2
  store { i64, [24 x i8] } %473, ptr %10, align 8
  %474 = load i1, ptr %10, align 1
  switch i1 %474, label %976 [
    i1 false, label %978
    i1 true, label %1054
  ]

475:                                              ; preds = %4
  %476 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %477 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %476, 1
  %478 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %479 = call ptr %478()
  %480 = load i64, ptr %479, align 8
  %481 = mul i64 %480, 3160
  %482 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %481)
  %483 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$12"({ { ptr, i32, i32, i32 } } %477)
  %484 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %483, 0
  %485 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %483, 1
  %486 = extractvalue { { ptr, i32, i32, i32 } } %485, 0
  %487 = extractvalue { ptr, i32, i32, i32 } %486, 1
  %488 = extractvalue { ptr, i32, i32, i32 } %486, 2
  %489 = sub i32 %488, %487
  call void @"drop$3"({ ptr, i32, i32, i32 } %486)
  %490 = zext i32 %489 to i252
  %491 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %492 = icmp eq i32 %491, 0
  br i1 %492, label %493, label %507

493:                                              ; preds = %475
  %494 = shl i32 %491, 1
  %495 = call i32 @llvm.umin.i32(i32 %494, i32 1024)
  %496 = add i32 %495, %491
  %497 = call i32 @llvm.umax.i32(i32 %496, i32 8)
  %498 = zext i32 %497 to i64
  %499 = mul i64 %498, 32
  %500 = add i64 %499, 16
  %501 = call ptr @realloc(ptr null, i64 %500)
  store i32 1, ptr %501, align 4
  %502 = getelementptr inbounds i8, ptr %501, i32 4
  store i32 0, ptr %502, align 4
  %503 = getelementptr inbounds i8, ptr %501, i32 16
  %504 = call ptr @realloc(ptr null, i64 8)
  store ptr %503, ptr %504, align 8
  %505 = insertvalue { ptr, i32, i32, i32 } %3, ptr %504, 0
  %506 = insertvalue { ptr, i32, i32, i32 } %505, i32 %497, 3
  br label %528

507:                                              ; preds = %475
  %508 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %509 = icmp ult i32 %508, %491
  br i1 %509, label %510, label %511

510:                                              ; preds = %507
  br label %525

511:                                              ; preds = %507
  %512 = shl i32 %491, 1
  %513 = call i32 @llvm.umin.i32(i32 %512, i32 1024)
  %514 = add i32 %513, %491
  %515 = call i32 @llvm.umax.i32(i32 %514, i32 8)
  %516 = zext i32 %515 to i64
  %517 = mul i64 %516, 32
  %518 = add i64 %517, 16
  %519 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %520 = load ptr, ptr %519, align 8
  %521 = getelementptr inbounds i8, ptr %520, i32 -16
  %522 = call ptr @realloc(ptr %521, i64 %518)
  %523 = getelementptr inbounds i8, ptr %522, i32 16
  store ptr %523, ptr %519, align 8
  %524 = insertvalue { ptr, i32, i32, i32 } %3, i32 %515, 3
  br label %525

525:                                              ; preds = %510, %511
  %526 = phi { ptr, i32, i32, i32 } [ %524, %511 ], [ %3, %510 ]
  br label %527

527:                                              ; preds = %525
  br label %528

528:                                              ; preds = %493, %527
  %529 = phi { ptr, i32, i32, i32 } [ %526, %527 ], [ %506, %493 ]
  br label %530

530:                                              ; preds = %528
  %531 = extractvalue { ptr, i32, i32, i32 } %529, 0
  %532 = load ptr, ptr %531, align 8
  %533 = extractvalue { ptr, i32, i32, i32 } %529, 2
  %534 = zext i32 %533 to i64
  %535 = mul i64 %534, 32
  %536 = getelementptr inbounds i8, ptr %532, i64 %535
  store i252 3, ptr %536, align 16
  %537 = extractvalue { ptr, i32, i32, i32 } %529, 2
  %538 = add i32 %537, 1
  %539 = insertvalue { ptr, i32, i32, i32 } %529, i32 %538, 2
  %540 = getelementptr inbounds i8, ptr %532, i32 -12
  store i32 %538, ptr %540, align 4
  %541 = extractvalue { ptr, i32, i32, i32 } %529, 3
  %542 = icmp eq i32 %541, 0
  br i1 %542, label %543, label %557

543:                                              ; preds = %530
  %544 = shl i32 %541, 1
  %545 = call i32 @llvm.umin.i32(i32 %544, i32 1024)
  %546 = add i32 %545, %541
  %547 = call i32 @llvm.umax.i32(i32 %546, i32 8)
  %548 = zext i32 %547 to i64
  %549 = mul i64 %548, 32
  %550 = add i64 %549, 16
  %551 = call ptr @realloc(ptr null, i64 %550)
  store i32 1, ptr %551, align 4
  %552 = getelementptr inbounds i8, ptr %551, i32 4
  store i32 0, ptr %552, align 4
  %553 = getelementptr inbounds i8, ptr %551, i32 16
  %554 = call ptr @realloc(ptr null, i64 8)
  store ptr %553, ptr %554, align 8
  %555 = insertvalue { ptr, i32, i32, i32 } %539, ptr %554, 0
  %556 = insertvalue { ptr, i32, i32, i32 } %555, i32 %547, 3
  br label %577

557:                                              ; preds = %530
  %558 = icmp ult i32 %538, %541
  br i1 %558, label %559, label %560

559:                                              ; preds = %557
  br label %574

560:                                              ; preds = %557
  %561 = shl i32 %541, 1
  %562 = call i32 @llvm.umin.i32(i32 %561, i32 1024)
  %563 = add i32 %562, %541
  %564 = call i32 @llvm.umax.i32(i32 %563, i32 8)
  %565 = zext i32 %564 to i64
  %566 = mul i64 %565, 32
  %567 = add i64 %566, 16
  %568 = extractvalue { ptr, i32, i32, i32 } %529, 0
  %569 = load ptr, ptr %568, align 8
  %570 = getelementptr inbounds i8, ptr %569, i32 -16
  %571 = call ptr @realloc(ptr %570, i64 %567)
  %572 = getelementptr inbounds i8, ptr %571, i32 16
  store ptr %572, ptr %568, align 8
  %573 = insertvalue { ptr, i32, i32, i32 } %539, i32 %564, 3
  br label %574

574:                                              ; preds = %559, %560
  %575 = phi { ptr, i32, i32, i32 } [ %573, %560 ], [ %539, %559 ]
  br label %576

576:                                              ; preds = %574
  br label %577

577:                                              ; preds = %543, %576
  %578 = phi { ptr, i32, i32, i32 } [ %575, %576 ], [ %556, %543 ]
  br label %579

579:                                              ; preds = %577
  %580 = extractvalue { ptr, i32, i32, i32 } %578, 0
  %581 = load ptr, ptr %580, align 8
  %582 = extractvalue { ptr, i32, i32, i32 } %578, 2
  %583 = zext i32 %582 to i64
  %584 = mul i64 %583, 32
  %585 = getelementptr inbounds i8, ptr %581, i64 %584
  store i252 %490, ptr %585, align 16
  %586 = extractvalue { ptr, i32, i32, i32 } %578, 2
  %587 = add i32 %586, 1
  %588 = insertvalue { ptr, i32, i32, i32 } %578, i32 %587, 2
  %589 = getelementptr inbounds i8, ptr %581, i32 -12
  store i32 %587, ptr %589, align 4
  %590 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f100"(i64 %0, i64 %482, { { ptr, i32, i32, i32 } } %484, { ptr, i32, i32, i32 } %588)
  %591 = extractvalue { i64, i64, { i64, [24 x i8] } } %590, 0
  %592 = extractvalue { i64, i64, { i64, [24 x i8] } } %590, 1
  %593 = extractvalue { i64, i64, { i64, [24 x i8] } } %590, 2
  %594 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %591, 0
  %595 = insertvalue { i64, i64, { i64, [24 x i8] } } %594, i64 %592, 1
  %596 = insertvalue { i64, i64, { i64, [24 x i8] } } %595, { i64, [24 x i8] } %593, 2
  ret { i64, i64, { i64, [24 x i8] } } %596

597:                                              ; preds = %4
  %598 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %599 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %598, 1
  %600 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %601 = call ptr %600()
  %602 = load i64, ptr %601, align 8
  %603 = mul i64 %602, 3160
  %604 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %603)
  %605 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$12"({ { ptr, i32, i32, i32 } } %599)
  %606 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %605, 0
  %607 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %605, 1
  %608 = extractvalue { { ptr, i32, i32, i32 } } %607, 0
  %609 = extractvalue { ptr, i32, i32, i32 } %608, 1
  %610 = extractvalue { ptr, i32, i32, i32 } %608, 2
  %611 = sub i32 %610, %609
  call void @"drop$3"({ ptr, i32, i32, i32 } %608)
  %612 = zext i32 %611 to i252
  %613 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %614 = icmp eq i32 %613, 0
  br i1 %614, label %615, label %629

615:                                              ; preds = %597
  %616 = shl i32 %613, 1
  %617 = call i32 @llvm.umin.i32(i32 %616, i32 1024)
  %618 = add i32 %617, %613
  %619 = call i32 @llvm.umax.i32(i32 %618, i32 8)
  %620 = zext i32 %619 to i64
  %621 = mul i64 %620, 32
  %622 = add i64 %621, 16
  %623 = call ptr @realloc(ptr null, i64 %622)
  store i32 1, ptr %623, align 4
  %624 = getelementptr inbounds i8, ptr %623, i32 4
  store i32 0, ptr %624, align 4
  %625 = getelementptr inbounds i8, ptr %623, i32 16
  %626 = call ptr @realloc(ptr null, i64 8)
  store ptr %625, ptr %626, align 8
  %627 = insertvalue { ptr, i32, i32, i32 } %3, ptr %626, 0
  %628 = insertvalue { ptr, i32, i32, i32 } %627, i32 %619, 3
  br label %650

629:                                              ; preds = %597
  %630 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %631 = icmp ult i32 %630, %613
  br i1 %631, label %632, label %633

632:                                              ; preds = %629
  br label %647

633:                                              ; preds = %629
  %634 = shl i32 %613, 1
  %635 = call i32 @llvm.umin.i32(i32 %634, i32 1024)
  %636 = add i32 %635, %613
  %637 = call i32 @llvm.umax.i32(i32 %636, i32 8)
  %638 = zext i32 %637 to i64
  %639 = mul i64 %638, 32
  %640 = add i64 %639, 16
  %641 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %642 = load ptr, ptr %641, align 8
  %643 = getelementptr inbounds i8, ptr %642, i32 -16
  %644 = call ptr @realloc(ptr %643, i64 %640)
  %645 = getelementptr inbounds i8, ptr %644, i32 16
  store ptr %645, ptr %641, align 8
  %646 = insertvalue { ptr, i32, i32, i32 } %3, i32 %637, 3
  br label %647

647:                                              ; preds = %632, %633
  %648 = phi { ptr, i32, i32, i32 } [ %646, %633 ], [ %3, %632 ]
  br label %649

649:                                              ; preds = %647
  br label %650

650:                                              ; preds = %615, %649
  %651 = phi { ptr, i32, i32, i32 } [ %648, %649 ], [ %628, %615 ]
  br label %652

652:                                              ; preds = %650
  %653 = extractvalue { ptr, i32, i32, i32 } %651, 0
  %654 = load ptr, ptr %653, align 8
  %655 = extractvalue { ptr, i32, i32, i32 } %651, 2
  %656 = zext i32 %655 to i64
  %657 = mul i64 %656, 32
  %658 = getelementptr inbounds i8, ptr %654, i64 %657
  store i252 4, ptr %658, align 16
  %659 = extractvalue { ptr, i32, i32, i32 } %651, 2
  %660 = add i32 %659, 1
  %661 = insertvalue { ptr, i32, i32, i32 } %651, i32 %660, 2
  %662 = getelementptr inbounds i8, ptr %654, i32 -12
  store i32 %660, ptr %662, align 4
  %663 = extractvalue { ptr, i32, i32, i32 } %651, 3
  %664 = icmp eq i32 %663, 0
  br i1 %664, label %665, label %679

665:                                              ; preds = %652
  %666 = shl i32 %663, 1
  %667 = call i32 @llvm.umin.i32(i32 %666, i32 1024)
  %668 = add i32 %667, %663
  %669 = call i32 @llvm.umax.i32(i32 %668, i32 8)
  %670 = zext i32 %669 to i64
  %671 = mul i64 %670, 32
  %672 = add i64 %671, 16
  %673 = call ptr @realloc(ptr null, i64 %672)
  store i32 1, ptr %673, align 4
  %674 = getelementptr inbounds i8, ptr %673, i32 4
  store i32 0, ptr %674, align 4
  %675 = getelementptr inbounds i8, ptr %673, i32 16
  %676 = call ptr @realloc(ptr null, i64 8)
  store ptr %675, ptr %676, align 8
  %677 = insertvalue { ptr, i32, i32, i32 } %661, ptr %676, 0
  %678 = insertvalue { ptr, i32, i32, i32 } %677, i32 %669, 3
  br label %699

679:                                              ; preds = %652
  %680 = icmp ult i32 %660, %663
  br i1 %680, label %681, label %682

681:                                              ; preds = %679
  br label %696

682:                                              ; preds = %679
  %683 = shl i32 %663, 1
  %684 = call i32 @llvm.umin.i32(i32 %683, i32 1024)
  %685 = add i32 %684, %663
  %686 = call i32 @llvm.umax.i32(i32 %685, i32 8)
  %687 = zext i32 %686 to i64
  %688 = mul i64 %687, 32
  %689 = add i64 %688, 16
  %690 = extractvalue { ptr, i32, i32, i32 } %651, 0
  %691 = load ptr, ptr %690, align 8
  %692 = getelementptr inbounds i8, ptr %691, i32 -16
  %693 = call ptr @realloc(ptr %692, i64 %689)
  %694 = getelementptr inbounds i8, ptr %693, i32 16
  store ptr %694, ptr %690, align 8
  %695 = insertvalue { ptr, i32, i32, i32 } %661, i32 %686, 3
  br label %696

696:                                              ; preds = %681, %682
  %697 = phi { ptr, i32, i32, i32 } [ %695, %682 ], [ %661, %681 ]
  br label %698

698:                                              ; preds = %696
  br label %699

699:                                              ; preds = %665, %698
  %700 = phi { ptr, i32, i32, i32 } [ %697, %698 ], [ %678, %665 ]
  br label %701

701:                                              ; preds = %699
  %702 = extractvalue { ptr, i32, i32, i32 } %700, 0
  %703 = load ptr, ptr %702, align 8
  %704 = extractvalue { ptr, i32, i32, i32 } %700, 2
  %705 = zext i32 %704 to i64
  %706 = mul i64 %705, 32
  %707 = getelementptr inbounds i8, ptr %703, i64 %706
  store i252 %612, ptr %707, align 16
  %708 = extractvalue { ptr, i32, i32, i32 } %700, 2
  %709 = add i32 %708, 1
  %710 = insertvalue { ptr, i32, i32, i32 } %700, i32 %709, 2
  %711 = getelementptr inbounds i8, ptr %703, i32 -12
  store i32 %709, ptr %711, align 4
  %712 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f100"(i64 %0, i64 %604, { { ptr, i32, i32, i32 } } %606, { ptr, i32, i32, i32 } %710)
  %713 = extractvalue { i64, i64, { i64, [24 x i8] } } %712, 0
  %714 = extractvalue { i64, i64, { i64, [24 x i8] } } %712, 1
  %715 = extractvalue { i64, i64, { i64, [24 x i8] } } %712, 2
  %716 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %713, 0
  %717 = insertvalue { i64, i64, { i64, [24 x i8] } } %716, i64 %714, 1
  %718 = insertvalue { i64, i64, { i64, [24 x i8] } } %717, { i64, [24 x i8] } %715, 2
  ret { i64, i64, { i64, [24 x i8] } } %718

719:                                              ; preds = %4
  %720 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %721 = call ptr %720()
  %722 = load i64, ptr %721, align 8
  %723 = mul i64 %722, 5450
  %724 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %723)
  %725 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %726 = icmp eq i32 %725, 0
  br i1 %726, label %727, label %741

727:                                              ; preds = %719
  %728 = shl i32 %725, 1
  %729 = call i32 @llvm.umin.i32(i32 %728, i32 1024)
  %730 = add i32 %729, %725
  %731 = call i32 @llvm.umax.i32(i32 %730, i32 8)
  %732 = zext i32 %731 to i64
  %733 = mul i64 %732, 32
  %734 = add i64 %733, 16
  %735 = call ptr @realloc(ptr null, i64 %734)
  store i32 1, ptr %735, align 4
  %736 = getelementptr inbounds i8, ptr %735, i32 4
  store i32 0, ptr %736, align 4
  %737 = getelementptr inbounds i8, ptr %735, i32 16
  %738 = call ptr @realloc(ptr null, i64 8)
  store ptr %737, ptr %738, align 8
  %739 = insertvalue { ptr, i32, i32, i32 } %3, ptr %738, 0
  %740 = insertvalue { ptr, i32, i32, i32 } %739, i32 %731, 3
  br label %762

741:                                              ; preds = %719
  %742 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %743 = icmp ult i32 %742, %725
  br i1 %743, label %744, label %745

744:                                              ; preds = %741
  br label %759

745:                                              ; preds = %741
  %746 = shl i32 %725, 1
  %747 = call i32 @llvm.umin.i32(i32 %746, i32 1024)
  %748 = add i32 %747, %725
  %749 = call i32 @llvm.umax.i32(i32 %748, i32 8)
  %750 = zext i32 %749 to i64
  %751 = mul i64 %750, 32
  %752 = add i64 %751, 16
  %753 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %754 = load ptr, ptr %753, align 8
  %755 = getelementptr inbounds i8, ptr %754, i32 -16
  %756 = call ptr @realloc(ptr %755, i64 %752)
  %757 = getelementptr inbounds i8, ptr %756, i32 16
  store ptr %757, ptr %753, align 8
  %758 = insertvalue { ptr, i32, i32, i32 } %3, i32 %749, 3
  br label %759

759:                                              ; preds = %744, %745
  %760 = phi { ptr, i32, i32, i32 } [ %758, %745 ], [ %3, %744 ]
  br label %761

761:                                              ; preds = %759
  br label %762

762:                                              ; preds = %727, %761
  %763 = phi { ptr, i32, i32, i32 } [ %760, %761 ], [ %740, %727 ]
  br label %764

764:                                              ; preds = %762
  %765 = extractvalue { ptr, i32, i32, i32 } %763, 0
  %766 = load ptr, ptr %765, align 8
  %767 = extractvalue { ptr, i32, i32, i32 } %763, 2
  %768 = zext i32 %767 to i64
  %769 = mul i64 %768, 32
  %770 = getelementptr inbounds i8, ptr %766, i64 %769
  store i252 5, ptr %770, align 16
  %771 = extractvalue { ptr, i32, i32, i32 } %763, 2
  %772 = add i32 %771, 1
  %773 = insertvalue { ptr, i32, i32, i32 } %763, i32 %772, 2
  %774 = getelementptr inbounds i8, ptr %766, i32 -12
  store i32 %772, ptr %774, align 4
  br label %1062

775:                                              ; preds = %4
  %776 = load { i3, { { { ptr, i32, i32, i32 } }, i32 } }, ptr %5, align 8
  %777 = extractvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %776, 1
  %778 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %777, 0
  %779 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %777, 1
  %780 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$12"({ { ptr, i32, i32, i32 } } %778)
  %781 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %780, 0
  %782 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %780, 1
  %783 = extractvalue { { ptr, i32, i32, i32 } } %782, 0
  %784 = extractvalue { ptr, i32, i32, i32 } %783, 1
  %785 = extractvalue { ptr, i32, i32, i32 } %783, 2
  %786 = sub i32 %785, %784
  call void @"drop$3"({ ptr, i32, i32, i32 } %783)
  %787 = zext i32 %786 to i252
  %788 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %789 = icmp eq i32 %788, 0
  br i1 %789, label %790, label %804

790:                                              ; preds = %775
  %791 = shl i32 %788, 1
  %792 = call i32 @llvm.umin.i32(i32 %791, i32 1024)
  %793 = add i32 %792, %788
  %794 = call i32 @llvm.umax.i32(i32 %793, i32 8)
  %795 = zext i32 %794 to i64
  %796 = mul i64 %795, 32
  %797 = add i64 %796, 16
  %798 = call ptr @realloc(ptr null, i64 %797)
  store i32 1, ptr %798, align 4
  %799 = getelementptr inbounds i8, ptr %798, i32 4
  store i32 0, ptr %799, align 4
  %800 = getelementptr inbounds i8, ptr %798, i32 16
  %801 = call ptr @realloc(ptr null, i64 8)
  store ptr %800, ptr %801, align 8
  %802 = insertvalue { ptr, i32, i32, i32 } %3, ptr %801, 0
  %803 = insertvalue { ptr, i32, i32, i32 } %802, i32 %794, 3
  br label %825

804:                                              ; preds = %775
  %805 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %806 = icmp ult i32 %805, %788
  br i1 %806, label %807, label %808

807:                                              ; preds = %804
  br label %822

808:                                              ; preds = %804
  %809 = shl i32 %788, 1
  %810 = call i32 @llvm.umin.i32(i32 %809, i32 1024)
  %811 = add i32 %810, %788
  %812 = call i32 @llvm.umax.i32(i32 %811, i32 8)
  %813 = zext i32 %812 to i64
  %814 = mul i64 %813, 32
  %815 = add i64 %814, 16
  %816 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %817 = load ptr, ptr %816, align 8
  %818 = getelementptr inbounds i8, ptr %817, i32 -16
  %819 = call ptr @realloc(ptr %818, i64 %815)
  %820 = getelementptr inbounds i8, ptr %819, i32 16
  store ptr %820, ptr %816, align 8
  %821 = insertvalue { ptr, i32, i32, i32 } %3, i32 %812, 3
  br label %822

822:                                              ; preds = %807, %808
  %823 = phi { ptr, i32, i32, i32 } [ %821, %808 ], [ %3, %807 ]
  br label %824

824:                                              ; preds = %822
  br label %825

825:                                              ; preds = %790, %824
  %826 = phi { ptr, i32, i32, i32 } [ %823, %824 ], [ %803, %790 ]
  br label %827

827:                                              ; preds = %825
  %828 = extractvalue { ptr, i32, i32, i32 } %826, 0
  %829 = load ptr, ptr %828, align 8
  %830 = extractvalue { ptr, i32, i32, i32 } %826, 2
  %831 = zext i32 %830 to i64
  %832 = mul i64 %831, 32
  %833 = getelementptr inbounds i8, ptr %829, i64 %832
  store i252 6, ptr %833, align 16
  %834 = extractvalue { ptr, i32, i32, i32 } %826, 2
  %835 = add i32 %834, 1
  %836 = insertvalue { ptr, i32, i32, i32 } %826, i32 %835, 2
  %837 = getelementptr inbounds i8, ptr %829, i32 -12
  store i32 %835, ptr %837, align 4
  %838 = extractvalue { ptr, i32, i32, i32 } %826, 3
  %839 = icmp eq i32 %838, 0
  br i1 %839, label %840, label %854

840:                                              ; preds = %827
  %841 = shl i32 %838, 1
  %842 = call i32 @llvm.umin.i32(i32 %841, i32 1024)
  %843 = add i32 %842, %838
  %844 = call i32 @llvm.umax.i32(i32 %843, i32 8)
  %845 = zext i32 %844 to i64
  %846 = mul i64 %845, 32
  %847 = add i64 %846, 16
  %848 = call ptr @realloc(ptr null, i64 %847)
  store i32 1, ptr %848, align 4
  %849 = getelementptr inbounds i8, ptr %848, i32 4
  store i32 0, ptr %849, align 4
  %850 = getelementptr inbounds i8, ptr %848, i32 16
  %851 = call ptr @realloc(ptr null, i64 8)
  store ptr %850, ptr %851, align 8
  %852 = insertvalue { ptr, i32, i32, i32 } %836, ptr %851, 0
  %853 = insertvalue { ptr, i32, i32, i32 } %852, i32 %844, 3
  br label %874

854:                                              ; preds = %827
  %855 = icmp ult i32 %835, %838
  br i1 %855, label %856, label %857

856:                                              ; preds = %854
  br label %871

857:                                              ; preds = %854
  %858 = shl i32 %838, 1
  %859 = call i32 @llvm.umin.i32(i32 %858, i32 1024)
  %860 = add i32 %859, %838
  %861 = call i32 @llvm.umax.i32(i32 %860, i32 8)
  %862 = zext i32 %861 to i64
  %863 = mul i64 %862, 32
  %864 = add i64 %863, 16
  %865 = extractvalue { ptr, i32, i32, i32 } %826, 0
  %866 = load ptr, ptr %865, align 8
  %867 = getelementptr inbounds i8, ptr %866, i32 -16
  %868 = call ptr @realloc(ptr %867, i64 %864)
  %869 = getelementptr inbounds i8, ptr %868, i32 16
  store ptr %869, ptr %865, align 8
  %870 = insertvalue { ptr, i32, i32, i32 } %836, i32 %861, 3
  br label %871

871:                                              ; preds = %856, %857
  %872 = phi { ptr, i32, i32, i32 } [ %870, %857 ], [ %836, %856 ]
  br label %873

873:                                              ; preds = %871
  br label %874

874:                                              ; preds = %840, %873
  %875 = phi { ptr, i32, i32, i32 } [ %872, %873 ], [ %853, %840 ]
  br label %876

876:                                              ; preds = %874
  %877 = extractvalue { ptr, i32, i32, i32 } %875, 0
  %878 = load ptr, ptr %877, align 8
  %879 = extractvalue { ptr, i32, i32, i32 } %875, 2
  %880 = zext i32 %879 to i64
  %881 = mul i64 %880, 32
  %882 = getelementptr inbounds i8, ptr %878, i64 %881
  store i252 %787, ptr %882, align 16
  %883 = extractvalue { ptr, i32, i32, i32 } %875, 2
  %884 = add i32 %883, 1
  %885 = insertvalue { ptr, i32, i32, i32 } %875, i32 %884, 2
  %886 = getelementptr inbounds i8, ptr %878, i32 -12
  store i32 %884, ptr %886, align 4
  %887 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f100"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %781, { ptr, i32, i32, i32 } %885)
  %888 = extractvalue { i64, i64, { i64, [24 x i8] } } %887, 0
  %889 = extractvalue { i64, i64, { i64, [24 x i8] } } %887, 1
  %890 = extractvalue { i64, i64, { i64, [24 x i8] } } %887, 2
  store { i64, [24 x i8] } %890, ptr %6, align 8
  %891 = load i1, ptr %6, align 1
  switch i1 %891, label %1073 [
    i1 false, label %1075
    i1 true, label %1142
  ]

892:                                              ; preds = %284
  br i1 false, label %893, label %1151

893:                                              ; preds = %892
  unreachable

894:                                              ; preds = %284
  %895 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %12, align 8
  %896 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %895, 1
  %897 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %898 = call ptr %897()
  %899 = call i64 @llvm.uadd.sat.i64(i64 %297, i64 0)
  %900 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %192, 1
  %901 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %192, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %900)
  %902 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$31"({ { ptr, i32, i32, i32 } } %901)
  %903 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %902, 0
  %904 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %902, 1
  %905 = extractvalue { { ptr, i32, i32, i32 } } %904, 0
  %906 = extractvalue { ptr, i32, i32, i32 } %905, 1
  %907 = extractvalue { ptr, i32, i32, i32 } %905, 2
  %908 = sub i32 %907, %906
  call void @"drop$30"({ ptr, i32, i32, i32 } %905)
  %909 = zext i32 %908 to i252
  %910 = extractvalue { { ptr, i32, i32, i32 }, {} } %896, 0
  %911 = extractvalue { ptr, i32, i32, i32 } %910, 3
  %912 = icmp eq i32 %911, 0
  br i1 %912, label %913, label %927

913:                                              ; preds = %894
  %914 = shl i32 %911, 1
  %915 = call i32 @llvm.umin.i32(i32 %914, i32 1024)
  %916 = add i32 %915, %911
  %917 = call i32 @llvm.umax.i32(i32 %916, i32 8)
  %918 = zext i32 %917 to i64
  %919 = mul i64 %918, 32
  %920 = add i64 %919, 16
  %921 = call ptr @realloc(ptr null, i64 %920)
  store i32 1, ptr %921, align 4
  %922 = getelementptr inbounds i8, ptr %921, i32 4
  store i32 0, ptr %922, align 4
  %923 = getelementptr inbounds i8, ptr %921, i32 16
  %924 = call ptr @realloc(ptr null, i64 8)
  store ptr %923, ptr %924, align 8
  %925 = insertvalue { ptr, i32, i32, i32 } %910, ptr %924, 0
  %926 = insertvalue { ptr, i32, i32, i32 } %925, i32 %917, 3
  br label %948

927:                                              ; preds = %894
  %928 = extractvalue { ptr, i32, i32, i32 } %910, 2
  %929 = icmp ult i32 %928, %911
  br i1 %929, label %930, label %931

930:                                              ; preds = %927
  br label %945

931:                                              ; preds = %927
  %932 = shl i32 %911, 1
  %933 = call i32 @llvm.umin.i32(i32 %932, i32 1024)
  %934 = add i32 %933, %911
  %935 = call i32 @llvm.umax.i32(i32 %934, i32 8)
  %936 = zext i32 %935 to i64
  %937 = mul i64 %936, 32
  %938 = add i64 %937, 16
  %939 = extractvalue { ptr, i32, i32, i32 } %910, 0
  %940 = load ptr, ptr %939, align 8
  %941 = getelementptr inbounds i8, ptr %940, i32 -16
  %942 = call ptr @realloc(ptr %941, i64 %938)
  %943 = getelementptr inbounds i8, ptr %942, i32 16
  store ptr %943, ptr %939, align 8
  %944 = insertvalue { ptr, i32, i32, i32 } %910, i32 %935, 3
  br label %945

945:                                              ; preds = %930, %931
  %946 = phi { ptr, i32, i32, i32 } [ %944, %931 ], [ %910, %930 ]
  br label %947

947:                                              ; preds = %945
  br label %948

948:                                              ; preds = %913, %947
  %949 = phi { ptr, i32, i32, i32 } [ %946, %947 ], [ %926, %913 ]
  br label %950

950:                                              ; preds = %948
  %951 = extractvalue { ptr, i32, i32, i32 } %949, 0
  %952 = load ptr, ptr %951, align 8
  %953 = extractvalue { ptr, i32, i32, i32 } %949, 2
  %954 = zext i32 %953 to i64
  %955 = mul i64 %954, 32
  %956 = getelementptr inbounds i8, ptr %952, i64 %955
  store i252 %909, ptr %956, align 16
  %957 = extractvalue { ptr, i32, i32, i32 } %949, 2
  %958 = add i32 %957, 1
  %959 = insertvalue { ptr, i32, i32, i32 } %949, i32 %958, 2
  %960 = getelementptr inbounds i8, ptr %952, i32 -12
  store i32 %958, ptr %960, align 4
  %961 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f93"(i64 %296, i64 %899, { { ptr, i32, i32, i32 } } %903, { ptr, i32, i32, i32 } %959)
  %962 = extractvalue { i64, i64, { i64, [24 x i8] } } %961, 0
  %963 = extractvalue { i64, i64, { i64, [24 x i8] } } %961, 1
  %964 = extractvalue { i64, i64, { i64, [24 x i8] } } %961, 2
  %965 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %962, 0
  %966 = insertvalue { i64, i64, { i64, [24 x i8] } } %965, i64 %963, 1
  %967 = insertvalue { i64, i64, { i64, [24 x i8] } } %966, { i64, [24 x i8] } %964, 2
  ret { i64, i64, { i64, [24 x i8] } } %967

968:                                              ; preds = %284
  %969 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %970 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %969, 1
  call void @"drop$32"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %192)
  %971 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %970, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %971, ptr %13, align 8
  %972 = load { i64, [24 x i8] }, ptr %13, align 8
  %973 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %296, 0
  %974 = insertvalue { i64, i64, { i64, [24 x i8] } } %973, i64 %297, 1
  %975 = insertvalue { i64, i64, { i64, [24 x i8] } } %974, { i64, [24 x i8] } %972, 2
  ret { i64, i64, { i64, [24 x i8] } } %975

976:                                              ; preds = %459
  br i1 false, label %977, label %1152

977:                                              ; preds = %976
  unreachable

978:                                              ; preds = %459
  %979 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %10, align 8
  %980 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %979, 1
  %981 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %982 = call ptr %981()
  %983 = load i64, ptr %982, align 8
  %984 = mul i64 %983, 90
  %985 = call i64 @llvm.uadd.sat.i64(i64 %472, i64 %984)
  %986 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %367, 1
  %987 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %367, 2
  call void @"drop$28"({ { ptr, i32, i32, i32 } } %986)
  %988 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$33"({ { ptr, i32, i32, i32 } } %987)
  %989 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %988, 0
  %990 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %988, 1
  %991 = extractvalue { { ptr, i32, i32, i32 } } %990, 0
  %992 = extractvalue { ptr, i32, i32, i32 } %991, 1
  %993 = extractvalue { ptr, i32, i32, i32 } %991, 2
  %994 = sub i32 %993, %992
  call void @"drop$7"({ ptr, i32, i32, i32 } %991)
  %995 = zext i32 %994 to i252
  %996 = extractvalue { { ptr, i32, i32, i32 }, {} } %980, 0
  %997 = extractvalue { ptr, i32, i32, i32 } %996, 3
  %998 = icmp eq i32 %997, 0
  br i1 %998, label %999, label %1013

999:                                              ; preds = %978
  %1000 = shl i32 %997, 1
  %1001 = call i32 @llvm.umin.i32(i32 %1000, i32 1024)
  %1002 = add i32 %1001, %997
  %1003 = call i32 @llvm.umax.i32(i32 %1002, i32 8)
  %1004 = zext i32 %1003 to i64
  %1005 = mul i64 %1004, 32
  %1006 = add i64 %1005, 16
  %1007 = call ptr @realloc(ptr null, i64 %1006)
  store i32 1, ptr %1007, align 4
  %1008 = getelementptr inbounds i8, ptr %1007, i32 4
  store i32 0, ptr %1008, align 4
  %1009 = getelementptr inbounds i8, ptr %1007, i32 16
  %1010 = call ptr @realloc(ptr null, i64 8)
  store ptr %1009, ptr %1010, align 8
  %1011 = insertvalue { ptr, i32, i32, i32 } %996, ptr %1010, 0
  %1012 = insertvalue { ptr, i32, i32, i32 } %1011, i32 %1003, 3
  br label %1034

1013:                                             ; preds = %978
  %1014 = extractvalue { ptr, i32, i32, i32 } %996, 2
  %1015 = icmp ult i32 %1014, %997
  br i1 %1015, label %1016, label %1017

1016:                                             ; preds = %1013
  br label %1031

1017:                                             ; preds = %1013
  %1018 = shl i32 %997, 1
  %1019 = call i32 @llvm.umin.i32(i32 %1018, i32 1024)
  %1020 = add i32 %1019, %997
  %1021 = call i32 @llvm.umax.i32(i32 %1020, i32 8)
  %1022 = zext i32 %1021 to i64
  %1023 = mul i64 %1022, 32
  %1024 = add i64 %1023, 16
  %1025 = extractvalue { ptr, i32, i32, i32 } %996, 0
  %1026 = load ptr, ptr %1025, align 8
  %1027 = getelementptr inbounds i8, ptr %1026, i32 -16
  %1028 = call ptr @realloc(ptr %1027, i64 %1024)
  %1029 = getelementptr inbounds i8, ptr %1028, i32 16
  store ptr %1029, ptr %1025, align 8
  %1030 = insertvalue { ptr, i32, i32, i32 } %996, i32 %1021, 3
  br label %1031

1031:                                             ; preds = %1016, %1017
  %1032 = phi { ptr, i32, i32, i32 } [ %1030, %1017 ], [ %996, %1016 ]
  br label %1033

1033:                                             ; preds = %1031
  br label %1034

1034:                                             ; preds = %999, %1033
  %1035 = phi { ptr, i32, i32, i32 } [ %1032, %1033 ], [ %1012, %999 ]
  br label %1036

1036:                                             ; preds = %1034
  %1037 = extractvalue { ptr, i32, i32, i32 } %1035, 0
  %1038 = load ptr, ptr %1037, align 8
  %1039 = extractvalue { ptr, i32, i32, i32 } %1035, 2
  %1040 = zext i32 %1039 to i64
  %1041 = mul i64 %1040, 32
  %1042 = getelementptr inbounds i8, ptr %1038, i64 %1041
  store i252 %995, ptr %1042, align 16
  %1043 = extractvalue { ptr, i32, i32, i32 } %1035, 2
  %1044 = add i32 %1043, 1
  %1045 = insertvalue { ptr, i32, i32, i32 } %1035, i32 %1044, 2
  %1046 = getelementptr inbounds i8, ptr %1038, i32 -12
  store i32 %1044, ptr %1046, align 4
  %1047 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f99"(i64 %471, i64 %985, { { ptr, i32, i32, i32 } } %989, { ptr, i32, i32, i32 } %1045)
  %1048 = extractvalue { i64, i64, { i64, [24 x i8] } } %1047, 0
  %1049 = extractvalue { i64, i64, { i64, [24 x i8] } } %1047, 1
  %1050 = extractvalue { i64, i64, { i64, [24 x i8] } } %1047, 2
  %1051 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %1048, 0
  %1052 = insertvalue { i64, i64, { i64, [24 x i8] } } %1051, i64 %1049, 1
  %1053 = insertvalue { i64, i64, { i64, [24 x i8] } } %1052, { i64, [24 x i8] } %1050, 2
  ret { i64, i64, { i64, [24 x i8] } } %1053

1054:                                             ; preds = %459
  %1055 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %1056 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %1055, 1
  call void @"drop$34"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %367)
  %1057 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %1056, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %1057, ptr %11, align 8
  %1058 = load { i64, [24 x i8] }, ptr %11, align 8
  %1059 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %471, 0
  %1060 = insertvalue { i64, i64, { i64, [24 x i8] } } %1059, i64 %472, 1
  %1061 = insertvalue { i64, i64, { i64, [24 x i8] } } %1060, { i64, [24 x i8] } %1058, 2
  ret { i64, i64, { i64, [24 x i8] } } %1061

1062:                                             ; preds = %114, %764
  %1063 = phi i64 [ %0, %764 ], [ %0, %114 ]
  %1064 = phi i64 [ %724, %764 ], [ %25, %114 ]
  %1065 = phi { ptr, i32, i32, i32 } [ %773, %764 ], [ %123, %114 ]
  %1066 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %1065, 0
  %1067 = insertvalue { { ptr, i32, i32, i32 }, {} } %1066, {} undef, 1
  %1068 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %1067, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %1068, ptr %9, align 8
  %1069 = load { i64, [24 x i8] }, ptr %9, align 8
  %1070 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %1063, 0
  %1071 = insertvalue { i64, i64, { i64, [24 x i8] } } %1070, i64 %1064, 1
  %1072 = insertvalue { i64, i64, { i64, [24 x i8] } } %1071, { i64, [24 x i8] } %1069, 2
  ret { i64, i64, { i64, [24 x i8] } } %1072

1073:                                             ; preds = %876
  br i1 false, label %1074, label %1153

1074:                                             ; preds = %1073
  unreachable

1075:                                             ; preds = %876
  %1076 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %1077 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %1076, 1
  %1078 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %1079 = call ptr %1078()
  %1080 = load i64, ptr %1079, align 8
  %1081 = mul i64 %1080, 2460
  %1082 = call i64 @llvm.uadd.sat.i64(i64 %889, i64 %1081)
  %1083 = zext i32 %779 to i252
  %1084 = extractvalue { { ptr, i32, i32, i32 }, {} } %1077, 0
  %1085 = extractvalue { ptr, i32, i32, i32 } %1084, 3
  %1086 = icmp eq i32 %1085, 0
  br i1 %1086, label %1087, label %1101

1087:                                             ; preds = %1075
  %1088 = shl i32 %1085, 1
  %1089 = call i32 @llvm.umin.i32(i32 %1088, i32 1024)
  %1090 = add i32 %1089, %1085
  %1091 = call i32 @llvm.umax.i32(i32 %1090, i32 8)
  %1092 = zext i32 %1091 to i64
  %1093 = mul i64 %1092, 32
  %1094 = add i64 %1093, 16
  %1095 = call ptr @realloc(ptr null, i64 %1094)
  store i32 1, ptr %1095, align 4
  %1096 = getelementptr inbounds i8, ptr %1095, i32 4
  store i32 0, ptr %1096, align 4
  %1097 = getelementptr inbounds i8, ptr %1095, i32 16
  %1098 = call ptr @realloc(ptr null, i64 8)
  store ptr %1097, ptr %1098, align 8
  %1099 = insertvalue { ptr, i32, i32, i32 } %1084, ptr %1098, 0
  %1100 = insertvalue { ptr, i32, i32, i32 } %1099, i32 %1091, 3
  br label %1122

1101:                                             ; preds = %1075
  %1102 = extractvalue { ptr, i32, i32, i32 } %1084, 2
  %1103 = icmp ult i32 %1102, %1085
  br i1 %1103, label %1104, label %1105

1104:                                             ; preds = %1101
  br label %1119

1105:                                             ; preds = %1101
  %1106 = shl i32 %1085, 1
  %1107 = call i32 @llvm.umin.i32(i32 %1106, i32 1024)
  %1108 = add i32 %1107, %1085
  %1109 = call i32 @llvm.umax.i32(i32 %1108, i32 8)
  %1110 = zext i32 %1109 to i64
  %1111 = mul i64 %1110, 32
  %1112 = add i64 %1111, 16
  %1113 = extractvalue { ptr, i32, i32, i32 } %1084, 0
  %1114 = load ptr, ptr %1113, align 8
  %1115 = getelementptr inbounds i8, ptr %1114, i32 -16
  %1116 = call ptr @realloc(ptr %1115, i64 %1112)
  %1117 = getelementptr inbounds i8, ptr %1116, i32 16
  store ptr %1117, ptr %1113, align 8
  %1118 = insertvalue { ptr, i32, i32, i32 } %1084, i32 %1109, 3
  br label %1119

1119:                                             ; preds = %1104, %1105
  %1120 = phi { ptr, i32, i32, i32 } [ %1118, %1105 ], [ %1084, %1104 ]
  br label %1121

1121:                                             ; preds = %1119
  br label %1122

1122:                                             ; preds = %1087, %1121
  %1123 = phi { ptr, i32, i32, i32 } [ %1120, %1121 ], [ %1100, %1087 ]
  br label %1124

1124:                                             ; preds = %1122
  %1125 = extractvalue { ptr, i32, i32, i32 } %1123, 0
  %1126 = load ptr, ptr %1125, align 8
  %1127 = extractvalue { ptr, i32, i32, i32 } %1123, 2
  %1128 = zext i32 %1127 to i64
  %1129 = mul i64 %1128, 32
  %1130 = getelementptr inbounds i8, ptr %1126, i64 %1129
  store i252 %1083, ptr %1130, align 16
  %1131 = extractvalue { ptr, i32, i32, i32 } %1123, 2
  %1132 = add i32 %1131, 1
  %1133 = insertvalue { ptr, i32, i32, i32 } %1123, i32 %1132, 2
  %1134 = getelementptr inbounds i8, ptr %1126, i32 -12
  store i32 %1132, ptr %1134, align 4
  %1135 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %1133, 0
  %1136 = insertvalue { { ptr, i32, i32, i32 }, {} } %1135, {} undef, 1
  %1137 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %1136, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %1137, ptr %8, align 8
  %1138 = load { i64, [24 x i8] }, ptr %8, align 8
  %1139 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %888, 0
  %1140 = insertvalue { i64, i64, { i64, [24 x i8] } } %1139, i64 %1082, 1
  %1141 = insertvalue { i64, i64, { i64, [24 x i8] } } %1140, { i64, [24 x i8] } %1138, 2
  ret { i64, i64, { i64, [24 x i8] } } %1141

1142:                                             ; preds = %876
  %1143 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %1144 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %1143, 1
  %1145 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %1144, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %1145, ptr %7, align 8
  %1146 = load { i64, [24 x i8] }, ptr %7, align 8
  %1147 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %888, 0
  %1148 = insertvalue { i64, i64, { i64, [24 x i8] } } %1147, i64 %889, 1
  %1149 = insertvalue { i64, i64, { i64, [24 x i8] } } %1148, { i64, [24 x i8] } %1146, 2
  ret { i64, i64, { i64, [24 x i8] } } %1149

1150:                                             ; preds = %16
  call void @puts(ptr @assert_msg_162)
  call void @abort()
  unreachable

1151:                                             ; preds = %892
  call void @puts(ptr @assert_msg_163)
  call void @abort()
  unreachable

1152:                                             ; preds = %976
  call void @puts(ptr @assert_msg_164)
  call void @abort()
  unreachable

1153:                                             ; preds = %1073
  call void @puts(ptr @assert_msg_165)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f96(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f96(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f96(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f97"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [8 x i8] }, i64 1, align 4
  %4 = alloca { i32, [8 x i8] }, i64 1, align 4
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %96

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp eq i252 %19, 0
  br i1 %20, label %21, label %22

21:                                               ; preds = %10
  br label %54

22:                                               ; preds = %10
  %23 = phi i252 [ %19, %10 ]
  %24 = zext i252 %23 to i256
  %25 = sub i256 %24, 1
  %26 = add i256 %24, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %27 = icmp ult i256 %24, 1
  %28 = select i1 %27, i256 %26, i256 %25
  %29 = trunc i256 %28 to i252
  %30 = icmp eq i252 %29, 0
  br i1 %30, label %31, label %32

31:                                               ; preds = %22
  br label %54

32:                                               ; preds = %22
  %33 = phi i252 [ %23, %22 ]
  %34 = zext i252 %33 to i256
  %35 = sub i256 %34, 2
  %36 = add i256 %34, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %37 = icmp ult i256 %34, 2
  %38 = select i1 %37, i256 %36, i256 %35
  %39 = trunc i256 %38 to i252
  %40 = icmp eq i252 %39, 0
  br i1 %40, label %41, label %42

41:                                               ; preds = %32
  br label %54

42:                                               ; preds = %32
  %43 = phi i252 [ %33, %32 ]
  %44 = phi i252 [ 3, %32 ]
  %45 = zext i252 %43 to i256
  %46 = zext i252 %44 to i256
  %47 = sub i256 %45, %46
  %48 = add i256 %47, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %49 = icmp ult i256 %45, %46
  %50 = select i1 %49, i256 %48, i256 %47
  %51 = trunc i256 %50 to i252
  %52 = icmp eq i252 %51, 0
  br i1 %52, label %53, label %96

53:                                               ; preds = %42
  br label %54

54:                                               ; preds = %21, %31, %41, %53
  %55 = phi i64 [ %0, %53 ], [ %0, %41 ], [ %0, %31 ], [ %0, %21 ]
  %56 = phi { ptr, i32, i32, i32 } [ %17, %53 ], [ %17, %41 ], [ %17, %31 ], [ %17, %21 ]
  %57 = phi { i2, [0 x i8] } [ { i2 -1, [0 x i8] undef }, %53 ], [ { i2 -2, [0 x i8] undef }, %41 ], [ { i2 1, [0 x i8] undef }, %31 ], [ { i2 0, [0 x i8] undef }, %21 ]
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %59 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %60 = sub i32 %59, %58
  %61 = icmp uge i32 %60, 1
  br i1 %61, label %62, label %96

62:                                               ; preds = %54
  %63 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %64 = load ptr, ptr %63, align 8
  %65 = zext i32 %58 to i64
  %66 = mul i64 %65, 32
  %67 = getelementptr inbounds i8, ptr %64, i64 %66
  %68 = add i32 %58, 1
  %69 = insertvalue { ptr, i32, i32, i32 } %56, i32 %68, 1
  %70 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %70, ptr %67, i64 32, i1 false)
  %71 = load i252, ptr %70, align 16
  call void @free(ptr %70)
  %72 = icmp sge i252 %71, -3618502788666131000275863779947924135206266826270938552493006944360846065663
  %73 = icmp slt i252 %71, 2147483648
  %74 = and i1 %72, %73
  %75 = icmp slt i252 %71, 0
  br i1 %75, label %76, label %78

76:                                               ; preds = %62
  %77 = sub i252 %71, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %79

78:                                               ; preds = %62
  br label %79

79:                                               ; preds = %76, %78
  %80 = phi i252 [ %71, %78 ], [ %77, %76 ]
  br label %81

81:                                               ; preds = %79
  %82 = add i64 %55, 2
  %83 = add i64 %55, 3
  %84 = select i1 %74, i64 %82, i64 %83
  %85 = trunc i252 %80 to i32
  br i1 %74, label %86, label %96

86:                                               ; preds = %81
  %87 = phi { ptr, i32, i32, i32 } [ %69, %81 ]
  %88 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %87, 0
  %89 = insertvalue { { i2, [0 x i8] }, i32 } undef, { i2, [0 x i8] } %57, 0
  %90 = insertvalue { { i2, [0 x i8] }, i32 } %89, i32 %85, 1
  %91 = insertvalue { i1, { { i2, [0 x i8] }, i32 } } { i1 false, { { i2, [0 x i8] }, i32 } undef }, { { i2, [0 x i8] }, i32 } %90, 1
  store { i1, { { i2, [0 x i8] }, i32 } } %91, ptr %4, align 4
  %92 = load { i32, [8 x i8] }, ptr %4, align 4
  %93 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %84, 0
  %94 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %93, { { ptr, i32, i32, i32 } } %88, 1
  %95 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %94, { i32, [8 x i8] } %92, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %95

96:                                               ; preds = %81, %54, %42, %2
  %97 = phi i64 [ %84, %81 ], [ %55, %54 ], [ %0, %42 ], [ %0, %2 ]
  %98 = phi { ptr, i32, i32, i32 } [ %69, %81 ], [ %56, %54 ], [ %17, %42 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %99 = load { i32, [8 x i8] }, ptr %3, align 4
  %100 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %98, 0
  %101 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %97, 0
  %102 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %101, { { ptr, i32, i32, i32 } } %100, 1
  %103 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %102, { i32, [8 x i8] } %99, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %103
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @f97(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f97"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %8, { i32, [8 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %9
}

define void @_mlir_ciface_f97(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @f97(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$9"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$9"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 24)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 24, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f98"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i32, [16 x i8] }, i64 1, align 4
  br label %13

13:                                               ; preds = %159, %4
  %14 = phi i64 [ %160, %159 ], [ %0, %4 ]
  %15 = phi i64 [ %163, %159 ], [ %1, %4 ]
  %16 = phi { { ptr, i32, i32, i32 } } [ %162, %159 ], [ %2, %4 ]
  %17 = phi { ptr, i32, i32, i32 } [ %167, %159 ], [ %3, %4 ]
  %18 = add i64 %14, 1
  %19 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %20 = call ptr %19()
  %21 = load i64, ptr %20, align 8
  %22 = mul i64 %21, 4970
  %23 = icmp uge i64 %15, %22
  %24 = call i64 @llvm.usub.sat.i64(i64 %15, i64 %22)
  br i1 %23, label %25, label %205

25:                                               ; preds = %13
  %26 = phi { { ptr, i32, i32, i32 } } [ %16, %13 ]
  %27 = extractvalue { { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { ptr, i32, i32, i32 } %27, 1
  %29 = extractvalue { ptr, i32, i32, i32 } %27, 2
  %30 = sub i32 %29, %28
  %31 = icmp uge i32 %30, 1
  br i1 %31, label %32, label %185

32:                                               ; preds = %25
  %33 = extractvalue { ptr, i32, i32, i32 } %27, 0
  %34 = load ptr, ptr %33, align 8
  %35 = zext i32 %28 to i64
  %36 = mul i64 %35, 24
  %37 = getelementptr inbounds i8, ptr %34, i64 %36
  %38 = add i32 %28, 1
  %39 = insertvalue { ptr, i32, i32, i32 } %27, i32 %38, 1
  %40 = call ptr @realloc(ptr null, i64 24)
  call void @llvm.memcpy.p0.p0.i64(ptr %40, ptr %37, i64 24, i1 false)
  %41 = load { { i1, [0 x i8] }, { i32, [16 x i8] } }, ptr %40, align 4
  call void @free(ptr %40)
  %42 = extractvalue { { i1, [0 x i8] }, { i32, [16 x i8] } } %41, 0
  %43 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %39, 0
  %44 = extractvalue { i1, [0 x i8] } %42, 0
  switch i1 %44, label %45 [
    i1 false, label %47
    i1 true, label %102
  ]

45:                                               ; preds = %32
  br i1 false, label %46, label %220

46:                                               ; preds = %45
  unreachable

47:                                               ; preds = %32
  %48 = phi i64 [ %24, %32 ]
  %49 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %50 = call ptr %49()
  %51 = call i64 @llvm.uadd.sat.i64(i64 %48, i64 0)
  %52 = extractvalue { ptr, i32, i32, i32 } %17, 3
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %54, label %68

54:                                               ; preds = %47
  %55 = shl i32 %52, 1
  %56 = call i32 @llvm.umin.i32(i32 %55, i32 1024)
  %57 = add i32 %56, %52
  %58 = call i32 @llvm.umax.i32(i32 %57, i32 8)
  %59 = zext i32 %58 to i64
  %60 = mul i64 %59, 32
  %61 = add i64 %60, 16
  %62 = call ptr @realloc(ptr null, i64 %61)
  store i32 1, ptr %62, align 4
  %63 = getelementptr inbounds i8, ptr %62, i32 4
  store i32 0, ptr %63, align 4
  %64 = getelementptr inbounds i8, ptr %62, i32 16
  %65 = call ptr @realloc(ptr null, i64 8)
  store ptr %64, ptr %65, align 8
  %66 = insertvalue { ptr, i32, i32, i32 } %17, ptr %65, 0
  %67 = insertvalue { ptr, i32, i32, i32 } %66, i32 %58, 3
  br label %89

68:                                               ; preds = %47
  %69 = extractvalue { ptr, i32, i32, i32 } %17, 2
  %70 = icmp ult i32 %69, %52
  br i1 %70, label %71, label %72

71:                                               ; preds = %68
  br label %86

72:                                               ; preds = %68
  %73 = shl i32 %52, 1
  %74 = call i32 @llvm.umin.i32(i32 %73, i32 1024)
  %75 = add i32 %74, %52
  %76 = call i32 @llvm.umax.i32(i32 %75, i32 8)
  %77 = zext i32 %76 to i64
  %78 = mul i64 %77, 32
  %79 = add i64 %78, 16
  %80 = extractvalue { ptr, i32, i32, i32 } %17, 0
  %81 = load ptr, ptr %80, align 8
  %82 = getelementptr inbounds i8, ptr %81, i32 -16
  %83 = call ptr @realloc(ptr %82, i64 %79)
  %84 = getelementptr inbounds i8, ptr %83, i32 16
  store ptr %84, ptr %80, align 8
  %85 = insertvalue { ptr, i32, i32, i32 } %17, i32 %76, 3
  br label %86

86:                                               ; preds = %71, %72
  %87 = phi { ptr, i32, i32, i32 } [ %85, %72 ], [ %17, %71 ]
  br label %88

88:                                               ; preds = %86
  br label %89

89:                                               ; preds = %54, %88
  %90 = phi { ptr, i32, i32, i32 } [ %87, %88 ], [ %67, %54 ]
  br label %91

91:                                               ; preds = %89
  %92 = extractvalue { ptr, i32, i32, i32 } %90, 0
  %93 = load ptr, ptr %92, align 8
  %94 = extractvalue { ptr, i32, i32, i32 } %90, 2
  %95 = zext i32 %94 to i64
  %96 = mul i64 %95, 32
  %97 = getelementptr inbounds i8, ptr %93, i64 %96
  store i252 0, ptr %97, align 16
  %98 = extractvalue { ptr, i32, i32, i32 } %90, 2
  %99 = add i32 %98, 1
  %100 = insertvalue { ptr, i32, i32, i32 } %90, i32 %99, 2
  %101 = getelementptr inbounds i8, ptr %93, i32 -12
  store i32 %99, ptr %101, align 4
  br label %159

102:                                              ; preds = %32
  %103 = phi i64 [ %24, %32 ]
  %104 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %105 = call ptr %104()
  %106 = load i64, ptr %105, align 8
  %107 = mul i64 %106, 100
  %108 = call i64 @llvm.uadd.sat.i64(i64 %103, i64 %107)
  %109 = extractvalue { ptr, i32, i32, i32 } %17, 3
  %110 = icmp eq i32 %109, 0
  br i1 %110, label %111, label %125

111:                                              ; preds = %102
  %112 = shl i32 %109, 1
  %113 = call i32 @llvm.umin.i32(i32 %112, i32 1024)
  %114 = add i32 %113, %109
  %115 = call i32 @llvm.umax.i32(i32 %114, i32 8)
  %116 = zext i32 %115 to i64
  %117 = mul i64 %116, 32
  %118 = add i64 %117, 16
  %119 = call ptr @realloc(ptr null, i64 %118)
  store i32 1, ptr %119, align 4
  %120 = getelementptr inbounds i8, ptr %119, i32 4
  store i32 0, ptr %120, align 4
  %121 = getelementptr inbounds i8, ptr %119, i32 16
  %122 = call ptr @realloc(ptr null, i64 8)
  store ptr %121, ptr %122, align 8
  %123 = insertvalue { ptr, i32, i32, i32 } %17, ptr %122, 0
  %124 = insertvalue { ptr, i32, i32, i32 } %123, i32 %115, 3
  br label %146

125:                                              ; preds = %102
  %126 = extractvalue { ptr, i32, i32, i32 } %17, 2
  %127 = icmp ult i32 %126, %109
  br i1 %127, label %128, label %129

128:                                              ; preds = %125
  br label %143

129:                                              ; preds = %125
  %130 = shl i32 %109, 1
  %131 = call i32 @llvm.umin.i32(i32 %130, i32 1024)
  %132 = add i32 %131, %109
  %133 = call i32 @llvm.umax.i32(i32 %132, i32 8)
  %134 = zext i32 %133 to i64
  %135 = mul i64 %134, 32
  %136 = add i64 %135, 16
  %137 = extractvalue { ptr, i32, i32, i32 } %17, 0
  %138 = load ptr, ptr %137, align 8
  %139 = getelementptr inbounds i8, ptr %138, i32 -16
  %140 = call ptr @realloc(ptr %139, i64 %136)
  %141 = getelementptr inbounds i8, ptr %140, i32 16
  store ptr %141, ptr %137, align 8
  %142 = insertvalue { ptr, i32, i32, i32 } %17, i32 %133, 3
  br label %143

143:                                              ; preds = %128, %129
  %144 = phi { ptr, i32, i32, i32 } [ %142, %129 ], [ %17, %128 ]
  br label %145

145:                                              ; preds = %143
  br label %146

146:                                              ; preds = %111, %145
  %147 = phi { ptr, i32, i32, i32 } [ %144, %145 ], [ %124, %111 ]
  br label %148

148:                                              ; preds = %146
  %149 = extractvalue { ptr, i32, i32, i32 } %147, 0
  %150 = load ptr, ptr %149, align 8
  %151 = extractvalue { ptr, i32, i32, i32 } %147, 2
  %152 = zext i32 %151 to i64
  %153 = mul i64 %152, 32
  %154 = getelementptr inbounds i8, ptr %150, i64 %153
  store i252 1, ptr %154, align 16
  %155 = extractvalue { ptr, i32, i32, i32 } %147, 2
  %156 = add i32 %155, 1
  %157 = insertvalue { ptr, i32, i32, i32 } %147, i32 %156, 2
  %158 = getelementptr inbounds i8, ptr %150, i32 -12
  store i32 %156, ptr %158, align 4
  br label %159

159:                                              ; preds = %91, %148
  %160 = phi i64 [ %18, %148 ], [ %18, %91 ]
  %161 = phi { { i1, [0 x i8] }, { i32, [16 x i8] } } [ %41, %148 ], [ %41, %91 ]
  %162 = phi { { ptr, i32, i32, i32 } } [ %43, %148 ], [ %43, %91 ]
  %163 = phi i64 [ %108, %148 ], [ %51, %91 ]
  %164 = phi { ptr, i32, i32, i32 } [ %157, %148 ], [ %100, %91 ]
  %165 = extractvalue { { i1, [0 x i8] }, { i32, [16 x i8] } } %161, 1
  store { i32, [16 x i8] } %165, ptr %12, align 4
  %166 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f101"(ptr %12, { ptr, i32, i32, i32 } %164)
  %167 = extractvalue { { ptr, i32, i32, i32 } } %166, 0
  %168 = extractvalue { ptr, ptr, i64 } %8, 1
  %169 = load i64, ptr %168, align 8
  %170 = add i64 %169, 1
  %171 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %170, ptr %171, align 8
  br label %13

172:                                              ; preds = %172, %185, %205
  %173 = phi i64 [ %18, %205 ], [ %18, %185 ], [ %173, %172 ]
  %174 = phi i64 [ %15, %205 ], [ %191, %185 ], [ %174, %172 ]
  %175 = phi { i64, [24 x i8] } [ %210, %205 ], [ %195, %185 ], [ %175, %172 ]
  %176 = extractvalue { ptr, ptr, i64 } %8, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %172

181:                                              ; preds = %172
  %182 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %173, 0
  %183 = insertvalue { i64, i64, { i64, [24 x i8] } } %182, i64 %174, 1
  %184 = insertvalue { i64, i64, { i64, [24 x i8] } } %183, { i64, [24 x i8] } %175, 2
  ret { i64, i64, { i64, [24 x i8] } } %184

185:                                              ; preds = %25
  %186 = phi { ptr, i32, i32, i32 } [ %27, %25 ]
  call void @"drop$16"({ ptr, i32, i32, i32 } %186)
  %187 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %188 = call ptr %187()
  %189 = load i64, ptr %188, align 8
  %190 = mul i64 %189, 5670
  %191 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 %190)
  %192 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %17, 0
  %193 = insertvalue { { ptr, i32, i32, i32 }, {} } %192, {} undef, 1
  %194 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %193, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %194, ptr %11, align 8
  %195 = load { i64, [24 x i8] }, ptr %11, align 8
  %196 = extractvalue { ptr, ptr, i64 } %8, 1
  %197 = load i64, ptr %196, align 8
  %198 = icmp eq i64 %197, 0
  %199 = sub i64 %197, 1
  %200 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %199, ptr %200, align 8
  br i1 %198, label %201, label %172

201:                                              ; preds = %185
  %202 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %18, 0
  %203 = insertvalue { i64, i64, { i64, [24 x i8] } } %202, i64 %191, 1
  %204 = insertvalue { i64, i64, { i64, [24 x i8] } } %203, { i64, [24 x i8] } %195, 2
  ret { i64, i64, { i64, [24 x i8] } } %204

205:                                              ; preds = %13
  %206 = phi { { ptr, i32, i32, i32 } } [ %16, %13 ]
  call void @"drop$17"({ { ptr, i32, i32, i32 } } %206)
  call void @"drop$26"({ ptr, i32, i32, i32 } %17)
  %207 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %208 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %207, 0
  %209 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %208, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %209, ptr %10, align 8
  %210 = load { i64, [24 x i8] }, ptr %10, align 8
  %211 = extractvalue { ptr, ptr, i64 } %8, 1
  %212 = load i64, ptr %211, align 8
  %213 = icmp eq i64 %212, 0
  %214 = sub i64 %212, 1
  %215 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %214, ptr %215, align 8
  br i1 %213, label %216, label %172

216:                                              ; preds = %205
  %217 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %18, 0
  %218 = insertvalue { i64, i64, { i64, [24 x i8] } } %217, i64 %15, 1
  %219 = insertvalue { i64, i64, { i64, [24 x i8] } } %218, { i64, [24 x i8] } %210, 2
  ret { i64, i64, { i64, [24 x i8] } } %219

220:                                              ; preds = %45
  call void @puts(ptr @assert_msg_166)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f98(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f98"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f98(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f98(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$5"(ptr %0) {
  %2 = load { i252, { i128, [80 x i8] } }, ptr %0, align 16
  call void @"drop$151"({ i252, { i128, [80 x i8] } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$5"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 128)
  %3 = load { i252, { i128, [80 x i8] } }, ptr %0, align 16
  %4 = call { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } @"dup$151"({ i252, { i128, [80 x i8] } } %3)
  %5 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %4, 0
  %6 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %4, 1
  store { i252, { i128, [80 x i8] } } %5, ptr %0, align 16
  store { i252, { i128, [80 x i8] } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f99"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %107, %4
  %16 = phi i64 [ %101, %107 ], [ %0, %4 ]
  %17 = phi i64 [ %112, %107 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %113, %107 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %114, %107 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 9820
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %166

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %146

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 128
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 128)
  %43 = load { i252, { i128, [80 x i8] } }, ptr %39, align 16
  %44 = call { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } @"dup$151"({ i252, { i128, [80 x i8] } } %43)
  %45 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %44, 0
  %46 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %44, 1
  store { i252, { i128, [80 x i8] } } %45, ptr %39, align 16
  store { i252, { i128, [80 x i8] } } %46, ptr %42, align 16
  %47 = load { i252, { i128, [80 x i8] } }, ptr %42, align 16
  call void @free(ptr %42)
  %48 = extractvalue { i252, { i128, [80 x i8] } } %47, 0
  %49 = extractvalue { i252, { i128, [80 x i8] } } %47, 1
  %50 = extractvalue { ptr, i32, i32, i32 } %19, 3
  %51 = icmp eq i32 %50, 0
  br i1 %51, label %52, label %66

52:                                               ; preds = %34
  %53 = shl i32 %50, 1
  %54 = call i32 @llvm.umin.i32(i32 %53, i32 1024)
  %55 = add i32 %54, %50
  %56 = call i32 @llvm.umax.i32(i32 %55, i32 8)
  %57 = zext i32 %56 to i64
  %58 = mul i64 %57, 32
  %59 = add i64 %58, 16
  %60 = call ptr @realloc(ptr null, i64 %59)
  store i32 1, ptr %60, align 4
  %61 = getelementptr inbounds i8, ptr %60, i32 4
  store i32 0, ptr %61, align 4
  %62 = getelementptr inbounds i8, ptr %60, i32 16
  %63 = call ptr @realloc(ptr null, i64 8)
  store ptr %62, ptr %63, align 8
  %64 = insertvalue { ptr, i32, i32, i32 } %19, ptr %63, 0
  %65 = insertvalue { ptr, i32, i32, i32 } %64, i32 %56, 3
  br label %87

66:                                               ; preds = %34
  %67 = extractvalue { ptr, i32, i32, i32 } %19, 2
  %68 = icmp ult i32 %67, %50
  br i1 %68, label %69, label %70

69:                                               ; preds = %66
  br label %84

70:                                               ; preds = %66
  %71 = shl i32 %50, 1
  %72 = call i32 @llvm.umin.i32(i32 %71, i32 1024)
  %73 = add i32 %72, %50
  %74 = call i32 @llvm.umax.i32(i32 %73, i32 8)
  %75 = zext i32 %74 to i64
  %76 = mul i64 %75, 32
  %77 = add i64 %76, 16
  %78 = extractvalue { ptr, i32, i32, i32 } %19, 0
  %79 = load ptr, ptr %78, align 8
  %80 = getelementptr inbounds i8, ptr %79, i32 -16
  %81 = call ptr @realloc(ptr %80, i64 %77)
  %82 = getelementptr inbounds i8, ptr %81, i32 16
  store ptr %82, ptr %78, align 8
  %83 = insertvalue { ptr, i32, i32, i32 } %19, i32 %74, 3
  br label %84

84:                                               ; preds = %69, %70
  %85 = phi { ptr, i32, i32, i32 } [ %83, %70 ], [ %19, %69 ]
  br label %86

86:                                               ; preds = %84
  br label %87

87:                                               ; preds = %52, %86
  %88 = phi { ptr, i32, i32, i32 } [ %85, %86 ], [ %65, %52 ]
  br label %89

89:                                               ; preds = %87
  %90 = extractvalue { ptr, i32, i32, i32 } %88, 0
  %91 = load ptr, ptr %90, align 8
  %92 = extractvalue { ptr, i32, i32, i32 } %88, 2
  %93 = zext i32 %92 to i64
  %94 = mul i64 %93, 32
  %95 = getelementptr inbounds i8, ptr %91, i64 %94
  store i252 %48, ptr %95, align 16
  %96 = extractvalue { ptr, i32, i32, i32 } %88, 2
  %97 = add i32 %96, 1
  %98 = insertvalue { ptr, i32, i32, i32 } %88, i32 %97, 2
  %99 = getelementptr inbounds i8, ptr %91, i32 -12
  store i32 %97, ptr %99, align 4
  store { i128, [80 x i8] } %49, ptr %12, align 16
  %100 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %20, i64 %26, ptr %12, { ptr, i32, i32, i32 } %98)
  %101 = extractvalue { i64, i64, { i64, [24 x i8] } } %100, 0
  %102 = extractvalue { i64, i64, { i64, [24 x i8] } } %100, 1
  %103 = extractvalue { i64, i64, { i64, [24 x i8] } } %100, 2
  store { i64, [24 x i8] } %103, ptr %13, align 8
  %104 = load i1, ptr %13, align 1
  switch i1 %104, label %105 [
    i1 false, label %107
    i1 true, label %119
  ]

105:                                              ; preds = %89
  br i1 false, label %106, label %181

106:                                              ; preds = %105
  unreachable

107:                                              ; preds = %89
  %108 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %109 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %108, 1
  %110 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %111 = call ptr %110()
  %112 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 0)
  %113 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %114 = extractvalue { { ptr, i32, i32, i32 }, {} } %109, 0
  %115 = extractvalue { ptr, ptr, i64 } %8, 1
  %116 = load i64, ptr %115, align 8
  %117 = add i64 %116, 1
  %118 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %117, ptr %118, align 8
  br label %15

119:                                              ; preds = %89
  %120 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %121 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %120, 1
  call void @"drop$7"({ ptr, i32, i32, i32 } %41)
  %122 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %121, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %122, ptr %14, align 8
  %123 = load { i64, [24 x i8] }, ptr %14, align 8
  %124 = extractvalue { ptr, ptr, i64 } %8, 1
  %125 = load i64, ptr %124, align 8
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %125, 1
  %128 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %127, ptr %128, align 8
  br i1 %126, label %142, label %129

129:                                              ; preds = %129, %119, %146, %166
  %130 = phi i64 [ %20, %166 ], [ %20, %146 ], [ %130, %129 ], [ %101, %119 ]
  %131 = phi i64 [ %17, %166 ], [ %152, %146 ], [ %131, %129 ], [ %102, %119 ]
  %132 = phi { i64, [24 x i8] } [ %171, %166 ], [ %156, %146 ], [ %132, %129 ], [ %123, %119 ]
  %133 = extractvalue { ptr, ptr, i64 } %8, 1
  %134 = load i64, ptr %133, align 8
  %135 = icmp eq i64 %134, 0
  %136 = sub i64 %134, 1
  %137 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %136, ptr %137, align 8
  br i1 %135, label %138, label %129

138:                                              ; preds = %129
  %139 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %130, 0
  %140 = insertvalue { i64, i64, { i64, [24 x i8] } } %139, i64 %131, 1
  %141 = insertvalue { i64, i64, { i64, [24 x i8] } } %140, { i64, [24 x i8] } %132, 2
  ret { i64, i64, { i64, [24 x i8] } } %141

142:                                              ; preds = %119
  %143 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %101, 0
  %144 = insertvalue { i64, i64, { i64, [24 x i8] } } %143, i64 %102, 1
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } %144, { i64, [24 x i8] } %123, 2
  ret { i64, i64, { i64, [24 x i8] } } %145

146:                                              ; preds = %27
  %147 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$7"({ ptr, i32, i32, i32 } %147)
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = load i64, ptr %149, align 8
  %151 = mul i64 %150, 10520
  %152 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %151)
  %153 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %19, 0
  %154 = insertvalue { { ptr, i32, i32, i32 }, {} } %153, {} undef, 1
  %155 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %154, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %155, ptr %11, align 8
  %156 = load { i64, [24 x i8] }, ptr %11, align 8
  %157 = extractvalue { ptr, ptr, i64 } %8, 1
  %158 = load i64, ptr %157, align 8
  %159 = icmp eq i64 %158, 0
  %160 = sub i64 %158, 1
  %161 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %160, ptr %161, align 8
  br i1 %159, label %162, label %129

162:                                              ; preds = %146
  %163 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %164 = insertvalue { i64, i64, { i64, [24 x i8] } } %163, i64 %152, 1
  %165 = insertvalue { i64, i64, { i64, [24 x i8] } } %164, { i64, [24 x i8] } %156, 2
  ret { i64, i64, { i64, [24 x i8] } } %165

166:                                              ; preds = %15
  %167 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  call void @"drop$33"({ { ptr, i32, i32, i32 } } %167)
  call void @"drop$26"({ ptr, i32, i32, i32 } %19)
  %168 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %169 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %168, 0
  %170 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %169, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %170, ptr %10, align 8
  %171 = load { i64, [24 x i8] }, ptr %10, align 8
  %172 = extractvalue { ptr, ptr, i64 } %8, 1
  %173 = load i64, ptr %172, align 8
  %174 = icmp eq i64 %173, 0
  %175 = sub i64 %173, 1
  %176 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %175, ptr %176, align 8
  br i1 %174, label %177, label %129

177:                                              ; preds = %166
  %178 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %179 = insertvalue { i64, i64, { i64, [24 x i8] } } %178, i64 %17, 1
  %180 = insertvalue { i64, i64, { i64, [24 x i8] } } %179, { i64, [24 x i8] } %171, 2
  ret { i64, i64, { i64, [24 x i8] } } %180

181:                                              ; preds = %105
  call void @puts(ptr @assert_msg_167)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f99(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f99"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f99(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f99(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$1"(ptr %0) {
  %2 = load { i128, [80 x i8] }, ptr %0, align 16
  call void @"drop$35"({ i128, [80 x i8] } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$1"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 96)
  %3 = load { i128, [80 x i8] }, ptr %0, align 16
  %4 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$35"({ i128, [80 x i8] } %3)
  %5 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %4, 0
  %6 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %4, 1
  store { i128, [80 x i8] } %5, ptr %0, align 16
  store { i128, [80 x i8] } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f100"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %55, %4
  %16 = phi i64 [ %49, %55 ], [ %0, %4 ]
  %17 = phi i64 [ %60, %55 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %61, %55 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %62, %55 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 9620
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %114

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %94

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 96
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 96)
  %43 = load { i128, [80 x i8] }, ptr %39, align 16
  %44 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$35"({ i128, [80 x i8] } %43)
  %45 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %44, 0
  %46 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %44, 1
  store { i128, [80 x i8] } %45, ptr %39, align 16
  store { i128, [80 x i8] } %46, ptr %42, align 16
  %47 = load { i128, [80 x i8] }, ptr %42, align 16
  call void @free(ptr %42)
  store { i128, [80 x i8] } %47, ptr %12, align 16
  %48 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %20, i64 %26, ptr %12, { ptr, i32, i32, i32 } %19)
  %49 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 1
  %51 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 2
  store { i64, [24 x i8] } %51, ptr %13, align 8
  %52 = load i1, ptr %13, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %67
  ]

53:                                               ; preds = %34
  br i1 false, label %54, label %129

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %34
  %56 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %57 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %56, 1
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 0)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %62 = extractvalue { { ptr, i32, i32, i32 }, {} } %57, 0
  %63 = extractvalue { ptr, ptr, i64 } %8, 1
  %64 = load i64, ptr %63, align 8
  %65 = add i64 %64, 1
  %66 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %65, ptr %66, align 8
  br label %15

67:                                               ; preds = %34
  %68 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %69 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %68, 1
  call void @"drop$3"({ ptr, i32, i32, i32 } %41)
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %14, align 8
  %71 = load { i64, [24 x i8] }, ptr %14, align 8
  %72 = extractvalue { ptr, ptr, i64 } %8, 1
  %73 = load i64, ptr %72, align 8
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %73, 1
  %76 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %75, ptr %76, align 8
  br i1 %74, label %90, label %77

77:                                               ; preds = %77, %67, %94, %114
  %78 = phi i64 [ %20, %114 ], [ %20, %94 ], [ %78, %77 ], [ %49, %67 ]
  %79 = phi i64 [ %17, %114 ], [ %100, %94 ], [ %79, %77 ], [ %50, %67 ]
  %80 = phi { i64, [24 x i8] } [ %119, %114 ], [ %104, %94 ], [ %80, %77 ], [ %71, %67 ]
  %81 = extractvalue { ptr, ptr, i64 } %8, 1
  %82 = load i64, ptr %81, align 8
  %83 = icmp eq i64 %82, 0
  %84 = sub i64 %82, 1
  %85 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %84, ptr %85, align 8
  br i1 %83, label %86, label %77

86:                                               ; preds = %77
  %87 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %78, 0
  %88 = insertvalue { i64, i64, { i64, [24 x i8] } } %87, i64 %79, 1
  %89 = insertvalue { i64, i64, { i64, [24 x i8] } } %88, { i64, [24 x i8] } %80, 2
  ret { i64, i64, { i64, [24 x i8] } } %89

90:                                               ; preds = %67
  %91 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %49, 0
  %92 = insertvalue { i64, i64, { i64, [24 x i8] } } %91, i64 %50, 1
  %93 = insertvalue { i64, i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %71, 2
  ret { i64, i64, { i64, [24 x i8] } } %93

94:                                               ; preds = %27
  %95 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %95)
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = load i64, ptr %97, align 8
  %99 = mul i64 %98, 10320
  %100 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %99)
  %101 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %19, 0
  %102 = insertvalue { { ptr, i32, i32, i32 }, {} } %101, {} undef, 1
  %103 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %102, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %103, ptr %11, align 8
  %104 = load { i64, [24 x i8] }, ptr %11, align 8
  %105 = extractvalue { ptr, ptr, i64 } %8, 1
  %106 = load i64, ptr %105, align 8
  %107 = icmp eq i64 %106, 0
  %108 = sub i64 %106, 1
  %109 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %108, ptr %109, align 8
  br i1 %107, label %110, label %77

110:                                              ; preds = %94
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, i64 %100, 1
  %113 = insertvalue { i64, i64, { i64, [24 x i8] } } %112, { i64, [24 x i8] } %104, 2
  ret { i64, i64, { i64, [24 x i8] } } %113

114:                                              ; preds = %15
  %115 = phi { ptr, i32, i32, i32 } [ %19, %15 ]
  call void @"drop$26"({ ptr, i32, i32, i32 } %115)
  call void @"drop$12"({ { ptr, i32, i32, i32 } } %18)
  %116 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %117 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %116, 0
  %118 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %117, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %118, ptr %10, align 8
  %119 = load { i64, [24 x i8] }, ptr %10, align 8
  %120 = extractvalue { ptr, ptr, i64 } %8, 1
  %121 = load i64, ptr %120, align 8
  %122 = icmp eq i64 %121, 0
  %123 = sub i64 %121, 1
  %124 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %123, ptr %124, align 8
  br i1 %122, label %125, label %77

125:                                              ; preds = %114
  %126 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %127 = insertvalue { i64, i64, { i64, [24 x i8] } } %126, i64 %17, 1
  %128 = insertvalue { i64, i64, { i64, [24 x i8] } } %127, { i64, [24 x i8] } %119, 2
  ret { i64, i64, { i64, [24 x i8] } } %128

129:                                              ; preds = %53
  call void @puts(ptr @assert_msg_168)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f100(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f100"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f100(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f100(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { { ptr, i32, i32, i32 } } @"impl$f101"(ptr %0, { ptr, i32, i32, i32 } %1) {
  %3 = alloca { i32, [16 x i8] }, i64 1, align 4
  %4 = load { i32, [16 x i8] }, ptr %0, align 4
  store { i32, [16 x i8] } %4, ptr %3, align 4
  %5 = load i3, ptr %3, align 1
  switch i3 %5, label %6 [
    i3 0, label %8
    i3 1, label %117
    i3 2, label %395
    i3 3, label %450
    i3 -4, label %606
  ]

6:                                                ; preds = %2
  br i1 false, label %7, label %985

7:                                                ; preds = %6
  unreachable

8:                                                ; preds = %2
  %9 = load { i3, i32 }, ptr %3, align 4
  %10 = extractvalue { i3, i32 } %9, 1
  %11 = icmp slt i32 %10, 0
  %12 = zext i32 %10 to i252
  %13 = call i32 @llvm.abs.i32(i32 %10, i1 false)
  %14 = zext i32 %13 to i252
  %15 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %14
  %16 = select i1 %11, i252 %15, i252 %12
  %17 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %33

19:                                               ; preds = %8
  %20 = shl i32 %17, 1
  %21 = call i32 @llvm.umin.i32(i32 %20, i32 1024)
  %22 = add i32 %21, %17
  %23 = call i32 @llvm.umax.i32(i32 %22, i32 8)
  %24 = zext i32 %23 to i64
  %25 = mul i64 %24, 32
  %26 = add i64 %25, 16
  %27 = call ptr @realloc(ptr null, i64 %26)
  store i32 1, ptr %27, align 4
  %28 = getelementptr inbounds i8, ptr %27, i32 4
  store i32 0, ptr %28, align 4
  %29 = getelementptr inbounds i8, ptr %27, i32 16
  %30 = call ptr @realloc(ptr null, i64 8)
  store ptr %29, ptr %30, align 8
  %31 = insertvalue { ptr, i32, i32, i32 } %1, ptr %30, 0
  %32 = insertvalue { ptr, i32, i32, i32 } %31, i32 %23, 3
  br label %54

33:                                               ; preds = %8
  %34 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %35 = icmp ult i32 %34, %17
  br i1 %35, label %36, label %37

36:                                               ; preds = %33
  br label %51

37:                                               ; preds = %33
  %38 = shl i32 %17, 1
  %39 = call i32 @llvm.umin.i32(i32 %38, i32 1024)
  %40 = add i32 %39, %17
  %41 = call i32 @llvm.umax.i32(i32 %40, i32 8)
  %42 = zext i32 %41 to i64
  %43 = mul i64 %42, 32
  %44 = add i64 %43, 16
  %45 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %46 = load ptr, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %46, i32 -16
  %48 = call ptr @realloc(ptr %47, i64 %44)
  %49 = getelementptr inbounds i8, ptr %48, i32 16
  store ptr %49, ptr %45, align 8
  %50 = insertvalue { ptr, i32, i32, i32 } %1, i32 %41, 3
  br label %51

51:                                               ; preds = %36, %37
  %52 = phi { ptr, i32, i32, i32 } [ %50, %37 ], [ %1, %36 ]
  br label %53

53:                                               ; preds = %51
  br label %54

54:                                               ; preds = %19, %53
  %55 = phi { ptr, i32, i32, i32 } [ %52, %53 ], [ %32, %19 ]
  br label %56

56:                                               ; preds = %54
  %57 = extractvalue { ptr, i32, i32, i32 } %55, 0
  %58 = load ptr, ptr %57, align 8
  %59 = extractvalue { ptr, i32, i32, i32 } %55, 2
  %60 = zext i32 %59 to i64
  %61 = mul i64 %60, 32
  %62 = getelementptr inbounds i8, ptr %58, i64 %61
  store i252 0, ptr %62, align 16
  %63 = extractvalue { ptr, i32, i32, i32 } %55, 2
  %64 = add i32 %63, 1
  %65 = insertvalue { ptr, i32, i32, i32 } %55, i32 %64, 2
  %66 = getelementptr inbounds i8, ptr %58, i32 -12
  store i32 %64, ptr %66, align 4
  %67 = extractvalue { ptr, i32, i32, i32 } %55, 3
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %69, label %83

69:                                               ; preds = %56
  %70 = shl i32 %67, 1
  %71 = call i32 @llvm.umin.i32(i32 %70, i32 1024)
  %72 = add i32 %71, %67
  %73 = call i32 @llvm.umax.i32(i32 %72, i32 8)
  %74 = zext i32 %73 to i64
  %75 = mul i64 %74, 32
  %76 = add i64 %75, 16
  %77 = call ptr @realloc(ptr null, i64 %76)
  store i32 1, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %77, i32 4
  store i32 0, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %77, i32 16
  %80 = call ptr @realloc(ptr null, i64 8)
  store ptr %79, ptr %80, align 8
  %81 = insertvalue { ptr, i32, i32, i32 } %65, ptr %80, 0
  %82 = insertvalue { ptr, i32, i32, i32 } %81, i32 %73, 3
  br label %103

83:                                               ; preds = %56
  %84 = icmp ult i32 %64, %67
  br i1 %84, label %85, label %86

85:                                               ; preds = %83
  br label %100

86:                                               ; preds = %83
  %87 = shl i32 %67, 1
  %88 = call i32 @llvm.umin.i32(i32 %87, i32 1024)
  %89 = add i32 %88, %67
  %90 = call i32 @llvm.umax.i32(i32 %89, i32 8)
  %91 = zext i32 %90 to i64
  %92 = mul i64 %91, 32
  %93 = add i64 %92, 16
  %94 = extractvalue { ptr, i32, i32, i32 } %55, 0
  %95 = load ptr, ptr %94, align 8
  %96 = getelementptr inbounds i8, ptr %95, i32 -16
  %97 = call ptr @realloc(ptr %96, i64 %93)
  %98 = getelementptr inbounds i8, ptr %97, i32 16
  store ptr %98, ptr %94, align 8
  %99 = insertvalue { ptr, i32, i32, i32 } %65, i32 %90, 3
  br label %100

100:                                              ; preds = %85, %86
  %101 = phi { ptr, i32, i32, i32 } [ %99, %86 ], [ %65, %85 ]
  br label %102

102:                                              ; preds = %100
  br label %103

103:                                              ; preds = %69, %102
  %104 = phi { ptr, i32, i32, i32 } [ %101, %102 ], [ %82, %69 ]
  br label %105

105:                                              ; preds = %103
  %106 = extractvalue { ptr, i32, i32, i32 } %104, 0
  %107 = load ptr, ptr %106, align 8
  %108 = extractvalue { ptr, i32, i32, i32 } %104, 2
  %109 = zext i32 %108 to i64
  %110 = mul i64 %109, 32
  %111 = getelementptr inbounds i8, ptr %107, i64 %110
  store i252 %16, ptr %111, align 16
  %112 = extractvalue { ptr, i32, i32, i32 } %104, 2
  %113 = add i32 %112, 1
  %114 = insertvalue { ptr, i32, i32, i32 } %104, i32 %113, 2
  %115 = getelementptr inbounds i8, ptr %107, i32 -12
  store i32 %113, ptr %115, align 4
  %116 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %114, 0
  ret { { ptr, i32, i32, i32 } } %116

117:                                              ; preds = %2
  %118 = load { i3, { i32, i32, i32, i32 } }, ptr %3, align 4
  %119 = extractvalue { i3, { i32, i32, i32, i32 } } %118, 1
  %120 = extractvalue { i32, i32, i32, i32 } %119, 0
  %121 = icmp slt i32 %120, 0
  %122 = zext i32 %120 to i252
  %123 = call i32 @llvm.abs.i32(i32 %120, i1 false)
  %124 = zext i32 %123 to i252
  %125 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %124
  %126 = select i1 %121, i252 %125, i252 %122
  %127 = extractvalue { i32, i32, i32, i32 } %119, 1
  %128 = icmp slt i32 %127, 0
  %129 = zext i32 %127 to i252
  %130 = call i32 @llvm.abs.i32(i32 %127, i1 false)
  %131 = zext i32 %130 to i252
  %132 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %131
  %133 = select i1 %128, i252 %132, i252 %129
  %134 = extractvalue { i32, i32, i32, i32 } %119, 2
  %135 = icmp slt i32 %134, 0
  %136 = zext i32 %134 to i252
  %137 = call i32 @llvm.abs.i32(i32 %134, i1 false)
  %138 = zext i32 %137 to i252
  %139 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %138
  %140 = select i1 %135, i252 %139, i252 %136
  %141 = extractvalue { i32, i32, i32, i32 } %119, 3
  %142 = icmp slt i32 %141, 0
  %143 = zext i32 %141 to i252
  %144 = call i32 @llvm.abs.i32(i32 %141, i1 false)
  %145 = zext i32 %144 to i252
  %146 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %145
  %147 = select i1 %142, i252 %146, i252 %143
  %148 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %149 = icmp eq i32 %148, 0
  br i1 %149, label %150, label %164

150:                                              ; preds = %117
  %151 = shl i32 %148, 1
  %152 = call i32 @llvm.umin.i32(i32 %151, i32 1024)
  %153 = add i32 %152, %148
  %154 = call i32 @llvm.umax.i32(i32 %153, i32 8)
  %155 = zext i32 %154 to i64
  %156 = mul i64 %155, 32
  %157 = add i64 %156, 16
  %158 = call ptr @realloc(ptr null, i64 %157)
  store i32 1, ptr %158, align 4
  %159 = getelementptr inbounds i8, ptr %158, i32 4
  store i32 0, ptr %159, align 4
  %160 = getelementptr inbounds i8, ptr %158, i32 16
  %161 = call ptr @realloc(ptr null, i64 8)
  store ptr %160, ptr %161, align 8
  %162 = insertvalue { ptr, i32, i32, i32 } %1, ptr %161, 0
  %163 = insertvalue { ptr, i32, i32, i32 } %162, i32 %154, 3
  br label %185

164:                                              ; preds = %117
  %165 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %166 = icmp ult i32 %165, %148
  br i1 %166, label %167, label %168

167:                                              ; preds = %164
  br label %182

168:                                              ; preds = %164
  %169 = shl i32 %148, 1
  %170 = call i32 @llvm.umin.i32(i32 %169, i32 1024)
  %171 = add i32 %170, %148
  %172 = call i32 @llvm.umax.i32(i32 %171, i32 8)
  %173 = zext i32 %172 to i64
  %174 = mul i64 %173, 32
  %175 = add i64 %174, 16
  %176 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %177 = load ptr, ptr %176, align 8
  %178 = getelementptr inbounds i8, ptr %177, i32 -16
  %179 = call ptr @realloc(ptr %178, i64 %175)
  %180 = getelementptr inbounds i8, ptr %179, i32 16
  store ptr %180, ptr %176, align 8
  %181 = insertvalue { ptr, i32, i32, i32 } %1, i32 %172, 3
  br label %182

182:                                              ; preds = %167, %168
  %183 = phi { ptr, i32, i32, i32 } [ %181, %168 ], [ %1, %167 ]
  br label %184

184:                                              ; preds = %182
  br label %185

185:                                              ; preds = %150, %184
  %186 = phi { ptr, i32, i32, i32 } [ %183, %184 ], [ %163, %150 ]
  br label %187

187:                                              ; preds = %185
  %188 = extractvalue { ptr, i32, i32, i32 } %186, 0
  %189 = load ptr, ptr %188, align 8
  %190 = extractvalue { ptr, i32, i32, i32 } %186, 2
  %191 = zext i32 %190 to i64
  %192 = mul i64 %191, 32
  %193 = getelementptr inbounds i8, ptr %189, i64 %192
  store i252 1, ptr %193, align 16
  %194 = extractvalue { ptr, i32, i32, i32 } %186, 2
  %195 = add i32 %194, 1
  %196 = insertvalue { ptr, i32, i32, i32 } %186, i32 %195, 2
  %197 = getelementptr inbounds i8, ptr %189, i32 -12
  store i32 %195, ptr %197, align 4
  %198 = extractvalue { ptr, i32, i32, i32 } %186, 3
  %199 = icmp eq i32 %198, 0
  br i1 %199, label %200, label %214

200:                                              ; preds = %187
  %201 = shl i32 %198, 1
  %202 = call i32 @llvm.umin.i32(i32 %201, i32 1024)
  %203 = add i32 %202, %198
  %204 = call i32 @llvm.umax.i32(i32 %203, i32 8)
  %205 = zext i32 %204 to i64
  %206 = mul i64 %205, 32
  %207 = add i64 %206, 16
  %208 = call ptr @realloc(ptr null, i64 %207)
  store i32 1, ptr %208, align 4
  %209 = getelementptr inbounds i8, ptr %208, i32 4
  store i32 0, ptr %209, align 4
  %210 = getelementptr inbounds i8, ptr %208, i32 16
  %211 = call ptr @realloc(ptr null, i64 8)
  store ptr %210, ptr %211, align 8
  %212 = insertvalue { ptr, i32, i32, i32 } %196, ptr %211, 0
  %213 = insertvalue { ptr, i32, i32, i32 } %212, i32 %204, 3
  br label %234

214:                                              ; preds = %187
  %215 = icmp ult i32 %195, %198
  br i1 %215, label %216, label %217

216:                                              ; preds = %214
  br label %231

217:                                              ; preds = %214
  %218 = shl i32 %198, 1
  %219 = call i32 @llvm.umin.i32(i32 %218, i32 1024)
  %220 = add i32 %219, %198
  %221 = call i32 @llvm.umax.i32(i32 %220, i32 8)
  %222 = zext i32 %221 to i64
  %223 = mul i64 %222, 32
  %224 = add i64 %223, 16
  %225 = extractvalue { ptr, i32, i32, i32 } %186, 0
  %226 = load ptr, ptr %225, align 8
  %227 = getelementptr inbounds i8, ptr %226, i32 -16
  %228 = call ptr @realloc(ptr %227, i64 %224)
  %229 = getelementptr inbounds i8, ptr %228, i32 16
  store ptr %229, ptr %225, align 8
  %230 = insertvalue { ptr, i32, i32, i32 } %196, i32 %221, 3
  br label %231

231:                                              ; preds = %216, %217
  %232 = phi { ptr, i32, i32, i32 } [ %230, %217 ], [ %196, %216 ]
  br label %233

233:                                              ; preds = %231
  br label %234

234:                                              ; preds = %200, %233
  %235 = phi { ptr, i32, i32, i32 } [ %232, %233 ], [ %213, %200 ]
  br label %236

236:                                              ; preds = %234
  %237 = extractvalue { ptr, i32, i32, i32 } %235, 0
  %238 = load ptr, ptr %237, align 8
  %239 = extractvalue { ptr, i32, i32, i32 } %235, 2
  %240 = zext i32 %239 to i64
  %241 = mul i64 %240, 32
  %242 = getelementptr inbounds i8, ptr %238, i64 %241
  store i252 %126, ptr %242, align 16
  %243 = extractvalue { ptr, i32, i32, i32 } %235, 2
  %244 = add i32 %243, 1
  %245 = insertvalue { ptr, i32, i32, i32 } %235, i32 %244, 2
  %246 = getelementptr inbounds i8, ptr %238, i32 -12
  store i32 %244, ptr %246, align 4
  %247 = extractvalue { ptr, i32, i32, i32 } %235, 3
  %248 = icmp eq i32 %247, 0
  br i1 %248, label %249, label %263

249:                                              ; preds = %236
  %250 = shl i32 %247, 1
  %251 = call i32 @llvm.umin.i32(i32 %250, i32 1024)
  %252 = add i32 %251, %247
  %253 = call i32 @llvm.umax.i32(i32 %252, i32 8)
  %254 = zext i32 %253 to i64
  %255 = mul i64 %254, 32
  %256 = add i64 %255, 16
  %257 = call ptr @realloc(ptr null, i64 %256)
  store i32 1, ptr %257, align 4
  %258 = getelementptr inbounds i8, ptr %257, i32 4
  store i32 0, ptr %258, align 4
  %259 = getelementptr inbounds i8, ptr %257, i32 16
  %260 = call ptr @realloc(ptr null, i64 8)
  store ptr %259, ptr %260, align 8
  %261 = insertvalue { ptr, i32, i32, i32 } %245, ptr %260, 0
  %262 = insertvalue { ptr, i32, i32, i32 } %261, i32 %253, 3
  br label %283

263:                                              ; preds = %236
  %264 = icmp ult i32 %244, %247
  br i1 %264, label %265, label %266

265:                                              ; preds = %263
  br label %280

266:                                              ; preds = %263
  %267 = shl i32 %247, 1
  %268 = call i32 @llvm.umin.i32(i32 %267, i32 1024)
  %269 = add i32 %268, %247
  %270 = call i32 @llvm.umax.i32(i32 %269, i32 8)
  %271 = zext i32 %270 to i64
  %272 = mul i64 %271, 32
  %273 = add i64 %272, 16
  %274 = extractvalue { ptr, i32, i32, i32 } %235, 0
  %275 = load ptr, ptr %274, align 8
  %276 = getelementptr inbounds i8, ptr %275, i32 -16
  %277 = call ptr @realloc(ptr %276, i64 %273)
  %278 = getelementptr inbounds i8, ptr %277, i32 16
  store ptr %278, ptr %274, align 8
  %279 = insertvalue { ptr, i32, i32, i32 } %245, i32 %270, 3
  br label %280

280:                                              ; preds = %265, %266
  %281 = phi { ptr, i32, i32, i32 } [ %279, %266 ], [ %245, %265 ]
  br label %282

282:                                              ; preds = %280
  br label %283

283:                                              ; preds = %249, %282
  %284 = phi { ptr, i32, i32, i32 } [ %281, %282 ], [ %262, %249 ]
  br label %285

285:                                              ; preds = %283
  %286 = extractvalue { ptr, i32, i32, i32 } %284, 0
  %287 = load ptr, ptr %286, align 8
  %288 = extractvalue { ptr, i32, i32, i32 } %284, 2
  %289 = zext i32 %288 to i64
  %290 = mul i64 %289, 32
  %291 = getelementptr inbounds i8, ptr %287, i64 %290
  store i252 %133, ptr %291, align 16
  %292 = extractvalue { ptr, i32, i32, i32 } %284, 2
  %293 = add i32 %292, 1
  %294 = insertvalue { ptr, i32, i32, i32 } %284, i32 %293, 2
  %295 = getelementptr inbounds i8, ptr %287, i32 -12
  store i32 %293, ptr %295, align 4
  %296 = extractvalue { ptr, i32, i32, i32 } %284, 3
  %297 = icmp eq i32 %296, 0
  br i1 %297, label %298, label %312

298:                                              ; preds = %285
  %299 = shl i32 %296, 1
  %300 = call i32 @llvm.umin.i32(i32 %299, i32 1024)
  %301 = add i32 %300, %296
  %302 = call i32 @llvm.umax.i32(i32 %301, i32 8)
  %303 = zext i32 %302 to i64
  %304 = mul i64 %303, 32
  %305 = add i64 %304, 16
  %306 = call ptr @realloc(ptr null, i64 %305)
  store i32 1, ptr %306, align 4
  %307 = getelementptr inbounds i8, ptr %306, i32 4
  store i32 0, ptr %307, align 4
  %308 = getelementptr inbounds i8, ptr %306, i32 16
  %309 = call ptr @realloc(ptr null, i64 8)
  store ptr %308, ptr %309, align 8
  %310 = insertvalue { ptr, i32, i32, i32 } %294, ptr %309, 0
  %311 = insertvalue { ptr, i32, i32, i32 } %310, i32 %302, 3
  br label %332

312:                                              ; preds = %285
  %313 = icmp ult i32 %293, %296
  br i1 %313, label %314, label %315

314:                                              ; preds = %312
  br label %329

315:                                              ; preds = %312
  %316 = shl i32 %296, 1
  %317 = call i32 @llvm.umin.i32(i32 %316, i32 1024)
  %318 = add i32 %317, %296
  %319 = call i32 @llvm.umax.i32(i32 %318, i32 8)
  %320 = zext i32 %319 to i64
  %321 = mul i64 %320, 32
  %322 = add i64 %321, 16
  %323 = extractvalue { ptr, i32, i32, i32 } %284, 0
  %324 = load ptr, ptr %323, align 8
  %325 = getelementptr inbounds i8, ptr %324, i32 -16
  %326 = call ptr @realloc(ptr %325, i64 %322)
  %327 = getelementptr inbounds i8, ptr %326, i32 16
  store ptr %327, ptr %323, align 8
  %328 = insertvalue { ptr, i32, i32, i32 } %294, i32 %319, 3
  br label %329

329:                                              ; preds = %314, %315
  %330 = phi { ptr, i32, i32, i32 } [ %328, %315 ], [ %294, %314 ]
  br label %331

331:                                              ; preds = %329
  br label %332

332:                                              ; preds = %298, %331
  %333 = phi { ptr, i32, i32, i32 } [ %330, %331 ], [ %311, %298 ]
  br label %334

334:                                              ; preds = %332
  %335 = extractvalue { ptr, i32, i32, i32 } %333, 0
  %336 = load ptr, ptr %335, align 8
  %337 = extractvalue { ptr, i32, i32, i32 } %333, 2
  %338 = zext i32 %337 to i64
  %339 = mul i64 %338, 32
  %340 = getelementptr inbounds i8, ptr %336, i64 %339
  store i252 %140, ptr %340, align 16
  %341 = extractvalue { ptr, i32, i32, i32 } %333, 2
  %342 = add i32 %341, 1
  %343 = insertvalue { ptr, i32, i32, i32 } %333, i32 %342, 2
  %344 = getelementptr inbounds i8, ptr %336, i32 -12
  store i32 %342, ptr %344, align 4
  %345 = extractvalue { ptr, i32, i32, i32 } %333, 3
  %346 = icmp eq i32 %345, 0
  br i1 %346, label %347, label %361

347:                                              ; preds = %334
  %348 = shl i32 %345, 1
  %349 = call i32 @llvm.umin.i32(i32 %348, i32 1024)
  %350 = add i32 %349, %345
  %351 = call i32 @llvm.umax.i32(i32 %350, i32 8)
  %352 = zext i32 %351 to i64
  %353 = mul i64 %352, 32
  %354 = add i64 %353, 16
  %355 = call ptr @realloc(ptr null, i64 %354)
  store i32 1, ptr %355, align 4
  %356 = getelementptr inbounds i8, ptr %355, i32 4
  store i32 0, ptr %356, align 4
  %357 = getelementptr inbounds i8, ptr %355, i32 16
  %358 = call ptr @realloc(ptr null, i64 8)
  store ptr %357, ptr %358, align 8
  %359 = insertvalue { ptr, i32, i32, i32 } %343, ptr %358, 0
  %360 = insertvalue { ptr, i32, i32, i32 } %359, i32 %351, 3
  br label %381

361:                                              ; preds = %334
  %362 = icmp ult i32 %342, %345
  br i1 %362, label %363, label %364

363:                                              ; preds = %361
  br label %378

364:                                              ; preds = %361
  %365 = shl i32 %345, 1
  %366 = call i32 @llvm.umin.i32(i32 %365, i32 1024)
  %367 = add i32 %366, %345
  %368 = call i32 @llvm.umax.i32(i32 %367, i32 8)
  %369 = zext i32 %368 to i64
  %370 = mul i64 %369, 32
  %371 = add i64 %370, 16
  %372 = extractvalue { ptr, i32, i32, i32 } %333, 0
  %373 = load ptr, ptr %372, align 8
  %374 = getelementptr inbounds i8, ptr %373, i32 -16
  %375 = call ptr @realloc(ptr %374, i64 %371)
  %376 = getelementptr inbounds i8, ptr %375, i32 16
  store ptr %376, ptr %372, align 8
  %377 = insertvalue { ptr, i32, i32, i32 } %343, i32 %368, 3
  br label %378

378:                                              ; preds = %363, %364
  %379 = phi { ptr, i32, i32, i32 } [ %377, %364 ], [ %343, %363 ]
  br label %380

380:                                              ; preds = %378
  br label %381

381:                                              ; preds = %347, %380
  %382 = phi { ptr, i32, i32, i32 } [ %379, %380 ], [ %360, %347 ]
  br label %383

383:                                              ; preds = %381
  %384 = extractvalue { ptr, i32, i32, i32 } %382, 0
  %385 = load ptr, ptr %384, align 8
  %386 = extractvalue { ptr, i32, i32, i32 } %382, 2
  %387 = zext i32 %386 to i64
  %388 = mul i64 %387, 32
  %389 = getelementptr inbounds i8, ptr %385, i64 %388
  store i252 %147, ptr %389, align 16
  %390 = extractvalue { ptr, i32, i32, i32 } %382, 2
  %391 = add i32 %390, 1
  %392 = insertvalue { ptr, i32, i32, i32 } %382, i32 %391, 2
  %393 = getelementptr inbounds i8, ptr %385, i32 -12
  store i32 %391, ptr %393, align 4
  %394 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %392, 0
  ret { { ptr, i32, i32, i32 } } %394

395:                                              ; preds = %2
  %396 = load { i3, { { i2, [0 x i8] }, i32 } }, ptr %3, align 4
  %397 = extractvalue { i3, { { i2, [0 x i8] }, i32 } } %396, 1
  %398 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %399 = icmp eq i32 %398, 0
  br i1 %399, label %400, label %414

400:                                              ; preds = %395
  %401 = shl i32 %398, 1
  %402 = call i32 @llvm.umin.i32(i32 %401, i32 1024)
  %403 = add i32 %402, %398
  %404 = call i32 @llvm.umax.i32(i32 %403, i32 8)
  %405 = zext i32 %404 to i64
  %406 = mul i64 %405, 32
  %407 = add i64 %406, 16
  %408 = call ptr @realloc(ptr null, i64 %407)
  store i32 1, ptr %408, align 4
  %409 = getelementptr inbounds i8, ptr %408, i32 4
  store i32 0, ptr %409, align 4
  %410 = getelementptr inbounds i8, ptr %408, i32 16
  %411 = call ptr @realloc(ptr null, i64 8)
  store ptr %410, ptr %411, align 8
  %412 = insertvalue { ptr, i32, i32, i32 } %1, ptr %411, 0
  %413 = insertvalue { ptr, i32, i32, i32 } %412, i32 %404, 3
  br label %435

414:                                              ; preds = %395
  %415 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %416 = icmp ult i32 %415, %398
  br i1 %416, label %417, label %418

417:                                              ; preds = %414
  br label %432

418:                                              ; preds = %414
  %419 = shl i32 %398, 1
  %420 = call i32 @llvm.umin.i32(i32 %419, i32 1024)
  %421 = add i32 %420, %398
  %422 = call i32 @llvm.umax.i32(i32 %421, i32 8)
  %423 = zext i32 %422 to i64
  %424 = mul i64 %423, 32
  %425 = add i64 %424, 16
  %426 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %427 = load ptr, ptr %426, align 8
  %428 = getelementptr inbounds i8, ptr %427, i32 -16
  %429 = call ptr @realloc(ptr %428, i64 %425)
  %430 = getelementptr inbounds i8, ptr %429, i32 16
  store ptr %430, ptr %426, align 8
  %431 = insertvalue { ptr, i32, i32, i32 } %1, i32 %422, 3
  br label %432

432:                                              ; preds = %417, %418
  %433 = phi { ptr, i32, i32, i32 } [ %431, %418 ], [ %1, %417 ]
  br label %434

434:                                              ; preds = %432
  br label %435

435:                                              ; preds = %400, %434
  %436 = phi { ptr, i32, i32, i32 } [ %433, %434 ], [ %413, %400 ]
  br label %437

437:                                              ; preds = %435
  %438 = extractvalue { ptr, i32, i32, i32 } %436, 0
  %439 = load ptr, ptr %438, align 8
  %440 = extractvalue { ptr, i32, i32, i32 } %436, 2
  %441 = zext i32 %440 to i64
  %442 = mul i64 %441, 32
  %443 = getelementptr inbounds i8, ptr %439, i64 %442
  store i252 2, ptr %443, align 16
  %444 = extractvalue { ptr, i32, i32, i32 } %436, 2
  %445 = add i32 %444, 1
  %446 = insertvalue { ptr, i32, i32, i32 } %436, i32 %445, 2
  %447 = getelementptr inbounds i8, ptr %439, i32 -12
  store i32 %445, ptr %447, align 4
  %448 = extractvalue { { i2, [0 x i8] }, i32 } %397, 0
  %449 = extractvalue { i2, [0 x i8] } %448, 0
  switch i2 %449, label %710 [
    i2 0, label %712
    i2 1, label %765
    i2 -2, label %818
    i2 -1, label %871
  ]

450:                                              ; preds = %2
  %451 = load { i3, { i8, i32 } }, ptr %3, align 4
  %452 = extractvalue { i3, { i8, i32 } } %451, 1
  %453 = extractvalue { i8, i32 } %452, 0
  %454 = zext i8 %453 to i252
  %455 = extractvalue { i8, i32 } %452, 1
  %456 = zext i32 %455 to i252
  %457 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %458 = icmp eq i32 %457, 0
  br i1 %458, label %459, label %473

459:                                              ; preds = %450
  %460 = shl i32 %457, 1
  %461 = call i32 @llvm.umin.i32(i32 %460, i32 1024)
  %462 = add i32 %461, %457
  %463 = call i32 @llvm.umax.i32(i32 %462, i32 8)
  %464 = zext i32 %463 to i64
  %465 = mul i64 %464, 32
  %466 = add i64 %465, 16
  %467 = call ptr @realloc(ptr null, i64 %466)
  store i32 1, ptr %467, align 4
  %468 = getelementptr inbounds i8, ptr %467, i32 4
  store i32 0, ptr %468, align 4
  %469 = getelementptr inbounds i8, ptr %467, i32 16
  %470 = call ptr @realloc(ptr null, i64 8)
  store ptr %469, ptr %470, align 8
  %471 = insertvalue { ptr, i32, i32, i32 } %1, ptr %470, 0
  %472 = insertvalue { ptr, i32, i32, i32 } %471, i32 %463, 3
  br label %494

473:                                              ; preds = %450
  %474 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %475 = icmp ult i32 %474, %457
  br i1 %475, label %476, label %477

476:                                              ; preds = %473
  br label %491

477:                                              ; preds = %473
  %478 = shl i32 %457, 1
  %479 = call i32 @llvm.umin.i32(i32 %478, i32 1024)
  %480 = add i32 %479, %457
  %481 = call i32 @llvm.umax.i32(i32 %480, i32 8)
  %482 = zext i32 %481 to i64
  %483 = mul i64 %482, 32
  %484 = add i64 %483, 16
  %485 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %486 = load ptr, ptr %485, align 8
  %487 = getelementptr inbounds i8, ptr %486, i32 -16
  %488 = call ptr @realloc(ptr %487, i64 %484)
  %489 = getelementptr inbounds i8, ptr %488, i32 16
  store ptr %489, ptr %485, align 8
  %490 = insertvalue { ptr, i32, i32, i32 } %1, i32 %481, 3
  br label %491

491:                                              ; preds = %476, %477
  %492 = phi { ptr, i32, i32, i32 } [ %490, %477 ], [ %1, %476 ]
  br label %493

493:                                              ; preds = %491
  br label %494

494:                                              ; preds = %459, %493
  %495 = phi { ptr, i32, i32, i32 } [ %492, %493 ], [ %472, %459 ]
  br label %496

496:                                              ; preds = %494
  %497 = extractvalue { ptr, i32, i32, i32 } %495, 0
  %498 = load ptr, ptr %497, align 8
  %499 = extractvalue { ptr, i32, i32, i32 } %495, 2
  %500 = zext i32 %499 to i64
  %501 = mul i64 %500, 32
  %502 = getelementptr inbounds i8, ptr %498, i64 %501
  store i252 3, ptr %502, align 16
  %503 = extractvalue { ptr, i32, i32, i32 } %495, 2
  %504 = add i32 %503, 1
  %505 = insertvalue { ptr, i32, i32, i32 } %495, i32 %504, 2
  %506 = getelementptr inbounds i8, ptr %498, i32 -12
  store i32 %504, ptr %506, align 4
  %507 = extractvalue { ptr, i32, i32, i32 } %495, 3
  %508 = icmp eq i32 %507, 0
  br i1 %508, label %509, label %523

509:                                              ; preds = %496
  %510 = shl i32 %507, 1
  %511 = call i32 @llvm.umin.i32(i32 %510, i32 1024)
  %512 = add i32 %511, %507
  %513 = call i32 @llvm.umax.i32(i32 %512, i32 8)
  %514 = zext i32 %513 to i64
  %515 = mul i64 %514, 32
  %516 = add i64 %515, 16
  %517 = call ptr @realloc(ptr null, i64 %516)
  store i32 1, ptr %517, align 4
  %518 = getelementptr inbounds i8, ptr %517, i32 4
  store i32 0, ptr %518, align 4
  %519 = getelementptr inbounds i8, ptr %517, i32 16
  %520 = call ptr @realloc(ptr null, i64 8)
  store ptr %519, ptr %520, align 8
  %521 = insertvalue { ptr, i32, i32, i32 } %505, ptr %520, 0
  %522 = insertvalue { ptr, i32, i32, i32 } %521, i32 %513, 3
  br label %543

523:                                              ; preds = %496
  %524 = icmp ult i32 %504, %507
  br i1 %524, label %525, label %526

525:                                              ; preds = %523
  br label %540

526:                                              ; preds = %523
  %527 = shl i32 %507, 1
  %528 = call i32 @llvm.umin.i32(i32 %527, i32 1024)
  %529 = add i32 %528, %507
  %530 = call i32 @llvm.umax.i32(i32 %529, i32 8)
  %531 = zext i32 %530 to i64
  %532 = mul i64 %531, 32
  %533 = add i64 %532, 16
  %534 = extractvalue { ptr, i32, i32, i32 } %495, 0
  %535 = load ptr, ptr %534, align 8
  %536 = getelementptr inbounds i8, ptr %535, i32 -16
  %537 = call ptr @realloc(ptr %536, i64 %533)
  %538 = getelementptr inbounds i8, ptr %537, i32 16
  store ptr %538, ptr %534, align 8
  %539 = insertvalue { ptr, i32, i32, i32 } %505, i32 %530, 3
  br label %540

540:                                              ; preds = %525, %526
  %541 = phi { ptr, i32, i32, i32 } [ %539, %526 ], [ %505, %525 ]
  br label %542

542:                                              ; preds = %540
  br label %543

543:                                              ; preds = %509, %542
  %544 = phi { ptr, i32, i32, i32 } [ %541, %542 ], [ %522, %509 ]
  br label %545

545:                                              ; preds = %543
  %546 = extractvalue { ptr, i32, i32, i32 } %544, 0
  %547 = load ptr, ptr %546, align 8
  %548 = extractvalue { ptr, i32, i32, i32 } %544, 2
  %549 = zext i32 %548 to i64
  %550 = mul i64 %549, 32
  %551 = getelementptr inbounds i8, ptr %547, i64 %550
  store i252 %454, ptr %551, align 16
  %552 = extractvalue { ptr, i32, i32, i32 } %544, 2
  %553 = add i32 %552, 1
  %554 = insertvalue { ptr, i32, i32, i32 } %544, i32 %553, 2
  %555 = getelementptr inbounds i8, ptr %547, i32 -12
  store i32 %553, ptr %555, align 4
  %556 = extractvalue { ptr, i32, i32, i32 } %544, 3
  %557 = icmp eq i32 %556, 0
  br i1 %557, label %558, label %572

558:                                              ; preds = %545
  %559 = shl i32 %556, 1
  %560 = call i32 @llvm.umin.i32(i32 %559, i32 1024)
  %561 = add i32 %560, %556
  %562 = call i32 @llvm.umax.i32(i32 %561, i32 8)
  %563 = zext i32 %562 to i64
  %564 = mul i64 %563, 32
  %565 = add i64 %564, 16
  %566 = call ptr @realloc(ptr null, i64 %565)
  store i32 1, ptr %566, align 4
  %567 = getelementptr inbounds i8, ptr %566, i32 4
  store i32 0, ptr %567, align 4
  %568 = getelementptr inbounds i8, ptr %566, i32 16
  %569 = call ptr @realloc(ptr null, i64 8)
  store ptr %568, ptr %569, align 8
  %570 = insertvalue { ptr, i32, i32, i32 } %554, ptr %569, 0
  %571 = insertvalue { ptr, i32, i32, i32 } %570, i32 %562, 3
  br label %592

572:                                              ; preds = %545
  %573 = icmp ult i32 %553, %556
  br i1 %573, label %574, label %575

574:                                              ; preds = %572
  br label %589

575:                                              ; preds = %572
  %576 = shl i32 %556, 1
  %577 = call i32 @llvm.umin.i32(i32 %576, i32 1024)
  %578 = add i32 %577, %556
  %579 = call i32 @llvm.umax.i32(i32 %578, i32 8)
  %580 = zext i32 %579 to i64
  %581 = mul i64 %580, 32
  %582 = add i64 %581, 16
  %583 = extractvalue { ptr, i32, i32, i32 } %544, 0
  %584 = load ptr, ptr %583, align 8
  %585 = getelementptr inbounds i8, ptr %584, i32 -16
  %586 = call ptr @realloc(ptr %585, i64 %582)
  %587 = getelementptr inbounds i8, ptr %586, i32 16
  store ptr %587, ptr %583, align 8
  %588 = insertvalue { ptr, i32, i32, i32 } %554, i32 %579, 3
  br label %589

589:                                              ; preds = %574, %575
  %590 = phi { ptr, i32, i32, i32 } [ %588, %575 ], [ %554, %574 ]
  br label %591

591:                                              ; preds = %589
  br label %592

592:                                              ; preds = %558, %591
  %593 = phi { ptr, i32, i32, i32 } [ %590, %591 ], [ %571, %558 ]
  br label %594

594:                                              ; preds = %592
  %595 = extractvalue { ptr, i32, i32, i32 } %593, 0
  %596 = load ptr, ptr %595, align 8
  %597 = extractvalue { ptr, i32, i32, i32 } %593, 2
  %598 = zext i32 %597 to i64
  %599 = mul i64 %598, 32
  %600 = getelementptr inbounds i8, ptr %596, i64 %599
  store i252 %456, ptr %600, align 16
  %601 = extractvalue { ptr, i32, i32, i32 } %593, 2
  %602 = add i32 %601, 1
  %603 = insertvalue { ptr, i32, i32, i32 } %593, i32 %602, 2
  %604 = getelementptr inbounds i8, ptr %596, i32 -12
  store i32 %602, ptr %604, align 4
  %605 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %603, 0
  ret { { ptr, i32, i32, i32 } } %605

606:                                              ; preds = %2
  %607 = load { i3, i8 }, ptr %3, align 1
  %608 = extractvalue { i3, i8 } %607, 1
  %609 = zext i8 %608 to i252
  %610 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %611 = icmp eq i32 %610, 0
  br i1 %611, label %612, label %626

612:                                              ; preds = %606
  %613 = shl i32 %610, 1
  %614 = call i32 @llvm.umin.i32(i32 %613, i32 1024)
  %615 = add i32 %614, %610
  %616 = call i32 @llvm.umax.i32(i32 %615, i32 8)
  %617 = zext i32 %616 to i64
  %618 = mul i64 %617, 32
  %619 = add i64 %618, 16
  %620 = call ptr @realloc(ptr null, i64 %619)
  store i32 1, ptr %620, align 4
  %621 = getelementptr inbounds i8, ptr %620, i32 4
  store i32 0, ptr %621, align 4
  %622 = getelementptr inbounds i8, ptr %620, i32 16
  %623 = call ptr @realloc(ptr null, i64 8)
  store ptr %622, ptr %623, align 8
  %624 = insertvalue { ptr, i32, i32, i32 } %1, ptr %623, 0
  %625 = insertvalue { ptr, i32, i32, i32 } %624, i32 %616, 3
  br label %647

626:                                              ; preds = %606
  %627 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %628 = icmp ult i32 %627, %610
  br i1 %628, label %629, label %630

629:                                              ; preds = %626
  br label %644

630:                                              ; preds = %626
  %631 = shl i32 %610, 1
  %632 = call i32 @llvm.umin.i32(i32 %631, i32 1024)
  %633 = add i32 %632, %610
  %634 = call i32 @llvm.umax.i32(i32 %633, i32 8)
  %635 = zext i32 %634 to i64
  %636 = mul i64 %635, 32
  %637 = add i64 %636, 16
  %638 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %639 = load ptr, ptr %638, align 8
  %640 = getelementptr inbounds i8, ptr %639, i32 -16
  %641 = call ptr @realloc(ptr %640, i64 %637)
  %642 = getelementptr inbounds i8, ptr %641, i32 16
  store ptr %642, ptr %638, align 8
  %643 = insertvalue { ptr, i32, i32, i32 } %1, i32 %634, 3
  br label %644

644:                                              ; preds = %629, %630
  %645 = phi { ptr, i32, i32, i32 } [ %643, %630 ], [ %1, %629 ]
  br label %646

646:                                              ; preds = %644
  br label %647

647:                                              ; preds = %612, %646
  %648 = phi { ptr, i32, i32, i32 } [ %645, %646 ], [ %625, %612 ]
  br label %649

649:                                              ; preds = %647
  %650 = extractvalue { ptr, i32, i32, i32 } %648, 0
  %651 = load ptr, ptr %650, align 8
  %652 = extractvalue { ptr, i32, i32, i32 } %648, 2
  %653 = zext i32 %652 to i64
  %654 = mul i64 %653, 32
  %655 = getelementptr inbounds i8, ptr %651, i64 %654
  store i252 4, ptr %655, align 16
  %656 = extractvalue { ptr, i32, i32, i32 } %648, 2
  %657 = add i32 %656, 1
  %658 = insertvalue { ptr, i32, i32, i32 } %648, i32 %657, 2
  %659 = getelementptr inbounds i8, ptr %651, i32 -12
  store i32 %657, ptr %659, align 4
  %660 = extractvalue { ptr, i32, i32, i32 } %648, 3
  %661 = icmp eq i32 %660, 0
  br i1 %661, label %662, label %676

662:                                              ; preds = %649
  %663 = shl i32 %660, 1
  %664 = call i32 @llvm.umin.i32(i32 %663, i32 1024)
  %665 = add i32 %664, %660
  %666 = call i32 @llvm.umax.i32(i32 %665, i32 8)
  %667 = zext i32 %666 to i64
  %668 = mul i64 %667, 32
  %669 = add i64 %668, 16
  %670 = call ptr @realloc(ptr null, i64 %669)
  store i32 1, ptr %670, align 4
  %671 = getelementptr inbounds i8, ptr %670, i32 4
  store i32 0, ptr %671, align 4
  %672 = getelementptr inbounds i8, ptr %670, i32 16
  %673 = call ptr @realloc(ptr null, i64 8)
  store ptr %672, ptr %673, align 8
  %674 = insertvalue { ptr, i32, i32, i32 } %658, ptr %673, 0
  %675 = insertvalue { ptr, i32, i32, i32 } %674, i32 %666, 3
  br label %696

676:                                              ; preds = %649
  %677 = icmp ult i32 %657, %660
  br i1 %677, label %678, label %679

678:                                              ; preds = %676
  br label %693

679:                                              ; preds = %676
  %680 = shl i32 %660, 1
  %681 = call i32 @llvm.umin.i32(i32 %680, i32 1024)
  %682 = add i32 %681, %660
  %683 = call i32 @llvm.umax.i32(i32 %682, i32 8)
  %684 = zext i32 %683 to i64
  %685 = mul i64 %684, 32
  %686 = add i64 %685, 16
  %687 = extractvalue { ptr, i32, i32, i32 } %648, 0
  %688 = load ptr, ptr %687, align 8
  %689 = getelementptr inbounds i8, ptr %688, i32 -16
  %690 = call ptr @realloc(ptr %689, i64 %686)
  %691 = getelementptr inbounds i8, ptr %690, i32 16
  store ptr %691, ptr %687, align 8
  %692 = insertvalue { ptr, i32, i32, i32 } %658, i32 %683, 3
  br label %693

693:                                              ; preds = %678, %679
  %694 = phi { ptr, i32, i32, i32 } [ %692, %679 ], [ %658, %678 ]
  br label %695

695:                                              ; preds = %693
  br label %696

696:                                              ; preds = %662, %695
  %697 = phi { ptr, i32, i32, i32 } [ %694, %695 ], [ %675, %662 ]
  br label %698

698:                                              ; preds = %696
  %699 = extractvalue { ptr, i32, i32, i32 } %697, 0
  %700 = load ptr, ptr %699, align 8
  %701 = extractvalue { ptr, i32, i32, i32 } %697, 2
  %702 = zext i32 %701 to i64
  %703 = mul i64 %702, 32
  %704 = getelementptr inbounds i8, ptr %700, i64 %703
  store i252 %609, ptr %704, align 16
  %705 = extractvalue { ptr, i32, i32, i32 } %697, 2
  %706 = add i32 %705, 1
  %707 = insertvalue { ptr, i32, i32, i32 } %697, i32 %706, 2
  %708 = getelementptr inbounds i8, ptr %700, i32 -12
  store i32 %706, ptr %708, align 4
  %709 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %707, 0
  ret { { ptr, i32, i32, i32 } } %709

710:                                              ; preds = %437
  br i1 false, label %711, label %986

711:                                              ; preds = %710
  unreachable

712:                                              ; preds = %437
  %713 = phi { ptr, i32, i32, i32 } [ %446, %437 ]
  %714 = phi i252 [ 0, %437 ]
  %715 = extractvalue { ptr, i32, i32, i32 } %713, 3
  %716 = icmp eq i32 %715, 0
  br i1 %716, label %717, label %731

717:                                              ; preds = %712
  %718 = shl i32 %715, 1
  %719 = call i32 @llvm.umin.i32(i32 %718, i32 1024)
  %720 = add i32 %719, %715
  %721 = call i32 @llvm.umax.i32(i32 %720, i32 8)
  %722 = zext i32 %721 to i64
  %723 = mul i64 %722, 32
  %724 = add i64 %723, 16
  %725 = call ptr @realloc(ptr null, i64 %724)
  store i32 1, ptr %725, align 4
  %726 = getelementptr inbounds i8, ptr %725, i32 4
  store i32 0, ptr %726, align 4
  %727 = getelementptr inbounds i8, ptr %725, i32 16
  %728 = call ptr @realloc(ptr null, i64 8)
  store ptr %727, ptr %728, align 8
  %729 = insertvalue { ptr, i32, i32, i32 } %713, ptr %728, 0
  %730 = insertvalue { ptr, i32, i32, i32 } %729, i32 %721, 3
  br label %752

731:                                              ; preds = %712
  %732 = extractvalue { ptr, i32, i32, i32 } %713, 2
  %733 = icmp ult i32 %732, %715
  br i1 %733, label %734, label %735

734:                                              ; preds = %731
  br label %749

735:                                              ; preds = %731
  %736 = shl i32 %715, 1
  %737 = call i32 @llvm.umin.i32(i32 %736, i32 1024)
  %738 = add i32 %737, %715
  %739 = call i32 @llvm.umax.i32(i32 %738, i32 8)
  %740 = zext i32 %739 to i64
  %741 = mul i64 %740, 32
  %742 = add i64 %741, 16
  %743 = extractvalue { ptr, i32, i32, i32 } %713, 0
  %744 = load ptr, ptr %743, align 8
  %745 = getelementptr inbounds i8, ptr %744, i32 -16
  %746 = call ptr @realloc(ptr %745, i64 %742)
  %747 = getelementptr inbounds i8, ptr %746, i32 16
  store ptr %747, ptr %743, align 8
  %748 = insertvalue { ptr, i32, i32, i32 } %713, i32 %739, 3
  br label %749

749:                                              ; preds = %734, %735
  %750 = phi { ptr, i32, i32, i32 } [ %748, %735 ], [ %713, %734 ]
  br label %751

751:                                              ; preds = %749
  br label %752

752:                                              ; preds = %717, %751
  %753 = phi { ptr, i32, i32, i32 } [ %750, %751 ], [ %730, %717 ]
  br label %754

754:                                              ; preds = %752
  %755 = extractvalue { ptr, i32, i32, i32 } %753, 0
  %756 = load ptr, ptr %755, align 8
  %757 = extractvalue { ptr, i32, i32, i32 } %753, 2
  %758 = zext i32 %757 to i64
  %759 = mul i64 %758, 32
  %760 = getelementptr inbounds i8, ptr %756, i64 %759
  store i252 %714, ptr %760, align 16
  %761 = extractvalue { ptr, i32, i32, i32 } %753, 2
  %762 = add i32 %761, 1
  %763 = insertvalue { ptr, i32, i32, i32 } %753, i32 %762, 2
  %764 = getelementptr inbounds i8, ptr %756, i32 -12
  store i32 %762, ptr %764, align 4
  br label %924

765:                                              ; preds = %437
  %766 = phi { ptr, i32, i32, i32 } [ %446, %437 ]
  %767 = phi i252 [ 1, %437 ]
  %768 = extractvalue { ptr, i32, i32, i32 } %766, 3
  %769 = icmp eq i32 %768, 0
  br i1 %769, label %770, label %784

770:                                              ; preds = %765
  %771 = shl i32 %768, 1
  %772 = call i32 @llvm.umin.i32(i32 %771, i32 1024)
  %773 = add i32 %772, %768
  %774 = call i32 @llvm.umax.i32(i32 %773, i32 8)
  %775 = zext i32 %774 to i64
  %776 = mul i64 %775, 32
  %777 = add i64 %776, 16
  %778 = call ptr @realloc(ptr null, i64 %777)
  store i32 1, ptr %778, align 4
  %779 = getelementptr inbounds i8, ptr %778, i32 4
  store i32 0, ptr %779, align 4
  %780 = getelementptr inbounds i8, ptr %778, i32 16
  %781 = call ptr @realloc(ptr null, i64 8)
  store ptr %780, ptr %781, align 8
  %782 = insertvalue { ptr, i32, i32, i32 } %766, ptr %781, 0
  %783 = insertvalue { ptr, i32, i32, i32 } %782, i32 %774, 3
  br label %805

784:                                              ; preds = %765
  %785 = extractvalue { ptr, i32, i32, i32 } %766, 2
  %786 = icmp ult i32 %785, %768
  br i1 %786, label %787, label %788

787:                                              ; preds = %784
  br label %802

788:                                              ; preds = %784
  %789 = shl i32 %768, 1
  %790 = call i32 @llvm.umin.i32(i32 %789, i32 1024)
  %791 = add i32 %790, %768
  %792 = call i32 @llvm.umax.i32(i32 %791, i32 8)
  %793 = zext i32 %792 to i64
  %794 = mul i64 %793, 32
  %795 = add i64 %794, 16
  %796 = extractvalue { ptr, i32, i32, i32 } %766, 0
  %797 = load ptr, ptr %796, align 8
  %798 = getelementptr inbounds i8, ptr %797, i32 -16
  %799 = call ptr @realloc(ptr %798, i64 %795)
  %800 = getelementptr inbounds i8, ptr %799, i32 16
  store ptr %800, ptr %796, align 8
  %801 = insertvalue { ptr, i32, i32, i32 } %766, i32 %792, 3
  br label %802

802:                                              ; preds = %787, %788
  %803 = phi { ptr, i32, i32, i32 } [ %801, %788 ], [ %766, %787 ]
  br label %804

804:                                              ; preds = %802
  br label %805

805:                                              ; preds = %770, %804
  %806 = phi { ptr, i32, i32, i32 } [ %803, %804 ], [ %783, %770 ]
  br label %807

807:                                              ; preds = %805
  %808 = extractvalue { ptr, i32, i32, i32 } %806, 0
  %809 = load ptr, ptr %808, align 8
  %810 = extractvalue { ptr, i32, i32, i32 } %806, 2
  %811 = zext i32 %810 to i64
  %812 = mul i64 %811, 32
  %813 = getelementptr inbounds i8, ptr %809, i64 %812
  store i252 %767, ptr %813, align 16
  %814 = extractvalue { ptr, i32, i32, i32 } %806, 2
  %815 = add i32 %814, 1
  %816 = insertvalue { ptr, i32, i32, i32 } %806, i32 %815, 2
  %817 = getelementptr inbounds i8, ptr %809, i32 -12
  store i32 %815, ptr %817, align 4
  br label %924

818:                                              ; preds = %437
  %819 = phi { ptr, i32, i32, i32 } [ %446, %437 ]
  %820 = phi i252 [ 2, %437 ]
  %821 = extractvalue { ptr, i32, i32, i32 } %819, 3
  %822 = icmp eq i32 %821, 0
  br i1 %822, label %823, label %837

823:                                              ; preds = %818
  %824 = shl i32 %821, 1
  %825 = call i32 @llvm.umin.i32(i32 %824, i32 1024)
  %826 = add i32 %825, %821
  %827 = call i32 @llvm.umax.i32(i32 %826, i32 8)
  %828 = zext i32 %827 to i64
  %829 = mul i64 %828, 32
  %830 = add i64 %829, 16
  %831 = call ptr @realloc(ptr null, i64 %830)
  store i32 1, ptr %831, align 4
  %832 = getelementptr inbounds i8, ptr %831, i32 4
  store i32 0, ptr %832, align 4
  %833 = getelementptr inbounds i8, ptr %831, i32 16
  %834 = call ptr @realloc(ptr null, i64 8)
  store ptr %833, ptr %834, align 8
  %835 = insertvalue { ptr, i32, i32, i32 } %819, ptr %834, 0
  %836 = insertvalue { ptr, i32, i32, i32 } %835, i32 %827, 3
  br label %858

837:                                              ; preds = %818
  %838 = extractvalue { ptr, i32, i32, i32 } %819, 2
  %839 = icmp ult i32 %838, %821
  br i1 %839, label %840, label %841

840:                                              ; preds = %837
  br label %855

841:                                              ; preds = %837
  %842 = shl i32 %821, 1
  %843 = call i32 @llvm.umin.i32(i32 %842, i32 1024)
  %844 = add i32 %843, %821
  %845 = call i32 @llvm.umax.i32(i32 %844, i32 8)
  %846 = zext i32 %845 to i64
  %847 = mul i64 %846, 32
  %848 = add i64 %847, 16
  %849 = extractvalue { ptr, i32, i32, i32 } %819, 0
  %850 = load ptr, ptr %849, align 8
  %851 = getelementptr inbounds i8, ptr %850, i32 -16
  %852 = call ptr @realloc(ptr %851, i64 %848)
  %853 = getelementptr inbounds i8, ptr %852, i32 16
  store ptr %853, ptr %849, align 8
  %854 = insertvalue { ptr, i32, i32, i32 } %819, i32 %845, 3
  br label %855

855:                                              ; preds = %840, %841
  %856 = phi { ptr, i32, i32, i32 } [ %854, %841 ], [ %819, %840 ]
  br label %857

857:                                              ; preds = %855
  br label %858

858:                                              ; preds = %823, %857
  %859 = phi { ptr, i32, i32, i32 } [ %856, %857 ], [ %836, %823 ]
  br label %860

860:                                              ; preds = %858
  %861 = extractvalue { ptr, i32, i32, i32 } %859, 0
  %862 = load ptr, ptr %861, align 8
  %863 = extractvalue { ptr, i32, i32, i32 } %859, 2
  %864 = zext i32 %863 to i64
  %865 = mul i64 %864, 32
  %866 = getelementptr inbounds i8, ptr %862, i64 %865
  store i252 %820, ptr %866, align 16
  %867 = extractvalue { ptr, i32, i32, i32 } %859, 2
  %868 = add i32 %867, 1
  %869 = insertvalue { ptr, i32, i32, i32 } %859, i32 %868, 2
  %870 = getelementptr inbounds i8, ptr %862, i32 -12
  store i32 %868, ptr %870, align 4
  br label %924

871:                                              ; preds = %437
  %872 = phi { ptr, i32, i32, i32 } [ %446, %437 ]
  %873 = phi i252 [ 3, %437 ]
  %874 = extractvalue { ptr, i32, i32, i32 } %872, 3
  %875 = icmp eq i32 %874, 0
  br i1 %875, label %876, label %890

876:                                              ; preds = %871
  %877 = shl i32 %874, 1
  %878 = call i32 @llvm.umin.i32(i32 %877, i32 1024)
  %879 = add i32 %878, %874
  %880 = call i32 @llvm.umax.i32(i32 %879, i32 8)
  %881 = zext i32 %880 to i64
  %882 = mul i64 %881, 32
  %883 = add i64 %882, 16
  %884 = call ptr @realloc(ptr null, i64 %883)
  store i32 1, ptr %884, align 4
  %885 = getelementptr inbounds i8, ptr %884, i32 4
  store i32 0, ptr %885, align 4
  %886 = getelementptr inbounds i8, ptr %884, i32 16
  %887 = call ptr @realloc(ptr null, i64 8)
  store ptr %886, ptr %887, align 8
  %888 = insertvalue { ptr, i32, i32, i32 } %872, ptr %887, 0
  %889 = insertvalue { ptr, i32, i32, i32 } %888, i32 %880, 3
  br label %911

890:                                              ; preds = %871
  %891 = extractvalue { ptr, i32, i32, i32 } %872, 2
  %892 = icmp ult i32 %891, %874
  br i1 %892, label %893, label %894

893:                                              ; preds = %890
  br label %908

894:                                              ; preds = %890
  %895 = shl i32 %874, 1
  %896 = call i32 @llvm.umin.i32(i32 %895, i32 1024)
  %897 = add i32 %896, %874
  %898 = call i32 @llvm.umax.i32(i32 %897, i32 8)
  %899 = zext i32 %898 to i64
  %900 = mul i64 %899, 32
  %901 = add i64 %900, 16
  %902 = extractvalue { ptr, i32, i32, i32 } %872, 0
  %903 = load ptr, ptr %902, align 8
  %904 = getelementptr inbounds i8, ptr %903, i32 -16
  %905 = call ptr @realloc(ptr %904, i64 %901)
  %906 = getelementptr inbounds i8, ptr %905, i32 16
  store ptr %906, ptr %902, align 8
  %907 = insertvalue { ptr, i32, i32, i32 } %872, i32 %898, 3
  br label %908

908:                                              ; preds = %893, %894
  %909 = phi { ptr, i32, i32, i32 } [ %907, %894 ], [ %872, %893 ]
  br label %910

910:                                              ; preds = %908
  br label %911

911:                                              ; preds = %876, %910
  %912 = phi { ptr, i32, i32, i32 } [ %909, %910 ], [ %889, %876 ]
  br label %913

913:                                              ; preds = %911
  %914 = extractvalue { ptr, i32, i32, i32 } %912, 0
  %915 = load ptr, ptr %914, align 8
  %916 = extractvalue { ptr, i32, i32, i32 } %912, 2
  %917 = zext i32 %916 to i64
  %918 = mul i64 %917, 32
  %919 = getelementptr inbounds i8, ptr %915, i64 %918
  store i252 %873, ptr %919, align 16
  %920 = extractvalue { ptr, i32, i32, i32 } %912, 2
  %921 = add i32 %920, 1
  %922 = insertvalue { ptr, i32, i32, i32 } %912, i32 %921, 2
  %923 = getelementptr inbounds i8, ptr %915, i32 -12
  store i32 %921, ptr %923, align 4
  br label %924

924:                                              ; preds = %754, %807, %860, %913
  %925 = phi { { i2, [0 x i8] }, i32 } [ %397, %913 ], [ %397, %860 ], [ %397, %807 ], [ %397, %754 ]
  %926 = phi { ptr, i32, i32, i32 } [ %922, %913 ], [ %869, %860 ], [ %816, %807 ], [ %763, %754 ]
  %927 = extractvalue { { i2, [0 x i8] }, i32 } %925, 1
  %928 = icmp slt i32 %927, 0
  %929 = zext i32 %927 to i252
  %930 = call i32 @llvm.abs.i32(i32 %927, i1 false)
  %931 = zext i32 %930 to i252
  %932 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %931
  %933 = select i1 %928, i252 %932, i252 %929
  %934 = extractvalue { ptr, i32, i32, i32 } %926, 3
  %935 = icmp eq i32 %934, 0
  br i1 %935, label %936, label %950

936:                                              ; preds = %924
  %937 = shl i32 %934, 1
  %938 = call i32 @llvm.umin.i32(i32 %937, i32 1024)
  %939 = add i32 %938, %934
  %940 = call i32 @llvm.umax.i32(i32 %939, i32 8)
  %941 = zext i32 %940 to i64
  %942 = mul i64 %941, 32
  %943 = add i64 %942, 16
  %944 = call ptr @realloc(ptr null, i64 %943)
  store i32 1, ptr %944, align 4
  %945 = getelementptr inbounds i8, ptr %944, i32 4
  store i32 0, ptr %945, align 4
  %946 = getelementptr inbounds i8, ptr %944, i32 16
  %947 = call ptr @realloc(ptr null, i64 8)
  store ptr %946, ptr %947, align 8
  %948 = insertvalue { ptr, i32, i32, i32 } %926, ptr %947, 0
  %949 = insertvalue { ptr, i32, i32, i32 } %948, i32 %940, 3
  br label %971

950:                                              ; preds = %924
  %951 = extractvalue { ptr, i32, i32, i32 } %926, 2
  %952 = icmp ult i32 %951, %934
  br i1 %952, label %953, label %954

953:                                              ; preds = %950
  br label %968

954:                                              ; preds = %950
  %955 = shl i32 %934, 1
  %956 = call i32 @llvm.umin.i32(i32 %955, i32 1024)
  %957 = add i32 %956, %934
  %958 = call i32 @llvm.umax.i32(i32 %957, i32 8)
  %959 = zext i32 %958 to i64
  %960 = mul i64 %959, 32
  %961 = add i64 %960, 16
  %962 = extractvalue { ptr, i32, i32, i32 } %926, 0
  %963 = load ptr, ptr %962, align 8
  %964 = getelementptr inbounds i8, ptr %963, i32 -16
  %965 = call ptr @realloc(ptr %964, i64 %961)
  %966 = getelementptr inbounds i8, ptr %965, i32 16
  store ptr %966, ptr %962, align 8
  %967 = insertvalue { ptr, i32, i32, i32 } %926, i32 %958, 3
  br label %968

968:                                              ; preds = %953, %954
  %969 = phi { ptr, i32, i32, i32 } [ %967, %954 ], [ %926, %953 ]
  br label %970

970:                                              ; preds = %968
  br label %971

971:                                              ; preds = %936, %970
  %972 = phi { ptr, i32, i32, i32 } [ %969, %970 ], [ %949, %936 ]
  br label %973

973:                                              ; preds = %971
  %974 = extractvalue { ptr, i32, i32, i32 } %972, 0
  %975 = load ptr, ptr %974, align 8
  %976 = extractvalue { ptr, i32, i32, i32 } %972, 2
  %977 = zext i32 %976 to i64
  %978 = mul i64 %977, 32
  %979 = getelementptr inbounds i8, ptr %975, i64 %978
  store i252 %933, ptr %979, align 16
  %980 = extractvalue { ptr, i32, i32, i32 } %972, 2
  %981 = add i32 %980, 1
  %982 = insertvalue { ptr, i32, i32, i32 } %972, i32 %981, 2
  %983 = getelementptr inbounds i8, ptr %975, i32 -12
  store i32 %981, ptr %983, align 4
  %984 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %982, 0
  ret { { ptr, i32, i32, i32 } } %984

985:                                              ; preds = %6
  call void @puts(ptr @assert_msg_169)
  call void @abort()
  unreachable

986:                                              ; preds = %710
  call void @puts(ptr @assert_msg_170)
  call void @abort()
  unreachable
}

define private { ptr, i32, i32, i32 } @f101(ptr %0, { ptr, i32, i32, i32 } %1) {
  %3 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f101"(ptr %0, { ptr, i32, i32, i32 } %1)
  %4 = extractvalue { { ptr, i32, i32, i32 } } %3, 0
  ret { ptr, i32, i32, i32 } %4
}

define void @_mlir_ciface_f101(ptr %0, ptr %1, { ptr, i32, i32, i32 } %2) {
  %4 = call { ptr, i32, i32, i32 } @f101(ptr %1, { ptr, i32, i32, i32 } %2)
  store { ptr, i32, i32, i32 } %4, ptr %0, align 8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.usub.sat.i64(i64, i64) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.uadd.sat.i64(i64, i64) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umin.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umax.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i32, i1 } @llvm.uadd.with.overflow.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i128, i1 } @llvm.uadd.with.overflow.i128(i128, i128) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i32, i1 } @llvm.usub.with.overflow.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.abs.i32(i32, i1 immarg) #1

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
