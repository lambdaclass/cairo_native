<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Gas and Builtins Accounting"><title>cairo_native::docs::section04 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cairo_native" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../cairo_native/index.html">cairo_<wbr>native</a><span class="version">0.2.0-alpha.4</span></h2></div><h2 class="location"><a href="#">Module section04</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In cairo_<wbr>native::<wbr>docs</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">cairo_native</a>::<wbr><a href="../index.html">docs</a>::<wbr><a class="mod" href="#">section04</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/cairo_native/docs.rs.html#20">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="gas-and-builtins-accounting"><a class="doc-anchor" href="#gas-and-builtins-accounting">§</a>Gas and Builtins Accounting</h2>
<p>This section documents how programs generated by Cairo Native keep track of
gas and builtins during execution.</p>
<h3 id="gas"><a class="doc-anchor" href="#gas">§</a>Gas</h3><h4 id="introduction"><a class="doc-anchor" href="#introduction">§</a>Introduction</h4>
<p>Gas management in a blockchain environment involves accounting for the amount
of computation performed during the execution of a transaction. This is used
to accurately charge the user at the end of the execution or to revert early
if the transaction consumes more gas than provided by the sender.</p>
<p>This documentation assumes prior knowledge about Sierra and about the way
gas accounting is performed in Sierra. For those seeking to deepen their
understanding, refer to Enitrat’s Medium post about
<a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5">Sierra</a>
and greged’s about
<a href="https://blog.kakarot.org/understanding-sierra-gas-accounting-19d6141d28b9">gas accounting in Sierra</a>.</p>
<h4 id="gas-builtin"><a class="doc-anchor" href="#gas-builtin">§</a>Gas builtin</h4>
<p>The gas builtin is used in Sierra in order to perform gas accounting. It is
passed as an input to all function calls and holds the current remaining
gas. It is represented in MLIR by a simple <code>u128</code>.</p>
<h4 id="gas-metadata"><a class="doc-anchor" href="#gas-metadata">§</a>Gas metadata</h4>
<p>The process of calculating gas begins at the very outset of the compilation
process. During the initial setup of the Sierra program, metadata about the
program, including gas information, is extracted. Using gas helper functions
from the <a href="https://github.com/starkware-libs/cairo/tree/main">Cairo compiler</a>,
the consumed cost (steps, memory holes, builtins usage) for each statement
in the Sierra code is stored in a HashMap.</p>
<h4 id="withdrawing-gas"><a class="doc-anchor" href="#withdrawing-gas">§</a>Withdrawing gas</h4>
<p>The action of withdrawing gas can be split in two steps:</p>
<ul>
<li><strong>Calculating Total Gas Cost</strong>: Using the previously constructed HashMap,
we iterate over the various cost tokens (including steps, built-in usage,
and memory holes) for the statement, convert them into a
<a href="https://github.com/starkware-libs/cairo/blob/v2.7.1/crates/cairo-lang-runner/src/lib.rs#L136">common gas unit</a>,
and sum them up to get the total gas cost for the statement.</li>
<li><strong>Executing Gas Withdrawal</strong>: The previously calculated gas cost is used
when the current statement is a <code>withdraw_gas</code> libfunc call.</li>
</ul>
<p>The <code>withdraw_gas</code> libfunc takes the current leftover gas as input and uses
the calculated gas cost for the statement to deduct the appropriate amount
from the gas builtin. In the compiled IR, gas withdrawal appears as the
total gas being reduced by a predefined constant. Additionally, the libfunc
branches based on whether the remaining gas is greater than or equal to the
amount being withdrawn.</p>
<h4 id="example"><a class="doc-anchor" href="#example">§</a>Example</h4>
<p>Let’s illustrate this with a simple example using the following Cairo 1 code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>run_test() {
    <span class="kw">let </span><span class="kw-2">mut </span>i: u8 = <span class="number">0</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>val = <span class="number">0</span>;
    <span class="kw">while </span>i &lt; <span class="number">5 </span>{
        val = val + i;
        i = i + <span class="number">1</span>;
    }
}</code></pre></div>
<p>As noted earlier, gas usage is initially computed by the Cairo compiler for
each state. A snippet of the resulting HashMap shows the cost for each
statement:</p>
<div class="example-wrap"><pre class="language-json"><code>...
(
    StatementIdx(26),
    Const,
): 2680,
(
    StatementIdx(26),
    Pedersen,
): 0,
(
    StatementIdx(26),
    Poseidon,
): 0,
...
</code></pre></div>
<p>For statement 26, the cost of the <code>Const</code> token type (a combination of step,
memory hole, and range check costs) is 2680, while other costs are 0.
Let’s see which libfunc is called at statement 26:</p>
<div class="example-wrap"><pre class="language-assembly"><code>...
disable_ap_tracking() -&gt; (); // 25
withdraw_gas([0], [1]) { fallthrough([4], [5]) 84([6], [7]) }; // 26
branch_align() -&gt; (); // 27
const_as_immediate&lt;Const&lt;u8, 5&gt;&gt;() -&gt; ([8]); // 28
...
</code></pre></div>
<p>When the Cairo native compiler reaches statement 26, it combines all costs
into gas using the Cairo compiler code. In this example, the total cost is
2680 gas. This value is used in the <code>withdraw_gas</code> libfunc and the compiled
corresponding IR to withdraw the gas and determine whether execution should
revert or continue. This can be observed in the following MLIR dump:</p>
<div class="example-wrap"><pre class="language-assembly"><code>llvm.func @&quot;test::test::run_test[expr16](f0)&quot;(%arg0: i64 loc(unknown), %arg1: i128 loc(unknown), %arg2: i8 loc(unknown), %arg3: i8 loc(unknown)) -&gt; !llvm.struct&lt;(i64, i128, struct&lt;(i64, array&lt;24 x i8&gt;)&gt;)&gt; attributes {llvm.emit_c_interface} {
  ...
  %12 = llvm.mlir.constant(5 : i8) : i8 loc(#loc1)
  %13 = llvm.mlir.constant(2680 : i128) : i128 loc(#loc1)
  %14 = llvm.mlir.constant(1 : i64) : i64 loc(#loc1)
  ...
  ^bb1(%27: i64 loc(unknown), %28: i128 loc(unknown), %29: i8 loc(unknown), %30: i8 loc(unknown)):  // 2 preds: ^bb0, ^bb6
    %31 = llvm.add %27, %14  : i64 loc(#loc13)
    %32 = llvm.icmp &quot;uge&quot; %28, %13 : i128 loc(#loc13)
    %33 = llvm.intr.usub.sat(%28, %13)  : (i128, i128) -&gt; i128 loc(#loc13)
    llvm.cond_br %32, ^bb2(%29 : i8), ^bb7(%5, %23, %23, %31 : i252, !llvm.ptr, !llvm.ptr, i64) loc(#loc13)
    ...
</code></pre></div>
<p>Here, we see the constant <code>2680</code> defined at the begining of the function.
In basic block 1, the withdraw_gas operations are performed: by comparing
<code>%28</code> (remaining gas) and <code>%13</code> (gas cost), the result stored in <code>%32</code>
determines the conditional branching. A saturating subtraction between the
remaining gas and the gas cost is then performed, updating the remaining gas
in the IR.</p>
<h4 id="final-gas-usage"><a class="doc-anchor" href="#final-gas-usage">§</a>Final gas usage</h4>
<p>The final gas usage can be easily retrieved from the gas builtin value
returned by the function. This is accomplished when
<a href="https://github.com/lambdaclass/cairo_native/blob/65face8194054b7ed396a34a60e7b1595197543a/src/executor.rs#L286">parsing the return values</a>
from the function call:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>...
<span class="kw">for </span>type_id <span class="kw">in </span><span class="kw-2">&amp;</span>function_signature.ret_types {
    <span class="kw">let </span>type_info = registry.get_type(type_id).unwrap();
    <span class="kw">match </span>type_info {
        CoreTypeConcrete::GasBuiltin(<span class="kw">_</span>) =&gt; {
            remaining_gas = <span class="prelude-val">Some</span>(<span class="kw">match </span><span class="kw-2">&amp;mut </span>return_ptr {
                <span class="prelude-val">Some</span>(return_ptr) =&gt; <span class="kw">unsafe </span>{ <span class="kw-2">*</span>read_value::&lt;u128&gt;(return_ptr) },
                <span class="prelude-val">None </span>=&gt; {
                    <span class="comment">// If there's no return ptr then the function only returned the gas. We don't
                    // need to bother with the syscall handler builtin.
                    </span>((ret_registers[<span class="number">1</span>] <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>) | ret_registers[<span class="number">0</span>] <span class="kw">as </span>u128
                }
            });
        }
        ...
    }
    ...
}
...</code></pre></div>
<p>This code snippet extracts the remaining gas from the return pointer based
on the function’s signature. If the function only returns the gas value,
the absence of a return pointer is handled appropriately, ensuring accurate
gas accounting.</p>
<h3 id="builtins-counter"><a class="doc-anchor" href="#builtins-counter">§</a>Builtins Counter</h3><h4 id="introduction-1"><a class="doc-anchor" href="#introduction-1">§</a>Introduction</h4>
<p>The Cairo Native compiler records the usage of each builtins in order to
provide information about the program’s builtins consumption.
This information is NOT used for the gas calculation, as the gas cost of
builtins is already taken into account during the <a href="./gas.md">gas accounting process</a>.
The builtins counter types can each be found in the <a href="../src/types/">types folder</a>.
Taking the <a href="../src/types/pedersen.rs">Pedersen hash</a> as an example, we see
that the counters will be represented as i64 integers in MLIR.
Counters are then simply incremented by one each time the builtins are
called from within the program.</p>
<h4 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h4>
<p>Let us consider the following Cairo program which uses the <code>pedersen</code> builtin:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::integer::bitwise;
<span class="kw">use </span>core::pedersen::pedersen;

<span class="kw">fn </span>run_test() {
    <span class="kw">let </span><span class="kw-2">mut </span>hash = pedersen(<span class="number">1</span>.into(), <span class="number">2</span>.into());
    hash += <span class="number">1</span>;
}</code></pre></div>
<p>We expect Native to increment the <code>pedersen</code> counter by 1 given the above code.
Let’s first check how this compiles to Sierra:</p>
<div class="example-wrap"><pre class="language-sierra"><code>const_as_immediate&lt;Const&lt;felt252, 1&gt;&gt;() -&gt; ([1]); // 0
const_as_immediate&lt;Const&lt;felt252, 2&gt;&gt;() -&gt; ([2]); // 1
store_temp&lt;felt252&gt;([1]) -&gt; ([1]); // 2
store_temp&lt;felt252&gt;([2]) -&gt; ([2]); // 3
pedersen([0], [1], [2]) -&gt; ([3], [4]); // 4
drop&lt;felt252&gt;([4]) -&gt; (); // 5
store_temp&lt;Pedersen&gt;([3]) -&gt; ([3]); // 6
return([3]); // 7

contracts::run_test@0([0]: Pedersen) -&gt; (Pedersen);
</code></pre></div>
<p>In the compiled Sierra, we can see that the <code>pedersen</code> builtin is passed
with the call to the <code>run_test</code> which starts at statement <code>0</code>. It is then
used in the call to the <code>pedersen</code> libfunc. We would expect to see the
<code>pedersen</code> counter incremented by 1 in the Native compiler. Below is the
compiled MLIR dump for the same program:</p>
<div class="example-wrap"><pre class="language-assembly"><code>...
llvm.func @&quot;test::test::run_test(f0)&quot;(%arg0: i64 loc(unknown)) -&gt; i64 attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(2 : i256) : i256 loc(#loc1)
    %1 = llvm.mlir.constant(1 : i256) : i256 loc(#loc1)
    %2 = llvm.mlir.constant(1 : i64) : i64 loc(#loc1)
    %3 = llvm.alloca %2 x i256 {alignment = 16 : i64} : (i64) -&gt; !llvm.ptr loc(#loc2)
    %4 = llvm.alloca %2 x i256 {alignment = 16 : i64} : (i64) -&gt; !llvm.ptr loc(#loc2)
    %5 = llvm.alloca %2 x i256 {alignment = 16 : i64} : (i64) -&gt; !llvm.ptr loc(#loc2)
    %6 = llvm.add %arg0, %2  : i64 loc(#loc2)
    %7 = llvm.intr.bswap(%1)  : (i256) -&gt; i256 loc(#loc2)
    %8 = llvm.intr.bswap(%0)  : (i256) -&gt; i256 loc(#loc2)
    llvm.store %7, %3 {alignment = 16 : i64} : i256, !llvm.ptr loc(#loc2)
    llvm.store %8, %4 {alignment = 16 : i64} : i256, !llvm.ptr loc(#loc2)
    llvm.call @cairo_native__libfunc__pedersen(%5, %3, %4) : (!llvm.ptr, !llvm.ptr, !llvm.ptr) -&gt; () loc(#loc2)
    llvm.return %6 : i64 loc(#loc3)
  } loc(#loc1)
  ...
</code></pre></div>
<p>The compiled MLIR function <code>run_test</code> takes a single argument as input, the
<code>pedersen</code> counter and returns the incremented counter at the end of the call.
The counter is incremented by 1 in the MLIR code, in the statement
<code>%6 = llvm.add %arg0, %2  : i64 loc(#loc2)</code>, which takes the <code>%arg0</code> input
and adds <code>%2</code> to it. We can see from statement
<code>%2 = llvm.mlir.constant(1 : i64) : i64 loc(#loc1)</code> that <code>%2</code> holds the
constant 1.
When this compiled MLIR code is called, the initial value of all builtin
counters is set to <code>0</code> as can be seen in the
<a href="../src/executor.rs#L240"><code>invoke_dynamic</code> function</a>.</p>
</div></details></section></div></main></body></html>