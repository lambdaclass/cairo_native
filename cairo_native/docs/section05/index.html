<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementing Libfuncs"><title>cairo_native::docs::section05 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cairo_native" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../cairo_native/index.html">cairo_<wbr>native</a><span class="version">0.2.4</span></h2></div><h2 class="location"><a href="#">Module section05</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In cairo_<wbr>native::<wbr>docs</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">cairo_native</a>::<wbr><a href="../index.html">docs</a>::<wbr><a class="mod" href="#">section05</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/cairo_native/docs.rs.html#24">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="implementing-libfuncs"><a class="doc-anchor" href="#implementing-libfuncs">Â§</a>Implementing Libfuncs</h2>
<p>ðŸš§ WIP</p>
<h3 id="a-libfunc-implementation"><a class="doc-anchor" href="#a-libfunc-implementation">Â§</a>A libfunc implementation.</h3>
<p>A libfunc usually works with a <code>type</code>, such as <code>felt252</code>. The compiler
needs to have information on this type, such as its layout and size.
This is defined in <code>src/types.rs</code> and <code>src/types/{typename}.rs</code>.</p>
<p>On each <code>src/types/{typename}.rs</code> such as <code>src/types/felt252.rs</code> you will
find a <code>build</code> function, this has all the necessary arguments to generate
the proper type and return a MLIR type, such as
<code>IntegerType::new(context, 252)</code> (a 252 bit integer).</p>
<p>In <code>src/types.rs</code> we need to declare the type layout, for example the
<code>felt252</code> would have the layout returned by <code>get_integer_layout(252)</code>.
A type that doesnâ€™t have size would be <code>Layout::new::&lt;()&gt;()</code>, or if the
type is a pointer like box: <code>Layout::new::&lt;*mut ()&gt;()</code></p>
<p>When adding a type, we also need to add the <strong>serialization</strong> and
<strong>deserialization</strong> functionality to convert the value to a memory representation that works with cairo-native.</p>
<p>You can find this functionality under <code>src/values.rs</code>.</p>
<p>There is a <code>Value</code> enum with all the possible values that can be passed as input/output.</p>
<p>This enum has a <code>impl</code> block with 2 important methods <code>to_ptr</code> and <code>from_ptr</code> which convert the Value into and from said
memory representation, held behind a pointer.</p>
<p>When passing the values as inputs, there is one more required step, that is to pass the bytes of those values in the
target platform ABI compatible way, this is done with the <code>AbiArgument</code> trait and the <code>to_bytes</code> method.</p>
<p>This trait, located in <code>src/arch.rs</code> is implemented currently for aarch64 and x86_64 (depending on the host platform) for some basic types, such as u64, u128, pointers, etc. Most importantly, it is also implemented for <code>ValueWithInfoWrapper</code> which allows to convert the Value using itâ€™s <code>to_ptr</code> method and correctly passing it as an argument in the given <code>buffer: &amp;mut Vec&lt;u8&gt;</code>.</p>
<p>In <code>types.rs</code> we should also declare whether the type is complex under
<code>is_complex</code>, whether its a builtin in <code>is_builtin</code>, a zst in <code>is_zst</code> and define itâ€™s layout in the <code>TypeBuilder</code> trait implementation.</p>
<blockquote>
<p>Complex types are always passed by pointer (both as params and return
values) and require a stack allocation. Examples of complex values include
structs and enums, but not felts since LLVM considers them integers.</p>
</blockquote>
<h4 id="deserializing-a-type"><a class="doc-anchor" href="#deserializing-a-type">Â§</a>Deserializing a type</h4>
<p>When <strong>deserializing</strong> (a.k.a converting the inputs so the runner
accepts them), you are passed a bump allocator arena from <code>Bumpalo</code>, the
general idea is to get the layout and size of the type, allocate it under
the arena, get a pointer, and return it (Some types require additional data on the heap, such as arrays, such allocations should be done with libcâ€™s malloc.). Which will later be passed to the runner. It is important the pointers passed are allocated by the
arena and not Rust itself.</p>
<p>This is done in the <code>to_ptr</code> method.</p>
<h4 id="serializing-a-type"><a class="doc-anchor" href="#serializing-a-type">Â§</a>Serializing a type</h4>
<p>When <strong>serializing</strong> a type, you will get a <code>ptr: NonNull&lt;()&gt;</code> (non null
pointer), which you will have to cast, dereference and then deserialize.</p>
<p>For a simple type to learn how it works, we recommend checking
<code>src/values.rs</code>, in the <code>from_ptr</code> method, look the u8 type in the match, for more complex types, check the felt252 type.
The hardest types to understand are the enums, dictionaries and arrays,
since they are complex types.</p>
<h4 id="implementing-the-library-function"><a class="doc-anchor" href="#implementing-the-library-function">Â§</a>Implementing the library function</h4>
<p>Libfuncs are implemented under <code>src/libfuncs.rs</code> and
<code>src/libfuncs/{libfunc_name}.rs</code>. Just like types.</p>
<p>Using the <code>src/libfuncs/felt252.rs</code> libfuncs as a aid:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Select and call the correct libfunc builder function from the selector.
</span><span class="kw">pub fn </span>build&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>&gt;(
    context: <span class="kw-2">&amp;</span><span class="lifetime">'ctx </span>Context,
    registry: <span class="kw-2">&amp;</span>ProgramRegistry&lt;CoreType, CoreLibfunc&gt;,
    entry: <span class="kw-2">&amp;</span><span class="lifetime">'this </span>Block&lt;<span class="lifetime">'ctx</span>&gt;,
    location: Location&lt;<span class="lifetime">'ctx</span>&gt;,
    helper: <span class="kw-2">&amp;</span>LibfuncHelper&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>&gt;,
    metadata: <span class="kw-2">&amp;mut </span>MetadataStorage,
    selector: <span class="kw-2">&amp;</span>Felt252Concrete,
) -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="kw">match </span>selector {
        Felt252Concrete::BinaryOperation(info) =&gt; {
            build_binary_operation(context, registry, entry, location, helper, metadata, info)
        }
        Felt252Concrete::Const(info) =&gt; {
            build_const(context, registry, entry, location, helper, metadata, info)
        }
        Felt252Concrete::IsZero(info) =&gt; {
            build_is_zero(context, registry, entry, location, helper, metadata, info)
        }
    }
}</code></pre></div>
<p>You can see it also defines a build function, in this case the last method
is a selector, this means in this case we have a group of related libfuncs,
which we will implement in this same file. This is where calls to melior
(MLIR) and most MLIR code is located, where one gets their hands dirty.</p>
<p>After implementing the libfuncs, we need to hookup the <code>build</code> method in
the <code>src/libfuncs.rs</code> match statement.</p>
<h4 id="example-libfunc-implementation-u8_to_felt252"><a class="doc-anchor" href="#example-libfunc-implementation-u8_to_felt252">Â§</a>Example libfunc implementation: u8_to_felt252</h4>
<p>An example libfunc, converting a u8 to a felt252, extensively commented:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Generate MLIR operations for the `u8_to_felt252` libfunc.
</span><span class="kw">pub fn </span>build_to_felt252&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>&gt;(
    <span class="comment">// The Context from MLIR, this is like the heart of the MLIR API, its required to create most stuff like types.
    </span>context: <span class="kw-2">&amp;</span><span class="lifetime">'ctx </span>Context,
    <span class="comment">// This is the sierra program registry, it aids us at finding types, functions, etc.
    </span>registry: <span class="kw-2">&amp;</span>ProgramRegistry&lt;CoreType, CoreLibfunc&gt;,
    <span class="comment">// This is the MLIR entry block for this libfunc. Remember we append operations to blocks.
    </span>entry: <span class="kw-2">&amp;</span><span class="lifetime">'this </span>Block&lt;<span class="lifetime">'ctx</span>&gt;,
    <span class="comment">// The already created MLIR location for this libfunc, we need to pass this to all the MLIR operations.
    </span>location: Location&lt;<span class="lifetime">'ctx</span>&gt;,
    <span class="comment">// A helper, which also works as a MLIR Module, it has useful functions for stuff like branching to other libfuncs.
    </span>helper: <span class="kw-2">&amp;</span>LibfuncHelper&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>&gt;,
    <span class="comment">// The metadata storage, contains extra information needed on some libfuncs. Check out `src/metadata.rs` to learn how it works.
    </span>metadata: <span class="kw-2">&amp;mut </span>MetadataStorage,
    <span class="comment">// The sierra information for this specific library function. This libfunc only contains signature information, but
    // others which are generic over a type will contain information about that type, for example array related libfuncs.
    </span>info: <span class="kw-2">&amp;</span>SignatureOnlyConcreteLibfunc,
) -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="comment">// We retrieve the felt252 type from the registry and call the "build" method to create the MLIR type.
    // We could also just call get_type() to hold on to the sierra type, and then `.layout(registry)` to get the type layout,
    // which is needed in some libfuncs doing more complex stuff.
    </span><span class="kw">let </span>felt252_ty = registry.build_type(
        context,
        helper,
        registry,
        metadata,
        <span class="kw-2">&amp;</span>info.branch_signatures()[<span class="number">0</span>].vars[<span class="number">0</span>].ty,
    )<span class="question-mark">?</span>;

    <span class="comment">// Retrieve the first argument passed to this library function, in this case its the u8 value we need to convert.
    </span><span class="kw">let </span>value: Value = entry.argument(<span class="number">0</span>)<span class="question-mark">?</span>.into();

    <span class="comment">// We create a "extui" operation from the "arith" dialect, which basically
    // zero extends the value to have the same bits as the given type.
    </span><span class="kw">let </span>result = entry.append_op_result(arith::extui(value, felt252_ty, location))<span class="question-mark">?</span>;

    <span class="comment">// Using the helper argument, append the branching operation to the next statement, passing result as our output variable.
    </span>entry.append_operation(helper.br(<span class="number">0</span>, <span class="kw-2">&amp;</span>[result], location));

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>More info on the <code>extui</code> operation: <a href="https://mlir.llvm.org/docs/Dialects/ArithOps/#arithextui-arithextuiop">https://mlir.llvm.org/docs/Dialects/ArithOps/#arithextui-arithextuiop</a></p>
</div></details></section></div></main></body></html>