<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementing Libfuncs"><title>cairo_native::docs::section05 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cairo_native" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../cairo_native/index.html">cairo_native</a><span class="version">0.2.0-alpha.2</span></h2></div><h2 class="location"><a href="#">Module section05</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In cairo_native::docs</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">cairo_native</a>::<wbr><a href="../index.html">docs</a>::<wbr><a class="mod" href="#">section05</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/cairo_native/docs.rs.html#24">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="implementing-libfuncs"><a class="doc-anchor" href="#implementing-libfuncs">Â§</a>Implementing Libfuncs</h2>
<p>ðŸš§ WIP</p>
<h3 id="a-libfunc-implementation"><a class="doc-anchor" href="#a-libfunc-implementation">Â§</a>A libfunc implementation.</h3>
<p>A libfunc usually works with a <code>type</code>, such as <code>felt252</code>. The compiler
needs to have information on this type, such as its layout and size.
This is defined in <code>src/types.rs</code> and <code>src/types/{typename}.rs</code>.</p>
<p>On each <code>src/types/{typename}.rs</code> such as <code>src/types/felt252.rs</code> you will
find a <code>build</code> function, this has all the necessary arguments to generate
the proper type and return a MLIR type, such as
<code>IntegerType::new(context, 252)</code> (a 252 bit integer).</p>
<p>In <code>src/types.rs</code> we need to declare the type layout, for example the
<code>felt252</code> would have the layout returned by <code>get_integer_layout(252)</code>.
A type that doesnâ€™t have size would be <code>Layout::new::&lt;()&gt;()</code>, or if the
type is a pointer like box: <code>Layout::new::&lt;*mut ()&gt;()</code></p>
<p>When adding a type, we also need to add the <strong>serialization</strong> and
<strong>deserialization</strong> functionality, so we can use it with the JIT runner.</p>
<p>You can find this functionality under <code>src/values.rs</code> and
<code>src/values/{typename}.rs</code>. As you can see, the project is quite organized
if you have a feel of its layout.</p>
<p>Serialization is done using <code>Serde</code>, and each type provides a <code>deserialize</code>
and <code>serialize</code> function. The inner workings of such functions can be a bit
complex due to how the JIT runner works. You need to work with pointers and
unsafe rust.</p>
<p>In <code>values.rs</code> we should also declare whether the type is complex under
<code>is_complex</code> in the <code>ValueBuilder</code> trait implementation.</p>
<blockquote>
<p>Complex types are always passed by pointer (both as params and return
values) and require a stack allocation. Examples of complex values include
structs and enums, but not felts since LLVM considers them integers.</p>
</blockquote>
<h4 id="deserializing-a-type"><a class="doc-anchor" href="#deserializing-a-type">Â§</a>Deserializing a type</h4>
<p>When <strong>deserializing</strong> (a.k.a converting the inputs so the JIT runner
accepts them), you are passed a bump allocator arena from <code>Bumpalo</code>, the
general idea is to get the layout and size of the type, allocate it under
the arena, get a pointer, and return it. Which will later be passed to the
MLIR JIT runner. It is important the pointers passed are allocated by the
arena and not Rust itself.</p>
<p>Then we need to hookup de <code>deserialize</code> method in <code>values.rs</code> <code>deserialize</code>
method.</p>
<h4 id="serializing-a-type"><a class="doc-anchor" href="#serializing-a-type">Â§</a>Serializing a type</h4>
<p>When <strong>serializing</strong> a type, you will get a <code>ptr: NonNull&lt;()&gt;</code> (non null
pointer), which you will have to cast, dereference and then deserialize.</p>
<p>For a simple type to learn how it works, we recommend checking
<code>src/values/uint8.rs</code>, for more complex types, check <code>src/values/felt252.rs</code>.
The hardest types to understand are the enums, dictionaries and arrays,
since they are complex types.</p>
<p>Then we need to hookup de <code>serialize</code> method in <code>values.rs</code> <code>serialize</code> method.</p>
<h4 id="implementing-the-library-function"><a class="doc-anchor" href="#implementing-the-library-function">Â§</a>Implementing the library function</h4>
<p>Libfuncs are implemented under <code>src/libfuncs.rs</code> and
<code>src/libfuncs/{libfunc_name}.rs</code>. Just like types.</p>
<p>Using the <code>src/libfuncs/felt252.rs</code> libfuncs as a aid:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Select and call the correct libfunc builder function from the selector.
</span><span class="kw">pub fn </span>build&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>, TType, TLibfunc&gt;(
    context: <span class="kw-2">&amp;</span><span class="lifetime">'ctx </span>Context,
    registry: <span class="kw-2">&amp;</span>ProgramRegistry&lt;TType, TLibfunc&gt;,
    entry: <span class="kw-2">&amp;</span><span class="lifetime">'this </span>Block&lt;<span class="lifetime">'ctx</span>&gt;,
    location: Location&lt;<span class="lifetime">'ctx</span>&gt;,
    helper: <span class="kw-2">&amp;</span>LibfuncHelper&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>&gt;,
    metadata: <span class="kw-2">&amp;mut </span>MetadataStorage,
    selector: <span class="kw-2">&amp;</span>Felt252Concrete,
) -&gt; <span class="prelude-ty">Result</span>&lt;()&gt;
<span class="kw">where
    </span>TType: GenericType,
    TLibfunc: GenericLibfunc,
    &lt;TType <span class="kw">as </span>GenericType&gt;::Concrete: TypeBuilder&lt;TType, TLibfunc, Error = CoreTypeBuilderError&gt;,
    &lt;TLibfunc <span class="kw">as </span>GenericLibfunc&gt;::Concrete: LibfuncBuilder&lt;TType, TLibfunc, Error = Error&gt;,
{
    <span class="kw">match </span>selector {
        Felt252Concrete::BinaryOperation(info) =&gt; {
            build_binary_operation(context, registry, entry, location, helper, metadata, info)
        }
        Felt252Concrete::Const(info) =&gt; {
            build_const(context, registry, entry, location, helper, metadata, info)
        }
        Felt252Concrete::IsZero(info) =&gt; {
            build_is_zero(context, registry, entry, location, helper, metadata, info)
        }
    }
}</code></pre></div>
<p>You can see it also defines a build function, in this case the last method
is a selector, this means in this case we have a group of related libfuncs,
which we will implement in this same file. This is where calls to melior
(MLIR) and most MLIR code is located, where one gets their hands dirty.</p>
<p>After implementing the libfuncs, we need to hookup the <code>build</code> method in
the <code>src/libfuncs.rs</code> match statement.</p>
<h4 id="example-libfunc-implementation-u8_to_felt252"><a class="doc-anchor" href="#example-libfunc-implementation-u8_to_felt252">Â§</a>Example libfunc implementation: u8_to_felt252</h4>
<p>An example libfunc, converting a u8 to a felt252, extensively commented:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Generate MLIR operations for the `u8_to_felt252` libfunc.
</span><span class="kw">pub fn </span>build_to_felt252&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>, TType, TLibfunc&gt;(
    <span class="comment">// The Context from MLIR, this is like the heart of the MLIR API, its required to create most stuff like types.
    </span>context: <span class="kw-2">&amp;</span><span class="lifetime">'ctx </span>Context,
    <span class="comment">// This is the sierra program registry, it aids us at finding types, functions, etc.
    </span>registry: <span class="kw-2">&amp;</span>ProgramRegistry&lt;TType, TLibfunc&gt;,
    <span class="comment">// This is the MLIR entry block for this libfunc. Remember we append operations to blocks.
    </span>entry: <span class="kw-2">&amp;</span><span class="lifetime">'this </span>Block&lt;<span class="lifetime">'ctx</span>&gt;,
    <span class="comment">// The already created MLIR location for this libfunc, we need to pass this to all the MLIR operations.
    </span>location: Location&lt;<span class="lifetime">'ctx</span>&gt;,
    <span class="comment">// A helper, which also works as a MLIR Module, it has useful functions for stuff like branching to other libfuncs.
    </span>helper: <span class="kw-2">&amp;</span>LibfuncHelper&lt;<span class="lifetime">'ctx</span>, <span class="lifetime">'this</span>&gt;,
    <span class="comment">// The metadata storage, contains extra information needed on some libfuncs. Check out `src/metadata.rs` to learn how it works.
    </span>metadata: <span class="kw-2">&amp;mut </span>MetadataStorage,
    <span class="comment">// The sierra information for this specific library function. This libfunc only contains signature information, but
    // others which are generic over a type will contain information about that type, for example array related libfuncs.
    </span>info: <span class="kw-2">&amp;</span>SignatureOnlyConcreteLibfunc,
) -&gt; <span class="prelude-ty">Result</span>&lt;()&gt;
<span class="kw">where
    </span>TType: GenericType,
    TLibfunc: GenericLibfunc,
    &lt;TType <span class="kw">as </span>GenericType&gt;::Concrete: TypeBuilder&lt;TType, TLibfunc, Error = CoreTypeBuilderError&gt;,
    &lt;TLibfunc <span class="kw">as </span>GenericLibfunc&gt;::Concrete: LibfuncBuilder&lt;TType, TLibfunc, Error = Error&gt;,
{
    <span class="comment">// We retrieve the felt252 type from the registry and call the "build" method to create the MLIR type.
    // We could also just call get_type() to hold on to the sierra type, and then `.layout(registry)` to get the type layout,
    // which is needed in some libfuncs doing more complex stuff.
    </span><span class="kw">let </span>felt252_ty = registry
        .get_type(<span class="kw-2">&amp;</span>info.branch_signatures()[<span class="number">0</span>].vars[<span class="number">0</span>].ty)<span class="question-mark">?
        </span>.build(context, helper, registry, metadata)<span class="question-mark">?</span>;

    <span class="comment">// Retrieve the first argument passed to this library function, in this case its the u8 value we need to convert.
    </span><span class="kw">let </span>value: Value = entry.argument(<span class="number">0</span>)<span class="question-mark">?</span>.into();

    <span class="comment">// We create a "extui" operation from the "arith" dialect, which basically zero extends the value to have the same bits as the given type.
    </span><span class="kw">let </span>op = entry.append_operation(arith::extui(value, felt252_ty, location));

    <span class="comment">// Get  the result from the operation, in this case it's the extended value
    </span><span class="kw">let </span>result = op.result(<span class="number">0</span>)<span class="question-mark">?</span>.into();

    <span class="comment">// Using the helper argument, append the branching operation to the next statement, passing result as our output variable.
    </span>entry.append_operation(helper.br(<span class="number">0</span>, <span class="kw-2">&amp;</span>[result], location));

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>More info on the <code>extui</code> operation: <a href="https://mlir.llvm.org/docs/Dialects/ArithOps/#arithextui-arithextuiop">https://mlir.llvm.org/docs/Dialects/ArithOps/#arithextui-arithextuiop</a></p>
</div></details></section></div></main></body></html>