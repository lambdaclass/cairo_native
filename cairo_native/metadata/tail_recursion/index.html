<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Tail recursion information"><title>cairo_native::metadata::tail_recursion - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-081576b923113409.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cairo_native" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0 (129f3b996 2024-06-10)" data-channel="1.79.0" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-e32f0c247825364d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../cairo_native/index.html">cairo_native</a><span class="version">0.2.0</span></h2></div><h2 class="location"><a href="#">Module tail_recursion</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section><h2><a href="../index.html">In cairo_native::metadata</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../cairo_native/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">cairo_native</a>::<wbr><a href="../index.html">metadata</a>::<wbr><a class="mod" href="#">tail_recursion</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/cairo_native/metadata/tail_recursion.rs.html#1-85">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="tail-recursion-information"><a class="doc-anchor" href="#tail-recursion-information">§</a>Tail recursion information</h2>
<p>Whenever the compiler detects a direct tail-recursive function call it’ll insert this metadata.
If the libfunc handler decides to use it by setting a return target, the compiler will insert
the required instructions to make it really tail-recursive.</p>
<p>Directly recursive functions are detected by checking if the current statement is a function
call. Indirect recursion is not handled and generates normal recursive code.</p>
<p>Next, the compiler check whether those direct recursive calls are in fact tail recursive.
Recursive function calls are tail recursive if nothing declared before the function call is used
after it. Due to the way Sierra works, this is as simple as checking whether the state is empty
after taking the variables sent to the function call from itself.</p>
<p>When tail recursion is detected, a counter is added which counts the current recursion depth.
The counter being zero means that no recursion has taken place (either because the program
hasn’t reached the recursion point yet, or because it has completely unwinded already).</p>
<p>Every time the recursive function call is invoked, the libfunc builder should increment this
counter by one and jump to the recursion target block provided by the meta. This recursion
target is provided by the compiler and should point to the beginning of the function and have
the same arguments. The function call libfunc builder should then set the return target to a
block which jumps to the next libfunc (a standard libfunc builder terminator as in every other
libfunc).</p>
<p>When the compiler generates the code for a return statement of a tail recursive function, it’ll
first check whether the depth counter is zero or not. If zero, a normal return statement will be
generated since it’d mean our parent frame is a different function. However if the counter is
not zero, the counter is decremented by one and a jump to the return target is generated, which
will return control to the function call libfunc builder. The builder should then jump to the
next libfunc statement as if it were a normal function call.</p>
<p>After calling the libfunc builder, the metadata is removed from storage to avoid collisions
later on.</p>
<p>The same algorithm can be applied multiple times if there are multiple tail-recursive calls
within a function. The compiler should create a different depth counter for each recursive call
in the function.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.TailRecursionMeta.html" title="struct cairo_native::metadata::tail_recursion::TailRecursionMeta">TailRecursionMeta</a></div><div class="desc docblock-short">The tail recursion metadata.</div></li></ul></section></div></main></body></html>