; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128-Fn32"
target triple = "arm64-apple-darwin24.6.0"

@assert_msg_202 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_201 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_200 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_199 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_198 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_197 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_196 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_195 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_194 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_193 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_192 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_191 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_190 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_189 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_188 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_187 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_186 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_185 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_184 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_183 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_182 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_181 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_180 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_179 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_178 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_177 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_176 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_175 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_174 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_173 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_172 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_171 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_170 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_169 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_168 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_167 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_166 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_165 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_164 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_163 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_162 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_161 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_160 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_159 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_158 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_157 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_156 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_155 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_154 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_153 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_152 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_151 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_150 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_149 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_148 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_147 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_146 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_145 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_144 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_143 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_142 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_141 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_140 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_139 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_138 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_137 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_136 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_135 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_134 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_133 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_132 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_131 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_130 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_129 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_128 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_127 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_126 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_125 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_124 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_123 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_122 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_121 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_120 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_119 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_118 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_117 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_116 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_115 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_114 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_113 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_112 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_111 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_110 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_109 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_108 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_107 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_106 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_105 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_104 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_103 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_102 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_101 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_100 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_99 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_98 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_97 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_96 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_95 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_94 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_93 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_92 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_91 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_90 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_89 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_88 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_87 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_86 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_85 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_84 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_83 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_82 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_81 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_80 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_79 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_78 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_77 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_76 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_75 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_74 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_73 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_72 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_71 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_70 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_69 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_68 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_67 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_66 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_65 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_64 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_63 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_62 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_61 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_60 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_59 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_58 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_57 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_56 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_55 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_54 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_53 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_52 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_51 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_50 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_49 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_48 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_47 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_46 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_45 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_44 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_43 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_42 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_41 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_40 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_39 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_38 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_37 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_36 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_35 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_34 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_33 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_32 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_31 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_30 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_29 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_28 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_27 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_26 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_25 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_24 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_23 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_22 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_21 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_20 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_19 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_18 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_17 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_16 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_15 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_14 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_13 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_12 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_11 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_10 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_9 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_8 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_7 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_6 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_5 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_4 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_3 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_2 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_1 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg_0 = private constant [18 x i8] c"Invalid enum tag.\00"
@assert_msg = private constant [18 x i8] c"Invalid enum tag.\00"
@cairo_native__get_costs_builtin = weak global ptr undef
@cairo_native__libfunc__pedersen = weak global ptr undef

declare void @abort()

declare void @puts(ptr)

declare ptr @realloc(ptr, i64)

declare void @free(ptr)

define private void @"drop$2"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$3"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$2"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$4"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$3"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$550"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$550"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { {}, { ptr, i32, i32, i32 } } %0, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { {}, { ptr, i32, i32, i32 } } %0, 0
  %3 = insertvalue { {}, { ptr, i32, i32, i32 } } %0, {} %2, 0
  %4 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, {} %2, 0
  %5 = extractvalue { {}, { ptr, i32, i32, i32 } } %0, 1
  %6 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %5)
  %7 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 1
  %9 = insertvalue { {}, { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %7, 1
  %10 = insertvalue { {}, { ptr, i32, i32, i32 } } %4, { ptr, i32, i32, i32 } %8, 1
  %11 = insertvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %9, 0
  %12 = insertvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %11, { {}, { ptr, i32, i32, i32 } } %10, 1
  ret { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %12
}

define private void @"drop$554"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, 1
  call void @"drop$550"({ { { ptr, i32, i32, i32 } } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$554"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$550"({ { { ptr, i32, i32, i32 } } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, { { { ptr, i32, i32, i32 } } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } %5, { { { ptr, i32, i32, i32 } } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$555"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$555"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$552"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$552"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } }, ptr %2, align 2
  %6 = extractvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, 1
  %7 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %7, ptr %2, align 2
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %9, ptr %2, align 2
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f0"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = add i64 %1, 1
  %15 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %16 = call ptr %15()
  %17 = icmp uge i64 %3, 0
  %18 = call i64 @llvm.usub.sat.i64(i64 %3, i64 0)
  br i1 %17, label %19, label %328

19:                                               ; preds = %6
  %20 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  %21 = extractvalue { { ptr, i32, i32, i32 } } %20, 0
  %22 = extractvalue { ptr, i32, i32, i32 } %21, 1
  %23 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %24 = sub i32 %23, %22
  %25 = icmp uge i32 %24, 1
  br i1 %25, label %26, label %305

26:                                               ; preds = %19
  %27 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %28 = load ptr, ptr %27, align 8
  %29 = zext i32 %22 to i64
  %30 = mul i64 %29, 32
  %31 = getelementptr inbounds i8, ptr %28, i64 %30
  %32 = add i32 %22, 1
  %33 = insertvalue { ptr, i32, i32, i32 } %21, i32 %32, 1
  %34 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %34, ptr %31, i64 32, i1 false)
  %35 = load i252, ptr %34, align 16
  call void @free(ptr %34)
  %36 = add i64 %1, 4
  %37 = icmp ult i252 %35, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %37, label %38, label %298

38:                                               ; preds = %26
  %39 = phi { ptr, i32, i32, i32 } [ %33, %26 ]
  %40 = extractvalue { ptr, i32, i32, i32 } %39, 1
  %41 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %42 = sub i32 %41, %40
  %43 = icmp uge i32 %42, 1
  br i1 %43, label %44, label %275

44:                                               ; preds = %38
  %45 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %46 = load ptr, ptr %45, align 8
  %47 = zext i32 %40 to i64
  %48 = mul i64 %47, 32
  %49 = getelementptr inbounds i8, ptr %46, i64 %48
  %50 = add i32 %40, 1
  %51 = insertvalue { ptr, i32, i32, i32 } %39, i32 %50, 1
  %52 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %52, ptr %49, i64 32, i1 false)
  %53 = load i252, ptr %52, align 16
  call void @free(ptr %52)
  %54 = trunc i252 %53 to i128
  %55 = lshr i252 %53, 128
  %56 = trunc i252 %55 to i128
  %57 = icmp ne i128 %56, 0
  %58 = add i64 %1, 7
  %59 = add i64 %1, 5
  %60 = select i1 %57, i64 %58, i64 %59
  br i1 %57, label %268, label %61

61:                                               ; preds = %44
  %62 = phi { ptr, i32, i32, i32 } [ %51, %44 ]
  %63 = extractvalue { ptr, i32, i32, i32 } %62, 1
  %64 = extractvalue { ptr, i32, i32, i32 } %62, 2
  %65 = sub i32 %64, %63
  %66 = icmp uge i32 %65, 1
  br i1 %66, label %67, label %261

67:                                               ; preds = %61
  %68 = extractvalue { ptr, i32, i32, i32 } %62, 0
  %69 = load ptr, ptr %68, align 8
  %70 = zext i32 %63 to i64
  %71 = mul i64 %70, 32
  %72 = getelementptr inbounds i8, ptr %69, i64 %71
  %73 = add i32 %63, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %62, i32 %73, 1
  %75 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %75, ptr %72, i64 32, i1 false)
  %76 = load i252, ptr %75, align 16
  call void @free(ptr %75)
  %77 = trunc i252 %76 to i128
  %78 = lshr i252 %76, 128
  %79 = trunc i252 %78 to i128
  %80 = icmp ne i128 %79, 0
  %81 = add i64 %60, 3
  %82 = add i64 %60, 1
  %83 = select i1 %80, i64 %81, i64 %82
  br i1 %80, label %254, label %84

84:                                               ; preds = %67
  %85 = phi { ptr, i32, i32, i32 } [ %74, %67 ]
  %86 = extractvalue { ptr, i32, i32, i32 } %85, 1
  %87 = extractvalue { ptr, i32, i32, i32 } %85, 2
  %88 = sub i32 %87, %86
  %89 = icmp uge i32 %88, 1
  br i1 %89, label %90, label %109

90:                                               ; preds = %84
  %91 = extractvalue { ptr, i32, i32, i32 } %85, 0
  %92 = load ptr, ptr %91, align 8
  %93 = zext i32 %86 to i64
  %94 = mul i64 %93, 32
  %95 = getelementptr inbounds i8, ptr %92, i64 %94
  %96 = add i32 %86, 1
  %97 = insertvalue { ptr, i32, i32, i32 } %85, i32 %96, 1
  %98 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %98, ptr %95, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %97)
  call void @"drop$555"(ptr %98)
  %99 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %100 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %99, 0
  %101 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %100, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %101, ptr %13, align 8
  %102 = load { i64, [24 x i8] }, ptr %13, align 8
  %103 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %104 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %103, i64 %83, 1
  %105 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %104, i64 %2, 2
  %106 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %105, i64 %18, 3
  %107 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %106, ptr %4, 4
  %108 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %107, { i64, [24 x i8] } %102, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %108

109:                                              ; preds = %84
  %110 = phi { ptr, i32, i32, i32 } [ %85, %84 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %110)
  %111 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %112 = call ptr %111()
  %113 = add i64 %83, 1
  %114 = getelementptr inbounds i64, ptr %112, i32 1
  %115 = load i64, ptr %114, align 8
  %116 = getelementptr inbounds i64, ptr %112, i32 2
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 11
  %119 = add i64 %115, %118
  %120 = load i64, ptr %112, align 8
  %121 = mul i64 %120, 108740
  %122 = add i64 %119, %121
  %123 = icmp uge i64 %18, %122
  %124 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %122)
  br i1 %123, label %125, label %247

125:                                              ; preds = %109
  %126 = phi i128 [ %54, %109 ]
  %127 = phi i128 [ %77, %109 ]
  %128 = insertvalue { i128, i128 } undef, i128 %126, 0
  %129 = insertvalue { i128, i128 } %128, i128 %127, 1
  %130 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f14"(i64 %113, i64 %124, i64 %2, i64 %0, ptr %4, { {} } undef, i252 %35, { i128, i128 } %129)
  %131 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 0
  %132 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 1
  %133 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 2
  %134 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 3
  %135 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 4
  %136 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 5
  store { i64, [24 x i8] } %136, ptr %10, align 8
  %137 = load i1, ptr %10, align 1
  switch i1 %137, label %138 [
    i1 false, label %140
    i1 true, label %236
  ]

138:                                              ; preds = %125
  br i1 false, label %139, label %351

139:                                              ; preds = %138
  unreachable

140:                                              ; preds = %125
  %141 = load { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } }, ptr %10, align 2
  %142 = extractvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %141, 1
  %143 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %144 = call ptr %143()
  %145 = call i64 @llvm.uadd.sat.i64(i64 %132, i64 0)
  %146 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %142, 0
  %147 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 0
  %148 = zext i8 %147 to i252
  %149 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 1
  %150 = zext i8 %149 to i252
  %151 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 2
  %152 = zext i8 %151 to i252
  %153 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 3
  %154 = zext i8 %153 to i252
  %155 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 4
  %156 = zext i8 %155 to i252
  %157 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 5
  %158 = zext i8 %157 to i252
  %159 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 6
  %160 = zext i8 %159 to i252
  %161 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 7
  %162 = zext i8 %161 to i252
  %163 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 8
  %164 = zext i16 %163 to i252
  %165 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 9
  %166 = zext i16 %165 to i252
  %167 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %146, 10
  %168 = zext i16 %167 to i252
  %169 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %169, align 4
  %170 = getelementptr inbounds i8, ptr %169, i32 4
  store i32 0, ptr %170, align 4
  %171 = getelementptr inbounds i8, ptr %169, i32 16
  %172 = call ptr @realloc(ptr null, i64 8)
  store ptr %171, ptr %172, align 8
  %173 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %172, 0
  %174 = insertvalue { ptr, i32, i32, i32 } %173, i32 8, 3
  %175 = load ptr, ptr %172, align 8
  store i252 %148, ptr %175, align 16
  %176 = insertvalue { ptr, i32, i32, i32 } %174, i32 1, 2
  %177 = getelementptr inbounds i8, ptr %175, i32 -12
  store i32 1, ptr %177, align 4
  %178 = load ptr, ptr %172, align 8
  %179 = getelementptr inbounds i8, ptr %178, i32 32
  store i252 %150, ptr %179, align 16
  %180 = insertvalue { ptr, i32, i32, i32 } %176, i32 2, 2
  %181 = getelementptr inbounds i8, ptr %178, i32 -12
  store i32 2, ptr %181, align 4
  %182 = load ptr, ptr %172, align 8
  %183 = getelementptr inbounds i8, ptr %182, i32 64
  store i252 %152, ptr %183, align 16
  %184 = insertvalue { ptr, i32, i32, i32 } %180, i32 3, 2
  %185 = getelementptr inbounds i8, ptr %182, i32 -12
  store i32 3, ptr %185, align 4
  %186 = load ptr, ptr %172, align 8
  %187 = getelementptr inbounds i8, ptr %186, i32 96
  store i252 %154, ptr %187, align 16
  %188 = insertvalue { ptr, i32, i32, i32 } %184, i32 4, 2
  %189 = getelementptr inbounds i8, ptr %186, i32 -12
  store i32 4, ptr %189, align 4
  %190 = load ptr, ptr %172, align 8
  %191 = getelementptr inbounds i8, ptr %190, i32 128
  store i252 %156, ptr %191, align 16
  %192 = insertvalue { ptr, i32, i32, i32 } %188, i32 5, 2
  %193 = getelementptr inbounds i8, ptr %190, i32 -12
  store i32 5, ptr %193, align 4
  %194 = load ptr, ptr %172, align 8
  %195 = getelementptr inbounds i8, ptr %194, i32 160
  store i252 %158, ptr %195, align 16
  %196 = insertvalue { ptr, i32, i32, i32 } %192, i32 6, 2
  %197 = getelementptr inbounds i8, ptr %194, i32 -12
  store i32 6, ptr %197, align 4
  %198 = load ptr, ptr %172, align 8
  %199 = getelementptr inbounds i8, ptr %198, i32 192
  store i252 %160, ptr %199, align 16
  %200 = insertvalue { ptr, i32, i32, i32 } %196, i32 7, 2
  %201 = getelementptr inbounds i8, ptr %198, i32 -12
  store i32 7, ptr %201, align 4
  %202 = load ptr, ptr %172, align 8
  %203 = getelementptr inbounds i8, ptr %202, i32 224
  store i252 %162, ptr %203, align 16
  %204 = insertvalue { ptr, i32, i32, i32 } %200, i32 8, 2
  %205 = getelementptr inbounds i8, ptr %202, i32 -12
  store i32 8, ptr %205, align 4
  %206 = load ptr, ptr %172, align 8
  %207 = getelementptr inbounds i8, ptr %206, i32 -16
  %208 = call ptr @realloc(ptr %207, i64 784)
  %209 = getelementptr inbounds i8, ptr %208, i32 16
  store ptr %209, ptr %172, align 8
  %210 = insertvalue { ptr, i32, i32, i32 } %204, i32 24, 3
  %211 = load ptr, ptr %172, align 8
  %212 = getelementptr inbounds i8, ptr %211, i32 256
  store i252 %164, ptr %212, align 16
  %213 = insertvalue { ptr, i32, i32, i32 } %210, i32 9, 2
  %214 = getelementptr inbounds i8, ptr %211, i32 -12
  store i32 9, ptr %214, align 4
  %215 = load ptr, ptr %172, align 8
  %216 = getelementptr inbounds i8, ptr %215, i32 288
  store i252 %166, ptr %216, align 16
  %217 = insertvalue { ptr, i32, i32, i32 } %213, i32 10, 2
  %218 = getelementptr inbounds i8, ptr %215, i32 -12
  store i32 10, ptr %218, align 4
  %219 = load ptr, ptr %172, align 8
  %220 = getelementptr inbounds i8, ptr %219, i32 320
  store i252 %168, ptr %220, align 16
  %221 = insertvalue { ptr, i32, i32, i32 } %217, i32 11, 2
  %222 = getelementptr inbounds i8, ptr %219, i32 -12
  store i32 11, ptr %222, align 4
  %223 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %221)
  %224 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %223, 0
  %225 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %223, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %224)
  %226 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %225, 0
  %227 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %226, 0
  %228 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %227, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %228, ptr %12, align 8
  %229 = load { i64, [24 x i8] }, ptr %12, align 8
  %230 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %134, 0
  %231 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %230, i64 %131, 1
  %232 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %231, i64 %133, 2
  %233 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %232, i64 %145, 3
  %234 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %233, ptr %135, 4
  %235 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %234, { i64, [24 x i8] } %229, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %235

236:                                              ; preds = %125
  %237 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %238 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %237, 1
  %239 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %238, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %239, ptr %11, align 8
  %240 = load { i64, [24 x i8] }, ptr %11, align 8
  %241 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %134, 0
  %242 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %241, i64 %131, 1
  %243 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %242, i64 %133, 2
  %244 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %243, i64 %132, 3
  %245 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %244, ptr %135, 4
  %246 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %245, { i64, [24 x i8] } %240, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %246

247:                                              ; preds = %109
  %248 = phi i64 [ %18, %109 ]
  %249 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %250 = call ptr %249()
  %251 = load i64, ptr %250, align 8
  %252 = mul i64 %251, 2910
  %253 = call i64 @llvm.uadd.sat.i64(i64 %248, i64 %252)
  br label %335

254:                                              ; preds = %67
  %255 = phi { ptr, i32, i32, i32 } [ %74, %67 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %255)
  %256 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %257 = call ptr %256()
  %258 = load i64, ptr %257, align 8
  %259 = mul i64 %258, 3840
  %260 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %259)
  br label %282

261:                                              ; preds = %61
  %262 = phi { ptr, i32, i32, i32 } [ %62, %61 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %262)
  %263 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %264 = call ptr %263()
  %265 = load i64, ptr %264, align 8
  %266 = mul i64 %265, 5150
  %267 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %266)
  br label %282

268:                                              ; preds = %44
  %269 = phi { ptr, i32, i32, i32 } [ %51, %44 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %269)
  %270 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %271 = call ptr %270()
  %272 = load i64, ptr %271, align 8
  %273 = mul i64 %272, 4610
  %274 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %273)
  br label %282

275:                                              ; preds = %38
  %276 = phi { ptr, i32, i32, i32 } [ %39, %38 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %276)
  %277 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %278 = call ptr %277()
  %279 = load i64, ptr %278, align 8
  %280 = mul i64 %279, 6020
  %281 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %280)
  br label %282

282:                                              ; preds = %268, %254, %261, %275
  %283 = phi i64 [ %0, %275 ], [ %0, %268 ], [ %0, %261 ], [ %0, %254 ]
  %284 = phi i64 [ %2, %275 ], [ %2, %268 ], [ %2, %261 ], [ %2, %254 ]
  %285 = phi ptr [ %4, %275 ], [ %4, %268 ], [ %4, %261 ], [ %4, %254 ]
  %286 = phi i64 [ %36, %275 ], [ %60, %268 ], [ %60, %261 ], [ %83, %254 ]
  %287 = phi i64 [ %281, %275 ], [ %274, %268 ], [ %267, %261 ], [ %260, %254 ]
  %288 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %289 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %288, 0
  %290 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %289, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %290, ptr %9, align 8
  %291 = load { i64, [24 x i8] }, ptr %9, align 8
  %292 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %283, 0
  %293 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %292, i64 %286, 1
  %294 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %293, i64 %284, 2
  %295 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %294, i64 %287, 3
  %296 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %295, ptr %285, 4
  %297 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %296, { i64, [24 x i8] } %291, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %297

298:                                              ; preds = %26
  %299 = phi { ptr, i32, i32, i32 } [ %33, %26 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %299)
  %300 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %301 = call ptr %300()
  %302 = load i64, ptr %301, align 8
  %303 = mul i64 %302, 6220
  %304 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %303)
  br label %312

305:                                              ; preds = %19
  %306 = phi { ptr, i32, i32, i32 } [ %21, %19 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %306)
  %307 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %308 = call ptr %307()
  %309 = load i64, ptr %308, align 8
  %310 = mul i64 %309, 7430
  %311 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %310)
  br label %312

312:                                              ; preds = %298, %305
  %313 = phi i64 [ %0, %305 ], [ %0, %298 ]
  %314 = phi i64 [ %2, %305 ], [ %2, %298 ]
  %315 = phi ptr [ %4, %305 ], [ %4, %298 ]
  %316 = phi i64 [ %14, %305 ], [ %36, %298 ]
  %317 = phi i64 [ %311, %305 ], [ %304, %298 ]
  %318 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %319 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %318, 0
  %320 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %319, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %320, ptr %8, align 8
  %321 = load { i64, [24 x i8] }, ptr %8, align 8
  %322 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %313, 0
  %323 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %322, i64 %316, 1
  %324 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %323, i64 %314, 2
  %325 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %324, i64 %317, 3
  %326 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %325, ptr %315, 4
  %327 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %326, { i64, [24 x i8] } %321, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %327

328:                                              ; preds = %6
  %329 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %329)
  %330 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %331 = call ptr %330()
  %332 = load i64, ptr %331, align 8
  %333 = mul i64 %332, 7630
  %334 = call i64 @llvm.uadd.sat.i64(i64 %3, i64 %333)
  br label %335

335:                                              ; preds = %247, %328
  %336 = phi i64 [ %0, %328 ], [ %0, %247 ]
  %337 = phi i64 [ %2, %328 ], [ %2, %247 ]
  %338 = phi ptr [ %4, %328 ], [ %4, %247 ]
  %339 = phi i64 [ %14, %328 ], [ %113, %247 ]
  %340 = phi i64 [ %334, %328 ], [ %253, %247 ]
  %341 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %342 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %341, 0
  %343 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %342, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %343, ptr %7, align 8
  %344 = load { i64, [24 x i8] }, ptr %7, align 8
  %345 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %336, 0
  %346 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %345, i64 %339, 1
  %347 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %346, i64 %337, 2
  %348 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %347, i64 %340, 3
  %349 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %348, ptr %338, 4
  %350 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %349, { i64, [24 x i8] } %344, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %350

351:                                              ; preds = %138
  call void @puts(ptr @assert_msg)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f0(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f0"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f0(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f0(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$284"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -4
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 24
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { ptr, i32, i32, i32 }, ptr %22, align 8
  call void @"drop$2"({ ptr, i32, i32, i32 } %23)
  %24 = add i64 %19, 24
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$284"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$542"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$284"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$542"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$284"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$543"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$542"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$543"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$542"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$544"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$543"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$544"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$543"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$540"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$540"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$541"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %5, 1
  call void @"drop$540"({ { ptr, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$541"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$540"({ { ptr, i32, i32, i32 } } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %8, 1
  store { i1, { { ptr, i32, i32, i32 } } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %9, 1
  store { i1, { { ptr, i32, i32, i32 } } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$138"({ { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } @"dup$138"({ { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 }, {} } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = insertvalue { { ptr, i32, i32, i32 }, {} } %6, {} %8, 1
  %10 = insertvalue { { ptr, i32, i32, i32 }, {} } %7, {} %8, 1
  %11 = insertvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } undef, { { ptr, i32, i32, i32 }, {} } %9, 0
  %12 = insertvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %11, { { ptr, i32, i32, i32 }, {} } %10, 1
  ret { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %12
}

define private void @"drop$539"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$138"({ { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$539"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } @"dup$138"({ { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 }, {} }, { { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, { { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } %5, { { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f1"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [56 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = add i64 %1, 1
  %20 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %21 = call ptr %20()
  %22 = load i64, ptr %21, align 8
  %23 = mul i64 %22, 380
  %24 = icmp uge i64 %2, %23
  %25 = call i64 @llvm.usub.sat.i64(i64 %2, i64 %23)
  br i1 %24, label %26, label %357

26:                                               ; preds = %5
  %27 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %28 = extractvalue { { ptr, i32, i32, i32 } } %27, 0
  %29 = extractvalue { ptr, i32, i32, i32 } %28, 1
  %30 = extractvalue { ptr, i32, i32, i32 } %28, 2
  %31 = sub i32 %30, %29
  %32 = icmp uge i32 %31, 1
  br i1 %32, label %33, label %336

33:                                               ; preds = %26
  %34 = extractvalue { ptr, i32, i32, i32 } %28, 0
  %35 = load ptr, ptr %34, align 8
  %36 = zext i32 %29 to i64
  %37 = mul i64 %36, 32
  %38 = getelementptr inbounds i8, ptr %35, i64 %37
  %39 = add i32 %29, 1
  %40 = insertvalue { ptr, i32, i32, i32 } %28, i32 %39, 1
  %41 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %41, ptr %38, i64 32, i1 false)
  %42 = load i252, ptr %41, align 16
  call void @free(ptr %41)
  %43 = add i64 %1, 4
  %44 = icmp ult i252 %42, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %44, label %45, label %329

45:                                               ; preds = %33
  %46 = phi { ptr, i32, i32, i32 } [ %40, %33 ]
  %47 = extractvalue { ptr, i32, i32, i32 } %46, 1
  %48 = extractvalue { ptr, i32, i32, i32 } %46, 2
  %49 = sub i32 %48, %47
  %50 = icmp uge i32 %49, 1
  br i1 %50, label %51, label %308

51:                                               ; preds = %45
  %52 = extractvalue { ptr, i32, i32, i32 } %46, 0
  %53 = load ptr, ptr %52, align 8
  %54 = zext i32 %47 to i64
  %55 = mul i64 %54, 32
  %56 = getelementptr inbounds i8, ptr %53, i64 %55
  %57 = add i32 %47, 1
  %58 = insertvalue { ptr, i32, i32, i32 } %46, i32 %57, 1
  %59 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %59, ptr %56, i64 32, i1 false)
  %60 = load i252, ptr %59, align 16
  call void @free(ptr %59)
  %61 = trunc i252 %60 to i128
  %62 = lshr i252 %60, 128
  %63 = trunc i252 %62 to i128
  %64 = icmp ne i128 %63, 0
  %65 = add i64 %1, 7
  %66 = add i64 %1, 5
  %67 = select i1 %64, i64 %65, i64 %66
  br i1 %64, label %301, label %68

68:                                               ; preds = %51
  %69 = phi { ptr, i32, i32, i32 } [ %58, %51 ]
  %70 = extractvalue { ptr, i32, i32, i32 } %69, 1
  %71 = extractvalue { ptr, i32, i32, i32 } %69, 2
  %72 = sub i32 %71, %70
  %73 = icmp uge i32 %72, 1
  br i1 %73, label %74, label %294

74:                                               ; preds = %68
  %75 = extractvalue { ptr, i32, i32, i32 } %69, 0
  %76 = load ptr, ptr %75, align 8
  %77 = zext i32 %70 to i64
  %78 = mul i64 %77, 32
  %79 = getelementptr inbounds i8, ptr %76, i64 %78
  %80 = add i32 %70, 1
  %81 = insertvalue { ptr, i32, i32, i32 } %69, i32 %80, 1
  %82 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %82, ptr %79, i64 32, i1 false)
  %83 = load i252, ptr %82, align 16
  call void @free(ptr %82)
  %84 = trunc i252 %83 to i128
  %85 = lshr i252 %83, 128
  %86 = trunc i252 %85 to i128
  %87 = icmp ne i128 %86, 0
  %88 = add i64 %67, 3
  %89 = add i64 %67, 1
  %90 = select i1 %87, i64 %88, i64 %89
  br i1 %87, label %287, label %91

91:                                               ; preds = %74
  %92 = phi { ptr, i32, i32, i32 } [ %81, %74 ]
  %93 = extractvalue { ptr, i32, i32, i32 } %92, 1
  %94 = extractvalue { ptr, i32, i32, i32 } %92, 2
  %95 = sub i32 %94, %93
  %96 = icmp uge i32 %95, 1
  br i1 %96, label %97, label %266

97:                                               ; preds = %91
  %98 = extractvalue { ptr, i32, i32, i32 } %92, 0
  %99 = load ptr, ptr %98, align 8
  %100 = zext i32 %93 to i64
  %101 = mul i64 %100, 32
  %102 = getelementptr inbounds i8, ptr %99, i64 %101
  %103 = add i32 %93, 1
  %104 = insertvalue { ptr, i32, i32, i32 } %92, i32 %103, 1
  %105 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %105, ptr %102, i64 32, i1 false)
  %106 = load i252, ptr %105, align 16
  call void @free(ptr %105)
  %107 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %104, 0
  %108 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f18"(i64 %90, i64 %25, { { ptr, i32, i32, i32 } } %107, { ptr, i32, i32, i32 } zeroinitializer, i252 %106)
  %109 = extractvalue { i64, i64, { i64, [56 x i8] } } %108, 0
  %110 = extractvalue { i64, i64, { i64, [56 x i8] } } %108, 1
  %111 = extractvalue { i64, i64, { i64, [56 x i8] } } %108, 2
  store { i64, [56 x i8] } %111, ptr %10, align 8
  %112 = load i1, ptr %10, align 1
  switch i1 %112, label %113 [
    i1 false, label %115
    i1 true, label %121
  ]

113:                                              ; preds = %97
  br i1 false, label %114, label %378

114:                                              ; preds = %113
  unreachable

115:                                              ; preds = %97
  %116 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %10, align 8
  %117 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %116, 1
  %118 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %117, 0
  %119 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %117, 1
  store { i64, [24 x i8] } %119, ptr %12, align 8
  %120 = load i1, ptr %12, align 1
  switch i1 %120, label %131 [
    i1 false, label %133
    i1 true, label %141
  ]

121:                                              ; preds = %97
  %122 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %123 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %122, 1
  %124 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %123, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %124, ptr %11, align 8
  %125 = load { i64, [24 x i8] }, ptr %11, align 8
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, i64 %109, 1
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %110, 2
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, ptr %3, 3
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, { i64, [24 x i8] } %125, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %130

131:                                              ; preds = %115
  br i1 false, label %132, label %379

132:                                              ; preds = %131
  unreachable

133:                                              ; preds = %115
  %134 = load { i1, { ptr, i32, i32, i32 } }, ptr %12, align 8
  %135 = extractvalue { i1, { ptr, i32, i32, i32 } } %134, 1
  %136 = extractvalue { { ptr, i32, i32, i32 } } %118, 0
  %137 = extractvalue { ptr, i32, i32, i32 } %136, 1
  %138 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %139 = sub i32 %138, %137
  %140 = icmp uge i32 %139, 1
  br i1 %140, label %147, label %165

141:                                              ; preds = %115
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %118)
  %142 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %143 = call ptr %142()
  %144 = load i64, ptr %143, align 8
  %145 = mul i64 %144, 1470
  %146 = call i64 @llvm.uadd.sat.i64(i64 %110, i64 %145)
  br label %273

147:                                              ; preds = %133
  %148 = extractvalue { ptr, i32, i32, i32 } %136, 0
  %149 = load ptr, ptr %148, align 8
  %150 = zext i32 %137 to i64
  %151 = mul i64 %150, 32
  %152 = getelementptr inbounds i8, ptr %149, i64 %151
  %153 = add i32 %137, 1
  %154 = insertvalue { ptr, i32, i32, i32 } %136, i32 %153, 1
  %155 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %155, ptr %152, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %154)
  call void @"drop$555"(ptr %155)
  call void @"drop$284"({ ptr, i32, i32, i32 } %135)
  %156 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %157 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %156, 0
  %158 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %157, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %158, ptr %18, align 8
  %159 = load { i64, [24 x i8] }, ptr %18, align 8
  %160 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %160, i64 %109, 1
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, i64 %110, 2
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, ptr %3, 3
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %163, { i64, [24 x i8] } %159, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %164

165:                                              ; preds = %133
  %166 = phi { ptr, i32, i32, i32 } [ %136, %133 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %166)
  %167 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %168 = call ptr %167()
  %169 = add i64 %109, 1
  %170 = getelementptr inbounds i64, ptr %168, i32 1
  %171 = load i64, ptr %170, align 8
  %172 = load i64, ptr %168, align 8
  %173 = mul i64 %172, 47470
  %174 = add i64 %171, %173
  %175 = icmp uge i64 %110, %174
  %176 = call i64 @llvm.usub.sat.i64(i64 %110, i64 %174)
  br i1 %175, label %177, label %261

177:                                              ; preds = %165
  %178 = phi i128 [ %61, %165 ]
  %179 = phi i128 [ %84, %165 ]
  %180 = insertvalue { i128, i128 } undef, i128 %178, 0
  %181 = insertvalue { i128, i128 } %180, i128 %179, 1
  %182 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f19"(i64 %169, i64 %176, i64 %0, ptr %3, { {} } undef, i252 %42, { i128, i128 } %181, { ptr, i32, i32, i32 } %135)
  %183 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, 0
  %184 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, 1
  %185 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, 2
  %186 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, 3
  %187 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, 4
  store { i64, [24 x i8] } %187, ptr %13, align 8
  %188 = load i1, ptr %13, align 1
  switch i1 %188, label %189 [
    i1 false, label %191
    i1 true, label %220
  ]

189:                                              ; preds = %177
  br i1 false, label %190, label %380

190:                                              ; preds = %189
  unreachable

191:                                              ; preds = %177
  %192 = load { i1, { { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %193 = extractvalue { i1, { { ptr, i32, i32, i32 } } } %192, 1
  %194 = extractvalue { { ptr, i32, i32, i32 } } %193, 0
  %195 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %194)
  %196 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %195, 0
  %197 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %195, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %196)
  %198 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %197)
  %199 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %198, 0
  %200 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %198, 1
  %201 = extractvalue { ptr, i32, i32, i32 } %200, 1
  %202 = extractvalue { ptr, i32, i32, i32 } %200, 2
  %203 = sub i32 %202, %201
  call void @"drop$3"({ ptr, i32, i32, i32 } %200)
  %204 = zext i32 %203 to i252
  %205 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %205, align 4
  %206 = getelementptr inbounds i8, ptr %205, i32 4
  store i32 0, ptr %206, align 4
  %207 = getelementptr inbounds i8, ptr %205, i32 16
  %208 = call ptr @realloc(ptr null, i64 8)
  store ptr %207, ptr %208, align 8
  %209 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %208, 0
  %210 = insertvalue { ptr, i32, i32, i32 } %209, i32 8, 3
  %211 = load ptr, ptr %208, align 8
  store i252 %204, ptr %211, align 16
  %212 = insertvalue { ptr, i32, i32, i32 } %210, i32 1, 2
  %213 = getelementptr inbounds i8, ptr %211, i32 -12
  store i32 1, ptr %213, align 4
  %214 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %199, 0
  %215 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %183, i64 %184, { { ptr, i32, i32, i32 } } %214, { ptr, i32, i32, i32 } %212)
  %216 = extractvalue { i64, i64, { i64, [24 x i8] } } %215, 0
  %217 = extractvalue { i64, i64, { i64, [24 x i8] } } %215, 1
  %218 = extractvalue { i64, i64, { i64, [24 x i8] } } %215, 2
  store { i64, [24 x i8] } %218, ptr %15, align 8
  %219 = load i1, ptr %15, align 1
  switch i1 %219, label %230 [
    i1 false, label %232
    i1 true, label %251
  ]

220:                                              ; preds = %177
  %221 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %222 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %221, 1
  %223 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %222, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %223, ptr %14, align 8
  %224 = load { i64, [24 x i8] }, ptr %14, align 8
  %225 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %185, 0
  %226 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %225, i64 %183, 1
  %227 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %226, i64 %184, 2
  %228 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %227, ptr %186, 3
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %228, { i64, [24 x i8] } %224, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %229

230:                                              ; preds = %191
  br i1 false, label %231, label %381

231:                                              ; preds = %230
  unreachable

232:                                              ; preds = %191
  %233 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %15, align 8
  %234 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %233, 1
  %235 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %236 = call ptr %235()
  %237 = call i64 @llvm.uadd.sat.i64(i64 %217, i64 0)
  %238 = extractvalue { { ptr, i32, i32, i32 }, {} } %234, 0
  %239 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %238)
  %240 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %239, 0
  %241 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %239, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %240)
  %242 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %241, 0
  %243 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %242, 0
  %244 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %243, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %244, ptr %17, align 8
  %245 = load { i64, [24 x i8] }, ptr %17, align 8
  %246 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %185, 0
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %246, i64 %216, 1
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %237, 2
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, ptr %186, 3
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, { i64, [24 x i8] } %245, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %250

251:                                              ; preds = %191
  %252 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %253 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %252, 1
  %254 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %253, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %254, ptr %16, align 8
  %255 = load { i64, [24 x i8] }, ptr %16, align 8
  %256 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %185, 0
  %257 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %256, i64 %216, 1
  %258 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %257, i64 %217, 2
  %259 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %258, ptr %186, 3
  %260 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %259, { i64, [24 x i8] } %255, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %260

261:                                              ; preds = %165
  %262 = phi { ptr, i32, i32, i32 } [ %135, %165 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %262)
  %263 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %264 = call ptr %263()
  %265 = call i64 @llvm.uadd.sat.i64(i64 %110, i64 0)
  br label %364

266:                                              ; preds = %91
  %267 = phi { ptr, i32, i32, i32 } [ %92, %91 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %267)
  %268 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %269 = call ptr %268()
  %270 = load i64, ptr %269, align 8
  %271 = mul i64 %270, 4840
  %272 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %271)
  br label %273

273:                                              ; preds = %141, %266
  %274 = phi i64 [ %0, %266 ], [ %0, %141 ]
  %275 = phi ptr [ %3, %266 ], [ %3, %141 ]
  %276 = phi i64 [ %90, %266 ], [ %109, %141 ]
  %277 = phi i64 [ %272, %266 ], [ %146, %141 ]
  %278 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f21"()
  %279 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %278, 0
  %280 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %279, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %280, ptr %9, align 8
  %281 = load { i64, [24 x i8] }, ptr %9, align 8
  %282 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %274, 0
  %283 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %282, i64 %276, 1
  %284 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %283, i64 %277, 2
  %285 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %284, ptr %275, 3
  %286 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %285, { i64, [24 x i8] } %281, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %286

287:                                              ; preds = %74
  %288 = phi { ptr, i32, i32, i32 } [ %81, %74 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %288)
  %289 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %290 = call ptr %289()
  %291 = load i64, ptr %290, align 8
  %292 = mul i64 %291, 4200
  %293 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %292)
  br label %315

294:                                              ; preds = %68
  %295 = phi { ptr, i32, i32, i32 } [ %69, %68 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %295)
  %296 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %297 = call ptr %296()
  %298 = load i64, ptr %297, align 8
  %299 = mul i64 %298, 5500
  %300 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %299)
  br label %315

301:                                              ; preds = %51
  %302 = phi { ptr, i32, i32, i32 } [ %58, %51 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %302)
  %303 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %304 = call ptr %303()
  %305 = load i64, ptr %304, align 8
  %306 = mul i64 %305, 4960
  %307 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %306)
  br label %315

308:                                              ; preds = %45
  %309 = phi { ptr, i32, i32, i32 } [ %46, %45 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %309)
  %310 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %311 = call ptr %310()
  %312 = load i64, ptr %311, align 8
  %313 = mul i64 %312, 6360
  %314 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %313)
  br label %315

315:                                              ; preds = %301, %287, %294, %308
  %316 = phi i64 [ %0, %308 ], [ %0, %301 ], [ %0, %294 ], [ %0, %287 ]
  %317 = phi ptr [ %3, %308 ], [ %3, %301 ], [ %3, %294 ], [ %3, %287 ]
  %318 = phi i64 [ %43, %308 ], [ %67, %301 ], [ %67, %294 ], [ %90, %287 ]
  %319 = phi i64 [ %314, %308 ], [ %307, %301 ], [ %300, %294 ], [ %293, %287 ]
  %320 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %321 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %320, 0
  %322 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %321, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %322, ptr %8, align 8
  %323 = load { i64, [24 x i8] }, ptr %8, align 8
  %324 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %316, 0
  %325 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %324, i64 %318, 1
  %326 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %325, i64 %319, 2
  %327 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, ptr %317, 3
  %328 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %327, { i64, [24 x i8] } %323, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %328

329:                                              ; preds = %33
  %330 = phi { ptr, i32, i32, i32 } [ %40, %33 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %330)
  %331 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %332 = call ptr %331()
  %333 = load i64, ptr %332, align 8
  %334 = mul i64 %333, 6560
  %335 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %334)
  br label %343

336:                                              ; preds = %26
  %337 = phi { ptr, i32, i32, i32 } [ %28, %26 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %337)
  %338 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %339 = call ptr %338()
  %340 = load i64, ptr %339, align 8
  %341 = mul i64 %340, 7760
  %342 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %341)
  br label %343

343:                                              ; preds = %329, %336
  %344 = phi i64 [ %0, %336 ], [ %0, %329 ]
  %345 = phi ptr [ %3, %336 ], [ %3, %329 ]
  %346 = phi i64 [ %19, %336 ], [ %43, %329 ]
  %347 = phi i64 [ %342, %336 ], [ %335, %329 ]
  %348 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %349 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %348, 0
  %350 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %349, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %350, ptr %7, align 8
  %351 = load { i64, [24 x i8] }, ptr %7, align 8
  %352 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %344, 0
  %353 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %352, i64 %346, 1
  %354 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %353, i64 %347, 2
  %355 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %354, ptr %345, 3
  %356 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %355, { i64, [24 x i8] } %351, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %356

357:                                              ; preds = %5
  %358 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %358)
  %359 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %360 = call ptr %359()
  %361 = load i64, ptr %360, align 8
  %362 = mul i64 %361, 7580
  %363 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %362)
  br label %364

364:                                              ; preds = %261, %357
  %365 = phi i64 [ %0, %357 ], [ %0, %261 ]
  %366 = phi ptr [ %3, %357 ], [ %3, %261 ]
  %367 = phi i64 [ %19, %357 ], [ %169, %261 ]
  %368 = phi i64 [ %363, %357 ], [ %265, %261 ]
  %369 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %370 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %369, 0
  %371 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %370, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %371, ptr %6, align 8
  %372 = load { i64, [24 x i8] }, ptr %6, align 8
  %373 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %365, 0
  %374 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %373, i64 %367, 1
  %375 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %374, i64 %368, 2
  %376 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %375, ptr %366, 3
  %377 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %376, { i64, [24 x i8] } %372, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %377

378:                                              ; preds = %113
  call void @puts(ptr @assert_msg_0)
  call void @abort()
  unreachable

379:                                              ; preds = %131
  call void @puts(ptr @assert_msg_1)
  call void @abort()
  unreachable

380:                                              ; preds = %189
  call void @puts(ptr @assert_msg_2)
  call void @abort()
  unreachable

381:                                              ; preds = %230
  call void @puts(ptr @assert_msg_3)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f1(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f1"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f1(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f1(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 0
  %3 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 0
  %4 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 0
  %5 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 1
  %6 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %5)
  %7 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 1
  %9 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %7, 1
  %10 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %4, { ptr, i32, i32, i32 } %8, 1
  %11 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %9, 0
  %12 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %11, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %10, 1
  ret { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %12
}

define private void @"drop$535"({ { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } @"dup$535"({ { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %0, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } undef, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %8, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$536"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %5, 1
  call void @"drop$535"({ { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [40 x i8] }, { i64, [40 x i8] } } @"dup$536"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %5, 1
  %7 = call { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } @"dup$535"({ { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %6)
  %8 = extractvalue { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %7, 1
  %10 = insertvalue { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %5, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %8, 1
  store { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %10, ptr %2, align 8
  %11 = load { i64, [40 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %5, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %9, 1
  store { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %12, ptr %2, align 8
  %13 = load { i64, [40 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %11, 0
  %15 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %14, { i64, [40 x i8] } %13, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [40 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [40 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %23, 0
  %27 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %26, { i64, [40 x i8] } %25, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$534"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  call void @"drop$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0)
  ret void
}

define private { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$534"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  %2 = call { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0)
  %3 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %2, 0
  %4 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %2, 1
  %5 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %3, 0
  %6 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %5, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %4, 1
  ret { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %6
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f2"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [40 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = add i64 %1, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 790
  %25 = icmp uge i64 %3, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %3, i64 %24)
  br i1 %25, label %27, label %447

27:                                               ; preds = %6
  %28 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %424

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 32
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %42, ptr %39, i64 32, i1 false)
  %43 = load i252, ptr %42, align 16
  call void @free(ptr %42)
  %44 = add i64 %1, 4
  %45 = icmp ult i252 %43, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %45, label %46, label %417

46:                                               ; preds = %34
  %47 = phi { ptr, i32, i32, i32 } [ %41, %34 ]
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %52, label %394

52:                                               ; preds = %46
  %53 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %54 = load ptr, ptr %53, align 8
  %55 = zext i32 %48 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %54, i64 %56
  %58 = add i32 %48, 1
  %59 = insertvalue { ptr, i32, i32, i32 } %47, i32 %58, 1
  %60 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %60, ptr %57, i64 32, i1 false)
  %61 = load i252, ptr %60, align 16
  call void @free(ptr %60)
  %62 = trunc i252 %61 to i128
  %63 = lshr i252 %61, 128
  %64 = trunc i252 %63 to i128
  %65 = icmp ne i128 %64, 0
  %66 = add i64 %1, 7
  %67 = add i64 %1, 5
  %68 = select i1 %65, i64 %66, i64 %67
  br i1 %65, label %387, label %69

69:                                               ; preds = %52
  %70 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  %71 = extractvalue { ptr, i32, i32, i32 } %70, 1
  %72 = extractvalue { ptr, i32, i32, i32 } %70, 2
  %73 = sub i32 %72, %71
  %74 = icmp uge i32 %73, 1
  br i1 %74, label %75, label %380

75:                                               ; preds = %69
  %76 = extractvalue { ptr, i32, i32, i32 } %70, 0
  %77 = load ptr, ptr %76, align 8
  %78 = zext i32 %71 to i64
  %79 = mul i64 %78, 32
  %80 = getelementptr inbounds i8, ptr %77, i64 %79
  %81 = add i32 %71, 1
  %82 = insertvalue { ptr, i32, i32, i32 } %70, i32 %81, 1
  %83 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %83, ptr %80, i64 32, i1 false)
  %84 = load i252, ptr %83, align 16
  call void @free(ptr %83)
  %85 = trunc i252 %84 to i128
  %86 = lshr i252 %84, 128
  %87 = trunc i252 %86 to i128
  %88 = icmp ne i128 %87, 0
  %89 = add i64 %68, 3
  %90 = add i64 %68, 1
  %91 = select i1 %88, i64 %89, i64 %90
  br i1 %88, label %373, label %92

92:                                               ; preds = %75
  %93 = phi { ptr, i32, i32, i32 } [ %82, %75 ]
  %94 = extractvalue { ptr, i32, i32, i32 } %93, 1
  %95 = extractvalue { ptr, i32, i32, i32 } %93, 2
  %96 = sub i32 %95, %94
  %97 = icmp uge i32 %96, 1
  br i1 %97, label %98, label %350

98:                                               ; preds = %92
  %99 = extractvalue { ptr, i32, i32, i32 } %93, 0
  %100 = load ptr, ptr %99, align 8
  %101 = zext i32 %94 to i64
  %102 = mul i64 %101, 32
  %103 = getelementptr inbounds i8, ptr %100, i64 %102
  %104 = add i32 %94, 1
  %105 = insertvalue { ptr, i32, i32, i32 } %93, i32 %104, 1
  %106 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %103, i64 32, i1 false)
  %107 = load i252, ptr %106, align 16
  call void @free(ptr %106)
  %108 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %105, 0
  %109 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f18"(i64 %91, i64 %26, { { ptr, i32, i32, i32 } } %108, { ptr, i32, i32, i32 } zeroinitializer, i252 %107)
  %110 = extractvalue { i64, i64, { i64, [56 x i8] } } %109, 0
  %111 = extractvalue { i64, i64, { i64, [56 x i8] } } %109, 1
  %112 = extractvalue { i64, i64, { i64, [56 x i8] } } %109, 2
  store { i64, [56 x i8] } %112, ptr %11, align 8
  %113 = load i1, ptr %11, align 1
  switch i1 %113, label %114 [
    i1 false, label %116
    i1 true, label %122
  ]

114:                                              ; preds = %98
  br i1 false, label %115, label %470

115:                                              ; preds = %114
  unreachable

116:                                              ; preds = %98
  %117 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %11, align 8
  %118 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %117, 1
  %119 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %118, 0
  %120 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %118, 1
  store { i64, [24 x i8] } %120, ptr %13, align 8
  %121 = load i1, ptr %13, align 1
  switch i1 %121, label %133 [
    i1 false, label %135
    i1 true, label %143
  ]

122:                                              ; preds = %98
  %123 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %124 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %123, 1
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %12, align 8
  %126 = load { i64, [24 x i8] }, ptr %12, align 8
  %127 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %128 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %110, 1
  %129 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %2, 2
  %130 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %111, 3
  %131 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, ptr %4, 4
  %132 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %131, { i64, [24 x i8] } %126, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %132

133:                                              ; preds = %116
  br i1 false, label %134, label %471

134:                                              ; preds = %133
  unreachable

135:                                              ; preds = %116
  %136 = load { i1, { ptr, i32, i32, i32 } }, ptr %13, align 8
  %137 = extractvalue { i1, { ptr, i32, i32, i32 } } %136, 1
  %138 = extractvalue { { ptr, i32, i32, i32 } } %119, 0
  %139 = extractvalue { ptr, i32, i32, i32 } %138, 1
  %140 = extractvalue { ptr, i32, i32, i32 } %138, 2
  %141 = sub i32 %140, %139
  %142 = icmp uge i32 %141, 1
  br i1 %142, label %149, label %168

143:                                              ; preds = %116
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %119)
  %144 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %145 = call ptr %144()
  %146 = load i64, ptr %145, align 8
  %147 = mul i64 %146, 1770
  %148 = call i64 @llvm.uadd.sat.i64(i64 %111, i64 %147)
  br label %357

149:                                              ; preds = %135
  %150 = extractvalue { ptr, i32, i32, i32 } %138, 0
  %151 = load ptr, ptr %150, align 8
  %152 = zext i32 %139 to i64
  %153 = mul i64 %152, 32
  %154 = getelementptr inbounds i8, ptr %151, i64 %153
  %155 = add i32 %139, 1
  %156 = insertvalue { ptr, i32, i32, i32 } %138, i32 %155, 1
  %157 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %157, ptr %154, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %156)
  call void @"drop$555"(ptr %157)
  call void @"drop$284"({ ptr, i32, i32, i32 } %137)
  %158 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %159 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %158, 0
  %160 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %159, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %160, ptr %19, align 8
  %161 = load { i64, [24 x i8] }, ptr %19, align 8
  %162 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %163 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %162, i64 %110, 1
  %164 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %163, i64 %2, 2
  %165 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %164, i64 %111, 3
  %166 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %165, ptr %4, 4
  %167 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %166, { i64, [24 x i8] } %161, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %167

168:                                              ; preds = %135
  %169 = phi { ptr, i32, i32, i32 } [ %138, %135 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %169)
  %170 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %171 = call ptr %170()
  %172 = add i64 %110, 1
  %173 = getelementptr inbounds i64, ptr %171, i32 1
  %174 = load i64, ptr %173, align 8
  %175 = getelementptr inbounds i64, ptr %171, i32 2
  %176 = load i64, ptr %175, align 8
  %177 = mul i64 %176, 11
  %178 = add i64 %174, %177
  %179 = load i64, ptr %171, align 8
  %180 = mul i64 %179, 122480
  %181 = add i64 %178, %180
  %182 = icmp uge i64 %111, %181
  %183 = call i64 @llvm.usub.sat.i64(i64 %111, i64 %181)
  br i1 %182, label %184, label %345

184:                                              ; preds = %168
  %185 = phi i128 [ %62, %168 ]
  %186 = phi i128 [ %85, %168 ]
  %187 = insertvalue { i128, i128 } undef, i128 %185, 0
  %188 = insertvalue { i128, i128 } %187, i128 %186, 1
  %189 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f22"(i64 %172, i64 %183, i64 %2, i64 %0, ptr %4, { {} } undef, i252 %43, { i128, i128 } %188, { ptr, i32, i32, i32 } %137)
  %190 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %189, 0
  %191 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %189, 1
  %192 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %189, 2
  %193 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %189, 3
  %194 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %189, 4
  %195 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %189, 5
  store { i64, [40 x i8] } %195, ptr %14, align 8
  %196 = load i1, ptr %14, align 1
  switch i1 %196, label %197 [
    i1 false, label %199
    i1 true, label %301
  ]

197:                                              ; preds = %184
  br i1 false, label %198, label %472

198:                                              ; preds = %197
  unreachable

199:                                              ; preds = %184
  %200 = load { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } }, ptr %14, align 8
  %201 = extractvalue { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %200, 1
  %202 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %201, 0
  %203 = call { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %202)
  %204 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %203, 0
  %205 = extractvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %203, 1
  call void @"drop$533"({ { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %204)
  %206 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %205, 0
  %207 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %205, 1
  %208 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 0
  %209 = zext i8 %208 to i252
  %210 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 1
  %211 = zext i8 %210 to i252
  %212 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 2
  %213 = zext i8 %212 to i252
  %214 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 3
  %215 = zext i8 %214 to i252
  %216 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 4
  %217 = zext i8 %216 to i252
  %218 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 5
  %219 = zext i8 %218 to i252
  %220 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 6
  %221 = zext i8 %220 to i252
  %222 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 7
  %223 = zext i8 %222 to i252
  %224 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 8
  %225 = zext i16 %224 to i252
  %226 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 9
  %227 = zext i16 %226 to i252
  %228 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %206, 10
  %229 = zext i16 %228 to i252
  %230 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %207)
  %231 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %230, 0
  %232 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %230, 1
  %233 = extractvalue { ptr, i32, i32, i32 } %232, 1
  %234 = extractvalue { ptr, i32, i32, i32 } %232, 2
  %235 = sub i32 %234, %233
  call void @"drop$3"({ ptr, i32, i32, i32 } %232)
  %236 = zext i32 %235 to i252
  %237 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %237, align 4
  %238 = getelementptr inbounds i8, ptr %237, i32 4
  store i32 0, ptr %238, align 4
  %239 = getelementptr inbounds i8, ptr %237, i32 16
  %240 = call ptr @realloc(ptr null, i64 8)
  store ptr %239, ptr %240, align 8
  %241 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %240, 0
  %242 = insertvalue { ptr, i32, i32, i32 } %241, i32 8, 3
  %243 = load ptr, ptr %240, align 8
  store i252 %209, ptr %243, align 16
  %244 = insertvalue { ptr, i32, i32, i32 } %242, i32 1, 2
  %245 = getelementptr inbounds i8, ptr %243, i32 -12
  store i32 1, ptr %245, align 4
  %246 = load ptr, ptr %240, align 8
  %247 = getelementptr inbounds i8, ptr %246, i32 32
  store i252 %211, ptr %247, align 16
  %248 = insertvalue { ptr, i32, i32, i32 } %244, i32 2, 2
  %249 = getelementptr inbounds i8, ptr %246, i32 -12
  store i32 2, ptr %249, align 4
  %250 = load ptr, ptr %240, align 8
  %251 = getelementptr inbounds i8, ptr %250, i32 64
  store i252 %213, ptr %251, align 16
  %252 = insertvalue { ptr, i32, i32, i32 } %248, i32 3, 2
  %253 = getelementptr inbounds i8, ptr %250, i32 -12
  store i32 3, ptr %253, align 4
  %254 = load ptr, ptr %240, align 8
  %255 = getelementptr inbounds i8, ptr %254, i32 96
  store i252 %215, ptr %255, align 16
  %256 = insertvalue { ptr, i32, i32, i32 } %252, i32 4, 2
  %257 = getelementptr inbounds i8, ptr %254, i32 -12
  store i32 4, ptr %257, align 4
  %258 = load ptr, ptr %240, align 8
  %259 = getelementptr inbounds i8, ptr %258, i32 128
  store i252 %217, ptr %259, align 16
  %260 = insertvalue { ptr, i32, i32, i32 } %256, i32 5, 2
  %261 = getelementptr inbounds i8, ptr %258, i32 -12
  store i32 5, ptr %261, align 4
  %262 = load ptr, ptr %240, align 8
  %263 = getelementptr inbounds i8, ptr %262, i32 160
  store i252 %219, ptr %263, align 16
  %264 = insertvalue { ptr, i32, i32, i32 } %260, i32 6, 2
  %265 = getelementptr inbounds i8, ptr %262, i32 -12
  store i32 6, ptr %265, align 4
  %266 = load ptr, ptr %240, align 8
  %267 = getelementptr inbounds i8, ptr %266, i32 192
  store i252 %221, ptr %267, align 16
  %268 = insertvalue { ptr, i32, i32, i32 } %264, i32 7, 2
  %269 = getelementptr inbounds i8, ptr %266, i32 -12
  store i32 7, ptr %269, align 4
  %270 = load ptr, ptr %240, align 8
  %271 = getelementptr inbounds i8, ptr %270, i32 224
  store i252 %223, ptr %271, align 16
  %272 = insertvalue { ptr, i32, i32, i32 } %268, i32 8, 2
  %273 = getelementptr inbounds i8, ptr %270, i32 -12
  store i32 8, ptr %273, align 4
  %274 = load ptr, ptr %240, align 8
  %275 = getelementptr inbounds i8, ptr %274, i32 -16
  %276 = call ptr @realloc(ptr %275, i64 784)
  %277 = getelementptr inbounds i8, ptr %276, i32 16
  store ptr %277, ptr %240, align 8
  %278 = insertvalue { ptr, i32, i32, i32 } %272, i32 24, 3
  %279 = load ptr, ptr %240, align 8
  %280 = getelementptr inbounds i8, ptr %279, i32 256
  store i252 %225, ptr %280, align 16
  %281 = insertvalue { ptr, i32, i32, i32 } %278, i32 9, 2
  %282 = getelementptr inbounds i8, ptr %279, i32 -12
  store i32 9, ptr %282, align 4
  %283 = load ptr, ptr %240, align 8
  %284 = getelementptr inbounds i8, ptr %283, i32 288
  store i252 %227, ptr %284, align 16
  %285 = insertvalue { ptr, i32, i32, i32 } %281, i32 10, 2
  %286 = getelementptr inbounds i8, ptr %283, i32 -12
  store i32 10, ptr %286, align 4
  %287 = load ptr, ptr %240, align 8
  %288 = getelementptr inbounds i8, ptr %287, i32 320
  store i252 %229, ptr %288, align 16
  %289 = insertvalue { ptr, i32, i32, i32 } %285, i32 11, 2
  %290 = getelementptr inbounds i8, ptr %287, i32 -12
  store i32 11, ptr %290, align 4
  %291 = load ptr, ptr %240, align 8
  %292 = getelementptr inbounds i8, ptr %291, i32 352
  store i252 %236, ptr %292, align 16
  %293 = insertvalue { ptr, i32, i32, i32 } %289, i32 12, 2
  %294 = getelementptr inbounds i8, ptr %291, i32 -12
  store i32 12, ptr %294, align 4
  %295 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %231, 0
  %296 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %190, i64 %191, { { ptr, i32, i32, i32 } } %295, { ptr, i32, i32, i32 } %293)
  %297 = extractvalue { i64, i64, { i64, [24 x i8] } } %296, 0
  %298 = extractvalue { i64, i64, { i64, [24 x i8] } } %296, 1
  %299 = extractvalue { i64, i64, { i64, [24 x i8] } } %296, 2
  store { i64, [24 x i8] } %299, ptr %16, align 8
  %300 = load i1, ptr %16, align 1
  switch i1 %300, label %312 [
    i1 false, label %314
    i1 true, label %334
  ]

301:                                              ; preds = %184
  %302 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %303 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %302, 1
  %304 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %303, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %304, ptr %15, align 8
  %305 = load { i64, [24 x i8] }, ptr %15, align 8
  %306 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %193, 0
  %307 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %306, i64 %190, 1
  %308 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %307, i64 %192, 2
  %309 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %308, i64 %191, 3
  %310 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %309, ptr %194, 4
  %311 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %310, { i64, [24 x i8] } %305, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %311

312:                                              ; preds = %199
  br i1 false, label %313, label %473

313:                                              ; preds = %312
  unreachable

314:                                              ; preds = %199
  %315 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %16, align 8
  %316 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %315, 1
  %317 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %318 = call ptr %317()
  %319 = call i64 @llvm.uadd.sat.i64(i64 %298, i64 0)
  %320 = extractvalue { { ptr, i32, i32, i32 }, {} } %316, 0
  %321 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %320)
  %322 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %321, 0
  %323 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %321, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %322)
  %324 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %323, 0
  %325 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %324, 0
  %326 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %325, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %326, ptr %18, align 8
  %327 = load { i64, [24 x i8] }, ptr %18, align 8
  %328 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %193, 0
  %329 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %328, i64 %297, 1
  %330 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %329, i64 %192, 2
  %331 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %330, i64 %319, 3
  %332 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %331, ptr %194, 4
  %333 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %332, { i64, [24 x i8] } %327, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %333

334:                                              ; preds = %199
  %335 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %336 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %335, 1
  %337 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %336, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %337, ptr %17, align 8
  %338 = load { i64, [24 x i8] }, ptr %17, align 8
  %339 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %193, 0
  %340 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %339, i64 %297, 1
  %341 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %340, i64 %192, 2
  %342 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %341, i64 %298, 3
  %343 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %342, ptr %194, 4
  %344 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %343, { i64, [24 x i8] } %338, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %344

345:                                              ; preds = %168
  %346 = phi { ptr, i32, i32, i32 } [ %137, %168 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %346)
  %347 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %348 = call ptr %347()
  %349 = call i64 @llvm.uadd.sat.i64(i64 %111, i64 0)
  br label %454

350:                                              ; preds = %92
  %351 = phi { ptr, i32, i32, i32 } [ %93, %92 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %351)
  %352 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %353 = call ptr %352()
  %354 = load i64, ptr %353, align 8
  %355 = mul i64 %354, 5140
  %356 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %355)
  br label %357

357:                                              ; preds = %143, %350
  %358 = phi i64 [ %0, %350 ], [ %0, %143 ]
  %359 = phi i64 [ %2, %350 ], [ %2, %143 ]
  %360 = phi ptr [ %4, %350 ], [ %4, %143 ]
  %361 = phi i64 [ %91, %350 ], [ %110, %143 ]
  %362 = phi i64 [ %356, %350 ], [ %148, %143 ]
  %363 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f21"()
  %364 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %363, 0
  %365 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %364, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %365, ptr %10, align 8
  %366 = load { i64, [24 x i8] }, ptr %10, align 8
  %367 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %358, 0
  %368 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %367, i64 %361, 1
  %369 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %368, i64 %359, 2
  %370 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %369, i64 %362, 3
  %371 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %370, ptr %360, 4
  %372 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %371, { i64, [24 x i8] } %366, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %372

373:                                              ; preds = %75
  %374 = phi { ptr, i32, i32, i32 } [ %82, %75 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %374)
  %375 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %376 = call ptr %375()
  %377 = load i64, ptr %376, align 8
  %378 = mul i64 %377, 4500
  %379 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %378)
  br label %401

380:                                              ; preds = %69
  %381 = phi { ptr, i32, i32, i32 } [ %70, %69 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %381)
  %382 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %383 = call ptr %382()
  %384 = load i64, ptr %383, align 8
  %385 = mul i64 %384, 5800
  %386 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %385)
  br label %401

387:                                              ; preds = %52
  %388 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %388)
  %389 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %390 = call ptr %389()
  %391 = load i64, ptr %390, align 8
  %392 = mul i64 %391, 5260
  %393 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %392)
  br label %401

394:                                              ; preds = %46
  %395 = phi { ptr, i32, i32, i32 } [ %47, %46 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %395)
  %396 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %397 = call ptr %396()
  %398 = load i64, ptr %397, align 8
  %399 = mul i64 %398, 6660
  %400 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %399)
  br label %401

401:                                              ; preds = %387, %373, %380, %394
  %402 = phi i64 [ %0, %394 ], [ %0, %387 ], [ %0, %380 ], [ %0, %373 ]
  %403 = phi i64 [ %2, %394 ], [ %2, %387 ], [ %2, %380 ], [ %2, %373 ]
  %404 = phi ptr [ %4, %394 ], [ %4, %387 ], [ %4, %380 ], [ %4, %373 ]
  %405 = phi i64 [ %44, %394 ], [ %68, %387 ], [ %68, %380 ], [ %91, %373 ]
  %406 = phi i64 [ %400, %394 ], [ %393, %387 ], [ %386, %380 ], [ %379, %373 ]
  %407 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %408 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %407, 0
  %409 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %408, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %409, ptr %9, align 8
  %410 = load { i64, [24 x i8] }, ptr %9, align 8
  %411 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %402, 0
  %412 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %411, i64 %405, 1
  %413 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %412, i64 %403, 2
  %414 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %413, i64 %406, 3
  %415 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %414, ptr %404, 4
  %416 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %415, { i64, [24 x i8] } %410, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %416

417:                                              ; preds = %34
  %418 = phi { ptr, i32, i32, i32 } [ %41, %34 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %418)
  %419 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %420 = call ptr %419()
  %421 = load i64, ptr %420, align 8
  %422 = mul i64 %421, 6860
  %423 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %422)
  br label %431

424:                                              ; preds = %27
  %425 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %425)
  %426 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %427 = call ptr %426()
  %428 = load i64, ptr %427, align 8
  %429 = mul i64 %428, 8060
  %430 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %429)
  br label %431

431:                                              ; preds = %417, %424
  %432 = phi i64 [ %0, %424 ], [ %0, %417 ]
  %433 = phi i64 [ %2, %424 ], [ %2, %417 ]
  %434 = phi ptr [ %4, %424 ], [ %4, %417 ]
  %435 = phi i64 [ %20, %424 ], [ %44, %417 ]
  %436 = phi i64 [ %430, %424 ], [ %423, %417 ]
  %437 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %438 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %437, 0
  %439 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %438, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %439, ptr %8, align 8
  %440 = load { i64, [24 x i8] }, ptr %8, align 8
  %441 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %432, 0
  %442 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %441, i64 %435, 1
  %443 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %442, i64 %433, 2
  %444 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %443, i64 %436, 3
  %445 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %444, ptr %434, 4
  %446 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %445, { i64, [24 x i8] } %440, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %446

447:                                              ; preds = %6
  %448 = phi { { ptr, i32, i32, i32 } } [ %5, %6 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %448)
  %449 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %450 = call ptr %449()
  %451 = load i64, ptr %450, align 8
  %452 = mul i64 %451, 7470
  %453 = call i64 @llvm.uadd.sat.i64(i64 %3, i64 %452)
  br label %454

454:                                              ; preds = %345, %447
  %455 = phi i64 [ %0, %447 ], [ %0, %345 ]
  %456 = phi i64 [ %2, %447 ], [ %2, %345 ]
  %457 = phi ptr [ %4, %447 ], [ %4, %345 ]
  %458 = phi i64 [ %20, %447 ], [ %172, %345 ]
  %459 = phi i64 [ %453, %447 ], [ %349, %345 ]
  %460 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %461 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %460, 0
  %462 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %461, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %462, ptr %7, align 8
  %463 = load { i64, [24 x i8] }, ptr %7, align 8
  %464 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %455, 0
  %465 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %464, i64 %458, 1
  %466 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %465, i64 %456, 2
  %467 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %466, i64 %459, 3
  %468 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %467, ptr %457, 4
  %469 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %468, { i64, [24 x i8] } %463, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %469

470:                                              ; preds = %114
  call void @puts(ptr @assert_msg_4)
  call void @abort()
  unreachable

471:                                              ; preds = %133
  call void @puts(ptr @assert_msg_5)
  call void @abort()
  unreachable

472:                                              ; preds = %197
  call void @puts(ptr @assert_msg_6)
  call void @abort()
  unreachable

473:                                              ; preds = %312
  call void @puts(ptr @assert_msg_7)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f2(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f2"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f2(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f2(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$520"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$520"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 48)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 48, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$521"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$521"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$522"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$521"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$522"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$521"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$523"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$522"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$523"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$522"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$524"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 3
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 7
  call void @"drop$523"({ { ptr, i32, i32, i32 } } %3)
  %4 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 9
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %4)
  %5 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 12
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %5)
  ret void
}

define private { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } @"dup$524"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, i252 %2, 0
  %4 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } undef, i252 %2, 0
  %5 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %3, i252 %5, 1
  %7 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %4, i252 %5, 1
  %8 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 2
  %9 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %6, i128 %8, 2
  %10 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %7, i128 %8, 2
  %11 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 3
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %9, { { ptr, i32, i32, i32 } } %13, 3
  %16 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %10, { { ptr, i32, i32, i32 } } %14, 3
  %17 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 4
  %18 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %15, i252 %17, 4
  %19 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %16, i252 %17, 4
  %20 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 5
  %21 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %18, i252 %20, 5
  %22 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %19, i252 %20, 5
  %23 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 6
  %24 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %21, i252 %23, 6
  %25 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %22, i252 %23, 6
  %26 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 7
  %27 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$523"({ { ptr, i32, i32, i32 } } %26)
  %28 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %27, 0
  %29 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %27, 1
  %30 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %24, { { ptr, i32, i32, i32 } } %28, 7
  %31 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %25, { { ptr, i32, i32, i32 } } %29, 7
  %32 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 8
  %33 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %30, i128 %32, 8
  %34 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %31, i128 %32, 8
  %35 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 9
  %36 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %35)
  %37 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %36, 0
  %38 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %36, 1
  %39 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %33, { { ptr, i32, i32, i32 } } %37, 9
  %40 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %34, { { ptr, i32, i32, i32 } } %38, 9
  %41 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 10
  %42 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %39, i32 %41, 10
  %43 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %40, i32 %41, 10
  %44 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 11
  %45 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %42, i32 %44, 11
  %46 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %43, i32 %44, 11
  %47 = extractvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %0, 12
  %48 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %47)
  %49 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %48, 0
  %50 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %48, 1
  %51 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %45, { { ptr, i32, i32, i32 } } %49, 12
  %52 = insertvalue { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %46, { { ptr, i32, i32, i32 } } %50, 12
  %53 = insertvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } undef, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %51, 0
  %54 = insertvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %53, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %52, 1
  ret { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %54
}

define private void @"drop$519"(ptr %0) {
  %2 = load { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, ptr %0, align 16
  call void @"drop$524"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$519"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 320)
  %3 = load { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, ptr %0, align 16
  %4 = call { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } @"dup$524"({ i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %3)
  %5 = extractvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %4, 0
  %6 = extractvalue { { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } }, { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } } %4, 1
  store { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %5, ptr %0, align 16
  store { i252, i252, i128, { { ptr, i32, i32, i32 } }, i252, i252, i252, { { ptr, i32, i32, i32 } }, i128, { { ptr, i32, i32, i32 } }, i32, i32, { { ptr, i32, i32, i32 } } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$528"({ ptr, ptr, i252, i252, i252 } %0) {
  %2 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 0
  call void @"drop$520"(ptr %2)
  %3 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 1
  call void @"drop$519"(ptr %3)
  ret void
}

define private { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } @"dup$528"({ ptr, ptr, i252, i252, i252 } %0) {
  %2 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 0
  %3 = call { ptr, ptr } @"dup$520"(ptr %2)
  %4 = extractvalue { ptr, ptr } %3, 0
  %5 = extractvalue { ptr, ptr } %3, 1
  %6 = insertvalue { ptr, ptr, i252, i252, i252 } %0, ptr %4, 0
  %7 = insertvalue { ptr, ptr, i252, i252, i252 } undef, ptr %5, 0
  %8 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 1
  %9 = call { ptr, ptr } @"dup$519"(ptr %8)
  %10 = extractvalue { ptr, ptr } %9, 0
  %11 = extractvalue { ptr, ptr } %9, 1
  %12 = insertvalue { ptr, ptr, i252, i252, i252 } %6, ptr %10, 1
  %13 = insertvalue { ptr, ptr, i252, i252, i252 } %7, ptr %11, 1
  %14 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 2
  %15 = insertvalue { ptr, ptr, i252, i252, i252 } %12, i252 %14, 2
  %16 = insertvalue { ptr, ptr, i252, i252, i252 } %13, i252 %14, 2
  %17 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 3
  %18 = insertvalue { ptr, ptr, i252, i252, i252 } %15, i252 %17, 3
  %19 = insertvalue { ptr, ptr, i252, i252, i252 } %16, i252 %17, 3
  %20 = extractvalue { ptr, ptr, i252, i252, i252 } %0, 4
  %21 = insertvalue { ptr, ptr, i252, i252, i252 } %18, i252 %20, 4
  %22 = insertvalue { ptr, ptr, i252, i252, i252 } %19, i252 %20, 4
  %23 = insertvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } undef, { ptr, ptr, i252, i252, i252 } %21, 0
  %24 = insertvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %23, { ptr, ptr, i252, i252, i252 } %22, 1
  ret { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %24
}

define private void @"drop$529"(ptr %0) {
  %2 = load { ptr, ptr, i252, i252, i252 }, ptr %0, align 16
  call void @"drop$528"({ ptr, ptr, i252, i252, i252 } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$529"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 112)
  %3 = load { ptr, ptr, i252, i252, i252 }, ptr %0, align 16
  %4 = call { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } @"dup$528"({ ptr, ptr, i252, i252, i252 } %3)
  %5 = extractvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %4, 0
  %6 = extractvalue { { ptr, ptr, i252, i252, i252 }, { ptr, ptr, i252, i252, i252 } } %4, 1
  store { ptr, ptr, i252, i252, i252 } %5, ptr %0, align 16
  store { ptr, ptr, i252, i252, i252 } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$518"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$518"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { {} } }, ptr %2, align 1
  %6 = extractvalue { i1, { {} } } %5, 1
  %7 = insertvalue { i1, { {} } } %5, { {} } %6, 1
  store { i1, { {} } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { {} } } %5, { {} } %6, 1
  store { i1, { {} } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$516"({ i128, [16 x i8] } %0) {
  %2 = alloca { i128, [16 x i8] }, i64 1, align 16
  store { i128, [16 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [16 x i8] }, { i128, [16 x i8] } } @"dup$516"({ i128, [16 x i8] } %0) {
  %2 = alloca { i128, [16 x i8] }, i64 1, align 16
  store { i128, [16 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i128 } }, ptr %2, align 16
  %6 = extractvalue { i1, { i128 } } %5, 1
  %7 = insertvalue { i1, { i128 } } %5, { i128 } %6, 1
  store { i1, { i128 } } %7, ptr %2, align 16
  %8 = load { i128, [16 x i8] }, ptr %2, align 16
  %9 = insertvalue { i1, { i128 } } %5, { i128 } %6, 1
  store { i1, { i128 } } %9, ptr %2, align 16
  %10 = load { i128, [16 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } undef, { i128, [16 x i8] } %8, 0
  %12 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } %11, { i128, [16 x i8] } %10, 1
  ret { { i128, [16 x i8] }, { i128, [16 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i128, [16 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i128, [16 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } undef, { i128, [16 x i8] } %20, 0
  %24 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } %23, { i128, [16 x i8] } %22, 1
  ret { { i128, [16 x i8] }, { i128, [16 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f3"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i16, [14 x i8] }, i64 1, align 2
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i1, [31 x i8] }, i64 1, align 8
  %10 = alloca i64, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i128, [16 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i1, [31 x i8] }, i64 1, align 8
  %17 = alloca i64, i64 1, align 8
  %18 = alloca i252, i64 1, align 16
  %19 = alloca i252, i64 1, align 16
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = add i64 %1, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = load i64, ptr %25, align 8
  %27 = mul i64 %26, 9050
  %28 = icmp uge i64 %2, %27
  %29 = call i64 @llvm.usub.sat.i64(i64 %2, i64 %27)
  br i1 %28, label %30, label %201

30:                                               ; preds = %5
  %31 = phi i64 [ %23, %5 ]
  %32 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f23"(i64 %31, { { ptr, i32, i32, i32 } } %4)
  %33 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %32, 0
  %34 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %32, 1
  %35 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %32, 2
  store { i16, [14 x i8] } %35, ptr %7, align 2
  %36 = load i1, ptr %7, align 1
  switch i1 %36, label %37 [
    i1 false, label %39
    i1 true, label %47
  ]

37:                                               ; preds = %30
  br i1 false, label %38, label %222

38:                                               ; preds = %37
  unreachable

39:                                               ; preds = %30
  %40 = load { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, ptr %7, align 2
  %41 = extractvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %40, 1
  %42 = extractvalue { { ptr, i32, i32, i32 } } %34, 0
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %57, label %75

47:                                               ; preds = %30
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %34)
  %48 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %49 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %48, 0
  %50 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %49, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %50, ptr %8, align 8
  %51 = load { i64, [24 x i8] }, ptr %8, align 8
  %52 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %53 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %52, i64 %33, 1
  %54 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %53, i64 %29, 2
  %55 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %54, ptr %3, 3
  %56 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %55, { i64, [24 x i8] } %51, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %56

57:                                               ; preds = %39
  %58 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %59 = load ptr, ptr %58, align 8
  %60 = zext i32 %43 to i64
  %61 = mul i64 %60, 32
  %62 = getelementptr inbounds i8, ptr %59, i64 %61
  %63 = add i32 %43, 1
  %64 = insertvalue { ptr, i32, i32, i32 } %42, i32 %63, 1
  %65 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %65, ptr %62, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %64)
  call void @"drop$555"(ptr %65)
  %66 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %67 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %66, 0
  %68 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %67, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %68, ptr %22, align 8
  %69 = load { i64, [24 x i8] }, ptr %22, align 8
  %70 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %71 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %33, 1
  %72 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %71, i64 %29, 2
  %73 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %72, ptr %3, 3
  %74 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, { i64, [24 x i8] } %69, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %74

75:                                               ; preds = %39
  %76 = phi { ptr, i32, i32, i32 } [ %42, %39 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %76)
  %77 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %78 = call ptr %77()
  %79 = add i64 %33, 1
  %80 = getelementptr inbounds i64, ptr %78, i32 1
  %81 = load i64, ptr %80, align 8
  %82 = load i64, ptr %78, align 8
  %83 = mul i64 %82, 109460
  %84 = add i64 %81, %83
  %85 = icmp uge i64 %29, %84
  %86 = call i64 @llvm.usub.sat.i64(i64 %29, i64 %84)
  br i1 %85, label %87, label %196

87:                                               ; preds = %75
  %88 = phi i64 [ %86, %75 ]
  %89 = phi ptr [ %3, %75 ]
  %90 = load ptr, ptr %89, align 8
  store i64 %88, ptr %10, align 8
  %91 = getelementptr inbounds ptr, ptr %89, i32 3
  %92 = load ptr, ptr %91, align 8
  call void %92(ptr %9, ptr %90, ptr %10)
  %93 = load { i1, [31 x i8] }, ptr %9, align 1
  %94 = extractvalue { i1, [31 x i8] } %93, 0
  %95 = getelementptr inbounds i8, ptr %9, i32 8
  %96 = load ptr, ptr %95, align 8
  %97 = getelementptr inbounds i8, ptr %9, i32 8
  %98 = load { ptr, i32, i32, i32 }, ptr %97, align 8
  %99 = load i64, ptr %10, align 8
  br i1 %94, label %186, label %100

100:                                              ; preds = %87
  %101 = phi { {} } [ undef, %87 ]
  %102 = load { ptr, ptr, i252, i252, i252 }, ptr %96, align 16
  call void @free(ptr %96)
  %103 = extractvalue { ptr, ptr, i252, i252, i252 } %102, 0
  %104 = extractvalue { ptr, ptr, i252, i252, i252 } %102, 1
  %105 = extractvalue { ptr, ptr, i252, i252, i252 } %102, 2
  call void @"drop$520"(ptr %103)
  call void @"drop$519"(ptr %104)
  %106 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f24"(i64 %79, i64 %99, i64 %0, ptr %89, { {} } %101, i252 %105)
  %107 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 0
  %108 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 1
  %109 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 2
  %110 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 3
  %111 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 4
  store { i64, [24 x i8] } %111, ptr %12, align 8
  %112 = load i1, ptr %12, align 1
  switch i1 %112, label %113 [
    i1 false, label %115
    i1 true, label %120
  ]

113:                                              ; preds = %100
  br i1 false, label %114, label %223

114:                                              ; preds = %113
  unreachable

115:                                              ; preds = %100
  %116 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f25"(i64 %107, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %41)
  %117 = extractvalue { i64, { i128, [16 x i8] } } %116, 0
  %118 = extractvalue { i64, { i128, [16 x i8] } } %116, 1
  store { i128, [16 x i8] } %118, ptr %14, align 16
  %119 = load i1, ptr %14, align 1
  switch i1 %119, label %132 [
    i1 false, label %134
    i1 true, label %147
  ]

120:                                              ; preds = %100
  %121 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %122 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %121, 1
  %123 = extractvalue { {}, { ptr, i32, i32, i32 } } %122, 1
  %124 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %123, 1
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %13, align 8
  %126 = load { i64, [24 x i8] }, ptr %13, align 8
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %107, 1
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %108, 2
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, ptr %110, 3
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %126, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %131

132:                                              ; preds = %115
  br i1 false, label %133, label %224

133:                                              ; preds = %132
  unreachable

134:                                              ; preds = %115
  %135 = load { i1, { i128 } }, ptr %14, align 16
  %136 = extractvalue { i1, { i128 } } %135, 1
  %137 = extractvalue { i128 } %136, 0
  %138 = zext i128 %137 to i252
  %139 = load ptr, ptr %110, align 8
  store i64 %108, ptr %17, align 8
  store i252 1254074017074475171384430419983034313718811929311188110826608799162214963686, ptr %18, align 16
  store i252 %138, ptr %19, align 16
  %140 = getelementptr inbounds ptr, ptr %110, i32 9
  %141 = load ptr, ptr %140, align 8
  call void %141(ptr %16, ptr %139, ptr %17, i32 0, ptr %18, ptr %19)
  %142 = load { i1, [31 x i8] }, ptr %16, align 1
  %143 = extractvalue { i1, [31 x i8] } %142, 0
  %144 = getelementptr inbounds i8, ptr %16, i32 8
  %145 = load { ptr, i32, i32, i32 }, ptr %144, align 8
  %146 = load i64, ptr %17, align 8
  br i1 %143, label %176, label %159

147:                                              ; preds = %115
  %148 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %149 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %148, 1
  %150 = extractvalue { {}, { ptr, i32, i32, i32 } } %149, 1
  %151 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %150, 1
  %152 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %151, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %152, ptr %15, align 8
  %153 = load { i64, [24 x i8] }, ptr %15, align 8
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %154, i64 %117, 1
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %108, 2
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, ptr %110, 3
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %153, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %158

159:                                              ; preds = %134
  %160 = phi i64 [ %146, %134 ]
  %161 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %162 = call ptr %161()
  %163 = call i64 @llvm.uadd.sat.i64(i64 %160, i64 0)
  %164 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %165 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %164, 0
  %166 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %164, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %165)
  %167 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %166, 0
  %168 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %167, 0
  %169 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %168, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %169, ptr %21, align 8
  %170 = load { i64, [24 x i8] }, ptr %21, align 8
  %171 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %172 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %171, i64 %117, 1
  %173 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %172, i64 %163, 2
  %174 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %173, ptr %110, 3
  %175 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %174, { i64, [24 x i8] } %170, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %175

176:                                              ; preds = %134
  %177 = phi { ptr, i32, i32, i32 } [ %145, %134 ]
  %178 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %177, 1
  %179 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %178, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %179, ptr %20, align 8
  %180 = load { i64, [24 x i8] }, ptr %20, align 8
  %181 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %182 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %181, i64 %117, 1
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, i64 %146, 2
  %184 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %183, ptr %110, 3
  %185 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %184, { i64, [24 x i8] } %180, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %185

186:                                              ; preds = %87
  %187 = phi { ptr, i32, i32, i32 } [ %98, %87 ]
  %188 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %187, 1
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %11, align 8
  %190 = load { i64, [24 x i8] }, ptr %11, align 8
  %191 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %192 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %191, i64 %79, 1
  %193 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %192, i64 %99, 2
  %194 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %193, ptr %89, 3
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %194, { i64, [24 x i8] } %190, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %195

196:                                              ; preds = %75
  %197 = phi i64 [ %29, %75 ]
  %198 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %199 = call ptr %198()
  %200 = call i64 @llvm.uadd.sat.i64(i64 %197, i64 0)
  br label %208

201:                                              ; preds = %5
  %202 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %202)
  %203 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %204 = call ptr %203()
  %205 = load i64, ptr %204, align 8
  %206 = mul i64 %205, 7520
  %207 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %206)
  br label %208

208:                                              ; preds = %196, %201
  %209 = phi i64 [ %0, %201 ], [ %0, %196 ]
  %210 = phi ptr [ %3, %201 ], [ %3, %196 ]
  %211 = phi i64 [ %23, %201 ], [ %79, %196 ]
  %212 = phi i64 [ %207, %201 ], [ %200, %196 ]
  %213 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %214 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %213, 0
  %215 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %214, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %215, ptr %6, align 8
  %216 = load { i64, [24 x i8] }, ptr %6, align 8
  %217 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %209, 0
  %218 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %217, i64 %211, 1
  %219 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %218, i64 %212, 2
  %220 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %219, ptr %210, 3
  %221 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %220, { i64, [24 x i8] } %216, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %221

222:                                              ; preds = %37
  call void @puts(ptr @assert_msg_8)
  call void @abort()
  unreachable

223:                                              ; preds = %113
  call void @puts(ptr @assert_msg_9)
  call void @abort()
  unreachable

224:                                              ; preds = %132
  call void @puts(ptr @assert_msg_10)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f3(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f3"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f3(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f3(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$42"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$42"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 0
  call void @"drop$42"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$42"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 1
  %9 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %6, i252 %8, 1
  %10 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %7, i252 %8, 1
  %11 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %0, 2
  %12 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %9, i32 %11, 2
  %13 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %10, i32 %11, 2
  %14 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %12, 0
  %15 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %14, { { ptr, i32, i32, i32 }, i252, i32 } %13, 1
  ret { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %15
}

define private void @"drop$500"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$500"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, { { ptr, i32, i32, i32 }, i252, i32 } %8, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %10, ptr %2, align 16
  %11 = load { i128, [80 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %5, { { ptr, i32, i32, i32 }, i252, i32 } %9, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %12, ptr %2, align 16
  %13 = load { i128, [80 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %11, 0
  %15 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %14, { i128, [80 x i8] } %13, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [80 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [80 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %20, 0
  %24 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %23, { i128, [80 x i8] } %22, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$501"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  call void @"drop$500"({ i128, [80 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$501"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  %9 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$500"({ i128, [80 x i8] } %8)
  %10 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %9, 0
  %11 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6, { i128, [80 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %7, { i128, [80 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %15
}

define private void @"drop$502"({ i128, [128 x i8] } %0) {
  %2 = alloca { i128, [128 x i8] }, i64 1, align 16
  store { i128, [128 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, 1
  call void @"drop$501"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [128 x i8] }, { i128, [128 x i8] } } @"dup$502"({ i128, [128 x i8] } %0) {
  %2 = alloca { i128, [128 x i8] }, i64 1, align 16
  store { i128, [128 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$501"({ { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [128 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [128 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } undef, { i128, [128 x i8] } %11, 0
  %15 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } %14, { i128, [128 x i8] } %13, 1
  ret { { i128, [128 x i8] }, { i128, [128 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [128 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [128 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } undef, { i128, [128 x i8] } %23, 0
  %27 = insertvalue { { i128, [128 x i8] }, { i128, [128 x i8] } } %26, { i128, [128 x i8] } %25, 1
  ret { { i128, [128 x i8] }, { i128, [128 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$37"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$37"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 4
  call void @"drop$37"({ ptr, i32, i32, i32 } %3)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 5
  call void @"drop$37"({ ptr, i32, i32, i32 } %4)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, i16 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, i16 %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, i8 %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10, i8 %11, 2
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 3
  %15 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, i32 %14, 3
  %16 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13, i32 %14, 3
  %17 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 4
  %18 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$37"({ ptr, i32, i32, i32 } %17)
  %19 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 0
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 1
  %21 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %15, { ptr, i32, i32, i32 } %19, 4
  %22 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %16, { ptr, i32, i32, i32 } %20, 4
  %23 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0, 5
  %24 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$37"({ ptr, i32, i32, i32 } %23)
  %25 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %24, 0
  %26 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %24, 1
  %27 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %21, { ptr, i32, i32, i32 } %25, 5
  %28 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %22, { ptr, i32, i32, i32 } %26, 5
  %29 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %27, 0
  %30 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %29, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %28, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %30
}

define private void @"drop$140"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i2, ptr %2, align 1
  switch i2 %3, label %11 [
    i2 0, label %4
    i2 1, label %5
    i2 -2, label %8
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %7 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %7)
  ret void

8:                                                ; preds = %1
  %9 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %10 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %9, 1
  call void @"drop$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %10)
  ret void

11:                                               ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$140"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i2, ptr %2, align 1
  switch i2 %3, label %37 [
    i2 0, label %4
    i2 1, label %13
    i2 -2, label %25
  ]

4:                                                ; preds = %1
  %5 = load { i2, i252 }, ptr %2, align 16
  %6 = extractvalue { i2, i252 } %5, 1
  %7 = insertvalue { i2, i252 } %5, i252 %6, 1
  store { i2, i252 } %7, ptr %2, align 16
  %8 = load { i128, [144 x i8] }, ptr %2, align 16
  %9 = insertvalue { i2, i252 } %5, i252 %6, 1
  store { i2, i252 } %9, ptr %2, align 16
  %10 = load { i128, [144 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %8, 0
  %12 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %11, { i128, [144 x i8] } %10, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %2, align 16
  %15 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %14, 1
  %16 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %15)
  %17 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %16, 0
  %18 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %16, 1
  %19 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %14, { { ptr, i32, i32, i32 }, i252, i32 } %17, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %19, ptr %2, align 16
  %20 = load { i128, [144 x i8] }, ptr %2, align 16
  %21 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %14, { { ptr, i32, i32, i32 }, i252, i32 } %18, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %21, ptr %2, align 16
  %22 = load { i128, [144 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %20, 0
  %24 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %23, { i128, [144 x i8] } %22, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %24

25:                                               ; preds = %1
  %26 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %27 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %26, 1
  %28 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %27)
  %29 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %28, 0
  %30 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %28, 1
  %31 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %26, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %29, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %31, ptr %2, align 16
  %32 = load { i128, [144 x i8] }, ptr %2, align 16
  %33 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %26, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %30, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %33, ptr %2, align 16
  %34 = load { i128, [144 x i8] }, ptr %2, align 16
  %35 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %32, 0
  %36 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %35, { i128, [144 x i8] } %34, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %36

37:                                               ; preds = %1
  unreachable
}

define private void @"drop$292"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 160
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i128, [144 x i8] }, ptr %22, align 16
  call void @"drop$140"({ i128, [144 x i8] } %23)
  %24 = add i64 %19, 160
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$497"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$292"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$497"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$498"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$497"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$498"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$497"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$499"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$498"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$499"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$498"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$496"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$496"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { {} }, {} } }, ptr %2, align 1
  %6 = extractvalue { i1, { { {} }, {} } } %5, 1
  %7 = insertvalue { i1, { { {} }, {} } } %5, { { {} }, {} } %6, 1
  store { i1, { { {} }, {} } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { {} }, {} } } %5, { { {} }, {} } %6, 1
  store { i1, { { {} }, {} } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f4"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i128, [128 x i8] }, i64 1, align 16
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i16, [14 x i8] }, i64 1, align 2
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = add i64 %1, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = load i64, ptr %25, align 8
  %27 = mul i64 %26, 24450
  %28 = icmp uge i64 %2, %27
  %29 = call i64 @llvm.usub.sat.i64(i64 %2, i64 %27)
  br i1 %28, label %30, label %443

30:                                               ; preds = %5
  %31 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %32 = extractvalue { { ptr, i32, i32, i32 } } %31, 0
  %33 = extractvalue { ptr, i32, i32, i32 } %32, 1
  %34 = extractvalue { ptr, i32, i32, i32 } %32, 2
  %35 = sub i32 %34, %33
  %36 = icmp uge i32 %35, 1
  br i1 %36, label %37, label %422

37:                                               ; preds = %30
  %38 = extractvalue { ptr, i32, i32, i32 } %32, 0
  %39 = load ptr, ptr %38, align 8
  %40 = zext i32 %33 to i64
  %41 = mul i64 %40, 32
  %42 = getelementptr inbounds i8, ptr %39, i64 %41
  %43 = add i32 %33, 1
  %44 = insertvalue { ptr, i32, i32, i32 } %32, i32 %43, 1
  %45 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %45, ptr %42, i64 32, i1 false)
  %46 = load i252, ptr %45, align 16
  call void @free(ptr %45)
  %47 = icmp eq i252 %46, 0
  br i1 %47, label %48, label %55

48:                                               ; preds = %37
  %49 = phi i64 [ %29, %37 ]
  %50 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %51 = call ptr %50()
  %52 = load i64, ptr %51, align 8
  %53 = mul i64 %52, 950
  %54 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %53)
  br label %151

55:                                               ; preds = %37
  %56 = phi i252 [ %46, %37 ]
  %57 = zext i252 %56 to i256
  %58 = sub i256 %57, 1
  %59 = add i256 %57, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %60 = icmp ult i256 %57, 1
  %61 = select i1 %60, i256 %59, i256 %58
  %62 = trunc i256 %61 to i252
  %63 = icmp eq i252 %62, 0
  br i1 %63, label %64, label %71

64:                                               ; preds = %55
  %65 = phi i64 [ %29, %55 ]
  %66 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %67 = call ptr %66()
  %68 = load i64, ptr %67, align 8
  %69 = mul i64 %68, 760
  %70 = call i64 @llvm.uadd.sat.i64(i64 %65, i64 %69)
  br label %151

71:                                               ; preds = %55
  %72 = phi i252 [ %56, %55 ]
  %73 = zext i252 %72 to i256
  %74 = sub i256 %73, 2
  %75 = add i256 %73, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %76 = icmp ult i256 %73, 2
  %77 = select i1 %76, i256 %75, i256 %74
  %78 = trunc i256 %77 to i252
  %79 = icmp eq i252 %78, 0
  br i1 %79, label %80, label %87

80:                                               ; preds = %71
  %81 = phi i64 [ %29, %71 ]
  %82 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %83 = call ptr %82()
  %84 = load i64, ptr %83, align 8
  %85 = mul i64 %84, 570
  %86 = call i64 @llvm.uadd.sat.i64(i64 %81, i64 %85)
  br label %151

87:                                               ; preds = %71
  %88 = phi i252 [ %72, %71 ]
  %89 = zext i252 %88 to i256
  %90 = sub i256 %89, 3
  %91 = add i256 %89, 3618502788666131213697322783095070105623107215331596699973092056135872020478
  %92 = icmp ult i256 %89, 3
  %93 = select i1 %92, i256 %91, i256 %90
  %94 = trunc i256 %93 to i252
  %95 = icmp eq i252 %94, 0
  br i1 %95, label %96, label %103

96:                                               ; preds = %87
  %97 = phi i64 [ %29, %87 ]
  %98 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %99 = call ptr %98()
  %100 = load i64, ptr %99, align 8
  %101 = mul i64 %100, 380
  %102 = call i64 @llvm.uadd.sat.i64(i64 %97, i64 %101)
  br label %151

103:                                              ; preds = %87
  %104 = phi i252 [ %88, %87 ]
  %105 = zext i252 %104 to i256
  %106 = sub i256 %105, 4
  %107 = add i256 %105, 3618502788666131213697322783095070105623107215331596699973092056135872020477
  %108 = icmp ult i256 %105, 4
  %109 = select i1 %108, i256 %107, i256 %106
  %110 = trunc i256 %109 to i252
  %111 = icmp eq i252 %110, 0
  br i1 %111, label %112, label %119

112:                                              ; preds = %103
  %113 = phi i64 [ %29, %103 ]
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = load i64, ptr %115, align 8
  %117 = mul i64 %116, 190
  %118 = call i64 @llvm.uadd.sat.i64(i64 %113, i64 %117)
  br label %151

119:                                              ; preds = %103
  %120 = phi i252 [ %104, %103 ]
  %121 = zext i252 %120 to i256
  %122 = sub i256 %121, 5
  %123 = add i256 %121, 3618502788666131213697322783095070105623107215331596699973092056135872020476
  %124 = icmp ult i256 %121, 5
  %125 = select i1 %124, i256 %123, i256 %122
  %126 = trunc i256 %125 to i252
  %127 = icmp eq i252 %126, 0
  br i1 %127, label %128, label %133

128:                                              ; preds = %119
  %129 = phi i64 [ %29, %119 ]
  %130 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %131 = call ptr %130()
  %132 = call i64 @llvm.uadd.sat.i64(i64 %129, i64 0)
  br label %151

133:                                              ; preds = %119
  %134 = phi i252 [ %120, %119 ]
  %135 = phi i252 [ 6, %119 ]
  %136 = zext i252 %134 to i256
  %137 = zext i252 %135 to i256
  %138 = sub i256 %136, %137
  %139 = add i256 %138, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %140 = icmp ult i256 %136, %137
  %141 = select i1 %140, i256 %139, i256 %138
  %142 = trunc i256 %141 to i252
  %143 = icmp eq i252 %142, 0
  br i1 %143, label %144, label %415

144:                                              ; preds = %133
  %145 = phi i64 [ %29, %133 ]
  %146 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %147 = call ptr %146()
  %148 = load i64, ptr %147, align 8
  %149 = mul i64 %148, 10
  %150 = call i64 @llvm.uadd.sat.i64(i64 %145, i64 %149)
  br label %151

151:                                              ; preds = %48, %64, %80, %96, %112, %128, %144
  %152 = phi i64 [ %0, %144 ], [ %0, %128 ], [ %0, %112 ], [ %0, %96 ], [ %0, %80 ], [ %0, %64 ], [ %0, %48 ]
  %153 = phi ptr [ %3, %144 ], [ %3, %128 ], [ %3, %112 ], [ %3, %96 ], [ %3, %80 ], [ %3, %64 ], [ %3, %48 ]
  %154 = phi { i3, [0 x i8] } [ { i3 -2, [0 x i8] undef }, %144 ], [ { i3 -3, [0 x i8] undef }, %128 ], [ { i3 -4, [0 x i8] undef }, %112 ], [ { i3 3, [0 x i8] undef }, %96 ], [ { i3 2, [0 x i8] undef }, %80 ], [ { i3 1, [0 x i8] undef }, %64 ], [ { i3 0, [0 x i8] undef }, %48 ]
  %155 = phi i64 [ %23, %144 ], [ %23, %128 ], [ %23, %112 ], [ %23, %96 ], [ %23, %80 ], [ %23, %64 ], [ %23, %48 ]
  %156 = phi { ptr, i32, i32, i32 } [ %44, %144 ], [ %44, %128 ], [ %44, %112 ], [ %44, %96 ], [ %44, %80 ], [ %44, %64 ], [ %44, %48 ]
  %157 = phi i64 [ %150, %144 ], [ %132, %128 ], [ %118, %112 ], [ %102, %96 ], [ %86, %80 ], [ %70, %64 ], [ %54, %48 ]
  %158 = extractvalue { ptr, i32, i32, i32 } %156, 1
  %159 = extractvalue { ptr, i32, i32, i32 } %156, 2
  %160 = sub i32 %159, %158
  %161 = icmp uge i32 %160, 1
  br i1 %161, label %162, label %394

162:                                              ; preds = %151
  %163 = extractvalue { ptr, i32, i32, i32 } %156, 0
  %164 = load ptr, ptr %163, align 8
  %165 = zext i32 %158 to i64
  %166 = mul i64 %165, 32
  %167 = getelementptr inbounds i8, ptr %164, i64 %166
  %168 = add i32 %158, 1
  %169 = insertvalue { ptr, i32, i32, i32 } %156, i32 %168, 1
  %170 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %170, ptr %167, i64 32, i1 false)
  %171 = load i252, ptr %170, align 16
  call void @free(ptr %170)
  %172 = icmp ult i252 %171, 4294967296
  %173 = add i64 %155, 2
  %174 = add i64 %155, 3
  %175 = select i1 %172, i64 %173, i64 %174
  %176 = trunc i252 %171 to i32
  br i1 %172, label %177, label %387

177:                                              ; preds = %162
  %178 = phi { ptr, i32, i32, i32 } [ %169, %162 ]
  %179 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %178, 0
  %180 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f26"(i64 %175, i64 %157, { { ptr, i32, i32, i32 } } %179)
  %181 = extractvalue { i64, i64, { i128, [128 x i8] } } %180, 0
  %182 = extractvalue { i64, i64, { i128, [128 x i8] } } %180, 1
  %183 = extractvalue { i64, i64, { i128, [128 x i8] } } %180, 2
  store { i128, [128 x i8] } %183, ptr %9, align 16
  %184 = load i1, ptr %9, align 1
  switch i1 %184, label %185 [
    i1 false, label %187
    i1 true, label %193
  ]

185:                                              ; preds = %177
  br i1 false, label %186, label %464

186:                                              ; preds = %185
  unreachable

187:                                              ; preds = %177
  %188 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %9, align 16
  %189 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %188, 1
  %190 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %189, 0
  %191 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %189, 1
  store { i128, [80 x i8] } %191, ptr %11, align 16
  %192 = load i1, ptr %11, align 1
  switch i1 %192, label %203 [
    i1 false, label %205
    i1 true, label %213
  ]

193:                                              ; preds = %177
  %194 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %195 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %194, 1
  %196 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %195, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %196, ptr %10, align 8
  %197 = load { i64, [24 x i8] }, ptr %10, align 8
  %198 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %198, i64 %181, 1
  %200 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %199, i64 %182, 2
  %201 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %200, ptr %153, 3
  %202 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, { i64, [24 x i8] } %197, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %202

203:                                              ; preds = %187
  br i1 false, label %204, label %465

204:                                              ; preds = %203
  unreachable

205:                                              ; preds = %187
  %206 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %11, align 16
  %207 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %206, 1
  %208 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f27"(i64 %181, { { ptr, i32, i32, i32 } } %190)
  %209 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %208, 0
  %210 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %208, 1
  %211 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %208, 2
  store { i16, [14 x i8] } %211, ptr %13, align 2
  %212 = load i1, ptr %13, align 1
  switch i1 %212, label %223 [
    i1 false, label %225
    i1 true, label %233
  ]

213:                                              ; preds = %187
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %190)
  %214 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f21"()
  %215 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %214, 0
  %216 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %215, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %216, ptr %12, align 8
  %217 = load { i64, [24 x i8] }, ptr %12, align 8
  %218 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %219 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %218, i64 %181, 1
  %220 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %219, i64 %182, 2
  %221 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %220, ptr %153, 3
  %222 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %221, { i64, [24 x i8] } %217, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %222

223:                                              ; preds = %205
  br i1 false, label %224, label %466

224:                                              ; preds = %223
  unreachable

225:                                              ; preds = %205
  %226 = load { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, ptr %13, align 2
  %227 = extractvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %226, 1
  %228 = extractvalue { { ptr, i32, i32, i32 } } %210, 0
  %229 = extractvalue { ptr, i32, i32, i32 } %228, 1
  %230 = extractvalue { ptr, i32, i32, i32 } %228, 2
  %231 = sub i32 %230, %229
  %232 = icmp uge i32 %231, 1
  br i1 %232, label %243, label %366

233:                                              ; preds = %205
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %207)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %210)
  %234 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f31"()
  %235 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %234, 0
  %236 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %235, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %236, ptr %14, align 8
  %237 = load { i64, [24 x i8] }, ptr %14, align 8
  %238 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %239 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %238, i64 %209, 1
  %240 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %239, i64 %182, 2
  %241 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %240, ptr %153, 3
  %242 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %241, { i64, [24 x i8] } %237, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %242

243:                                              ; preds = %225
  %244 = extractvalue { ptr, i32, i32, i32 } %228, 0
  %245 = load ptr, ptr %244, align 8
  %246 = zext i32 %229 to i64
  %247 = mul i64 %246, 32
  %248 = getelementptr inbounds i8, ptr %245, i64 %247
  %249 = add i32 %229, 1
  %250 = insertvalue { ptr, i32, i32, i32 } %228, i32 %249, 1
  %251 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %251, ptr %248, i64 32, i1 false)
  %252 = load i252, ptr %251, align 16
  call void @free(ptr %251)
  %253 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %250, 0
  %254 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f28"(i64 %209, i64 %182, { { ptr, i32, i32, i32 } } %253, { ptr, i32, i32, i32 } zeroinitializer, i252 %252)
  %255 = extractvalue { i64, i64, { i64, [56 x i8] } } %254, 0
  %256 = extractvalue { i64, i64, { i64, [56 x i8] } } %254, 1
  %257 = extractvalue { i64, i64, { i64, [56 x i8] } } %254, 2
  store { i64, [56 x i8] } %257, ptr %16, align 8
  %258 = load i1, ptr %16, align 1
  switch i1 %258, label %259 [
    i1 false, label %261
    i1 true, label %267
  ]

259:                                              ; preds = %243
  br i1 false, label %260, label %467

260:                                              ; preds = %259
  unreachable

261:                                              ; preds = %243
  %262 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %16, align 8
  %263 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %262, 1
  %264 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %263, 0
  %265 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %263, 1
  store { i64, [24 x i8] } %265, ptr %18, align 8
  %266 = load i1, ptr %18, align 1
  switch i1 %266, label %277 [
    i1 false, label %279
    i1 true, label %287
  ]

267:                                              ; preds = %243
  %268 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %269 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %268, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %207)
  %270 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %269, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %270, ptr %17, align 8
  %271 = load { i64, [24 x i8] }, ptr %17, align 8
  %272 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %273 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %272, i64 %255, 1
  %274 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %273, i64 %256, 2
  %275 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %274, ptr %153, 3
  %276 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %275, { i64, [24 x i8] } %271, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %276

277:                                              ; preds = %261
  br i1 false, label %278, label %468

278:                                              ; preds = %277
  unreachable

279:                                              ; preds = %261
  %280 = load { i1, { ptr, i32, i32, i32 } }, ptr %18, align 8
  %281 = extractvalue { i1, { ptr, i32, i32, i32 } } %280, 1
  %282 = extractvalue { { ptr, i32, i32, i32 } } %264, 0
  %283 = extractvalue { ptr, i32, i32, i32 } %282, 1
  %284 = extractvalue { ptr, i32, i32, i32 } %282, 2
  %285 = sub i32 %284, %283
  %286 = icmp uge i32 %285, 1
  br i1 %286, label %293, label %311

287:                                              ; preds = %261
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %264)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %207)
  %288 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %289 = call ptr %288()
  %290 = load i64, ptr %289, align 8
  %291 = mul i64 %290, 1570
  %292 = call i64 @llvm.uadd.sat.i64(i64 %256, i64 %291)
  br label %373

293:                                              ; preds = %279
  %294 = extractvalue { ptr, i32, i32, i32 } %282, 0
  %295 = load ptr, ptr %294, align 8
  %296 = zext i32 %283 to i64
  %297 = mul i64 %296, 32
  %298 = getelementptr inbounds i8, ptr %295, i64 %297
  %299 = add i32 %283, 1
  %300 = insertvalue { ptr, i32, i32, i32 } %282, i32 %299, 1
  %301 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %301, ptr %298, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %300)
  call void @"drop$555"(ptr %301)
  call void @"drop$292"({ ptr, i32, i32, i32 } %281)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %207)
  %302 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %303 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %302, 0
  %304 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %303, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %304, ptr %22, align 8
  %305 = load { i64, [24 x i8] }, ptr %22, align 8
  %306 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %307 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %306, i64 %255, 1
  %308 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %307, i64 %256, 2
  %309 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %308, ptr %153, 3
  %310 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %309, { i64, [24 x i8] } %305, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %310

311:                                              ; preds = %279
  %312 = phi { ptr, i32, i32, i32 } [ %282, %279 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %312)
  %313 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %314 = call ptr %313()
  %315 = add i64 %255, 1
  %316 = getelementptr inbounds i64, ptr %314, i32 1
  %317 = load i64, ptr %316, align 8
  %318 = mul i64 %317, 3
  %319 = load i64, ptr %314, align 8
  %320 = mul i64 %319, 298000
  %321 = add i64 %318, %320
  %322 = icmp uge i64 %256, %321
  %323 = call i64 @llvm.usub.sat.i64(i64 %256, i64 %321)
  br i1 %322, label %324, label %361

324:                                              ; preds = %311
  %325 = phi i64 [ %315, %311 ]
  %326 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %325, i64 %323, i64 %152, ptr %153, { {} } undef, { i3, [0 x i8] } %154, i32 %176, { { ptr, i32, i32, i32 }, i252, i32 } %207, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %227, { ptr, i32, i32, i32 } %281)
  %327 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, 0
  %328 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, 1
  %329 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, 2
  %330 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, 3
  %331 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, 4
  store { i64, [24 x i8] } %331, ptr %19, align 8
  %332 = load i1, ptr %19, align 1
  switch i1 %332, label %333 [
    i1 false, label %335
    i1 true, label %351
  ]

333:                                              ; preds = %324
  br i1 false, label %334, label %469

334:                                              ; preds = %333
  unreachable

335:                                              ; preds = %324
  %336 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %337 = call ptr %336()
  %338 = call i64 @llvm.uadd.sat.i64(i64 %328, i64 0)
  %339 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %340 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %339, 0
  %341 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %339, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %340)
  %342 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %341, 0
  %343 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %342, 0
  %344 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %343, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %344, ptr %21, align 8
  %345 = load { i64, [24 x i8] }, ptr %21, align 8
  %346 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %329, 0
  %347 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %346, i64 %327, 1
  %348 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %347, i64 %338, 2
  %349 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %348, ptr %330, 3
  %350 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %349, { i64, [24 x i8] } %345, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %350

351:                                              ; preds = %324
  %352 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %353 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %352, 1
  %354 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %353, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %354, ptr %20, align 8
  %355 = load { i64, [24 x i8] }, ptr %20, align 8
  %356 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %329, 0
  %357 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %356, i64 %327, 1
  %358 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %357, i64 %328, 2
  %359 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %358, ptr %330, 3
  %360 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %359, { i64, [24 x i8] } %355, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %360

361:                                              ; preds = %311
  %362 = phi { ptr, i32, i32, i32 } [ %281, %311 ]
  call void @"drop$292"({ ptr, i32, i32, i32 } %362)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %207)
  %363 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %364 = call ptr %363()
  %365 = call i64 @llvm.uadd.sat.i64(i64 %256, i64 0)
  br label %450

366:                                              ; preds = %225
  %367 = phi { ptr, i32, i32, i32 } [ %228, %225 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %367)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %207)
  %368 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %369 = call ptr %368()
  %370 = load i64, ptr %369, align 8
  %371 = mul i64 %370, 4940
  %372 = call i64 @llvm.uadd.sat.i64(i64 %182, i64 %371)
  br label %373

373:                                              ; preds = %287, %366
  %374 = phi i64 [ %152, %366 ], [ %152, %287 ]
  %375 = phi ptr [ %153, %366 ], [ %153, %287 ]
  %376 = phi i64 [ %209, %366 ], [ %255, %287 ]
  %377 = phi i64 [ %372, %366 ], [ %292, %287 ]
  %378 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f30"()
  %379 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %378, 0
  %380 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %379, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %380, ptr %15, align 8
  %381 = load { i64, [24 x i8] }, ptr %15, align 8
  %382 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %374, 0
  %383 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %382, i64 %376, 1
  %384 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %383, i64 %377, 2
  %385 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %384, ptr %375, 3
  %386 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %385, { i64, [24 x i8] } %381, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %386

387:                                              ; preds = %162
  %388 = phi { ptr, i32, i32, i32 } [ %169, %162 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %388)
  %389 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %390 = call ptr %389()
  %391 = load i64, ptr %390, align 8
  %392 = mul i64 %391, 28310
  %393 = call i64 @llvm.uadd.sat.i64(i64 %157, i64 %392)
  br label %401

394:                                              ; preds = %151
  %395 = phi { ptr, i32, i32, i32 } [ %156, %151 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %395)
  %396 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %397 = call ptr %396()
  %398 = load i64, ptr %397, align 8
  %399 = mul i64 %398, 29610
  %400 = call i64 @llvm.uadd.sat.i64(i64 %157, i64 %399)
  br label %401

401:                                              ; preds = %387, %394
  %402 = phi i64 [ %152, %394 ], [ %152, %387 ]
  %403 = phi ptr [ %153, %394 ], [ %153, %387 ]
  %404 = phi i64 [ %155, %394 ], [ %175, %387 ]
  %405 = phi i64 [ %400, %394 ], [ %393, %387 ]
  %406 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %407 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %406, 0
  %408 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %407, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %408, ptr %8, align 8
  %409 = load { i64, [24 x i8] }, ptr %8, align 8
  %410 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %402, 0
  %411 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %410, i64 %404, 1
  %412 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %411, i64 %405, 2
  %413 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %412, ptr %403, 3
  %414 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %413, { i64, [24 x i8] } %409, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %414

415:                                              ; preds = %133
  %416 = phi { ptr, i32, i32, i32 } [ %44, %133 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %416)
  %417 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %418 = call ptr %417()
  %419 = load i64, ptr %418, align 8
  %420 = mul i64 %419, 30410
  %421 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %420)
  br label %429

422:                                              ; preds = %30
  %423 = phi { ptr, i32, i32, i32 } [ %32, %30 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %423)
  %424 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %425 = call ptr %424()
  %426 = load i64, ptr %425, align 8
  %427 = mul i64 %426, 31640
  %428 = call i64 @llvm.uadd.sat.i64(i64 %29, i64 %427)
  br label %429

429:                                              ; preds = %415, %422
  %430 = phi i64 [ %0, %422 ], [ %0, %415 ]
  %431 = phi ptr [ %3, %422 ], [ %3, %415 ]
  %432 = phi i64 [ %23, %422 ], [ %23, %415 ]
  %433 = phi i64 [ %428, %422 ], [ %421, %415 ]
  %434 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %435 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %434, 0
  %436 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %435, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %436, ptr %7, align 8
  %437 = load { i64, [24 x i8] }, ptr %7, align 8
  %438 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %430, 0
  %439 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %438, i64 %432, 1
  %440 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %439, i64 %433, 2
  %441 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %440, ptr %431, 3
  %442 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %441, { i64, [24 x i8] } %437, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %442

443:                                              ; preds = %5
  %444 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %444)
  %445 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %446 = call ptr %445()
  %447 = load i64, ptr %446, align 8
  %448 = mul i64 %447, 7460
  %449 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %448)
  br label %450

450:                                              ; preds = %361, %443
  %451 = phi i64 [ %0, %443 ], [ %152, %361 ]
  %452 = phi ptr [ %3, %443 ], [ %153, %361 ]
  %453 = phi i64 [ %23, %443 ], [ %315, %361 ]
  %454 = phi i64 [ %449, %443 ], [ %365, %361 ]
  %455 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %456 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %455, 0
  %457 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %456, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %457, ptr %6, align 8
  %458 = load { i64, [24 x i8] }, ptr %6, align 8
  %459 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %451, 0
  %460 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %459, i64 %453, 1
  %461 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %460, i64 %454, 2
  %462 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %461, ptr %452, 3
  %463 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %462, { i64, [24 x i8] } %458, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %463

464:                                              ; preds = %185
  call void @puts(ptr @assert_msg_11)
  call void @abort()
  unreachable

465:                                              ; preds = %203
  call void @puts(ptr @assert_msg_12)
  call void @abort()
  unreachable

466:                                              ; preds = %223
  call void @puts(ptr @assert_msg_13)
  call void @abort()
  unreachable

467:                                              ; preds = %259
  call void @puts(ptr @assert_msg_14)
  call void @abort()
  unreachable

468:                                              ; preds = %277
  call void @puts(ptr @assert_msg_15)
  call void @abort()
  unreachable

469:                                              ; preds = %333
  call void @puts(ptr @assert_msg_16)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f4(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f4"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f4(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f4(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 2
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 4
  call void @"drop$292"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 0
  %3 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, { i3, [0 x i8] } %2, 0
  %4 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } undef, { i3, [0 x i8] } %2, 0
  %5 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 1
  %6 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %3, i32 %5, 1
  %7 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %4, i32 %5, 1
  %8 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 2
  %9 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 1
  %12 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %6, { { ptr, i32, i32, i32 }, i252, i32 } %10, 2
  %13 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %7, { { ptr, i32, i32, i32 }, i252, i32 } %11, 2
  %14 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 3
  %15 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %12, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %14, 3
  %16 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %13, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %14, 3
  %17 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0, 4
  %18 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %17)
  %19 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 0
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %18, 1
  %21 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %15, { ptr, i32, i32, i32 } %19, 4
  %22 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %16, { ptr, i32, i32, i32 } %20, 4
  %23 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %21, 0
  %24 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %23, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %22, 1
  ret { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %24
}

define private void @"drop$286"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 144
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %22, align 16
  call void @"drop$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %23)
  %24 = add i64 %19, 144
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$286"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$492"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$492"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$286"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$493"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$492"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$493"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$492"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$494"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$493"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$494"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$493"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f5"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [56 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = add i64 %1, 1
  %16 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %17 = call ptr %16()
  %18 = icmp uge i64 %2, 0
  %19 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %18, label %20, label %172

20:                                               ; preds = %5
  %21 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %22 = extractvalue { { ptr, i32, i32, i32 } } %21, 0
  %23 = extractvalue { ptr, i32, i32, i32 } %22, 1
  %24 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %25 = sub i32 %24, %23
  %26 = icmp uge i32 %25, 1
  br i1 %26, label %27, label %151

27:                                               ; preds = %20
  %28 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %29 = load ptr, ptr %28, align 8
  %30 = zext i32 %23 to i64
  %31 = mul i64 %30, 32
  %32 = getelementptr inbounds i8, ptr %29, i64 %31
  %33 = add i32 %23, 1
  %34 = insertvalue { ptr, i32, i32, i32 } %22, i32 %33, 1
  %35 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %35, ptr %32, i64 32, i1 false)
  %36 = load i252, ptr %35, align 16
  call void @free(ptr %35)
  %37 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %34, 0
  %38 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f32"(i64 %15, i64 %19, { { ptr, i32, i32, i32 } } %37, { ptr, i32, i32, i32 } zeroinitializer, i252 %36)
  %39 = extractvalue { i64, i64, { i64, [56 x i8] } } %38, 0
  %40 = extractvalue { i64, i64, { i64, [56 x i8] } } %38, 1
  %41 = extractvalue { i64, i64, { i64, [56 x i8] } } %38, 2
  store { i64, [56 x i8] } %41, ptr %8, align 8
  %42 = load i1, ptr %8, align 1
  switch i1 %42, label %43 [
    i1 false, label %45
    i1 true, label %51
  ]

43:                                               ; preds = %27
  br i1 false, label %44, label %193

44:                                               ; preds = %43
  unreachable

45:                                               ; preds = %27
  %46 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %8, align 8
  %47 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, 1
  %48 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %47, 0
  %49 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %47, 1
  store { i64, [24 x i8] } %49, ptr %10, align 8
  %50 = load i1, ptr %10, align 1
  switch i1 %50, label %61 [
    i1 false, label %63
    i1 true, label %71
  ]

51:                                               ; preds = %27
  %52 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %53 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %52, 1
  %54 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %53, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %54, ptr %9, align 8
  %55 = load { i64, [24 x i8] }, ptr %9, align 8
  %56 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %57 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %56, i64 %39, 1
  %58 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %57, i64 %40, 2
  %59 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %58, ptr %3, 3
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, { i64, [24 x i8] } %55, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %60

61:                                               ; preds = %45
  br i1 false, label %62, label %194

62:                                               ; preds = %61
  unreachable

63:                                               ; preds = %45
  %64 = load { i1, { ptr, i32, i32, i32 } }, ptr %10, align 8
  %65 = extractvalue { i1, { ptr, i32, i32, i32 } } %64, 1
  %66 = extractvalue { { ptr, i32, i32, i32 } } %48, 0
  %67 = extractvalue { ptr, i32, i32, i32 } %66, 1
  %68 = extractvalue { ptr, i32, i32, i32 } %66, 2
  %69 = sub i32 %68, %67
  %70 = icmp uge i32 %69, 1
  br i1 %70, label %77, label %95

71:                                               ; preds = %45
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %48)
  %72 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %73 = call ptr %72()
  %74 = load i64, ptr %73, align 8
  %75 = mul i64 %74, 4160
  %76 = call i64 @llvm.uadd.sat.i64(i64 %40, i64 %75)
  br label %158

77:                                               ; preds = %63
  %78 = extractvalue { ptr, i32, i32, i32 } %66, 0
  %79 = load ptr, ptr %78, align 8
  %80 = zext i32 %67 to i64
  %81 = mul i64 %80, 32
  %82 = getelementptr inbounds i8, ptr %79, i64 %81
  %83 = add i32 %67, 1
  %84 = insertvalue { ptr, i32, i32, i32 } %66, i32 %83, 1
  %85 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %85, ptr %82, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %84)
  call void @"drop$555"(ptr %85)
  call void @"drop$286"({ ptr, i32, i32, i32 } %65)
  %86 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %87 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %86, 0
  %88 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %87, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %88, ptr %14, align 8
  %89 = load { i64, [24 x i8] }, ptr %14, align 8
  %90 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %91 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %90, i64 %39, 1
  %92 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %91, i64 %40, 2
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %92, ptr %3, 3
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, { i64, [24 x i8] } %89, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %94

95:                                               ; preds = %63
  %96 = phi { ptr, i32, i32, i32 } [ %66, %63 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %96)
  %97 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %98 = call ptr %97()
  %99 = add i64 %39, 1
  %100 = getelementptr inbounds i64, ptr %98, i32 1
  %101 = load i64, ptr %100, align 8
  %102 = load i64, ptr %98, align 8
  %103 = mul i64 %102, 95940
  %104 = add i64 %101, %103
  %105 = icmp uge i64 %40, %104
  %106 = call i64 @llvm.usub.sat.i64(i64 %40, i64 %104)
  br i1 %105, label %107, label %144

107:                                              ; preds = %95
  %108 = phi i64 [ %99, %95 ]
  %109 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f33"(i64 %108, i64 %106, i64 %0, ptr %3, { {} } undef, { ptr, i32, i32, i32 } %65)
  %110 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, 0
  %111 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, 1
  %112 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, 2
  %113 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, 3
  %114 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, 4
  store { i64, [24 x i8] } %114, ptr %11, align 8
  %115 = load i1, ptr %11, align 1
  switch i1 %115, label %116 [
    i1 false, label %118
    i1 true, label %134
  ]

116:                                              ; preds = %107
  br i1 false, label %117, label %195

117:                                              ; preds = %116
  unreachable

118:                                              ; preds = %107
  %119 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %120 = call ptr %119()
  %121 = call i64 @llvm.uadd.sat.i64(i64 %111, i64 0)
  %122 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %123 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %122, 0
  %124 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %122, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %123)
  %125 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %124, 0
  %126 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %125, 0
  %127 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %126, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %127, ptr %13, align 8
  %128 = load { i64, [24 x i8] }, ptr %13, align 8
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %112, 0
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %110, 1
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %121, 2
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, ptr %113, 3
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %132, { i64, [24 x i8] } %128, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %133

134:                                              ; preds = %107
  %135 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %136 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %135, 1
  %137 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %136, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %137, ptr %12, align 8
  %138 = load { i64, [24 x i8] }, ptr %12, align 8
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %112, 0
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, i64 %110, 1
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %140, i64 %111, 2
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, ptr %113, 3
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, { i64, [24 x i8] } %138, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %143

144:                                              ; preds = %95
  %145 = phi { ptr, i32, i32, i32 } [ %65, %95 ]
  call void @"drop$286"({ ptr, i32, i32, i32 } %145)
  %146 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %147 = call ptr %146()
  %148 = load i64, ptr %147, align 8
  %149 = mul i64 %148, 2690
  %150 = call i64 @llvm.uadd.sat.i64(i64 %40, i64 %149)
  br label %179

151:                                              ; preds = %20
  %152 = phi { ptr, i32, i32, i32 } [ %22, %20 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %152)
  %153 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %154 = call ptr %153()
  %155 = load i64, ptr %154, align 8
  %156 = mul i64 %155, 7530
  %157 = call i64 @llvm.uadd.sat.i64(i64 %19, i64 %156)
  br label %158

158:                                              ; preds = %71, %151
  %159 = phi i64 [ %0, %151 ], [ %0, %71 ]
  %160 = phi ptr [ %3, %151 ], [ %3, %71 ]
  %161 = phi i64 [ %15, %151 ], [ %39, %71 ]
  %162 = phi i64 [ %157, %151 ], [ %76, %71 ]
  %163 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %164 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %163, 0
  %165 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %164, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %165, ptr %7, align 8
  %166 = load { i64, [24 x i8] }, ptr %7, align 8
  %167 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %159, 0
  %168 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %167, i64 %161, 1
  %169 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %168, i64 %162, 2
  %170 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %169, ptr %160, 3
  %171 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %170, { i64, [24 x i8] } %166, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %171

172:                                              ; preds = %5
  %173 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %173)
  %174 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %175 = call ptr %174()
  %176 = load i64, ptr %175, align 8
  %177 = mul i64 %176, 7730
  %178 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %177)
  br label %179

179:                                              ; preds = %144, %172
  %180 = phi i64 [ %0, %172 ], [ %0, %144 ]
  %181 = phi ptr [ %3, %172 ], [ %3, %144 ]
  %182 = phi i64 [ %15, %172 ], [ %99, %144 ]
  %183 = phi i64 [ %178, %172 ], [ %150, %144 ]
  %184 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %185 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %184, 0
  %186 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %185, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %186, ptr %6, align 8
  %187 = load { i64, [24 x i8] }, ptr %6, align 8
  %188 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %180, 0
  %189 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %188, i64 %182, 1
  %190 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %189, i64 %183, 2
  %191 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %190, ptr %181, 3
  %192 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %191, { i64, [24 x i8] } %187, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %192

193:                                              ; preds = %43
  call void @puts(ptr @assert_msg_17)
  call void @abort()
  unreachable

194:                                              ; preds = %61
  call void @puts(ptr @assert_msg_18)
  call void @abort()
  unreachable

195:                                              ; preds = %116
  call void @puts(ptr @assert_msg_19)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f5(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f5"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f5(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f5(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f6"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca { i1, [47 x i8] }, i64 1, align 16
  %12 = alloca i64, i64 1, align 8
  %13 = alloca i252, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = icmp uge i64 %2, 0
  %21 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %20, label %22, label %249

22:                                               ; preds = %5
  %23 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %24 = extractvalue { { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  %28 = icmp uge i32 %27, 1
  br i1 %28, label %29, label %228

29:                                               ; preds = %22
  %30 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %31 = load ptr, ptr %30, align 8
  %32 = zext i32 %25 to i64
  %33 = mul i64 %32, 32
  %34 = getelementptr inbounds i8, ptr %31, i64 %33
  %35 = add i32 %25, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %24, i32 %35, 1
  %37 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %37, ptr %34, i64 32, i1 false)
  %38 = load i252, ptr %37, align 16
  call void @free(ptr %37)
  %39 = add i64 %1, 4
  %40 = icmp ult i252 %38, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %40, label %41, label %221

41:                                               ; preds = %29
  %42 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %65

47:                                               ; preds = %41
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %54)
  call void @"drop$555"(ptr %55)
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %57, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %58, ptr %16, align 8
  %59 = load { i64, [24 x i8] }, ptr %16, align 8
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, i64 %39, 1
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %21, 2
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, ptr %3, 3
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, { i64, [24 x i8] } %59, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %64

65:                                               ; preds = %41
  %66 = phi { ptr, i32, i32, i32 } [ %42, %41 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %66)
  %67 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %68 = call ptr %67()
  %69 = add i64 %1, 5
  %70 = getelementptr inbounds i64, ptr %68, i32 1
  %71 = load i64, ptr %70, align 8
  %72 = load i64, ptr %68, align 8
  %73 = mul i64 %72, 7560
  %74 = add i64 %71, %73
  %75 = icmp uge i64 %21, %74
  %76 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %74)
  br i1 %75, label %77, label %214

77:                                               ; preds = %65
  %78 = phi i252 [ %38, %65 ]
  %79 = add i64 %0, 3
  %80 = zext i252 %78 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %8, align 16
  store i256 %80, ptr %9, align 16
  %81 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %81(ptr %10, ptr %8, ptr %9)
  %82 = load i256, ptr %10, align 16
  %83 = trunc i256 %82 to i252
  %84 = add i64 %1, 8
  %85 = sub i252 %83, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %86 = icmp ult i252 %83, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %87 = select i1 %86, i252 %83, i252 %85
  %88 = load ptr, ptr %3, align 8
  store i64 %76, ptr %12, align 8
  store i252 %87, ptr %13, align 16
  %89 = getelementptr inbounds ptr, ptr %3, i32 8
  %90 = load ptr, ptr %89, align 8
  call void %90(ptr %11, ptr %88, ptr %12, i32 0, ptr %13)
  %91 = load { i1, [47 x i8] }, ptr %11, align 1
  %92 = extractvalue { i1, [47 x i8] } %91, 0
  %93 = getelementptr inbounds i8, ptr %11, i32 16
  %94 = load i252, ptr %93, align 16
  %95 = getelementptr inbounds i8, ptr %11, i32 8
  %96 = load { ptr, i32, i32, i32 }, ptr %95, align 8
  %97 = load i64, ptr %12, align 8
  br i1 %92, label %204, label %98

98:                                               ; preds = %77
  %99 = phi i252 [ %94, %77 ]
  %100 = icmp eq i252 %99, 0
  br i1 %100, label %101, label %106

101:                                              ; preds = %98
  %102 = phi i64 [ %97, %98 ]
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 0)
  br label %113

106:                                              ; preds = %98
  %107 = phi i64 [ %97, %98 ]
  %108 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %109 = call ptr %108()
  %110 = load i64, ptr %109, align 8
  %111 = mul i64 %110, 100
  %112 = call i64 @llvm.uadd.sat.i64(i64 %107, i64 %111)
  br label %113

113:                                              ; preds = %101, %106
  %114 = phi i64 [ %79, %106 ], [ %79, %101 ]
  %115 = phi i64 [ %84, %106 ], [ %84, %101 ]
  %116 = phi ptr [ %3, %106 ], [ %3, %101 ]
  %117 = phi i64 [ %112, %106 ], [ %105, %101 ]
  %118 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %106 ], [ { i1 true, [0 x i8] undef }, %101 ]
  %119 = extractvalue { i1, [0 x i8] } %118, 0
  %120 = xor i1 %119, true
  switch i1 %120, label %121 [
    i1 false, label %123
    i1 true, label %128
  ]

121:                                              ; preds = %113
  br i1 false, label %122, label %270

122:                                              ; preds = %121
  unreachable

123:                                              ; preds = %113
  %124 = phi i64 [ %117, %113 ]
  %125 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %126 = call ptr %125()
  %127 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 0)
  br label %135

128:                                              ; preds = %113
  %129 = phi i64 [ %117, %113 ]
  %130 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %131 = call ptr %130()
  %132 = load i64, ptr %131, align 8
  %133 = mul i64 %132, 100
  %134 = call i64 @llvm.uadd.sat.i64(i64 %129, i64 %133)
  br label %135

135:                                              ; preds = %123, %128
  %136 = phi i64 [ %114, %128 ], [ %114, %123 ]
  %137 = phi i64 [ %115, %128 ], [ %115, %123 ]
  %138 = phi ptr [ %116, %128 ], [ %116, %123 ]
  %139 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %128 ], [ zeroinitializer, %123 ]
  %140 = phi i64 [ %134, %128 ], [ %127, %123 ]
  %141 = phi i252 [ 1, %128 ], [ 0, %123 ]
  %142 = extractvalue { ptr, i32, i32, i32 } %139, 3
  %143 = icmp eq i32 %142, 0
  br i1 %143, label %144, label %158

144:                                              ; preds = %135
  %145 = shl i32 %142, 1
  %146 = call i32 @llvm.umin.i32(i32 %145, i32 1024)
  %147 = add i32 %146, %142
  %148 = call i32 @llvm.umax.i32(i32 %147, i32 8)
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 32
  %151 = add i64 %150, 16
  %152 = call ptr @realloc(ptr null, i64 %151)
  store i32 1, ptr %152, align 4
  %153 = getelementptr inbounds i8, ptr %152, i32 4
  store i32 0, ptr %153, align 4
  %154 = getelementptr inbounds i8, ptr %152, i32 16
  %155 = call ptr @realloc(ptr null, i64 8)
  store ptr %154, ptr %155, align 8
  %156 = insertvalue { ptr, i32, i32, i32 } %139, ptr %155, 0
  %157 = insertvalue { ptr, i32, i32, i32 } %156, i32 %148, 3
  br label %179

158:                                              ; preds = %135
  %159 = extractvalue { ptr, i32, i32, i32 } %139, 2
  %160 = icmp ult i32 %159, %142
  br i1 %160, label %161, label %162

161:                                              ; preds = %158
  br label %176

162:                                              ; preds = %158
  %163 = shl i32 %142, 1
  %164 = call i32 @llvm.umin.i32(i32 %163, i32 1024)
  %165 = add i32 %164, %142
  %166 = call i32 @llvm.umax.i32(i32 %165, i32 8)
  %167 = zext i32 %166 to i64
  %168 = mul i64 %167, 32
  %169 = add i64 %168, 16
  %170 = extractvalue { ptr, i32, i32, i32 } %139, 0
  %171 = load ptr, ptr %170, align 8
  %172 = getelementptr inbounds i8, ptr %171, i32 -16
  %173 = call ptr @realloc(ptr %172, i64 %169)
  %174 = getelementptr inbounds i8, ptr %173, i32 16
  store ptr %174, ptr %170, align 8
  %175 = insertvalue { ptr, i32, i32, i32 } %139, i32 %166, 3
  br label %176

176:                                              ; preds = %161, %162
  %177 = phi { ptr, i32, i32, i32 } [ %175, %162 ], [ %139, %161 ]
  br label %178

178:                                              ; preds = %176
  br label %179

179:                                              ; preds = %144, %178
  %180 = phi { ptr, i32, i32, i32 } [ %177, %178 ], [ %157, %144 ]
  br label %181

181:                                              ; preds = %179
  %182 = extractvalue { ptr, i32, i32, i32 } %180, 0
  %183 = load ptr, ptr %182, align 8
  %184 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %185 = zext i32 %184 to i64
  %186 = mul i64 %185, 32
  %187 = getelementptr inbounds i8, ptr %183, i64 %186
  store i252 %141, ptr %187, align 16
  %188 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %189 = add i32 %188, 1
  %190 = insertvalue { ptr, i32, i32, i32 } %180, i32 %189, 2
  %191 = getelementptr inbounds i8, ptr %183, i32 -12
  store i32 %189, ptr %191, align 4
  %192 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %190)
  %193 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %192, 0
  %194 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %192, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %193)
  %195 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %194, 0
  %196 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %195, 0
  %197 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %196, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %197, ptr %15, align 8
  %198 = load { i64, [24 x i8] }, ptr %15, align 8
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %136, 0
  %200 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %199, i64 %137, 1
  %201 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %200, i64 %140, 2
  %202 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, ptr %138, 3
  %203 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %202, { i64, [24 x i8] } %198, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %203

204:                                              ; preds = %77
  %205 = phi { ptr, i32, i32, i32 } [ %96, %77 ]
  %206 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %205, 1
  %207 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %206, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %207, ptr %14, align 8
  %208 = load { i64, [24 x i8] }, ptr %14, align 8
  %209 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %79, 0
  %210 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %209, i64 %84, 1
  %211 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %210, i64 %97, 2
  %212 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %211, ptr %3, 3
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %212, { i64, [24 x i8] } %208, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %213

214:                                              ; preds = %65
  %215 = phi i64 [ %21, %65 ]
  %216 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %217 = call ptr %216()
  %218 = load i64, ptr %217, align 8
  %219 = mul i64 %218, 4850
  %220 = call i64 @llvm.uadd.sat.i64(i64 %215, i64 %219)
  br label %256

221:                                              ; preds = %29
  %222 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %222)
  %223 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %224 = call ptr %223()
  %225 = load i64, ptr %224, align 8
  %226 = mul i64 %225, 6320
  %227 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %226)
  br label %235

228:                                              ; preds = %22
  %229 = phi { ptr, i32, i32, i32 } [ %24, %22 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %229)
  %230 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %231 = call ptr %230()
  %232 = load i64, ptr %231, align 8
  %233 = mul i64 %232, 7530
  %234 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %233)
  br label %235

235:                                              ; preds = %221, %228
  %236 = phi i64 [ %0, %228 ], [ %0, %221 ]
  %237 = phi ptr [ %3, %228 ], [ %3, %221 ]
  %238 = phi i64 [ %17, %228 ], [ %39, %221 ]
  %239 = phi i64 [ %234, %228 ], [ %227, %221 ]
  %240 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %241 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %240, 0
  %242 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %241, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %242, ptr %7, align 8
  %243 = load { i64, [24 x i8] }, ptr %7, align 8
  %244 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %236, 0
  %245 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %244, i64 %238, 1
  %246 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %245, i64 %239, 2
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %246, ptr %237, 3
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, { i64, [24 x i8] } %243, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %248

249:                                              ; preds = %5
  %250 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %250)
  %251 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %252 = call ptr %251()
  %253 = load i64, ptr %252, align 8
  %254 = mul i64 %253, 7730
  %255 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %254)
  br label %256

256:                                              ; preds = %214, %249
  %257 = phi i64 [ %0, %249 ], [ %0, %214 ]
  %258 = phi ptr [ %3, %249 ], [ %3, %214 ]
  %259 = phi i64 [ %17, %249 ], [ %69, %214 ]
  %260 = phi i64 [ %255, %249 ], [ %220, %214 ]
  %261 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %262 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %261, 0
  %263 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %262, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %263, ptr %6, align 8
  %264 = load { i64, [24 x i8] }, ptr %6, align 8
  %265 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %257, 0
  %266 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %265, i64 %259, 1
  %267 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %266, i64 %260, 2
  %268 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %267, ptr %258, 3
  %269 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %268, { i64, [24 x i8] } %264, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %269

270:                                              ; preds = %121
  call void @puts(ptr @assert_msg_20)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f6(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f6"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f6(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f6(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$485"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$485"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { {}, {} } }, ptr %2, align 1
  %6 = extractvalue { i1, { {}, {} } } %5, 1
  %7 = insertvalue { i1, { {}, {} } } %5, { {}, {} } %6, 1
  store { i1, { {}, {} } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { {}, {} } } %5, { {}, {} } %6, 1
  store { i1, { {}, {} } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f7"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i1, [31 x i8] }, i64 1, align 8
  %10 = alloca i64, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = add i64 %1, 1
  %19 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %20 = call ptr %19()
  %21 = icmp uge i64 %2, 0
  %22 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %21, label %23, label %250

23:                                               ; preds = %5
  %24 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %25 = extractvalue { { ptr, i32, i32, i32 } } %24, 0
  %26 = extractvalue { ptr, i32, i32, i32 } %25, 1
  %27 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %28 = sub i32 %27, %26
  %29 = icmp uge i32 %28, 1
  br i1 %29, label %30, label %229

30:                                               ; preds = %23
  %31 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %32 = load ptr, ptr %31, align 8
  %33 = zext i32 %26 to i64
  %34 = mul i64 %33, 32
  %35 = getelementptr inbounds i8, ptr %32, i64 %34
  %36 = add i32 %26, 1
  %37 = insertvalue { ptr, i32, i32, i32 } %25, i32 %36, 1
  %38 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %38, ptr %35, i64 32, i1 false)
  %39 = load i252, ptr %38, align 16
  call void @free(ptr %38)
  %40 = add i64 %1, 4
  %41 = icmp ult i252 %39, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %41, label %42, label %222

42:                                               ; preds = %30
  %43 = phi { ptr, i32, i32, i32 } [ %37, %30 ]
  %44 = extractvalue { ptr, i32, i32, i32 } %43, 1
  %45 = extractvalue { ptr, i32, i32, i32 } %43, 2
  %46 = sub i32 %45, %44
  %47 = icmp uge i32 %46, 1
  br i1 %47, label %48, label %211

48:                                               ; preds = %42
  %49 = extractvalue { ptr, i32, i32, i32 } %43, 0
  %50 = load ptr, ptr %49, align 8
  %51 = zext i32 %44 to i64
  %52 = mul i64 %51, 32
  %53 = getelementptr inbounds i8, ptr %50, i64 %52
  %54 = add i32 %44, 1
  %55 = insertvalue { ptr, i32, i32, i32 } %43, i32 %54, 1
  %56 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %56, ptr %53, i64 32, i1 false)
  %57 = load i252, ptr %56, align 16
  call void @free(ptr %56)
  %58 = icmp eq i252 %57, 0
  br i1 %58, label %59, label %66

59:                                               ; preds = %48
  %60 = phi i64 [ %22, %48 ]
  %61 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %62 = call ptr %61()
  %63 = load i64, ptr %62, align 8
  %64 = mul i64 %63, 3650
  %65 = call i64 @llvm.uadd.sat.i64(i64 %60, i64 %64)
  br label %73

66:                                               ; preds = %48
  %67 = phi i64 [ %22, %48 ]
  %68 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %69 = call ptr %68()
  %70 = load i64, ptr %69, align 8
  %71 = mul i64 %70, 3750
  %72 = call i64 @llvm.uadd.sat.i64(i64 %67, i64 %71)
  br label %73

73:                                               ; preds = %59, %66
  %74 = phi i64 [ %0, %66 ], [ %0, %59 ]
  %75 = phi ptr [ %3, %66 ], [ %3, %59 ]
  %76 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %66 ], [ { i1 true, [0 x i8] undef }, %59 ]
  %77 = phi i64 [ %40, %66 ], [ %40, %59 ]
  %78 = phi i252 [ %39, %66 ], [ %39, %59 ]
  %79 = phi { ptr, i32, i32, i32 } [ %55, %66 ], [ %55, %59 ]
  %80 = phi i64 [ %72, %66 ], [ %65, %59 ]
  %81 = extractvalue { ptr, i32, i32, i32 } %79, 1
  %82 = extractvalue { ptr, i32, i32, i32 } %79, 2
  %83 = sub i32 %82, %81
  %84 = icmp uge i32 %83, 1
  br i1 %84, label %85, label %103

85:                                               ; preds = %73
  %86 = extractvalue { ptr, i32, i32, i32 } %79, 0
  %87 = load ptr, ptr %86, align 8
  %88 = zext i32 %81 to i64
  %89 = mul i64 %88, 32
  %90 = getelementptr inbounds i8, ptr %87, i64 %89
  %91 = add i32 %81, 1
  %92 = insertvalue { ptr, i32, i32, i32 } %79, i32 %91, 1
  %93 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %93, ptr %90, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %92)
  call void @"drop$555"(ptr %93)
  %94 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %95 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %94, 0
  %96 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %95, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %96, ptr %17, align 8
  %97 = load { i64, [24 x i8] }, ptr %17, align 8
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %74, 0
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, i64 %77, 1
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %80, 2
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, ptr %75, 3
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, { i64, [24 x i8] } %97, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %102

103:                                              ; preds = %73
  %104 = phi { ptr, i32, i32, i32 } [ %79, %73 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %104)
  %105 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %106 = call ptr %105()
  %107 = add i64 %77, 1
  %108 = getelementptr inbounds i64, ptr %106, i32 1
  %109 = load i64, ptr %108, align 8
  %110 = mul i64 %109, 2
  %111 = load i64, ptr %106, align 8
  %112 = mul i64 %111, 86170
  %113 = add i64 %110, %112
  %114 = icmp uge i64 %80, %113
  %115 = call i64 @llvm.usub.sat.i64(i64 %80, i64 %113)
  br i1 %114, label %116, label %206

116:                                              ; preds = %103
  %117 = phi {} [ undef, %103 ]
  %118 = load ptr, ptr %75, align 8
  store i64 %115, ptr %10, align 8
  %119 = getelementptr inbounds ptr, ptr %75, i32 3
  %120 = load ptr, ptr %119, align 8
  call void %120(ptr %9, ptr %118, ptr %10)
  %121 = load { i1, [31 x i8] }, ptr %9, align 1
  %122 = extractvalue { i1, [31 x i8] } %121, 0
  %123 = getelementptr inbounds i8, ptr %9, i32 8
  %124 = load ptr, ptr %123, align 8
  %125 = getelementptr inbounds i8, ptr %9, i32 8
  %126 = load { ptr, i32, i32, i32 }, ptr %125, align 8
  %127 = load i64, ptr %10, align 8
  br i1 %122, label %196, label %128

128:                                              ; preds = %116
  %129 = phi ptr [ %124, %116 ]
  %130 = load { ptr, ptr, i252, i252, i252 }, ptr %129, align 16
  call void @free(ptr %129)
  %131 = extractvalue { ptr, ptr, i252, i252, i252 } %130, 0
  %132 = extractvalue { ptr, ptr, i252, i252, i252 } %130, 1
  %133 = extractvalue { ptr, ptr, i252, i252, i252 } %130, 2
  call void @"drop$520"(ptr %131)
  call void @"drop$519"(ptr %132)
  %134 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %107, i64 %127, i64 %74, ptr %75, {} %117, i252 %133)
  %135 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, 0
  %136 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, 1
  %137 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, 2
  %138 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, 3
  %139 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, 4
  store { i64, [24 x i8] } %139, ptr %12, align 8
  %140 = load i1, ptr %12, align 1
  switch i1 %140, label %141 [
    i1 false, label %143
    i1 true, label %154
  ]

141:                                              ; preds = %128
  br i1 false, label %142, label %271

142:                                              ; preds = %141
  unreachable

143:                                              ; preds = %128
  %144 = extractvalue { i1, [0 x i8] } %76, 0
  %145 = xor i1 %144, true
  %146 = insertvalue { i1, [0 x i8] } undef, i1 %145, 0
  %147 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f35"(i64 %135, i64 %136, i64 %137, ptr %138, {} %117, i252 %78, { i1, [0 x i8] } %146)
  %148 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, 0
  %149 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, 1
  %150 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, 2
  %151 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, 3
  %152 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %147, 4
  store { i64, [24 x i8] } %152, ptr %14, align 8
  %153 = load i1, ptr %14, align 1
  switch i1 %153, label %166 [
    i1 false, label %168
    i1 true, label %184
  ]

154:                                              ; preds = %128
  %155 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %156 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %155, 1
  %157 = extractvalue { {}, { ptr, i32, i32, i32 } } %156, 1
  %158 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %157, 1
  %159 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %158, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %159, ptr %13, align 8
  %160 = load { i64, [24 x i8] }, ptr %13, align 8
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %137, 0
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, i64 %135, 1
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, i64 %136, 2
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %163, ptr %138, 3
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %164, { i64, [24 x i8] } %160, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %165

166:                                              ; preds = %143
  br i1 false, label %167, label %272

167:                                              ; preds = %166
  unreachable

168:                                              ; preds = %143
  %169 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %170 = call ptr %169()
  %171 = call i64 @llvm.uadd.sat.i64(i64 %149, i64 0)
  %172 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %173 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %172, 0
  %174 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %172, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %173)
  %175 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %174, 0
  %176 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %175, 0
  %177 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %176, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %177, ptr %16, align 8
  %178 = load { i64, [24 x i8] }, ptr %16, align 8
  %179 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %150, 0
  %180 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %179, i64 %148, 1
  %181 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %180, i64 %171, 2
  %182 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %181, ptr %151, 3
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, { i64, [24 x i8] } %178, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %183

184:                                              ; preds = %143
  %185 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %186 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %185, 1
  %187 = extractvalue { {}, { ptr, i32, i32, i32 } } %186, 1
  %188 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %187, 1
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %15, align 8
  %190 = load { i64, [24 x i8] }, ptr %15, align 8
  %191 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %150, 0
  %192 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %191, i64 %148, 1
  %193 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %192, i64 %149, 2
  %194 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %193, ptr %151, 3
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %194, { i64, [24 x i8] } %190, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %195

196:                                              ; preds = %116
  %197 = phi { ptr, i32, i32, i32 } [ %126, %116 ]
  %198 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %197, 1
  %199 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %198, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %199, ptr %11, align 8
  %200 = load { i64, [24 x i8] }, ptr %11, align 8
  %201 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %74, 0
  %202 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %201, i64 %107, 1
  %203 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %202, i64 %127, 2
  %204 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %203, ptr %75, 3
  %205 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %204, { i64, [24 x i8] } %200, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %205

206:                                              ; preds = %103
  %207 = phi i64 [ %80, %103 ]
  %208 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %209 = call ptr %208()
  %210 = call i64 @llvm.uadd.sat.i64(i64 %207, i64 0)
  br label %257

211:                                              ; preds = %42
  %212 = phi { ptr, i32, i32, i32 } [ %43, %42 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %212)
  %213 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %214 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %213, 0
  %215 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %214, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %215, ptr %8, align 8
  %216 = load { i64, [24 x i8] }, ptr %8, align 8
  %217 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %218 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %217, i64 %40, 1
  %219 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %218, i64 %22, 2
  %220 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %219, ptr %3, 3
  %221 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %220, { i64, [24 x i8] } %216, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %221

222:                                              ; preds = %30
  %223 = phi { ptr, i32, i32, i32 } [ %37, %30 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %223)
  %224 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %225 = call ptr %224()
  %226 = load i64, ptr %225, align 8
  %227 = mul i64 %226, 6210
  %228 = call i64 @llvm.uadd.sat.i64(i64 %22, i64 %227)
  br label %236

229:                                              ; preds = %23
  %230 = phi { ptr, i32, i32, i32 } [ %25, %23 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %230)
  %231 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %232 = call ptr %231()
  %233 = load i64, ptr %232, align 8
  %234 = mul i64 %233, 7410
  %235 = call i64 @llvm.uadd.sat.i64(i64 %22, i64 %234)
  br label %236

236:                                              ; preds = %222, %229
  %237 = phi i64 [ %0, %229 ], [ %0, %222 ]
  %238 = phi ptr [ %3, %229 ], [ %3, %222 ]
  %239 = phi i64 [ %18, %229 ], [ %40, %222 ]
  %240 = phi i64 [ %235, %229 ], [ %228, %222 ]
  %241 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %242 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %241, 0
  %243 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %242, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %243, ptr %7, align 8
  %244 = load { i64, [24 x i8] }, ptr %7, align 8
  %245 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %237, 0
  %246 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %245, i64 %239, 1
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %246, i64 %240, 2
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, ptr %238, 3
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, { i64, [24 x i8] } %244, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %249

250:                                              ; preds = %5
  %251 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %251)
  %252 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %253 = call ptr %252()
  %254 = load i64, ptr %253, align 8
  %255 = mul i64 %254, 7610
  %256 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %255)
  br label %257

257:                                              ; preds = %206, %250
  %258 = phi i64 [ %0, %250 ], [ %74, %206 ]
  %259 = phi ptr [ %3, %250 ], [ %75, %206 ]
  %260 = phi i64 [ %18, %250 ], [ %107, %206 ]
  %261 = phi i64 [ %256, %250 ], [ %210, %206 ]
  %262 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %263 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %262, 0
  %264 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %263, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %264, ptr %6, align 8
  %265 = load { i64, [24 x i8] }, ptr %6, align 8
  %266 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %258, 0
  %267 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %266, i64 %260, 1
  %268 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %267, i64 %261, 2
  %269 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %268, ptr %259, 3
  %270 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %269, { i64, [24 x i8] } %265, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %270

271:                                              ; preds = %141
  call void @puts(ptr @assert_msg_21)
  call void @abort()
  unreachable

272:                                              ; preds = %166
  call void @puts(ptr @assert_msg_22)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f7(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f7"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f7(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f7(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f8"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i1, [31 x i8] }, i64 1, align 8
  %9 = alloca i64, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = icmp uge i64 %2, 0
  %21 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %20, label %22, label %200

22:                                               ; preds = %5
  %23 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %24 = extractvalue { { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  %28 = icmp uge i32 %27, 1
  br i1 %28, label %29, label %179

29:                                               ; preds = %22
  %30 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %31 = load ptr, ptr %30, align 8
  %32 = zext i32 %25 to i64
  %33 = mul i64 %32, 32
  %34 = getelementptr inbounds i8, ptr %31, i64 %33
  %35 = add i32 %25, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %24, i32 %35, 1
  %37 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %37, ptr %34, i64 32, i1 false)
  %38 = load i252, ptr %37, align 16
  call void @free(ptr %37)
  %39 = add i64 %1, 4
  %40 = icmp ult i252 %38, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %40, label %41, label %172

41:                                               ; preds = %29
  %42 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %65

47:                                               ; preds = %41
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %54)
  call void @"drop$555"(ptr %55)
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %57, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %58, ptr %16, align 8
  %59 = load { i64, [24 x i8] }, ptr %16, align 8
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, i64 %39, 1
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %21, 2
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, ptr %3, 3
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, { i64, [24 x i8] } %59, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %64

65:                                               ; preds = %41
  %66 = phi { ptr, i32, i32, i32 } [ %42, %41 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %66)
  %67 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %68 = call ptr %67()
  %69 = add i64 %1, 5
  %70 = getelementptr inbounds i64, ptr %68, i32 1
  %71 = load i64, ptr %70, align 8
  %72 = mul i64 %71, 2
  %73 = load i64, ptr %68, align 8
  %74 = mul i64 %73, 81030
  %75 = add i64 %72, %74
  %76 = icmp uge i64 %21, %75
  %77 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %75)
  br i1 %76, label %78, label %165

78:                                               ; preds = %65
  %79 = phi {} [ undef, %65 ]
  %80 = load ptr, ptr %3, align 8
  store i64 %77, ptr %9, align 8
  %81 = getelementptr inbounds ptr, ptr %3, i32 3
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %8, ptr %80, ptr %9)
  %83 = load { i1, [31 x i8] }, ptr %8, align 1
  %84 = extractvalue { i1, [31 x i8] } %83, 0
  %85 = getelementptr inbounds i8, ptr %8, i32 8
  %86 = load ptr, ptr %85, align 8
  %87 = getelementptr inbounds i8, ptr %8, i32 8
  %88 = load { ptr, i32, i32, i32 }, ptr %87, align 8
  %89 = load i64, ptr %9, align 8
  br i1 %84, label %155, label %90

90:                                               ; preds = %78
  %91 = phi ptr [ %86, %78 ]
  %92 = load { ptr, ptr, i252, i252, i252 }, ptr %91, align 16
  call void @free(ptr %91)
  %93 = extractvalue { ptr, ptr, i252, i252, i252 } %92, 0
  %94 = extractvalue { ptr, ptr, i252, i252, i252 } %92, 1
  %95 = extractvalue { ptr, ptr, i252, i252, i252 } %92, 2
  call void @"drop$520"(ptr %93)
  call void @"drop$519"(ptr %94)
  %96 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %69, i64 %89, i64 %0, ptr %3, {} %79, i252 %95)
  %97 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 0
  %98 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 1
  %99 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 2
  %100 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 3
  %101 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 4
  store { i64, [24 x i8] } %101, ptr %11, align 8
  %102 = load i1, ptr %11, align 1
  switch i1 %102, label %103 [
    i1 false, label %105
    i1 true, label %113
  ]

103:                                              ; preds = %90
  br i1 false, label %104, label %221

104:                                              ; preds = %103
  unreachable

105:                                              ; preds = %90
  %106 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f36"(i64 %97, i64 %98, i64 %99, ptr %100, {} %79, i252 %38)
  %107 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 0
  %108 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 1
  %109 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 2
  %110 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 3
  %111 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 4
  store { i64, [24 x i8] } %111, ptr %13, align 8
  %112 = load i1, ptr %13, align 1
  switch i1 %112, label %125 [
    i1 false, label %127
    i1 true, label %143
  ]

113:                                              ; preds = %90
  %114 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %115 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %114, 1
  %116 = extractvalue { {}, { ptr, i32, i32, i32 } } %115, 1
  %117 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %116, 1
  %118 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %117, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %118, ptr %12, align 8
  %119 = load { i64, [24 x i8] }, ptr %12, align 8
  %120 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %99, 0
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %120, i64 %97, 1
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, i64 %98, 2
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, ptr %100, 3
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, { i64, [24 x i8] } %119, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %124

125:                                              ; preds = %105
  br i1 false, label %126, label %222

126:                                              ; preds = %125
  unreachable

127:                                              ; preds = %105
  %128 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %129 = call ptr %128()
  %130 = call i64 @llvm.uadd.sat.i64(i64 %108, i64 0)
  %131 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %132 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %131, 0
  %133 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %131, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %132)
  %134 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %133, 0
  %135 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %134, 0
  %136 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %135, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %136, ptr %15, align 8
  %137 = load { i64, [24 x i8] }, ptr %15, align 8
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, i64 %107, 1
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, i64 %130, 2
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %140, ptr %110, 3
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, { i64, [24 x i8] } %137, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %142

143:                                              ; preds = %105
  %144 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %145 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %144, 1
  %146 = extractvalue { {}, { ptr, i32, i32, i32 } } %145, 1
  %147 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %146, 1
  %148 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %147, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %148, ptr %14, align 8
  %149 = load { i64, [24 x i8] }, ptr %14, align 8
  %150 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %151 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, i64 %107, 1
  %152 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %151, i64 %108, 2
  %153 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %152, ptr %110, 3
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %153, { i64, [24 x i8] } %149, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %154

155:                                              ; preds = %78
  %156 = phi { ptr, i32, i32, i32 } [ %88, %78 ]
  %157 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %156, 1
  %158 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %157, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %158, ptr %10, align 8
  %159 = load { i64, [24 x i8] }, ptr %10, align 8
  %160 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %160, i64 %69, 1
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, i64 %89, 2
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, ptr %3, 3
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %163, { i64, [24 x i8] } %159, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %164

165:                                              ; preds = %65
  %166 = phi i64 [ %21, %65 ]
  %167 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %168 = call ptr %167()
  %169 = load i64, ptr %168, align 8
  %170 = mul i64 %169, 4650
  %171 = call i64 @llvm.uadd.sat.i64(i64 %166, i64 %170)
  br label %207

172:                                              ; preds = %29
  %173 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %173)
  %174 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %175 = call ptr %174()
  %176 = load i64, ptr %175, align 8
  %177 = mul i64 %176, 6220
  %178 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %177)
  br label %186

179:                                              ; preds = %22
  %180 = phi { ptr, i32, i32, i32 } [ %24, %22 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %180)
  %181 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %182 = call ptr %181()
  %183 = load i64, ptr %182, align 8
  %184 = mul i64 %183, 7420
  %185 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %184)
  br label %186

186:                                              ; preds = %172, %179
  %187 = phi i64 [ %0, %179 ], [ %0, %172 ]
  %188 = phi ptr [ %3, %179 ], [ %3, %172 ]
  %189 = phi i64 [ %17, %179 ], [ %39, %172 ]
  %190 = phi i64 [ %185, %179 ], [ %178, %172 ]
  %191 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %192 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %191, 0
  %193 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %192, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %193, ptr %7, align 8
  %194 = load { i64, [24 x i8] }, ptr %7, align 8
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %187, 0
  %196 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, i64 %189, 1
  %197 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %196, i64 %190, 2
  %198 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %197, ptr %188, 3
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %198, { i64, [24 x i8] } %194, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %199

200:                                              ; preds = %5
  %201 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %201)
  %202 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %203 = call ptr %202()
  %204 = load i64, ptr %203, align 8
  %205 = mul i64 %204, 7620
  %206 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %205)
  br label %207

207:                                              ; preds = %165, %200
  %208 = phi i64 [ %0, %200 ], [ %0, %165 ]
  %209 = phi ptr [ %3, %200 ], [ %3, %165 ]
  %210 = phi i64 [ %17, %200 ], [ %69, %165 ]
  %211 = phi i64 [ %206, %200 ], [ %171, %165 ]
  %212 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %213 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %212, 0
  %214 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %213, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %214, ptr %6, align 8
  %215 = load { i64, [24 x i8] }, ptr %6, align 8
  %216 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %208, 0
  %217 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %216, i64 %210, 1
  %218 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %217, i64 %211, 2
  %219 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %218, ptr %209, 3
  %220 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %219, { i64, [24 x i8] } %215, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %220

221:                                              ; preds = %103
  call void @puts(ptr @assert_msg_23)
  call void @abort()
  unreachable

222:                                              ; preds = %125
  call void @puts(ptr @assert_msg_24)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f8(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f8"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f8(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f8(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f9"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i1, [31 x i8] }, i64 1, align 8
  %9 = alloca i64, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = icmp uge i64 %2, 0
  %21 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %20, label %22, label %200

22:                                               ; preds = %5
  %23 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %24 = extractvalue { { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 1
  %26 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %27 = sub i32 %26, %25
  %28 = icmp uge i32 %27, 1
  br i1 %28, label %29, label %179

29:                                               ; preds = %22
  %30 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %31 = load ptr, ptr %30, align 8
  %32 = zext i32 %25 to i64
  %33 = mul i64 %32, 32
  %34 = getelementptr inbounds i8, ptr %31, i64 %33
  %35 = add i32 %25, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %24, i32 %35, 1
  %37 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %37, ptr %34, i64 32, i1 false)
  %38 = load i252, ptr %37, align 16
  call void @free(ptr %37)
  %39 = add i64 %1, 4
  %40 = icmp ult i252 %38, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %40, label %41, label %172

41:                                               ; preds = %29
  %42 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %65

47:                                               ; preds = %41
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %54)
  call void @"drop$555"(ptr %55)
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %57, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %58, ptr %16, align 8
  %59 = load { i64, [24 x i8] }, ptr %16, align 8
  %60 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %60, i64 %39, 1
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %21, 2
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, ptr %3, 3
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, { i64, [24 x i8] } %59, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %64

65:                                               ; preds = %41
  %66 = phi { ptr, i32, i32, i32 } [ %42, %41 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %66)
  %67 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %68 = call ptr %67()
  %69 = add i64 %1, 5
  %70 = getelementptr inbounds i64, ptr %68, i32 1
  %71 = load i64, ptr %70, align 8
  %72 = mul i64 %71, 2
  %73 = load i64, ptr %68, align 8
  %74 = mul i64 %73, 81030
  %75 = add i64 %72, %74
  %76 = icmp uge i64 %21, %75
  %77 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %75)
  br i1 %76, label %78, label %165

78:                                               ; preds = %65
  %79 = phi {} [ undef, %65 ]
  %80 = load ptr, ptr %3, align 8
  store i64 %77, ptr %9, align 8
  %81 = getelementptr inbounds ptr, ptr %3, i32 3
  %82 = load ptr, ptr %81, align 8
  call void %82(ptr %8, ptr %80, ptr %9)
  %83 = load { i1, [31 x i8] }, ptr %8, align 1
  %84 = extractvalue { i1, [31 x i8] } %83, 0
  %85 = getelementptr inbounds i8, ptr %8, i32 8
  %86 = load ptr, ptr %85, align 8
  %87 = getelementptr inbounds i8, ptr %8, i32 8
  %88 = load { ptr, i32, i32, i32 }, ptr %87, align 8
  %89 = load i64, ptr %9, align 8
  br i1 %84, label %155, label %90

90:                                               ; preds = %78
  %91 = phi ptr [ %86, %78 ]
  %92 = load { ptr, ptr, i252, i252, i252 }, ptr %91, align 16
  call void @free(ptr %91)
  %93 = extractvalue { ptr, ptr, i252, i252, i252 } %92, 0
  %94 = extractvalue { ptr, ptr, i252, i252, i252 } %92, 1
  %95 = extractvalue { ptr, ptr, i252, i252, i252 } %92, 2
  call void @"drop$520"(ptr %93)
  call void @"drop$519"(ptr %94)
  %96 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %69, i64 %89, i64 %0, ptr %3, {} %79, i252 %95)
  %97 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 0
  %98 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 1
  %99 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 2
  %100 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 3
  %101 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, 4
  store { i64, [24 x i8] } %101, ptr %11, align 8
  %102 = load i1, ptr %11, align 1
  switch i1 %102, label %103 [
    i1 false, label %105
    i1 true, label %113
  ]

103:                                              ; preds = %90
  br i1 false, label %104, label %221

104:                                              ; preds = %103
  unreachable

105:                                              ; preds = %90
  %106 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f37"(i64 %97, i64 %98, i64 %99, ptr %100, {} %79, i252 %38)
  %107 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 0
  %108 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 1
  %109 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 2
  %110 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 3
  %111 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %106, 4
  store { i64, [24 x i8] } %111, ptr %13, align 8
  %112 = load i1, ptr %13, align 1
  switch i1 %112, label %125 [
    i1 false, label %127
    i1 true, label %143
  ]

113:                                              ; preds = %90
  %114 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %115 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %114, 1
  %116 = extractvalue { {}, { ptr, i32, i32, i32 } } %115, 1
  %117 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %116, 1
  %118 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %117, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %118, ptr %12, align 8
  %119 = load { i64, [24 x i8] }, ptr %12, align 8
  %120 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %99, 0
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %120, i64 %97, 1
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, i64 %98, 2
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, ptr %100, 3
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, { i64, [24 x i8] } %119, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %124

125:                                              ; preds = %105
  br i1 false, label %126, label %222

126:                                              ; preds = %125
  unreachable

127:                                              ; preds = %105
  %128 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %129 = call ptr %128()
  %130 = call i64 @llvm.uadd.sat.i64(i64 %108, i64 0)
  %131 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %132 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %131, 0
  %133 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %131, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %132)
  %134 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %133, 0
  %135 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %134, 0
  %136 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %135, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %136, ptr %15, align 8
  %137 = load { i64, [24 x i8] }, ptr %15, align 8
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, i64 %107, 1
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, i64 %130, 2
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %140, ptr %110, 3
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, { i64, [24 x i8] } %137, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %142

143:                                              ; preds = %105
  %144 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %145 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %144, 1
  %146 = extractvalue { {}, { ptr, i32, i32, i32 } } %145, 1
  %147 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %146, 1
  %148 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %147, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %148, ptr %14, align 8
  %149 = load { i64, [24 x i8] }, ptr %14, align 8
  %150 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %109, 0
  %151 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, i64 %107, 1
  %152 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %151, i64 %108, 2
  %153 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %152, ptr %110, 3
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %153, { i64, [24 x i8] } %149, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %154

155:                                              ; preds = %78
  %156 = phi { ptr, i32, i32, i32 } [ %88, %78 ]
  %157 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %156, 1
  %158 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %157, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %158, ptr %10, align 8
  %159 = load { i64, [24 x i8] }, ptr %10, align 8
  %160 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %160, i64 %69, 1
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, i64 %89, 2
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, ptr %3, 3
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %163, { i64, [24 x i8] } %159, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %164

165:                                              ; preds = %65
  %166 = phi i64 [ %21, %65 ]
  %167 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %168 = call ptr %167()
  %169 = load i64, ptr %168, align 8
  %170 = mul i64 %169, 4650
  %171 = call i64 @llvm.uadd.sat.i64(i64 %166, i64 %170)
  br label %207

172:                                              ; preds = %29
  %173 = phi { ptr, i32, i32, i32 } [ %36, %29 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %173)
  %174 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %175 = call ptr %174()
  %176 = load i64, ptr %175, align 8
  %177 = mul i64 %176, 6220
  %178 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %177)
  br label %186

179:                                              ; preds = %22
  %180 = phi { ptr, i32, i32, i32 } [ %24, %22 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %180)
  %181 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %182 = call ptr %181()
  %183 = load i64, ptr %182, align 8
  %184 = mul i64 %183, 7420
  %185 = call i64 @llvm.uadd.sat.i64(i64 %21, i64 %184)
  br label %186

186:                                              ; preds = %172, %179
  %187 = phi i64 [ %0, %179 ], [ %0, %172 ]
  %188 = phi ptr [ %3, %179 ], [ %3, %172 ]
  %189 = phi i64 [ %17, %179 ], [ %39, %172 ]
  %190 = phi i64 [ %185, %179 ], [ %178, %172 ]
  %191 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %192 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %191, 0
  %193 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %192, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %193, ptr %7, align 8
  %194 = load { i64, [24 x i8] }, ptr %7, align 8
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %187, 0
  %196 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %195, i64 %189, 1
  %197 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %196, i64 %190, 2
  %198 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %197, ptr %188, 3
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %198, { i64, [24 x i8] } %194, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %199

200:                                              ; preds = %5
  %201 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %201)
  %202 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %203 = call ptr %202()
  %204 = load i64, ptr %203, align 8
  %205 = mul i64 %204, 7620
  %206 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %205)
  br label %207

207:                                              ; preds = %165, %200
  %208 = phi i64 [ %0, %200 ], [ %0, %165 ]
  %209 = phi ptr [ %3, %200 ], [ %3, %165 ]
  %210 = phi i64 [ %17, %200 ], [ %69, %165 ]
  %211 = phi i64 [ %206, %200 ], [ %171, %165 ]
  %212 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %213 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %212, 0
  %214 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %213, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %214, ptr %6, align 8
  %215 = load { i64, [24 x i8] }, ptr %6, align 8
  %216 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %208, 0
  %217 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %216, i64 %210, 1
  %218 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %217, i64 %211, 2
  %219 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %218, ptr %209, 3
  %220 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %219, { i64, [24 x i8] } %215, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %220

221:                                              ; preds = %103
  call void @puts(ptr @assert_msg_25)
  call void @abort()
  unreachable

222:                                              ; preds = %125
  call void @puts(ptr @assert_msg_26)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f9(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f9"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f9(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f9(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$377"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$377"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$480"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$377"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$480"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$377"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$481"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$480"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$481"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$480"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$482"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$481"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$482"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$481"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$378"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$377"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$378"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$377"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$478"({ { { ptr, i32, i32, i32 } }, {}, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 0
  call void @"drop$378"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } @"dup$478"({ { { ptr, i32, i32, i32 } }, {}, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$378"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %6, {} %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %7, {} %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, {}, {} } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %9, {} %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } %10, {} %11, 2
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } undef, { { { ptr, i32, i32, i32 } }, {}, {} } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %14, { { { ptr, i32, i32, i32 } }, {}, {} } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %15
}

define private void @"drop$479"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, 1
  call void @"drop$478"({ { { ptr, i32, i32, i32 } }, {}, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$479"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } @"dup$478"({ { { ptr, i32, i32, i32 } }, {}, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, {}, {} }, { { { ptr, i32, i32, i32 } }, {}, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, { { { ptr, i32, i32, i32 } }, {}, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %5, { { { ptr, i32, i32, i32 } }, {}, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f10"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [56 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = add i64 %1, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = icmp uge i64 %2, 0
  %24 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %23, label %25, label %230

25:                                               ; preds = %5
  %26 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %27 = extractvalue { { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { ptr, i32, i32, i32 } %27, 1
  %29 = extractvalue { ptr, i32, i32, i32 } %27, 2
  %30 = sub i32 %29, %28
  %31 = icmp uge i32 %30, 1
  br i1 %31, label %32, label %209

32:                                               ; preds = %25
  %33 = extractvalue { ptr, i32, i32, i32 } %27, 0
  %34 = load ptr, ptr %33, align 8
  %35 = zext i32 %28 to i64
  %36 = mul i64 %35, 32
  %37 = getelementptr inbounds i8, ptr %34, i64 %36
  %38 = add i32 %28, 1
  %39 = insertvalue { ptr, i32, i32, i32 } %27, i32 %38, 1
  %40 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %40, ptr %37, i64 32, i1 false)
  %41 = load i252, ptr %40, align 16
  call void @free(ptr %40)
  %42 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %39, 0
  %43 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f38"(i64 %20, i64 %24, { { ptr, i32, i32, i32 } } %42, { ptr, i32, i32, i32 } zeroinitializer, i252 %41)
  %44 = extractvalue { i64, i64, { i64, [56 x i8] } } %43, 0
  %45 = extractvalue { i64, i64, { i64, [56 x i8] } } %43, 1
  %46 = extractvalue { i64, i64, { i64, [56 x i8] } } %43, 2
  store { i64, [56 x i8] } %46, ptr %8, align 8
  %47 = load i1, ptr %8, align 1
  switch i1 %47, label %48 [
    i1 false, label %50
    i1 true, label %56
  ]

48:                                               ; preds = %32
  br i1 false, label %49, label %251

49:                                               ; preds = %48
  unreachable

50:                                               ; preds = %32
  %51 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %8, align 8
  %52 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %51, 1
  %53 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %52, 0
  %54 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %52, 1
  store { i64, [24 x i8] } %54, ptr %10, align 8
  %55 = load i1, ptr %10, align 1
  switch i1 %55, label %66 [
    i1 false, label %68
    i1 true, label %76
  ]

56:                                               ; preds = %32
  %57 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %58 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %57, 1
  %59 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %58, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %59, ptr %9, align 8
  %60 = load { i64, [24 x i8] }, ptr %9, align 8
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %44, 1
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, i64 %45, 2
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, ptr %3, 3
  %65 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %64, { i64, [24 x i8] } %60, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %65

66:                                               ; preds = %50
  br i1 false, label %67, label %252

67:                                               ; preds = %66
  unreachable

68:                                               ; preds = %50
  %69 = load { i1, { ptr, i32, i32, i32 } }, ptr %10, align 8
  %70 = extractvalue { i1, { ptr, i32, i32, i32 } } %69, 1
  %71 = extractvalue { { ptr, i32, i32, i32 } } %53, 0
  %72 = extractvalue { ptr, i32, i32, i32 } %71, 1
  %73 = extractvalue { ptr, i32, i32, i32 } %71, 2
  %74 = sub i32 %73, %72
  %75 = icmp uge i32 %74, 1
  br i1 %75, label %82, label %100

76:                                               ; preds = %50
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %53)
  %77 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %78 = call ptr %77()
  %79 = load i64, ptr %78, align 8
  %80 = mul i64 %79, 4040
  %81 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %80)
  br label %216

82:                                               ; preds = %68
  %83 = extractvalue { ptr, i32, i32, i32 } %71, 0
  %84 = load ptr, ptr %83, align 8
  %85 = zext i32 %72 to i64
  %86 = mul i64 %85, 32
  %87 = getelementptr inbounds i8, ptr %84, i64 %86
  %88 = add i32 %72, 1
  %89 = insertvalue { ptr, i32, i32, i32 } %71, i32 %88, 1
  %90 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %90, ptr %87, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %89)
  call void @"drop$555"(ptr %90)
  call void @"drop$377"({ ptr, i32, i32, i32 } %70)
  %91 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %92 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %91, 0
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %19, align 8
  %94 = load { i64, [24 x i8] }, ptr %19, align 8
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %44, 1
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %45, 2
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, ptr %3, 3
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %94, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %68
  %101 = phi { ptr, i32, i32, i32 } [ %71, %68 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %101)
  %102 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %103 = call ptr %102()
  %104 = add i64 %44, 1
  %105 = getelementptr inbounds i64, ptr %103, i32 1
  %106 = load i64, ptr %105, align 8
  %107 = load i64, ptr %103, align 8
  %108 = mul i64 %107, 60440
  %109 = add i64 %106, %108
  %110 = icmp uge i64 %45, %109
  %111 = call i64 @llvm.usub.sat.i64(i64 %45, i64 %109)
  br i1 %110, label %112, label %202

112:                                              ; preds = %100
  %113 = phi {} [ undef, %100 ]
  %114 = load ptr, ptr %3, align 8
  store i64 %111, ptr %12, align 8
  %115 = getelementptr inbounds ptr, ptr %3, i32 3
  %116 = load ptr, ptr %115, align 8
  call void %116(ptr %11, ptr %114, ptr %12)
  %117 = load { i1, [31 x i8] }, ptr %11, align 1
  %118 = extractvalue { i1, [31 x i8] } %117, 0
  %119 = getelementptr inbounds i8, ptr %11, i32 8
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr inbounds i8, ptr %11, i32 8
  %122 = load { ptr, i32, i32, i32 }, ptr %121, align 8
  %123 = load i64, ptr %12, align 8
  br i1 %118, label %192, label %124

124:                                              ; preds = %112
  %125 = phi ptr [ %120, %112 ]
  %126 = load { ptr, ptr, i252, i252, i252 }, ptr %125, align 16
  call void @free(ptr %125)
  %127 = extractvalue { ptr, ptr, i252, i252, i252 } %126, 0
  %128 = extractvalue { ptr, ptr, i252, i252, i252 } %126, 1
  %129 = extractvalue { ptr, ptr, i252, i252, i252 } %126, 2
  call void @"drop$520"(ptr %127)
  call void @"drop$519"(ptr %128)
  %130 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %104, i64 %123, i64 %0, ptr %3, {} %113, i252 %129)
  %131 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 0
  %132 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 1
  %133 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 2
  %134 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 3
  %135 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 4
  store { i64, [24 x i8] } %135, ptr %14, align 8
  %136 = load i1, ptr %14, align 1
  switch i1 %136, label %137 [
    i1 false, label %139
    i1 true, label %148
  ]

137:                                              ; preds = %124
  br i1 false, label %138, label %253

138:                                              ; preds = %137
  unreachable

139:                                              ; preds = %124
  %140 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %70, 0
  %141 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f39"(i64 %131, i64 %132, i64 %133, ptr %134, { { ptr, i32, i32, i32 } } %140, {} %113)
  %142 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 0
  %143 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 1
  %144 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 2
  %145 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 3
  %146 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 4
  store { i64, [24 x i8] } %146, ptr %16, align 8
  %147 = load i1, ptr %16, align 1
  switch i1 %147, label %160 [
    i1 false, label %162
    i1 true, label %180
  ]

148:                                              ; preds = %124
  %149 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %150 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %149, 1
  call void @"drop$377"({ ptr, i32, i32, i32 } %70)
  %151 = extractvalue { {}, { ptr, i32, i32, i32 } } %150, 1
  %152 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %151, 1
  %153 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %152, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %153, ptr %15, align 8
  %154 = load { i64, [24 x i8] }, ptr %15, align 8
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %133, 0
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %131, 1
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, i64 %132, 2
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, ptr %134, 3
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %158, { i64, [24 x i8] } %154, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %159

160:                                              ; preds = %139
  br i1 false, label %161, label %254

161:                                              ; preds = %160
  unreachable

162:                                              ; preds = %139
  %163 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %16, align 8
  %164 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %163, 1
  call void @"drop$478"({ { { ptr, i32, i32, i32 } }, {}, {} } %164)
  %165 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %166 = call ptr %165()
  %167 = call i64 @llvm.uadd.sat.i64(i64 %143, i64 0)
  %168 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %169 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %168, 0
  %170 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %168, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %169)
  %171 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %170, 0
  %172 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %171, 0
  %173 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %172, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %173, ptr %18, align 8
  %174 = load { i64, [24 x i8] }, ptr %18, align 8
  %175 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %144, 0
  %176 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %175, i64 %142, 1
  %177 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %176, i64 %167, 2
  %178 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %177, ptr %145, 3
  %179 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %178, { i64, [24 x i8] } %174, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %179

180:                                              ; preds = %139
  %181 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %182 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %181, 1
  %183 = extractvalue { {}, { ptr, i32, i32, i32 } } %182, 1
  %184 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %183, 1
  %185 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %184, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %185, ptr %17, align 8
  %186 = load { i64, [24 x i8] }, ptr %17, align 8
  %187 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %144, 0
  %188 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %187, i64 %142, 1
  %189 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %188, i64 %143, 2
  %190 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %189, ptr %145, 3
  %191 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %190, { i64, [24 x i8] } %186, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %191

192:                                              ; preds = %112
  %193 = phi { ptr, i32, i32, i32 } [ %70, %112 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %193)
  %194 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %122, 1
  %195 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %194, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %195, ptr %13, align 8
  %196 = load { i64, [24 x i8] }, ptr %13, align 8
  %197 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %198 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %197, i64 %104, 1
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %198, i64 %123, 2
  %200 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %199, ptr %3, 3
  %201 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %200, { i64, [24 x i8] } %196, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %201

202:                                              ; preds = %100
  %203 = phi { ptr, i32, i32, i32 } [ %70, %100 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %203)
  %204 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %205 = call ptr %204()
  %206 = load i64, ptr %205, align 8
  %207 = mul i64 %206, 2390
  %208 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %207)
  br label %237

209:                                              ; preds = %25
  %210 = phi { ptr, i32, i32, i32 } [ %27, %25 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %210)
  %211 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %212 = call ptr %211()
  %213 = load i64, ptr %212, align 8
  %214 = mul i64 %213, 7410
  %215 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 %214)
  br label %216

216:                                              ; preds = %76, %209
  %217 = phi i64 [ %0, %209 ], [ %0, %76 ]
  %218 = phi ptr [ %3, %209 ], [ %3, %76 ]
  %219 = phi i64 [ %20, %209 ], [ %44, %76 ]
  %220 = phi i64 [ %215, %209 ], [ %81, %76 ]
  %221 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %222 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %221, 0
  %223 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %222, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %223, ptr %7, align 8
  %224 = load { i64, [24 x i8] }, ptr %7, align 8
  %225 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %217, 0
  %226 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %225, i64 %219, 1
  %227 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %226, i64 %220, 2
  %228 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %227, ptr %218, 3
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %228, { i64, [24 x i8] } %224, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %229

230:                                              ; preds = %5
  %231 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %231)
  %232 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %233 = call ptr %232()
  %234 = load i64, ptr %233, align 8
  %235 = mul i64 %234, 7610
  %236 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %235)
  br label %237

237:                                              ; preds = %202, %230
  %238 = phi i64 [ %0, %230 ], [ %0, %202 ]
  %239 = phi ptr [ %3, %230 ], [ %3, %202 ]
  %240 = phi i64 [ %20, %230 ], [ %104, %202 ]
  %241 = phi i64 [ %236, %230 ], [ %208, %202 ]
  %242 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %243 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %242, 0
  %244 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %243, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %244, ptr %6, align 8
  %245 = load { i64, [24 x i8] }, ptr %6, align 8
  %246 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %238, 0
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %246, i64 %240, 1
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %241, 2
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, ptr %239, 3
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, { i64, [24 x i8] } %245, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %250

251:                                              ; preds = %48
  call void @puts(ptr @assert_msg_27)
  call void @abort()
  unreachable

252:                                              ; preds = %66
  call void @puts(ptr @assert_msg_28)
  call void @abort()
  unreachable

253:                                              ; preds = %137
  call void @puts(ptr @assert_msg_29)
  call void @abort()
  unreachable

254:                                              ; preds = %160
  call void @puts(ptr @assert_msg_30)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f10(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f10"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f10(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f10(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f11"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [56 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = add i64 %1, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = icmp uge i64 %2, 0
  %24 = call i64 @llvm.usub.sat.i64(i64 %2, i64 0)
  br i1 %23, label %25, label %230

25:                                               ; preds = %5
  %26 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %27 = extractvalue { { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { ptr, i32, i32, i32 } %27, 1
  %29 = extractvalue { ptr, i32, i32, i32 } %27, 2
  %30 = sub i32 %29, %28
  %31 = icmp uge i32 %30, 1
  br i1 %31, label %32, label %209

32:                                               ; preds = %25
  %33 = extractvalue { ptr, i32, i32, i32 } %27, 0
  %34 = load ptr, ptr %33, align 8
  %35 = zext i32 %28 to i64
  %36 = mul i64 %35, 32
  %37 = getelementptr inbounds i8, ptr %34, i64 %36
  %38 = add i32 %28, 1
  %39 = insertvalue { ptr, i32, i32, i32 } %27, i32 %38, 1
  %40 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %40, ptr %37, i64 32, i1 false)
  %41 = load i252, ptr %40, align 16
  call void @free(ptr %40)
  %42 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %39, 0
  %43 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f38"(i64 %20, i64 %24, { { ptr, i32, i32, i32 } } %42, { ptr, i32, i32, i32 } zeroinitializer, i252 %41)
  %44 = extractvalue { i64, i64, { i64, [56 x i8] } } %43, 0
  %45 = extractvalue { i64, i64, { i64, [56 x i8] } } %43, 1
  %46 = extractvalue { i64, i64, { i64, [56 x i8] } } %43, 2
  store { i64, [56 x i8] } %46, ptr %8, align 8
  %47 = load i1, ptr %8, align 1
  switch i1 %47, label %48 [
    i1 false, label %50
    i1 true, label %56
  ]

48:                                               ; preds = %32
  br i1 false, label %49, label %251

49:                                               ; preds = %48
  unreachable

50:                                               ; preds = %32
  %51 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %8, align 8
  %52 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %51, 1
  %53 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %52, 0
  %54 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %52, 1
  store { i64, [24 x i8] } %54, ptr %10, align 8
  %55 = load i1, ptr %10, align 1
  switch i1 %55, label %66 [
    i1 false, label %68
    i1 true, label %76
  ]

56:                                               ; preds = %32
  %57 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %58 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %57, 1
  %59 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %58, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %59, ptr %9, align 8
  %60 = load { i64, [24 x i8] }, ptr %9, align 8
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %44, 1
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, i64 %45, 2
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, ptr %3, 3
  %65 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %64, { i64, [24 x i8] } %60, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %65

66:                                               ; preds = %50
  br i1 false, label %67, label %252

67:                                               ; preds = %66
  unreachable

68:                                               ; preds = %50
  %69 = load { i1, { ptr, i32, i32, i32 } }, ptr %10, align 8
  %70 = extractvalue { i1, { ptr, i32, i32, i32 } } %69, 1
  %71 = extractvalue { { ptr, i32, i32, i32 } } %53, 0
  %72 = extractvalue { ptr, i32, i32, i32 } %71, 1
  %73 = extractvalue { ptr, i32, i32, i32 } %71, 2
  %74 = sub i32 %73, %72
  %75 = icmp uge i32 %74, 1
  br i1 %75, label %82, label %100

76:                                               ; preds = %50
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %53)
  %77 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %78 = call ptr %77()
  %79 = load i64, ptr %78, align 8
  %80 = mul i64 %79, 4040
  %81 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %80)
  br label %216

82:                                               ; preds = %68
  %83 = extractvalue { ptr, i32, i32, i32 } %71, 0
  %84 = load ptr, ptr %83, align 8
  %85 = zext i32 %72 to i64
  %86 = mul i64 %85, 32
  %87 = getelementptr inbounds i8, ptr %84, i64 %86
  %88 = add i32 %72, 1
  %89 = insertvalue { ptr, i32, i32, i32 } %71, i32 %88, 1
  %90 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %90, ptr %87, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %89)
  call void @"drop$555"(ptr %90)
  call void @"drop$377"({ ptr, i32, i32, i32 } %70)
  %91 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %92 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %91, 0
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %19, align 8
  %94 = load { i64, [24 x i8] }, ptr %19, align 8
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %44, 1
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %45, 2
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, ptr %3, 3
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %94, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %68
  %101 = phi { ptr, i32, i32, i32 } [ %71, %68 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %101)
  %102 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %103 = call ptr %102()
  %104 = add i64 %44, 1
  %105 = getelementptr inbounds i64, ptr %103, i32 1
  %106 = load i64, ptr %105, align 8
  %107 = load i64, ptr %103, align 8
  %108 = mul i64 %107, 60440
  %109 = add i64 %106, %108
  %110 = icmp uge i64 %45, %109
  %111 = call i64 @llvm.usub.sat.i64(i64 %45, i64 %109)
  br i1 %110, label %112, label %202

112:                                              ; preds = %100
  %113 = phi {} [ undef, %100 ]
  %114 = load ptr, ptr %3, align 8
  store i64 %111, ptr %12, align 8
  %115 = getelementptr inbounds ptr, ptr %3, i32 3
  %116 = load ptr, ptr %115, align 8
  call void %116(ptr %11, ptr %114, ptr %12)
  %117 = load { i1, [31 x i8] }, ptr %11, align 1
  %118 = extractvalue { i1, [31 x i8] } %117, 0
  %119 = getelementptr inbounds i8, ptr %11, i32 8
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr inbounds i8, ptr %11, i32 8
  %122 = load { ptr, i32, i32, i32 }, ptr %121, align 8
  %123 = load i64, ptr %12, align 8
  br i1 %118, label %192, label %124

124:                                              ; preds = %112
  %125 = phi ptr [ %120, %112 ]
  %126 = load { ptr, ptr, i252, i252, i252 }, ptr %125, align 16
  call void @free(ptr %125)
  %127 = extractvalue { ptr, ptr, i252, i252, i252 } %126, 0
  %128 = extractvalue { ptr, ptr, i252, i252, i252 } %126, 1
  %129 = extractvalue { ptr, ptr, i252, i252, i252 } %126, 2
  call void @"drop$520"(ptr %127)
  call void @"drop$519"(ptr %128)
  %130 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %104, i64 %123, i64 %0, ptr %3, {} %113, i252 %129)
  %131 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 0
  %132 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 1
  %133 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 2
  %134 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 3
  %135 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, 4
  store { i64, [24 x i8] } %135, ptr %14, align 8
  %136 = load i1, ptr %14, align 1
  switch i1 %136, label %137 [
    i1 false, label %139
    i1 true, label %148
  ]

137:                                              ; preds = %124
  br i1 false, label %138, label %253

138:                                              ; preds = %137
  unreachable

139:                                              ; preds = %124
  %140 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %70, 0
  %141 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %131, i64 %132, i64 %133, ptr %134, { { ptr, i32, i32, i32 } } %140, {} %113)
  %142 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 0
  %143 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 1
  %144 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 2
  %145 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 3
  %146 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, 4
  store { i64, [24 x i8] } %146, ptr %16, align 8
  %147 = load i1, ptr %16, align 1
  switch i1 %147, label %160 [
    i1 false, label %162
    i1 true, label %180
  ]

148:                                              ; preds = %124
  %149 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %150 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %149, 1
  call void @"drop$377"({ ptr, i32, i32, i32 } %70)
  %151 = extractvalue { {}, { ptr, i32, i32, i32 } } %150, 1
  %152 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %151, 1
  %153 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %152, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %153, ptr %15, align 8
  %154 = load { i64, [24 x i8] }, ptr %15, align 8
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %133, 0
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %131, 1
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, i64 %132, 2
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, ptr %134, 3
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %158, { i64, [24 x i8] } %154, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %159

160:                                              ; preds = %139
  br i1 false, label %161, label %254

161:                                              ; preds = %160
  unreachable

162:                                              ; preds = %139
  %163 = load { i1, { { { ptr, i32, i32, i32 } }, {}, {} } }, ptr %16, align 8
  %164 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %163, 1
  call void @"drop$478"({ { { ptr, i32, i32, i32 } }, {}, {} } %164)
  %165 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %166 = call ptr %165()
  %167 = call i64 @llvm.uadd.sat.i64(i64 %143, i64 0)
  %168 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %169 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %168, 0
  %170 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %168, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %169)
  %171 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %170, 0
  %172 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %171, 0
  %173 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %172, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %173, ptr %18, align 8
  %174 = load { i64, [24 x i8] }, ptr %18, align 8
  %175 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %144, 0
  %176 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %175, i64 %142, 1
  %177 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %176, i64 %167, 2
  %178 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %177, ptr %145, 3
  %179 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %178, { i64, [24 x i8] } %174, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %179

180:                                              ; preds = %139
  %181 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %182 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %181, 1
  %183 = extractvalue { {}, { ptr, i32, i32, i32 } } %182, 1
  %184 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %183, 1
  %185 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %184, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %185, ptr %17, align 8
  %186 = load { i64, [24 x i8] }, ptr %17, align 8
  %187 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %144, 0
  %188 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %187, i64 %142, 1
  %189 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %188, i64 %143, 2
  %190 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %189, ptr %145, 3
  %191 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %190, { i64, [24 x i8] } %186, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %191

192:                                              ; preds = %112
  %193 = phi { ptr, i32, i32, i32 } [ %70, %112 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %193)
  %194 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %122, 1
  %195 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %194, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %195, ptr %13, align 8
  %196 = load { i64, [24 x i8] }, ptr %13, align 8
  %197 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %198 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %197, i64 %104, 1
  %199 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %198, i64 %123, 2
  %200 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %199, ptr %3, 3
  %201 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %200, { i64, [24 x i8] } %196, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %201

202:                                              ; preds = %100
  %203 = phi { ptr, i32, i32, i32 } [ %70, %100 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %203)
  %204 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %205 = call ptr %204()
  %206 = load i64, ptr %205, align 8
  %207 = mul i64 %206, 2390
  %208 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %207)
  br label %237

209:                                              ; preds = %25
  %210 = phi { ptr, i32, i32, i32 } [ %27, %25 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %210)
  %211 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %212 = call ptr %211()
  %213 = load i64, ptr %212, align 8
  %214 = mul i64 %213, 7410
  %215 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 %214)
  br label %216

216:                                              ; preds = %76, %209
  %217 = phi i64 [ %0, %209 ], [ %0, %76 ]
  %218 = phi ptr [ %3, %209 ], [ %3, %76 ]
  %219 = phi i64 [ %20, %209 ], [ %44, %76 ]
  %220 = phi i64 [ %215, %209 ], [ %81, %76 ]
  %221 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %222 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %221, 0
  %223 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %222, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %223, ptr %7, align 8
  %224 = load { i64, [24 x i8] }, ptr %7, align 8
  %225 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %217, 0
  %226 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %225, i64 %219, 1
  %227 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %226, i64 %220, 2
  %228 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %227, ptr %218, 3
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %228, { i64, [24 x i8] } %224, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %229

230:                                              ; preds = %5
  %231 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %231)
  %232 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %233 = call ptr %232()
  %234 = load i64, ptr %233, align 8
  %235 = mul i64 %234, 7610
  %236 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %235)
  br label %237

237:                                              ; preds = %202, %230
  %238 = phi i64 [ %0, %230 ], [ %0, %202 ]
  %239 = phi ptr [ %3, %230 ], [ %3, %202 ]
  %240 = phi i64 [ %20, %230 ], [ %104, %202 ]
  %241 = phi i64 [ %236, %230 ], [ %208, %202 ]
  %242 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %243 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %242, 0
  %244 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %243, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %244, ptr %6, align 8
  %245 = load { i64, [24 x i8] }, ptr %6, align 8
  %246 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %238, 0
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %246, i64 %240, 1
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %241, 2
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, ptr %239, 3
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, { i64, [24 x i8] } %245, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %250

251:                                              ; preds = %48
  call void @puts(ptr @assert_msg_31)
  call void @abort()
  unreachable

252:                                              ; preds = %66
  call void @puts(ptr @assert_msg_32)
  call void @abort()
  unreachable

253:                                              ; preds = %137
  call void @puts(ptr @assert_msg_33)
  call void @abort()
  unreachable

254:                                              ; preds = %160
  call void @puts(ptr @assert_msg_34)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f11(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f11"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f11(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f11(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f12"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [56 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = add i64 %1, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 230
  %22 = icmp uge i64 %2, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %2, i64 %21)
  br i1 %22, label %24, label %266

24:                                               ; preds = %5
  %25 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %245

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %41 = add i64 %1, 4
  %42 = icmp ult i252 %40, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %42, label %43, label %238

43:                                               ; preds = %31
  %44 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  %45 = extractvalue { ptr, i32, i32, i32 } %44, 1
  %46 = extractvalue { ptr, i32, i32, i32 } %44, 2
  %47 = sub i32 %46, %45
  %48 = icmp uge i32 %47, 1
  br i1 %48, label %49, label %217

49:                                               ; preds = %43
  %50 = extractvalue { ptr, i32, i32, i32 } %44, 0
  %51 = load ptr, ptr %50, align 8
  %52 = zext i32 %45 to i64
  %53 = mul i64 %52, 32
  %54 = getelementptr inbounds i8, ptr %51, i64 %53
  %55 = add i32 %45, 1
  %56 = insertvalue { ptr, i32, i32, i32 } %44, i32 %55, 1
  %57 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %57, ptr %54, i64 32, i1 false)
  %58 = load i252, ptr %57, align 16
  call void @free(ptr %57)
  %59 = add i64 %1, 7
  %60 = icmp ult i252 %58, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %60, label %61, label %210

61:                                               ; preds = %49
  %62 = phi { ptr, i32, i32, i32 } [ %56, %49 ]
  %63 = extractvalue { ptr, i32, i32, i32 } %62, 1
  %64 = extractvalue { ptr, i32, i32, i32 } %62, 2
  %65 = sub i32 %64, %63
  %66 = icmp uge i32 %65, 1
  br i1 %66, label %67, label %189

67:                                               ; preds = %61
  %68 = extractvalue { ptr, i32, i32, i32 } %62, 0
  %69 = load ptr, ptr %68, align 8
  %70 = zext i32 %63 to i64
  %71 = mul i64 %70, 32
  %72 = getelementptr inbounds i8, ptr %69, i64 %71
  %73 = add i32 %63, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %62, i32 %73, 1
  %75 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %75, ptr %72, i64 32, i1 false)
  %76 = load i252, ptr %75, align 16
  call void @free(ptr %75)
  %77 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %74, 0
  %78 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f38"(i64 %59, i64 %23, { { ptr, i32, i32, i32 } } %77, { ptr, i32, i32, i32 } zeroinitializer, i252 %76)
  %79 = extractvalue { i64, i64, { i64, [56 x i8] } } %78, 0
  %80 = extractvalue { i64, i64, { i64, [56 x i8] } } %78, 1
  %81 = extractvalue { i64, i64, { i64, [56 x i8] } } %78, 2
  store { i64, [56 x i8] } %81, ptr %10, align 8
  %82 = load i1, ptr %10, align 1
  switch i1 %82, label %83 [
    i1 false, label %85
    i1 true, label %91
  ]

83:                                               ; preds = %67
  br i1 false, label %84, label %287

84:                                               ; preds = %83
  unreachable

85:                                               ; preds = %67
  %86 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %10, align 8
  %87 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %86, 1
  %88 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %87, 0
  %89 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %87, 1
  store { i64, [24 x i8] } %89, ptr %12, align 8
  %90 = load i1, ptr %12, align 1
  switch i1 %90, label %101 [
    i1 false, label %103
    i1 true, label %111
  ]

91:                                               ; preds = %67
  %92 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %93 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %92, 1
  %94 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %93, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %94, ptr %11, align 8
  %95 = load { i64, [24 x i8] }, ptr %11, align 8
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %79, 1
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, i64 %80, 2
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, ptr %3, 3
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, { i64, [24 x i8] } %95, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %100

101:                                              ; preds = %85
  br i1 false, label %102, label %288

102:                                              ; preds = %101
  unreachable

103:                                              ; preds = %85
  %104 = load { i1, { ptr, i32, i32, i32 } }, ptr %12, align 8
  %105 = extractvalue { i1, { ptr, i32, i32, i32 } } %104, 1
  %106 = extractvalue { { ptr, i32, i32, i32 } } %88, 0
  %107 = extractvalue { ptr, i32, i32, i32 } %106, 1
  %108 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %109 = sub i32 %108, %107
  %110 = icmp uge i32 %109, 1
  br i1 %110, label %117, label %135

111:                                              ; preds = %85
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %88)
  %112 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %113 = call ptr %112()
  %114 = load i64, ptr %113, align 8
  %115 = mul i64 %114, 1470
  %116 = call i64 @llvm.uadd.sat.i64(i64 %80, i64 %115)
  br label %196

117:                                              ; preds = %103
  %118 = extractvalue { ptr, i32, i32, i32 } %106, 0
  %119 = load ptr, ptr %118, align 8
  %120 = zext i32 %107 to i64
  %121 = mul i64 %120, 32
  %122 = getelementptr inbounds i8, ptr %119, i64 %121
  %123 = add i32 %107, 1
  %124 = insertvalue { ptr, i32, i32, i32 } %106, i32 %123, 1
  %125 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %125, ptr %122, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %124)
  call void @"drop$555"(ptr %125)
  call void @"drop$377"({ ptr, i32, i32, i32 } %105)
  %126 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %127 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %126, 0
  %128 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %127, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %128, ptr %16, align 8
  %129 = load { i64, [24 x i8] }, ptr %16, align 8
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %79, 1
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %80, 2
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %132, ptr %3, 3
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %133, { i64, [24 x i8] } %129, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %134

135:                                              ; preds = %103
  %136 = phi { ptr, i32, i32, i32 } [ %106, %103 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %136)
  %137 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %138 = call ptr %137()
  %139 = add i64 %79, 1
  %140 = getelementptr inbounds i64, ptr %138, i32 1
  %141 = load i64, ptr %140, align 8
  %142 = load i64, ptr %138, align 8
  %143 = mul i64 %142, 160190
  %144 = add i64 %141, %143
  %145 = icmp uge i64 %80, %144
  %146 = call i64 @llvm.usub.sat.i64(i64 %80, i64 %144)
  br i1 %145, label %147, label %184

147:                                              ; preds = %135
  %148 = phi i64 [ %139, %135 ]
  %149 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f41"(i64 %148, i64 %146, i64 %0, ptr %3, { {} } undef, i252 %40, i252 %58, { ptr, i32, i32, i32 } %105)
  %150 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, 0
  %151 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, 1
  %152 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, 2
  %153 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, 3
  %154 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, 4
  store { i64, [24 x i8] } %154, ptr %13, align 8
  %155 = load i1, ptr %13, align 1
  switch i1 %155, label %156 [
    i1 false, label %158
    i1 true, label %174
  ]

156:                                              ; preds = %147
  br i1 false, label %157, label %289

157:                                              ; preds = %156
  unreachable

158:                                              ; preds = %147
  %159 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %160 = call ptr %159()
  %161 = call i64 @llvm.uadd.sat.i64(i64 %151, i64 0)
  %162 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %163 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %162, 0
  %164 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %162, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %163)
  %165 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %164, 0
  %166 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %165, 0
  %167 = insertvalue { i1, { { { ptr, i32, i32, i32 } } } } { i1 false, { { { ptr, i32, i32, i32 } } } undef }, { { { ptr, i32, i32, i32 } } } %166, 1
  store { i1, { { { ptr, i32, i32, i32 } } } } %167, ptr %15, align 8
  %168 = load { i64, [24 x i8] }, ptr %15, align 8
  %169 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %170 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %169, i64 %150, 1
  %171 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %170, i64 %161, 2
  %172 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %171, ptr %153, 3
  %173 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %172, { i64, [24 x i8] } %168, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %173

174:                                              ; preds = %147
  %175 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %176 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %175, 1
  %177 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %176, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %177, ptr %14, align 8
  %178 = load { i64, [24 x i8] }, ptr %14, align 8
  %179 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %152, 0
  %180 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %179, i64 %150, 1
  %181 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %180, i64 %151, 2
  %182 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %181, ptr %153, 3
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %182, { i64, [24 x i8] } %178, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %183

184:                                              ; preds = %135
  %185 = phi { ptr, i32, i32, i32 } [ %105, %135 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %185)
  %186 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %187 = call ptr %186()
  %188 = call i64 @llvm.uadd.sat.i64(i64 %80, i64 0)
  br label %273

189:                                              ; preds = %61
  %190 = phi { ptr, i32, i32, i32 } [ %62, %61 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %190)
  %191 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %192 = call ptr %191()
  %193 = load i64, ptr %192, align 8
  %194 = mul i64 %193, 4840
  %195 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %194)
  br label %196

196:                                              ; preds = %111, %189
  %197 = phi i64 [ %0, %189 ], [ %0, %111 ]
  %198 = phi ptr [ %3, %189 ], [ %3, %111 ]
  %199 = phi i64 [ %59, %189 ], [ %79, %111 ]
  %200 = phi i64 [ %195, %189 ], [ %116, %111 ]
  %201 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f21"()
  %202 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %201, 0
  %203 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %202, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %203, ptr %9, align 8
  %204 = load { i64, [24 x i8] }, ptr %9, align 8
  %205 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %197, 0
  %206 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %205, i64 %199, 1
  %207 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %206, i64 %200, 2
  %208 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %207, ptr %198, 3
  %209 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %208, { i64, [24 x i8] } %204, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %209

210:                                              ; preds = %49
  %211 = phi { ptr, i32, i32, i32 } [ %56, %49 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %211)
  %212 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %213 = call ptr %212()
  %214 = load i64, ptr %213, align 8
  %215 = mul i64 %214, 5040
  %216 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %215)
  br label %224

217:                                              ; preds = %43
  %218 = phi { ptr, i32, i32, i32 } [ %44, %43 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %218)
  %219 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %220 = call ptr %219()
  %221 = load i64, ptr %220, align 8
  %222 = mul i64 %221, 6240
  %223 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %222)
  br label %224

224:                                              ; preds = %210, %217
  %225 = phi i64 [ %0, %217 ], [ %0, %210 ]
  %226 = phi ptr [ %3, %217 ], [ %3, %210 ]
  %227 = phi i64 [ %41, %217 ], [ %59, %210 ]
  %228 = phi i64 [ %223, %217 ], [ %216, %210 ]
  %229 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %230 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %229, 0
  %231 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %230, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %231, ptr %8, align 8
  %232 = load { i64, [24 x i8] }, ptr %8, align 8
  %233 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %225, 0
  %234 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %233, i64 %227, 1
  %235 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %234, i64 %228, 2
  %236 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %235, ptr %226, 3
  %237 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %236, { i64, [24 x i8] } %232, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %237

238:                                              ; preds = %31
  %239 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %239)
  %240 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %241 = call ptr %240()
  %242 = load i64, ptr %241, align 8
  %243 = mul i64 %242, 6440
  %244 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %243)
  br label %252

245:                                              ; preds = %24
  %246 = phi { ptr, i32, i32, i32 } [ %26, %24 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %246)
  %247 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %248 = call ptr %247()
  %249 = load i64, ptr %248, align 8
  %250 = mul i64 %249, 7640
  %251 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %250)
  br label %252

252:                                              ; preds = %238, %245
  %253 = phi i64 [ %0, %245 ], [ %0, %238 ]
  %254 = phi ptr [ %3, %245 ], [ %3, %238 ]
  %255 = phi i64 [ %17, %245 ], [ %41, %238 ]
  %256 = phi i64 [ %251, %245 ], [ %244, %238 ]
  %257 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %258 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %257, 0
  %259 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %258, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %259, ptr %7, align 8
  %260 = load { i64, [24 x i8] }, ptr %7, align 8
  %261 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %253, 0
  %262 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %261, i64 %255, 1
  %263 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %262, i64 %256, 2
  %264 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %263, ptr %254, 3
  %265 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %264, { i64, [24 x i8] } %260, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %265

266:                                              ; preds = %5
  %267 = phi { { ptr, i32, i32, i32 } } [ %4, %5 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %267)
  %268 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %269 = call ptr %268()
  %270 = load i64, ptr %269, align 8
  %271 = mul i64 %270, 7610
  %272 = call i64 @llvm.uadd.sat.i64(i64 %2, i64 %271)
  br label %273

273:                                              ; preds = %184, %266
  %274 = phi i64 [ %0, %266 ], [ %0, %184 ]
  %275 = phi ptr [ %3, %266 ], [ %3, %184 ]
  %276 = phi i64 [ %17, %266 ], [ %139, %184 ]
  %277 = phi i64 [ %272, %266 ], [ %188, %184 ]
  %278 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %279 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %278, 0
  %280 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %279, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %280, ptr %6, align 8
  %281 = load { i64, [24 x i8] }, ptr %6, align 8
  %282 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %274, 0
  %283 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %282, i64 %276, 1
  %284 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %283, i64 %277, 2
  %285 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %284, ptr %275, 3
  %286 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %285, { i64, [24 x i8] } %281, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %286

287:                                              ; preds = %83
  call void @puts(ptr @assert_msg_35)
  call void @abort()
  unreachable

288:                                              ; preds = %101
  call void @puts(ptr @assert_msg_36)
  call void @abort()
  unreachable

289:                                              ; preds = %156
  call void @puts(ptr @assert_msg_37)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f12(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f12"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f12(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f12(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 7733229381460288120802334208475838166080759535023995805565484692595)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f13() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f13"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f13(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f13()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$460"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$460"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$470"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$470"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 40)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 40, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$462"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$462"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$463"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$462"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$463"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$462"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$464"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$463"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$464"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$463"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$465"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$464"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$465"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$464"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$467"({ { { { ptr, i32, i32, i32 } } }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, 0
  call void @"drop$465"({ { { ptr, i32, i32, i32 } } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } @"dup$467"({ { { { ptr, i32, i32, i32 } } }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$465"({ { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, { { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %6, {} %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } undef, { { { { ptr, i32, i32, i32 } } }, {} } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %11, { { { { ptr, i32, i32, i32 } } }, {} } %10, 1
  ret { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %12
}

define private void @"drop$468"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$467"({ { { { ptr, i32, i32, i32 } } }, {} } %2)
  %3 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } @"dup$468"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } @"dup$467"({ { { { ptr, i32, i32, i32 } } }, {} } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { { { { ptr, i32, i32, i32 } } }, {} } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, { { { { ptr, i32, i32, i32 } } }, {} } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } undef, { { { { ptr, i32, i32, i32 } } }, {} } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } undef, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %17, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$469"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$468"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$469"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } @"dup$468"({ { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %5, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f14"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7) {
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca { i1, [47 x i8] }, i64 1, align 16
  %13 = alloca i64, i64 1, align 8
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i1, [31 x i8] }, i64 1, align 8
  %17 = alloca i64, i64 1, align 8
  %18 = alloca i252, i64 1, align 16
  %19 = alloca i252, i64 1, align 16
  %20 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i32, [24 x i8] }, i64 1, align 4
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca { i32, [20 x i8] }, i64 1, align 4
  %25 = alloca { i32, [4 x i8] }, i64 1, align 4
  %26 = alloca { i32, [4 x i8] }, i64 1, align 4
  %27 = alloca { i32, [4 x i8] }, i64 1, align 4
  %28 = alloca { i32, [4 x i8] }, i64 1, align 4
  %29 = alloca { i32, [4 x i8] }, i64 1, align 4
  %30 = alloca { i64, [48 x i8] }, i64 1, align 8
  %31 = alloca { i64, [24 x i8] }, i64 1, align 8
  %32 = alloca { i64, [24 x i8] }, i64 1, align 8
  %33 = add i64 %3, 3
  %34 = zext i252 %6 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %9, align 16
  store i256 %34, ptr %10, align 16
  %35 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %35(ptr %11, ptr %9, ptr %10)
  %36 = load i256, ptr %11, align 16
  %37 = trunc i256 %36 to i252
  %38 = add i64 %0, 3
  %39 = sub i252 %37, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %40 = icmp ult i252 %37, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %41 = select i1 %40, i252 %37, i252 %39
  %42 = load ptr, ptr %4, align 8
  store i64 %1, ptr %13, align 8
  store i252 %41, ptr %14, align 16
  %43 = getelementptr inbounds ptr, ptr %4, i32 8
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %12, ptr %42, ptr %13, i32 0, ptr %14)
  %45 = load { i1, [47 x i8] }, ptr %12, align 1
  %46 = extractvalue { i1, [47 x i8] } %45, 0
  %47 = getelementptr inbounds i8, ptr %12, i32 16
  %48 = load i252, ptr %47, align 16
  %49 = getelementptr inbounds i8, ptr %12, i32 8
  %50 = load { ptr, i32, i32, i32 }, ptr %49, align 8
  %51 = load i64, ptr %13, align 8
  br i1 %46, label %248, label %52

52:                                               ; preds = %8
  %53 = phi i252 [ %48, %8 ]
  %54 = icmp eq i252 %53, 0
  br i1 %54, label %55, label %68

55:                                               ; preds = %52
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f43"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = extractvalue { {}, { ptr, i32, i32, i32 } } %57, 1
  %59 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 1
  %60 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %59, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %60, ptr %32, align 8
  %61 = load { i64, [24 x i8] }, ptr %32, align 8
  %62 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %38, 0
  %63 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %62, i64 %51, 1
  %64 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %63, i64 %2, 2
  %65 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %64, i64 %33, 3
  %66 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %65, ptr %4, 4
  %67 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %66, { i64, [24 x i8] } %61, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %67

68:                                               ; preds = %52
  %69 = phi { i128, i128 } [ %7, %52 ]
  %70 = extractvalue { i128, i128 } %69, 0
  %71 = zext i128 %70 to i252
  %72 = extractvalue { i128, i128 } %69, 1
  %73 = zext i128 %72 to i252
  %74 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %74, align 4
  %75 = getelementptr inbounds i8, ptr %74, i32 4
  store i32 0, ptr %75, align 4
  %76 = getelementptr inbounds i8, ptr %74, i32 16
  %77 = call ptr @realloc(ptr null, i64 8)
  store ptr %76, ptr %77, align 8
  %78 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %77, 0
  %79 = insertvalue { ptr, i32, i32, i32 } %78, i32 8, 3
  %80 = load ptr, ptr %77, align 8
  store i252 %71, ptr %80, align 16
  %81 = insertvalue { ptr, i32, i32, i32 } %79, i32 1, 2
  %82 = getelementptr inbounds i8, ptr %80, i32 -12
  store i32 1, ptr %82, align 4
  %83 = load ptr, ptr %77, align 8
  %84 = getelementptr inbounds i8, ptr %83, i32 32
  store i252 %73, ptr %84, align 16
  %85 = insertvalue { ptr, i32, i32, i32 } %81, i32 2, 2
  %86 = getelementptr inbounds i8, ptr %83, i32 -12
  store i32 2, ptr %86, align 4
  %87 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %85)
  %88 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %87, 0
  %89 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %87, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %88)
  %90 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %89, 0
  %91 = load ptr, ptr %4, align 8
  store i64 %51, ptr %17, align 8
  store i252 %6, ptr %18, align 16
  store i252 198245171877110614431632758327373800976566065571148526819123645061251396147, ptr %19, align 16
  store { { ptr, i32, i32, i32 } } %90, ptr %20, align 8
  %92 = getelementptr inbounds ptr, ptr %4, i32 7
  %93 = load ptr, ptr %92, align 8
  call void %93(ptr %16, ptr %91, ptr %17, ptr %18, ptr %19, ptr %20)
  %94 = load { i1, [31 x i8] }, ptr %16, align 1
  %95 = extractvalue { i1, [31 x i8] } %94, 0
  %96 = getelementptr inbounds i8, ptr %16, i32 8
  %97 = load { { ptr, i32, i32, i32 } }, ptr %96, align 8
  %98 = getelementptr inbounds i8, ptr %16, i32 8
  %99 = load { ptr, i32, i32, i32 }, ptr %98, align 8
  %100 = load i64, ptr %17, align 8
  br i1 %95, label %237, label %101

101:                                              ; preds = %68
  %102 = phi i64 [ %38, %68 ]
  %103 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f44"(i64 %102, { { ptr, i32, i32, i32 } } %97)
  %104 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %103, 0
  %105 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %103, 1
  %106 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %103, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %105)
  store { i32, [24 x i8] } %106, ptr %22, align 4
  %107 = load i1, ptr %22, align 1
  switch i1 %107, label %108 [
    i1 false, label %110
    i1 true, label %114
  ]

108:                                              ; preds = %101
  br i1 false, label %109, label %259

109:                                              ; preds = %108
  unreachable

110:                                              ; preds = %101
  %111 = load { i1, { i32, [20 x i8] } }, ptr %22, align 4
  %112 = extractvalue { i1, { i32, [20 x i8] } } %111, 1
  store { i32, [20 x i8] } %112, ptr %24, align 4
  %113 = load i1, ptr %24, align 1
  switch i1 %113, label %127 [
    i1 false, label %129
    i1 true, label %168
  ]

114:                                              ; preds = %101
  %115 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"()
  %116 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %115, 0
  %117 = extractvalue { {}, { ptr, i32, i32, i32 } } %116, 1
  %118 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %117, 1
  %119 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %118, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %119, ptr %23, align 8
  %120 = load { i64, [24 x i8] }, ptr %23, align 8
  %121 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %104, 0
  %122 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %121, i64 %100, 1
  %123 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %122, i64 %2, 2
  %124 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %123, i64 %33, 3
  %125 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %124, ptr %4, 4
  %126 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %125, { i64, [24 x i8] } %120, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %126

127:                                              ; preds = %110
  br i1 false, label %128, label %260

128:                                              ; preds = %127
  unreachable

129:                                              ; preds = %110
  %130 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %24, align 4
  %131 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %130, 1
  %132 = extractvalue { i32, i32, i32, i32, i32 } %131, 0
  %133 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %132, 1
  store { i3, i32 } %133, ptr %25, align 4
  %134 = load { i32, [4 x i8] }, ptr %25, align 4
  %135 = extractvalue { i32, i32, i32, i32, i32 } %131, 1
  %136 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %135, 1
  store { i3, i32 } %136, ptr %26, align 4
  %137 = load { i32, [4 x i8] }, ptr %26, align 4
  %138 = extractvalue { i32, i32, i32, i32, i32 } %131, 2
  %139 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %138, 1
  store { i3, i32 } %139, ptr %27, align 4
  %140 = load { i32, [4 x i8] }, ptr %27, align 4
  %141 = extractvalue { i32, i32, i32, i32, i32 } %131, 3
  %142 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %141, 1
  store { i3, i32 } %142, ptr %28, align 4
  %143 = load { i32, [4 x i8] }, ptr %28, align 4
  %144 = extractvalue { i32, i32, i32, i32, i32 } %131, 4
  %145 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %144, 1
  store { i3, i32 } %145, ptr %29, align 4
  %146 = load { i32, [4 x i8] }, ptr %29, align 4
  %147 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } undef, { i32, [4 x i8] } %134, 0
  %148 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %147, { i32, [4 x i8] } %137, 1
  %149 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %148, { i32, [4 x i8] } %140, 2
  %150 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %149, { i32, [4 x i8] } %143, 3
  %151 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %150, { i32, [4 x i8] } %146, 4
  %152 = call ptr @realloc(ptr null, i64 40)
  store { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %151, ptr %152, align 4
  %153 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 5 }, ptr %153, align 4
  %154 = getelementptr inbounds i8, ptr %153, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr %154, ptr %152, i64 40, i1 false)
  call void @free(ptr %152)
  %155 = call ptr @realloc(ptr null, i64 8)
  store ptr %154, ptr %155, align 8
  %156 = insertvalue { ptr, i32, i32, i32 } undef, ptr %155, 0
  %157 = insertvalue { ptr, i32, i32, i32 } %156, i32 0, 1
  %158 = insertvalue { ptr, i32, i32, i32 } %157, i32 5, 2
  %159 = insertvalue { ptr, i32, i32, i32 } %158, i32 5, 3
  %160 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %159, 0
  %161 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %160, 0
  %162 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %161, 0
  %163 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f45"(i64 %104, i64 %100, { { { { ptr, i32, i32, i32 } } }, {} } %162, { ptr, i32, i32, i32 } zeroinitializer)
  %164 = extractvalue { i64, i64, { i64, [48 x i8] } } %163, 0
  %165 = extractvalue { i64, i64, { i64, [48 x i8] } } %163, 1
  %166 = extractvalue { i64, i64, { i64, [48 x i8] } } %163, 2
  store { i64, [48 x i8] } %166, ptr %30, align 8
  %167 = load i1, ptr %30, align 1
  switch i1 %167, label %191 [
    i1 false, label %193
    i1 true, label %204
  ]

168:                                              ; preds = %110
  %169 = load { i1, i32 }, ptr %24, align 4
  %170 = extractvalue { i1, i32 } %169, 1
  %171 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %172 = call ptr %171()
  %173 = load i64, ptr %172, align 8
  %174 = mul i64 %173, 4770
  %175 = call i64 @llvm.uadd.sat.i64(i64 %100, i64 %174)
  %176 = zext i32 %170 to i256
  %177 = add i256 %176, 25769803776
  %178 = add i256 %176, -3618502788666131213697322783095070105623107215331596699973092056110102216705
  %179 = icmp uge i256 %177, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %180 = select i1 %179, i256 %178, i256 %177
  %181 = trunc i256 %180 to i252
  %182 = insertvalue { i252 } undef, i252 %181, 0
  %183 = call ptr @realloc(ptr null, i64 32)
  store { i252 } %182, ptr %183, align 16
  %184 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 1 }, ptr %184, align 4
  %185 = getelementptr inbounds i8, ptr %184, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %185, ptr %183, i64 32, i1 false)
  call void @free(ptr %183)
  %186 = call ptr @realloc(ptr null, i64 8)
  store ptr %185, ptr %186, align 8
  %187 = insertvalue { ptr, i32, i32, i32 } undef, ptr %186, 0
  %188 = insertvalue { ptr, i32, i32, i32 } %187, i32 0, 1
  %189 = insertvalue { ptr, i32, i32, i32 } %188, i32 1, 2
  %190 = insertvalue { ptr, i32, i32, i32 } %189, i32 1, 3
  br label %215

191:                                              ; preds = %129
  br i1 false, label %192, label %261

192:                                              ; preds = %191
  unreachable

193:                                              ; preds = %129
  %194 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %30, align 8
  %195 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %194, 1
  %196 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %197 = call ptr %196()
  %198 = call i64 @llvm.uadd.sat.i64(i64 %165, i64 0)
  %199 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %195, 0
  %200 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %195, 1
  call void @"drop$467"({ { { { ptr, i32, i32, i32 } } }, {} } %199)
  %201 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %200)
  %202 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, 0
  %203 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %201, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %202)
  br label %215

204:                                              ; preds = %129
  %205 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %30, align 8
  %206 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %205, 1
  %207 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %206, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %207, ptr %31, align 8
  %208 = load { i64, [24 x i8] }, ptr %31, align 8
  %209 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %164, 0
  %210 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %209, i64 %165, 1
  %211 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %210, i64 %2, 2
  %212 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %211, i64 %33, 3
  %213 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %212, ptr %4, 4
  %214 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %213, { i64, [24 x i8] } %208, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %214

215:                                              ; preds = %193, %168
  %216 = phi i64 [ %2, %193 ], [ %2, %168 ]
  %217 = phi { {} } [ %5, %193 ], [ %5, %168 ]
  %218 = phi ptr [ %4, %193 ], [ %4, %168 ]
  %219 = phi i64 [ %33, %193 ], [ %33, %168 ]
  %220 = phi i64 [ %164, %193 ], [ %104, %168 ]
  %221 = phi i64 [ %198, %193 ], [ %175, %168 ]
  %222 = phi { ptr, i32, i32, i32 } [ %203, %193 ], [ %190, %168 ]
  %223 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %222, 0
  %224 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f46"(i64 %220, i64 %221, i64 %216, i64 %219, ptr %218, { {} } %217, { { ptr, i32, i32, i32 } } %223)
  %225 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %224, 0
  %226 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %224, 1
  %227 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %224, 2
  %228 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %224, 3
  %229 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %224, 4
  %230 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %224, 5
  %231 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %225, 0
  %232 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %231, i64 %226, 1
  %233 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %232, i64 %227, 2
  %234 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %233, i64 %228, 3
  %235 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %234, ptr %229, 4
  %236 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %235, { i64, [24 x i8] } %230, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %236

237:                                              ; preds = %68
  %238 = phi { ptr, i32, i32, i32 } [ %99, %68 ]
  %239 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %238, 1
  %240 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %239, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %240, ptr %21, align 8
  %241 = load { i64, [24 x i8] }, ptr %21, align 8
  %242 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %38, 0
  %243 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %242, i64 %100, 1
  %244 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %243, i64 %2, 2
  %245 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %244, i64 %33, 3
  %246 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %245, ptr %4, 4
  %247 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %246, { i64, [24 x i8] } %241, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %247

248:                                              ; preds = %8
  %249 = phi { ptr, i32, i32, i32 } [ %50, %8 ]
  %250 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %249, 1
  %251 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %250, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %251, ptr %15, align 8
  %252 = load { i64, [24 x i8] }, ptr %15, align 8
  %253 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %38, 0
  %254 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %253, i64 %51, 1
  %255 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %254, i64 %2, 2
  %256 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %255, i64 %33, 3
  %257 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %256, ptr %4, 4
  %258 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %257, { i64, [24 x i8] } %252, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %258

259:                                              ; preds = %108
  call void @puts(ptr @assert_msg_38)
  call void @abort()
  unreachable

260:                                              ; preds = %127
  call void @puts(ptr @assert_msg_39)
  call void @abort()
  unreachable

261:                                              ; preds = %191
  call void @puts(ptr @assert_msg_40)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f14(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7) {
  %9 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f14"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7)
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 4
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 5
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %10, 0
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 1
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %12, 2
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %13, 3
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, ptr %14, 4
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20, { i64, [24 x i8] } %15, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %21
}

define void @_mlir_ciface_f14(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8) {
  %10 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f14(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %10, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 485748461484230571791265682659113160264223489397539653310998840191492914)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f15() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f15"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f15(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f15()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 485748461484230571791265682659113160264223489397539653310998840191492913)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f16() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f16"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f16(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f16()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 375233589013918064796019)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f17() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f17(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f17()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$454"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$454"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$455"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$454"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$455"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$454"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$456"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$455"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$456"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$455"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f18"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [56 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %19

19:                                               ; preds = %145, %5
  %20 = phi i64 [ %76, %145 ], [ %0, %5 ]
  %21 = phi i64 [ %105, %145 ], [ %1, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %85, %145 ], [ %2, %5 ]
  %23 = phi { ptr, i32, i32, i32 } [ %154, %145 ], [ %3, %5 ]
  %24 = phi i252 [ %161, %145 ], [ %4, %5 ]
  %25 = add i64 %20, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 5140
  %30 = icmp uge i64 %21, %29
  %31 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %29)
  br i1 %30, label %32, label %215

32:                                               ; preds = %19
  %33 = phi i252 [ %24, %19 ]
  %34 = icmp eq i252 %33, 0
  br i1 %34, label %35, label %57

35:                                               ; preds = %32
  %36 = phi i64 [ %31, %32 ]
  %37 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %38 = call ptr %37()
  %39 = load i64, ptr %38, align 8
  %40 = mul i64 %39, 6040
  %41 = call i64 @llvm.uadd.sat.i64(i64 %36, i64 %40)
  %42 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %23, 1
  store { i1, { ptr, i32, i32, i32 } } %42, ptr %17, align 8
  %43 = load { i64, [24 x i8] }, ptr %17, align 8
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %22, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %43, 1
  %46 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %45, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, ptr %18, align 8
  %47 = load { i64, [56 x i8] }, ptr %18, align 8
  %48 = extractvalue { ptr, ptr, i64 } %9, 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp eq i64 %49, 0
  %51 = sub i64 %49, 1
  %52 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %51, ptr %52, align 8
  br i1 %50, label %53, label %172

53:                                               ; preds = %35
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, i64 %41, 1
  %56 = insertvalue { i64, i64, { i64, [56 x i8] } } %55, { i64, [56 x i8] } %47, 2
  ret { i64, i64, { i64, [56 x i8] } } %56

57:                                               ; preds = %32
  %58 = phi { { ptr, i32, i32, i32 } } [ %22, %32 ]
  %59 = extractvalue { { ptr, i32, i32, i32 } } %58, 0
  %60 = extractvalue { ptr, i32, i32, i32 } %59, 1
  %61 = extractvalue { ptr, i32, i32, i32 } %59, 2
  %62 = sub i32 %61, %60
  %63 = icmp uge i32 %62, 1
  br i1 %63, label %64, label %189

64:                                               ; preds = %57
  %65 = extractvalue { ptr, i32, i32, i32 } %59, 0
  %66 = load ptr, ptr %65, align 8
  %67 = zext i32 %60 to i64
  %68 = mul i64 %67, 32
  %69 = getelementptr inbounds i8, ptr %66, i64 %68
  %70 = add i32 %60, 1
  %71 = insertvalue { ptr, i32, i32, i32 } %59, i32 %70, 1
  %72 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %72, ptr %69, i64 32, i1 false)
  %73 = load i252, ptr %72, align 16
  call void @free(ptr %72)
  %74 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %71, 0
  %75 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f48"(i64 %25, i64 %31, { { ptr, i32, i32, i32 } } %74, { ptr, i32, i32, i32 } zeroinitializer, i252 %73)
  %76 = extractvalue { i64, i64, { i64, [56 x i8] } } %75, 0
  %77 = extractvalue { i64, i64, { i64, [56 x i8] } } %75, 1
  %78 = extractvalue { i64, i64, { i64, [56 x i8] } } %75, 2
  store { i64, [56 x i8] } %78, ptr %14, align 8
  %79 = load i1, ptr %14, align 1
  switch i1 %79, label %80 [
    i1 false, label %82
    i1 true, label %88
  ]

80:                                               ; preds = %64
  br i1 false, label %81, label %230

81:                                               ; preds = %80
  unreachable

82:                                               ; preds = %64
  %83 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %14, align 8
  %84 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %83, 1
  %85 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %84, 0
  %86 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %84, 1
  store { i64, [24 x i8] } %86, ptr %16, align 8
  %87 = load i1, ptr %16, align 1
  switch i1 %87, label %98 [
    i1 false, label %100
    i1 true, label %166
  ]

88:                                               ; preds = %64
  %89 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %90 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %89, 1
  call void @"drop$284"({ ptr, i32, i32, i32 } %23)
  %91 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %90, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %91, ptr %15, align 8
  %92 = load { i64, [56 x i8] }, ptr %15, align 8
  %93 = extractvalue { ptr, ptr, i64 } %9, 1
  %94 = load i64, ptr %93, align 8
  %95 = icmp eq i64 %94, 0
  %96 = sub i64 %94, 1
  %97 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %96, ptr %97, align 8
  br i1 %95, label %185, label %172

98:                                               ; preds = %82
  br i1 false, label %99, label %231

99:                                               ; preds = %98
  unreachable

100:                                              ; preds = %82
  %101 = load { i1, { ptr, i32, i32, i32 } }, ptr %16, align 8
  %102 = extractvalue { i1, { ptr, i32, i32, i32 } } %101, 1
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %77, i64 0)
  %106 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %107 = icmp eq i32 %106, 0
  br i1 %107, label %108, label %122

108:                                              ; preds = %100
  %109 = shl i32 %106, 1
  %110 = call i32 @llvm.umin.i32(i32 %109, i32 1024)
  %111 = add i32 %110, %106
  %112 = call i32 @llvm.umax.i32(i32 %111, i32 8)
  %113 = zext i32 %112 to i64
  %114 = mul i64 %113, 24
  %115 = add i64 %114, 8
  %116 = call ptr @realloc(ptr null, i64 %115)
  store i32 1, ptr %116, align 4
  %117 = getelementptr inbounds i8, ptr %116, i32 4
  store i32 0, ptr %117, align 4
  %118 = getelementptr inbounds i8, ptr %116, i32 8
  %119 = call ptr @realloc(ptr null, i64 8)
  store ptr %118, ptr %119, align 8
  %120 = insertvalue { ptr, i32, i32, i32 } %23, ptr %119, 0
  %121 = insertvalue { ptr, i32, i32, i32 } %120, i32 %112, 3
  br label %143

122:                                              ; preds = %100
  %123 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %124 = icmp ult i32 %123, %106
  br i1 %124, label %125, label %126

125:                                              ; preds = %122
  br label %140

126:                                              ; preds = %122
  %127 = shl i32 %106, 1
  %128 = call i32 @llvm.umin.i32(i32 %127, i32 1024)
  %129 = add i32 %128, %106
  %130 = call i32 @llvm.umax.i32(i32 %129, i32 8)
  %131 = zext i32 %130 to i64
  %132 = mul i64 %131, 24
  %133 = add i64 %132, 8
  %134 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr inbounds i8, ptr %135, i32 -8
  %137 = call ptr @realloc(ptr %136, i64 %133)
  %138 = getelementptr inbounds i8, ptr %137, i32 8
  store ptr %138, ptr %134, align 8
  %139 = insertvalue { ptr, i32, i32, i32 } %23, i32 %130, 3
  br label %140

140:                                              ; preds = %125, %126
  %141 = phi { ptr, i32, i32, i32 } [ %139, %126 ], [ %23, %125 ]
  br label %142

142:                                              ; preds = %140
  br label %143

143:                                              ; preds = %108, %142
  %144 = phi { ptr, i32, i32, i32 } [ %141, %142 ], [ %121, %108 ]
  br label %145

145:                                              ; preds = %143
  %146 = extractvalue { ptr, i32, i32, i32 } %144, 0
  %147 = load ptr, ptr %146, align 8
  %148 = extractvalue { ptr, i32, i32, i32 } %144, 2
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 24
  %151 = getelementptr inbounds i8, ptr %147, i64 %150
  store { ptr, i32, i32, i32 } %102, ptr %151, align 8
  %152 = extractvalue { ptr, i32, i32, i32 } %144, 2
  %153 = add i32 %152, 1
  %154 = insertvalue { ptr, i32, i32, i32 } %144, i32 %153, 2
  %155 = getelementptr inbounds i8, ptr %147, i32 -4
  store i32 %153, ptr %155, align 4
  %156 = zext i252 %33 to i256
  %157 = sub i256 %156, 1
  %158 = add i256 %156, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %159 = icmp ult i256 %156, 1
  %160 = select i1 %159, i256 %158, i256 %157
  %161 = trunc i256 %160 to i252
  %162 = extractvalue { ptr, ptr, i64 } %9, 1
  %163 = load i64, ptr %162, align 8
  %164 = add i64 %163, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br label %19

166:                                              ; preds = %82
  call void @"drop$284"({ ptr, i32, i32, i32 } %23)
  %167 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %168 = call ptr %167()
  %169 = load i64, ptr %168, align 8
  %170 = mul i64 %169, 1970
  %171 = call i64 @llvm.uadd.sat.i64(i64 %77, i64 %170)
  br label %197

172:                                              ; preds = %172, %35, %197, %88, %215
  %173 = phi i64 [ %25, %215 ], [ %198, %197 ], [ %173, %172 ], [ %76, %88 ], [ %25, %35 ]
  %174 = phi i64 [ %21, %215 ], [ %199, %197 ], [ %174, %172 ], [ %77, %88 ], [ %41, %35 ]
  %175 = phi { i64, [56 x i8] } [ %220, %215 ], [ %205, %197 ], [ %175, %172 ], [ %92, %88 ], [ %47, %35 ]
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %172

181:                                              ; preds = %172
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %173, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %174, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184

185:                                              ; preds = %88
  %186 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %76, 0
  %187 = insertvalue { i64, i64, { i64, [56 x i8] } } %186, i64 %77, 1
  %188 = insertvalue { i64, i64, { i64, [56 x i8] } } %187, { i64, [56 x i8] } %92, 2
  ret { i64, i64, { i64, [56 x i8] } } %188

189:                                              ; preds = %57
  %190 = phi { ptr, i32, i32, i32 } [ %23, %57 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %190)
  %191 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %192 = call ptr %191()
  %193 = load i64, ptr %192, align 8
  %194 = mul i64 %193, 5340
  %195 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %194)
  %196 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %59, 0
  br label %197

197:                                              ; preds = %166, %189
  %198 = phi i64 [ %25, %189 ], [ %76, %166 ]
  %199 = phi i64 [ %195, %189 ], [ %171, %166 ]
  %200 = phi { { ptr, i32, i32, i32 } } [ %196, %189 ], [ %85, %166 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %201 = load { i64, [24 x i8] }, ptr %12, align 8
  %202 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %200, 0
  %203 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %202, { i64, [24 x i8] } %201, 1
  %204 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %203, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %204, ptr %13, align 8
  %205 = load { i64, [56 x i8] }, ptr %13, align 8
  %206 = extractvalue { ptr, ptr, i64 } %9, 1
  %207 = load i64, ptr %206, align 8
  %208 = icmp eq i64 %207, 0
  %209 = sub i64 %207, 1
  %210 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %209, ptr %210, align 8
  br i1 %208, label %211, label %172

211:                                              ; preds = %197
  %212 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %198, 0
  %213 = insertvalue { i64, i64, { i64, [56 x i8] } } %212, i64 %199, 1
  %214 = insertvalue { i64, i64, { i64, [56 x i8] } } %213, { i64, [56 x i8] } %205, 2
  ret { i64, i64, { i64, [56 x i8] } } %214

215:                                              ; preds = %19
  %216 = phi { ptr, i32, i32, i32 } [ %23, %19 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %216)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %22)
  %217 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %218 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %217, 0
  %219 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %218, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %219, ptr %11, align 8
  %220 = load { i64, [56 x i8] }, ptr %11, align 8
  %221 = extractvalue { ptr, ptr, i64 } %9, 1
  %222 = load i64, ptr %221, align 8
  %223 = icmp eq i64 %222, 0
  %224 = sub i64 %222, 1
  %225 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %224, ptr %225, align 8
  br i1 %223, label %226, label %172

226:                                              ; preds = %215
  %227 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %228 = insertvalue { i64, i64, { i64, [56 x i8] } } %227, i64 %21, 1
  %229 = insertvalue { i64, i64, { i64, [56 x i8] } } %228, { i64, [56 x i8] } %220, 2
  ret { i64, i64, { i64, [56 x i8] } } %229

230:                                              ; preds = %80
  call void @puts(ptr @assert_msg_41)
  call void @abort()
  unreachable

231:                                              ; preds = %98
  call void @puts(ptr @assert_msg_42)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f18(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f18"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f18(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f18(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$351"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$284"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$351"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$284"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %0, 0
  call void @"drop$351"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } @"dup$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$351"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %6, { { {} }, i252 } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %7, { { {} }, i252 } %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } %11, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } %12
}

define private void @"drop$447"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %2)
  %3 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } @"dup$447"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } @"dup$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %17, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$448"({ i128, [96 x i8] } %0) {
  %2 = alloca { i128, [96 x i8] }, i64 1, align 16
  store { i128, [96 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$447"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [96 x i8] }, { i128, [96 x i8] } } @"dup$448"({ i128, [96 x i8] } %0) {
  %2 = alloca { i128, [96 x i8] }, i64 1, align 16
  store { i128, [96 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } @"dup$447"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 16
  %11 = load { i128, [96 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 16
  %13 = load { i128, [96 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } undef, { i128, [96 x i8] } %11, 0
  %15 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } %14, { i128, [96 x i8] } %13, 1
  ret { { i128, [96 x i8] }, { i128, [96 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [96 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [96 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } undef, { i128, [96 x i8] } %23, 0
  %27 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } %26, { i128, [96 x i8] } %25, 1
  ret { { i128, [96 x i8] }, { i128, [96 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$450"({ { {} }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } @"dup$450"({ { {} }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, { {} } %2, 0
  %4 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } undef, { {} } %2, 0
  %5 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = insertvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { {} }, { { ptr, i32, i32, i32 } } } %9, 0
  %12 = insertvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %11, { { {} }, { { ptr, i32, i32, i32 } } } %10, 1
  ret { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %12
}

define private void @"drop$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 0
  call void @"drop$351"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 1
  call void @"drop$450"({ { {} }, { { ptr, i32, i32, i32 } } } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } @"dup$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$351"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %0, 1
  %9 = call { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } @"dup$450"({ { {} }, { { ptr, i32, i32, i32 } } } %8)
  %10 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %9, 0
  %11 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %6, { { {} }, { { ptr, i32, i32, i32 } } } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %7, { { {} }, { { ptr, i32, i32, i32 } } } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %14, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %15
}

define private void @"drop$452"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %2)
  %3 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } @"dup$452"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } @"dup$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %17, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$453"({ i64, [72 x i8] } %0) {
  %2 = alloca { i64, [72 x i8] }, i64 1, align 8
  store { i64, [72 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$452"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [72 x i8] }, { i64, [72 x i8] } } @"dup$453"({ i64, [72 x i8] } %0) {
  %2 = alloca { i64, [72 x i8] }, i64 1, align 8
  store { i64, [72 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } @"dup$452"({ { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [72 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [72 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } undef, { i64, [72 x i8] } %11, 0
  %15 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } %14, { i64, [72 x i8] } %13, 1
  ret { { i64, [72 x i8] }, { i64, [72 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [72 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [72 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } undef, { i64, [72 x i8] } %23, 0
  %27 = insertvalue { { i64, [72 x i8] }, { i64, [72 x i8] } } %26, { i64, [72 x i8] } %25, 1
  ret { { i64, [72 x i8] }, { i64, [72 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, { i128, i128 } %6, { ptr, i32, i32, i32 } %7) {
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca { i1, [47 x i8] }, i64 1, align 16
  %13 = alloca i64, i64 1, align 8
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i1, [31 x i8] }, i64 1, align 8
  %17 = alloca i64, i64 1, align 8
  %18 = alloca i252, i64 1, align 16
  %19 = alloca i252, i64 1, align 16
  %20 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i32, [24 x i8] }, i64 1, align 4
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca { i32, [20 x i8] }, i64 1, align 4
  %25 = alloca { i128, [96 x i8] }, i64 1, align 16
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = alloca { i64, [24 x i8] }, i64 1, align 8
  %28 = alloca { i32, [4 x i8] }, i64 1, align 4
  %29 = alloca { i32, [4 x i8] }, i64 1, align 4
  %30 = alloca { i32, [4 x i8] }, i64 1, align 4
  %31 = alloca { i32, [4 x i8] }, i64 1, align 4
  %32 = alloca { i32, [4 x i8] }, i64 1, align 4
  %33 = alloca { i64, [48 x i8] }, i64 1, align 8
  %34 = alloca { i64, [24 x i8] }, i64 1, align 8
  %35 = alloca { i64, [72 x i8] }, i64 1, align 8
  %36 = alloca { i64, [24 x i8] }, i64 1, align 8
  %37 = alloca { i64, [24 x i8] }, i64 1, align 8
  %38 = alloca { i64, [24 x i8] }, i64 1, align 8
  %39 = add i64 %2, 3
  %40 = zext i252 %5 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %9, align 16
  store i256 %40, ptr %10, align 16
  %41 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %41(ptr %11, ptr %9, ptr %10)
  %42 = load i256, ptr %11, align 16
  %43 = trunc i256 %42 to i252
  %44 = add i64 %0, 3
  %45 = sub i252 %43, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %46 = icmp ult i252 %43, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %47 = select i1 %46, i252 %43, i252 %45
  %48 = load ptr, ptr %3, align 8
  store i64 %1, ptr %13, align 8
  store i252 %47, ptr %14, align 16
  %49 = getelementptr inbounds ptr, ptr %3, i32 8
  %50 = load ptr, ptr %49, align 8
  call void %50(ptr %12, ptr %48, ptr %13, i32 0, ptr %14)
  %51 = load { i1, [47 x i8] }, ptr %12, align 1
  %52 = extractvalue { i1, [47 x i8] } %51, 0
  %53 = getelementptr inbounds i8, ptr %12, i32 16
  %54 = load i252, ptr %53, align 16
  %55 = getelementptr inbounds i8, ptr %12, i32 8
  %56 = load { ptr, i32, i32, i32 }, ptr %55, align 8
  %57 = load i64, ptr %13, align 8
  br i1 %52, label %302, label %58

58:                                               ; preds = %8
  %59 = phi i252 [ %54, %8 ]
  %60 = icmp eq i252 %59, 0
  br i1 %60, label %61, label %74

61:                                               ; preds = %58
  %62 = phi { ptr, i32, i32, i32 } [ %7, %58 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %62)
  %63 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f43"()
  %64 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %63, 0
  %65 = extractvalue { {}, { ptr, i32, i32, i32 } } %64, 1
  %66 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %65, 1
  %67 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %66, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %67, ptr %38, align 8
  %68 = load { i64, [24 x i8] }, ptr %38, align 8
  %69 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %44, 0
  %70 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %69, i64 %57, 1
  %71 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %39, 2
  %72 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %71, ptr %3, 3
  %73 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %72, { i64, [24 x i8] } %68, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %73

74:                                               ; preds = %58
  %75 = phi { i128, i128 } [ %6, %58 ]
  %76 = extractvalue { i128, i128 } %75, 0
  %77 = zext i128 %76 to i252
  %78 = extractvalue { i128, i128 } %75, 1
  %79 = zext i128 %78 to i252
  %80 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %80, align 4
  %81 = getelementptr inbounds i8, ptr %80, i32 4
  store i32 0, ptr %81, align 4
  %82 = getelementptr inbounds i8, ptr %80, i32 16
  %83 = call ptr @realloc(ptr null, i64 8)
  store ptr %82, ptr %83, align 8
  %84 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %83, 0
  %85 = insertvalue { ptr, i32, i32, i32 } %84, i32 8, 3
  %86 = load ptr, ptr %83, align 8
  store i252 %77, ptr %86, align 16
  %87 = insertvalue { ptr, i32, i32, i32 } %85, i32 1, 2
  %88 = getelementptr inbounds i8, ptr %86, i32 -12
  store i32 1, ptr %88, align 4
  %89 = load ptr, ptr %83, align 8
  %90 = getelementptr inbounds i8, ptr %89, i32 32
  store i252 %79, ptr %90, align 16
  %91 = insertvalue { ptr, i32, i32, i32 } %87, i32 2, 2
  %92 = getelementptr inbounds i8, ptr %89, i32 -12
  store i32 2, ptr %92, align 4
  %93 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %91)
  %94 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %93, 0
  %95 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %93, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %94)
  %96 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %95, 0
  %97 = load ptr, ptr %3, align 8
  store i64 %57, ptr %17, align 8
  store i252 %5, ptr %18, align 16
  store i252 198245171877110614431632758327373800976566065571148526819123645061251396147, ptr %19, align 16
  store { { ptr, i32, i32, i32 } } %96, ptr %20, align 8
  %98 = getelementptr inbounds ptr, ptr %3, i32 7
  %99 = load ptr, ptr %98, align 8
  call void %99(ptr %16, ptr %97, ptr %17, ptr %18, ptr %19, ptr %20)
  %100 = load { i1, [31 x i8] }, ptr %16, align 1
  %101 = extractvalue { i1, [31 x i8] } %100, 0
  %102 = getelementptr inbounds i8, ptr %16, i32 8
  %103 = load { { ptr, i32, i32, i32 } }, ptr %102, align 8
  %104 = getelementptr inbounds i8, ptr %16, i32 8
  %105 = load { ptr, i32, i32, i32 }, ptr %104, align 8
  %106 = load i64, ptr %17, align 8
  br i1 %101, label %292, label %107

107:                                              ; preds = %74
  %108 = phi i64 [ %44, %74 ]
  %109 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f44"(i64 %108, { { ptr, i32, i32, i32 } } %103)
  %110 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %109, 0
  %111 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %109, 1
  %112 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %109, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %111)
  store { i32, [24 x i8] } %112, ptr %22, align 4
  %113 = load i1, ptr %22, align 1
  switch i1 %113, label %114 [
    i1 false, label %116
    i1 true, label %120
  ]

114:                                              ; preds = %107
  br i1 false, label %115, label %312

115:                                              ; preds = %114
  unreachable

116:                                              ; preds = %107
  %117 = load { i1, { i32, [20 x i8] } }, ptr %22, align 4
  %118 = extractvalue { i1, { i32, [20 x i8] } } %117, 1
  store { i32, [20 x i8] } %118, ptr %24, align 4
  %119 = load i1, ptr %24, align 1
  switch i1 %119, label %132 [
    i1 false, label %134
    i1 true, label %173
  ]

120:                                              ; preds = %107
  call void @"drop$284"({ ptr, i32, i32, i32 } %7)
  %121 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"()
  %122 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %121, 0
  %123 = extractvalue { {}, { ptr, i32, i32, i32 } } %122, 1
  %124 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %123, 1
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %23, align 8
  %126 = load { i64, [24 x i8] }, ptr %23, align 8
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %110, 0
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, i64 %106, 1
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %39, 2
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, ptr %3, 3
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %126, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %131

132:                                              ; preds = %116
  br i1 false, label %133, label %313

133:                                              ; preds = %132
  unreachable

134:                                              ; preds = %116
  %135 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %24, align 4
  %136 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %135, 1
  %137 = extractvalue { i32, i32, i32, i32, i32 } %136, 0
  %138 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %137, 1
  store { i3, i32 } %138, ptr %28, align 4
  %139 = load { i32, [4 x i8] }, ptr %28, align 4
  %140 = extractvalue { i32, i32, i32, i32, i32 } %136, 1
  %141 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %140, 1
  store { i3, i32 } %141, ptr %29, align 4
  %142 = load { i32, [4 x i8] }, ptr %29, align 4
  %143 = extractvalue { i32, i32, i32, i32, i32 } %136, 2
  %144 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %143, 1
  store { i3, i32 } %144, ptr %30, align 4
  %145 = load { i32, [4 x i8] }, ptr %30, align 4
  %146 = extractvalue { i32, i32, i32, i32, i32 } %136, 3
  %147 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %146, 1
  store { i3, i32 } %147, ptr %31, align 4
  %148 = load { i32, [4 x i8] }, ptr %31, align 4
  %149 = extractvalue { i32, i32, i32, i32, i32 } %136, 4
  %150 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %149, 1
  store { i3, i32 } %150, ptr %32, align 4
  %151 = load { i32, [4 x i8] }, ptr %32, align 4
  %152 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } undef, { i32, [4 x i8] } %139, 0
  %153 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %152, { i32, [4 x i8] } %142, 1
  %154 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %153, { i32, [4 x i8] } %145, 2
  %155 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %154, { i32, [4 x i8] } %148, 3
  %156 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %155, { i32, [4 x i8] } %151, 4
  %157 = call ptr @realloc(ptr null, i64 40)
  store { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %156, ptr %157, align 4
  %158 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 5 }, ptr %158, align 4
  %159 = getelementptr inbounds i8, ptr %158, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr %159, ptr %157, i64 40, i1 false)
  call void @free(ptr %157)
  %160 = call ptr @realloc(ptr null, i64 8)
  store ptr %159, ptr %160, align 8
  %161 = insertvalue { ptr, i32, i32, i32 } undef, ptr %160, 0
  %162 = insertvalue { ptr, i32, i32, i32 } %161, i32 0, 1
  %163 = insertvalue { ptr, i32, i32, i32 } %162, i32 5, 2
  %164 = insertvalue { ptr, i32, i32, i32 } %163, i32 5, 3
  %165 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %164, 0
  %166 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %165, 0
  %167 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %166, 0
  %168 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f45"(i64 %110, i64 %106, { { { { ptr, i32, i32, i32 } } }, {} } %167, { ptr, i32, i32, i32 } zeroinitializer)
  %169 = extractvalue { i64, i64, { i64, [48 x i8] } } %168, 0
  %170 = extractvalue { i64, i64, { i64, [48 x i8] } } %168, 1
  %171 = extractvalue { i64, i64, { i64, [48 x i8] } } %168, 2
  store { i64, [48 x i8] } %171, ptr %33, align 8
  %172 = load i1, ptr %33, align 1
  switch i1 %172, label %199 [
    i1 false, label %201
    i1 true, label %224
  ]

173:                                              ; preds = %116
  %174 = load { i1, i32 }, ptr %24, align 4
  %175 = extractvalue { i1, i32 } %174, 1
  %176 = zext i32 %175 to i256
  %177 = add i256 %176, 25769803776
  %178 = add i256 %176, -3618502788666131213697322783095070105623107215331596699973092056110102216705
  %179 = icmp uge i256 %177, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %180 = select i1 %179, i256 %178, i256 %177
  %181 = trunc i256 %180 to i252
  %182 = zext i252 %181 to i512
  %183 = mul i512 %182, 4294967296
  %184 = urem i512 %183, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %185 = icmp uge i512 %183, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %186 = select i1 %185, i512 %184, i512 %183
  %187 = trunc i512 %186 to i252
  %188 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %7, 0
  %189 = insertvalue { { {} }, i252 } undef, i252 %187, 1
  %190 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } undef, { { ptr, i32, i32, i32 } } %188, 0
  %191 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %190, { { {} }, i252 } %189, 1
  %192 = call fastcc { i64, i64, i64, ptr, { i128, [96 x i8] } } @"impl$f50"(i64 %110, i64 %106, i64 %39, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %191, { ptr, i32, i32, i32 } zeroinitializer)
  %193 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %192, 0
  %194 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %192, 1
  %195 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %192, 2
  %196 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %192, 3
  %197 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %192, 4
  store { i128, [96 x i8] } %197, ptr %25, align 16
  %198 = load i1, ptr %25, align 1
  switch i1 %198, label %262 [
    i1 false, label %264
    i1 true, label %282
  ]

199:                                              ; preds = %134
  br i1 false, label %200, label %314

200:                                              ; preds = %199
  unreachable

201:                                              ; preds = %134
  %202 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %33, align 8
  %203 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %202, 1
  %204 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %203, 0
  %205 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %203, 1
  call void @"drop$467"({ { { { ptr, i32, i32, i32 } } }, {} } %204)
  %206 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %205)
  %207 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %206, 0
  %208 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %206, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %207)
  %209 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %208, 0
  %210 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %209)
  %211 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %210, 0
  %212 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %210, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %211)
  %213 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %7, 0
  %214 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %212, 1
  %215 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %213, 0
  %216 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %215, { { {} }, { { ptr, i32, i32, i32 } } } %214, 1
  %217 = call fastcc { i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f49"(i64 %169, i64 %170, i64 %39, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %216, { ptr, i32, i32, i32 } zeroinitializer)
  %218 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %217, 0
  %219 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %217, 1
  %220 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %217, 2
  %221 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %217, 3
  %222 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %217, 4
  store { i64, [72 x i8] } %222, ptr %35, align 8
  %223 = load i1, ptr %35, align 1
  switch i1 %223, label %234 [
    i1 false, label %236
    i1 true, label %252
  ]

224:                                              ; preds = %134
  %225 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %33, align 8
  %226 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %225, 1
  call void @"drop$284"({ ptr, i32, i32, i32 } %7)
  %227 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %226, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %227, ptr %34, align 8
  %228 = load { i64, [24 x i8] }, ptr %34, align 8
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %169, 0
  %230 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %229, i64 %170, 1
  %231 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %230, i64 %39, 2
  %232 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %231, ptr %3, 3
  %233 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %232, { i64, [24 x i8] } %228, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %233

234:                                              ; preds = %201
  br i1 false, label %235, label %315

235:                                              ; preds = %234
  unreachable

236:                                              ; preds = %201
  %237 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %35, align 8
  %238 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %237, 1
  %239 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %240 = call ptr %239()
  %241 = call i64 @llvm.uadd.sat.i64(i64 %219, i64 0)
  %242 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %238, 0
  %243 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %238, 1
  call void @"drop$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %242)
  %244 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %243, 0
  %245 = insertvalue { i1, { { ptr, i32, i32, i32 } } } { i1 false, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %244, 1
  store { i1, { { ptr, i32, i32, i32 } } } %245, ptr %37, align 8
  %246 = load { i64, [24 x i8] }, ptr %37, align 8
  %247 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %218, 0
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %247, i64 %241, 1
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, i64 %220, 2
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, ptr %221, 3
  %251 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %250, { i64, [24 x i8] } %246, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %251

252:                                              ; preds = %201
  %253 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %35, align 8
  %254 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %253, 1
  %255 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %254, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %255, ptr %36, align 8
  %256 = load { i64, [24 x i8] }, ptr %36, align 8
  %257 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %218, 0
  %258 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %257, i64 %219, 1
  %259 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %258, i64 %220, 2
  %260 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %259, ptr %221, 3
  %261 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %260, { i64, [24 x i8] } %256, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %261

262:                                              ; preds = %173
  br i1 false, label %263, label %316

263:                                              ; preds = %262
  unreachable

264:                                              ; preds = %173
  %265 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } }, ptr %25, align 16
  %266 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %265, 1
  %267 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %268 = call ptr %267()
  %269 = load i64, ptr %268, align 8
  %270 = mul i64 %269, 5070
  %271 = call i64 @llvm.uadd.sat.i64(i64 %194, i64 %270)
  %272 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %266, 0
  %273 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %266, 1
  call void @"drop$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %272)
  %274 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %273, 0
  %275 = insertvalue { i1, { { ptr, i32, i32, i32 } } } { i1 false, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %274, 1
  store { i1, { { ptr, i32, i32, i32 } } } %275, ptr %27, align 8
  %276 = load { i64, [24 x i8] }, ptr %27, align 8
  %277 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %193, 0
  %278 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %277, i64 %271, 1
  %279 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %278, i64 %195, 2
  %280 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %279, ptr %196, 3
  %281 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %280, { i64, [24 x i8] } %276, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %281

282:                                              ; preds = %173
  %283 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %25, align 8
  %284 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %283, 1
  %285 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %284, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %285, ptr %26, align 8
  %286 = load { i64, [24 x i8] }, ptr %26, align 8
  %287 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %193, 0
  %288 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %287, i64 %194, 1
  %289 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %288, i64 %195, 2
  %290 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %289, ptr %196, 3
  %291 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %290, { i64, [24 x i8] } %286, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %291

292:                                              ; preds = %74
  %293 = phi { ptr, i32, i32, i32 } [ %7, %74 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %293)
  %294 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %105, 1
  %295 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %294, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %295, ptr %21, align 8
  %296 = load { i64, [24 x i8] }, ptr %21, align 8
  %297 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %44, 0
  %298 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %297, i64 %106, 1
  %299 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %298, i64 %39, 2
  %300 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %299, ptr %3, 3
  %301 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %300, { i64, [24 x i8] } %296, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %301

302:                                              ; preds = %8
  %303 = phi { ptr, i32, i32, i32 } [ %7, %8 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %303)
  %304 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %56, 1
  %305 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %304, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %305, ptr %15, align 8
  %306 = load { i64, [24 x i8] }, ptr %15, align 8
  %307 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %44, 0
  %308 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %307, i64 %57, 1
  %309 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %308, i64 %39, 2
  %310 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %309, ptr %3, 3
  %311 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %310, { i64, [24 x i8] } %306, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %311

312:                                              ; preds = %114
  call void @puts(ptr @assert_msg_43)
  call void @abort()
  unreachable

313:                                              ; preds = %132
  call void @puts(ptr @assert_msg_44)
  call void @abort()
  unreachable

314:                                              ; preds = %199
  call void @puts(ptr @assert_msg_45)
  call void @abort()
  unreachable

315:                                              ; preds = %234
  call void @puts(ptr @assert_msg_46)
  call void @abort()
  unreachable

316:                                              ; preds = %262
  call void @puts(ptr @assert_msg_47)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f19(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, { i128, i128 } %6, { ptr, i32, i32, i32 } %7) {
  %9 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f19"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, { i128, i128 } %6, { ptr, i32, i32, i32 } %7)
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 4
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %10, 0
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %11, 1
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %12, 2
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %13, 3
  %19 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %14, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f19(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f19(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %10, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %12

12:                                               ; preds = %83, %4
  %13 = phi i64 [ %17, %83 ], [ %0, %4 ]
  %14 = phi i64 [ %42, %83 ], [ %1, %4 ]
  %15 = phi { { ptr, i32, i32, i32 } } [ %94, %83 ], [ %2, %4 ]
  %16 = phi { ptr, i32, i32, i32 } [ %92, %83 ], [ %3, %4 ]
  %17 = add i64 %13, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 1570
  %22 = icmp uge i64 %14, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %14, i64 %21)
  br i1 %22, label %24, label %131

24:                                               ; preds = %12
  %25 = phi { { ptr, i32, i32, i32 } } [ %15, %12 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %112

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 0)
  %43 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %44 = extractvalue { ptr, i32, i32, i32 } %16, 3
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %60

46:                                               ; preds = %31
  %47 = shl i32 %44, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %44
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = call ptr @realloc(ptr null, i64 %53)
  store i32 1, ptr %54, align 4
  %55 = getelementptr inbounds i8, ptr %54, i32 4
  store i32 0, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %54, i32 16
  %57 = call ptr @realloc(ptr null, i64 8)
  store ptr %56, ptr %57, align 8
  %58 = insertvalue { ptr, i32, i32, i32 } %16, ptr %57, 0
  %59 = insertvalue { ptr, i32, i32, i32 } %58, i32 %50, 3
  br label %81

60:                                               ; preds = %31
  %61 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %62 = icmp ult i32 %61, %44
  br i1 %62, label %63, label %64

63:                                               ; preds = %60
  br label %78

64:                                               ; preds = %60
  %65 = shl i32 %44, 1
  %66 = call i32 @llvm.umin.i32(i32 %65, i32 1024)
  %67 = add i32 %66, %44
  %68 = call i32 @llvm.umax.i32(i32 %67, i32 8)
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = add i64 %70, 16
  %72 = extractvalue { ptr, i32, i32, i32 } %16, 0
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %73, i32 -16
  %75 = call ptr @realloc(ptr %74, i64 %71)
  %76 = getelementptr inbounds i8, ptr %75, i32 16
  store ptr %76, ptr %72, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } %16, i32 %68, 3
  br label %78

78:                                               ; preds = %63, %64
  %79 = phi { ptr, i32, i32, i32 } [ %77, %64 ], [ %16, %63 ]
  br label %80

80:                                               ; preds = %78
  br label %81

81:                                               ; preds = %46, %80
  %82 = phi { ptr, i32, i32, i32 } [ %79, %80 ], [ %59, %46 ]
  br label %83

83:                                               ; preds = %81
  %84 = extractvalue { ptr, i32, i32, i32 } %82, 0
  %85 = load ptr, ptr %84, align 8
  %86 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %87 = zext i32 %86 to i64
  %88 = mul i64 %87, 32
  %89 = getelementptr inbounds i8, ptr %85, i64 %88
  store i252 %43, ptr %89, align 16
  %90 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %91 = add i32 %90, 1
  %92 = insertvalue { ptr, i32, i32, i32 } %82, i32 %91, 2
  %93 = getelementptr inbounds i8, ptr %85, i32 -12
  store i32 %91, ptr %93, align 4
  %94 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %38, 0
  %95 = extractvalue { ptr, ptr, i64 } %8, 1
  %96 = load i64, ptr %95, align 8
  %97 = add i64 %96, 1
  %98 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %97, ptr %98, align 8
  br label %12

99:                                               ; preds = %99, %112, %131
  %100 = phi i64 [ %17, %131 ], [ %17, %112 ], [ %100, %99 ]
  %101 = phi i64 [ %14, %131 ], [ %118, %112 ], [ %101, %99 ]
  %102 = phi { i64, [24 x i8] } [ %136, %131 ], [ %121, %112 ], [ %102, %99 ]
  %103 = extractvalue { ptr, ptr, i64 } %8, 1
  %104 = load i64, ptr %103, align 8
  %105 = icmp eq i64 %104, 0
  %106 = sub i64 %104, 1
  %107 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %106, ptr %107, align 8
  br i1 %105, label %108, label %99

108:                                              ; preds = %99
  %109 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %100, 0
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } %109, i64 %101, 1
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, { i64, [24 x i8] } %102, 2
  ret { i64, i64, { i64, [24 x i8] } } %111

112:                                              ; preds = %24
  %113 = phi { ptr, i32, i32, i32 } [ %26, %24 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %113)
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = load i64, ptr %115, align 8
  %117 = mul i64 %116, 2270
  %118 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %117)
  %119 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %16, 0
  %120 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %119, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %120, ptr %11, align 8
  %121 = load { i64, [24 x i8] }, ptr %11, align 8
  %122 = extractvalue { ptr, ptr, i64 } %8, 1
  %123 = load i64, ptr %122, align 8
  %124 = icmp eq i64 %123, 0
  %125 = sub i64 %123, 1
  %126 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %125, ptr %126, align 8
  br i1 %124, label %127, label %99

127:                                              ; preds = %112
  %128 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %129 = insertvalue { i64, i64, { i64, [24 x i8] } } %128, i64 %118, 1
  %130 = insertvalue { i64, i64, { i64, [24 x i8] } } %129, { i64, [24 x i8] } %121, 2
  ret { i64, i64, { i64, [24 x i8] } } %130

131:                                              ; preds = %12
  %132 = phi { ptr, i32, i32, i32 } [ %16, %12 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %132)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %15)
  %133 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %134 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %133, 0
  %135 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %134, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %135, ptr %10, align 8
  %136 = load { i64, [24 x i8] }, ptr %10, align 8
  %137 = extractvalue { ptr, ptr, i64 } %8, 1
  %138 = load i64, ptr %137, align 8
  %139 = icmp eq i64 %138, 0
  %140 = sub i64 %138, 1
  %141 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %140, ptr %141, align 8
  br i1 %139, label %142, label %99

142:                                              ; preds = %131
  %143 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %144 = insertvalue { i64, i64, { i64, [24 x i8] } } %143, i64 %14, 1
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } %144, { i64, [24 x i8] } %136, 2
  ret { i64, i64, { i64, [24 x i8] } } %145
}

define private { i64, i64, { i64, [24 x i8] } } @f20(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f20(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f20(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f21"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 485748461484230571791265682659113160264223489397539653310998840191492915)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f21() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f21"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f21(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f21()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f22"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = alloca i256, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca { i1, [47 x i8] }, i64 1, align 16
  %14 = alloca i64, i64 1, align 8
  %15 = alloca i252, i64 1, align 16
  %16 = alloca { i64, [40 x i8] }, i64 1, align 8
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca i252, i64 1, align 16
  %20 = alloca i252, i64 1, align 16
  %21 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %22 = alloca { i64, [40 x i8] }, i64 1, align 8
  %23 = alloca { i32, [24 x i8] }, i64 1, align 4
  %24 = alloca { i64, [40 x i8] }, i64 1, align 8
  %25 = alloca { i32, [20 x i8] }, i64 1, align 4
  %26 = alloca { i128, [96 x i8] }, i64 1, align 16
  %27 = alloca { i64, [40 x i8] }, i64 1, align 8
  %28 = alloca { i64, [24 x i8] }, i64 1, align 8
  %29 = alloca { i64, [40 x i8] }, i64 1, align 8
  %30 = alloca { i64, [40 x i8] }, i64 1, align 8
  %31 = alloca { i32, [4 x i8] }, i64 1, align 4
  %32 = alloca { i32, [4 x i8] }, i64 1, align 4
  %33 = alloca { i32, [4 x i8] }, i64 1, align 4
  %34 = alloca { i32, [4 x i8] }, i64 1, align 4
  %35 = alloca { i32, [4 x i8] }, i64 1, align 4
  %36 = alloca { i64, [48 x i8] }, i64 1, align 8
  %37 = alloca { i64, [40 x i8] }, i64 1, align 8
  %38 = alloca { i64, [72 x i8] }, i64 1, align 8
  %39 = alloca { i64, [40 x i8] }, i64 1, align 8
  %40 = alloca { i64, [40 x i8] }, i64 1, align 8
  %41 = add i64 %3, 3
  %42 = zext i252 %6 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %10, align 16
  store i256 %42, ptr %11, align 16
  %43 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %43(ptr %12, ptr %10, ptr %11)
  %44 = load i256, ptr %12, align 16
  %45 = trunc i256 %44 to i252
  %46 = add i64 %0, 3
  %47 = sub i252 %45, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %48 = icmp ult i252 %45, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %49 = select i1 %48, i252 %45, i252 %47
  %50 = load ptr, ptr %4, align 8
  store i64 %1, ptr %14, align 8
  store i252 %49, ptr %15, align 16
  %51 = getelementptr inbounds ptr, ptr %4, i32 8
  %52 = load ptr, ptr %51, align 8
  call void %52(ptr %13, ptr %50, ptr %14, i32 0, ptr %15)
  %53 = load { i1, [47 x i8] }, ptr %13, align 1
  %54 = extractvalue { i1, [47 x i8] } %53, 0
  %55 = getelementptr inbounds i8, ptr %13, i32 16
  %56 = load i252, ptr %55, align 16
  %57 = getelementptr inbounds i8, ptr %13, i32 8
  %58 = load { ptr, i32, i32, i32 }, ptr %57, align 8
  %59 = load i64, ptr %14, align 8
  br i1 %54, label %355, label %60

60:                                               ; preds = %9
  %61 = phi i252 [ %56, %9 ]
  %62 = icmp eq i252 %61, 0
  br i1 %62, label %63, label %77

63:                                               ; preds = %60
  %64 = phi { ptr, i32, i32, i32 } [ %8, %60 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %64)
  %65 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f43"()
  %66 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %65, 0
  %67 = extractvalue { {}, { ptr, i32, i32, i32 } } %66, 1
  %68 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %67, 1
  %69 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %68, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %69, ptr %40, align 8
  %70 = load { i64, [40 x i8] }, ptr %40, align 8
  %71 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %46, 0
  %72 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %71, i64 %59, 1
  %73 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %72, i64 %2, 2
  %74 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %73, i64 %41, 3
  %75 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %74, ptr %4, 4
  %76 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %75, { i64, [40 x i8] } %70, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %76

77:                                               ; preds = %60
  %78 = phi { i128, i128 } [ %7, %60 ]
  %79 = extractvalue { i128, i128 } %78, 0
  %80 = zext i128 %79 to i252
  %81 = extractvalue { i128, i128 } %78, 1
  %82 = zext i128 %81 to i252
  %83 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %83, align 4
  %84 = getelementptr inbounds i8, ptr %83, i32 4
  store i32 0, ptr %84, align 4
  %85 = getelementptr inbounds i8, ptr %83, i32 16
  %86 = call ptr @realloc(ptr null, i64 8)
  store ptr %85, ptr %86, align 8
  %87 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %86, 0
  %88 = insertvalue { ptr, i32, i32, i32 } %87, i32 8, 3
  %89 = load ptr, ptr %86, align 8
  store i252 %80, ptr %89, align 16
  %90 = insertvalue { ptr, i32, i32, i32 } %88, i32 1, 2
  %91 = getelementptr inbounds i8, ptr %89, i32 -12
  store i32 1, ptr %91, align 4
  %92 = load ptr, ptr %86, align 8
  %93 = getelementptr inbounds i8, ptr %92, i32 32
  store i252 %82, ptr %93, align 16
  %94 = insertvalue { ptr, i32, i32, i32 } %90, i32 2, 2
  %95 = getelementptr inbounds i8, ptr %92, i32 -12
  store i32 2, ptr %95, align 4
  %96 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %94)
  %97 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %96, 0
  %98 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %96, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %97)
  %99 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %98, 0
  %100 = load ptr, ptr %4, align 8
  store i64 %59, ptr %18, align 8
  store i252 %6, ptr %19, align 16
  store i252 198245171877110614431632758327373800976566065571148526819123645061251396147, ptr %20, align 16
  store { { ptr, i32, i32, i32 } } %99, ptr %21, align 8
  %101 = getelementptr inbounds ptr, ptr %4, i32 7
  %102 = load ptr, ptr %101, align 8
  call void %102(ptr %17, ptr %100, ptr %18, ptr %19, ptr %20, ptr %21)
  %103 = load { i1, [31 x i8] }, ptr %17, align 1
  %104 = extractvalue { i1, [31 x i8] } %103, 0
  %105 = getelementptr inbounds i8, ptr %17, i32 8
  %106 = load { { ptr, i32, i32, i32 } }, ptr %105, align 8
  %107 = getelementptr inbounds i8, ptr %17, i32 8
  %108 = load { ptr, i32, i32, i32 }, ptr %107, align 8
  %109 = load i64, ptr %18, align 8
  br i1 %104, label %344, label %110

110:                                              ; preds = %77
  %111 = phi i64 [ %46, %77 ]
  %112 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f44"(i64 %111, { { ptr, i32, i32, i32 } } %106)
  %113 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %112, 0
  %114 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %112, 1
  %115 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %112, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %114)
  store { i32, [24 x i8] } %115, ptr %23, align 4
  %116 = load i1, ptr %23, align 1
  switch i1 %116, label %117 [
    i1 false, label %119
    i1 true, label %123
  ]

117:                                              ; preds = %110
  br i1 false, label %118, label %366

118:                                              ; preds = %117
  unreachable

119:                                              ; preds = %110
  %120 = load { i1, { i32, [20 x i8] } }, ptr %23, align 4
  %121 = extractvalue { i1, { i32, [20 x i8] } } %120, 1
  store { i32, [20 x i8] } %121, ptr %25, align 4
  %122 = load i1, ptr %25, align 1
  switch i1 %122, label %136 [
    i1 false, label %138
    i1 true, label %177
  ]

123:                                              ; preds = %110
  call void @"drop$284"({ ptr, i32, i32, i32 } %8)
  %124 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"()
  %125 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %124, 0
  %126 = extractvalue { {}, { ptr, i32, i32, i32 } } %125, 1
  %127 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %126, 1
  %128 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %127, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %128, ptr %24, align 8
  %129 = load { i64, [40 x i8] }, ptr %24, align 8
  %130 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %113, 0
  %131 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %130, i64 %109, 1
  %132 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %131, i64 %2, 2
  %133 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %132, i64 %41, 3
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %133, ptr %4, 4
  %135 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %134, { i64, [40 x i8] } %129, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %135

136:                                              ; preds = %119
  br i1 false, label %137, label %367

137:                                              ; preds = %136
  unreachable

138:                                              ; preds = %119
  %139 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %25, align 4
  %140 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %139, 1
  %141 = extractvalue { i32, i32, i32, i32, i32 } %140, 0
  %142 = insertvalue { i3, i32 } { i3 1, i32 undef }, i32 %141, 1
  store { i3, i32 } %142, ptr %31, align 4
  %143 = load { i32, [4 x i8] }, ptr %31, align 4
  %144 = extractvalue { i32, i32, i32, i32, i32 } %140, 1
  %145 = insertvalue { i3, i32 } { i3 2, i32 undef }, i32 %144, 1
  store { i3, i32 } %145, ptr %32, align 4
  %146 = load { i32, [4 x i8] }, ptr %32, align 4
  %147 = extractvalue { i32, i32, i32, i32, i32 } %140, 2
  %148 = insertvalue { i3, i32 } { i3 3, i32 undef }, i32 %147, 1
  store { i3, i32 } %148, ptr %33, align 4
  %149 = load { i32, [4 x i8] }, ptr %33, align 4
  %150 = extractvalue { i32, i32, i32, i32, i32 } %140, 3
  %151 = insertvalue { i3, i32 } { i3 -4, i32 undef }, i32 %150, 1
  store { i3, i32 } %151, ptr %34, align 4
  %152 = load { i32, [4 x i8] }, ptr %34, align 4
  %153 = extractvalue { i32, i32, i32, i32, i32 } %140, 4
  %154 = insertvalue { i3, i32 } { i3 -3, i32 undef }, i32 %153, 1
  store { i3, i32 } %154, ptr %35, align 4
  %155 = load { i32, [4 x i8] }, ptr %35, align 4
  %156 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } undef, { i32, [4 x i8] } %143, 0
  %157 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %156, { i32, [4 x i8] } %146, 1
  %158 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %157, { i32, [4 x i8] } %149, 2
  %159 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %158, { i32, [4 x i8] } %152, 3
  %160 = insertvalue { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %159, { i32, [4 x i8] } %155, 4
  %161 = call ptr @realloc(ptr null, i64 40)
  store { { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] }, { i32, [4 x i8] } } %160, ptr %161, align 4
  %162 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 5 }, ptr %162, align 4
  %163 = getelementptr inbounds i8, ptr %162, i32 8
  call void @llvm.memcpy.p0.p0.i64(ptr %163, ptr %161, i64 40, i1 false)
  call void @free(ptr %161)
  %164 = call ptr @realloc(ptr null, i64 8)
  store ptr %163, ptr %164, align 8
  %165 = insertvalue { ptr, i32, i32, i32 } undef, ptr %164, 0
  %166 = insertvalue { ptr, i32, i32, i32 } %165, i32 0, 1
  %167 = insertvalue { ptr, i32, i32, i32 } %166, i32 5, 2
  %168 = insertvalue { ptr, i32, i32, i32 } %167, i32 5, 3
  %169 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %168, 0
  %170 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %169, 0
  %171 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %170, 0
  %172 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f45"(i64 %113, i64 %109, { { { { ptr, i32, i32, i32 } } }, {} } %171, { ptr, i32, i32, i32 } zeroinitializer)
  %173 = extractvalue { i64, i64, { i64, [48 x i8] } } %172, 0
  %174 = extractvalue { i64, i64, { i64, [48 x i8] } } %172, 1
  %175 = extractvalue { i64, i64, { i64, [48 x i8] } } %172, 2
  store { i64, [48 x i8] } %175, ptr %36, align 8
  %176 = load i1, ptr %36, align 1
  switch i1 %176, label %212 [
    i1 false, label %214
    i1 true, label %240
  ]

177:                                              ; preds = %119
  %178 = load { i1, i32 }, ptr %25, align 4
  %179 = extractvalue { i1, i32 } %178, 1
  %180 = zext i32 %179 to i256
  %181 = add i256 %180, 25769803776
  %182 = add i256 %180, -3618502788666131213697322783095070105623107215331596699973092056110102216705
  %183 = icmp uge i256 %181, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %184 = select i1 %183, i256 %182, i256 %181
  %185 = trunc i256 %184 to i252
  %186 = insertvalue { i252 } undef, i252 %185, 0
  %187 = call ptr @realloc(ptr null, i64 32)
  store { i252 } %186, ptr %187, align 16
  %188 = call ptr @realloc(ptr null, i64 48)
  store { i32, i32 } { i32 1, i32 1 }, ptr %188, align 4
  %189 = getelementptr inbounds i8, ptr %188, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %189, ptr %187, i64 32, i1 false)
  call void @free(ptr %187)
  %190 = call ptr @realloc(ptr null, i64 8)
  store ptr %189, ptr %190, align 8
  %191 = insertvalue { ptr, i32, i32, i32 } undef, ptr %190, 0
  %192 = insertvalue { ptr, i32, i32, i32 } %191, i32 0, 1
  %193 = insertvalue { ptr, i32, i32, i32 } %192, i32 1, 2
  %194 = insertvalue { ptr, i32, i32, i32 } %193, i32 1, 3
  %195 = zext i252 %185 to i512
  %196 = mul i512 %195, 4294967296
  %197 = urem i512 %196, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %198 = icmp uge i512 %196, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %199 = select i1 %198, i512 %197, i512 %196
  %200 = trunc i512 %199 to i252
  %201 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %8, 0
  %202 = insertvalue { { {} }, i252 } undef, i252 %200, 1
  %203 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } undef, { { ptr, i32, i32, i32 } } %201, 0
  %204 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %203, { { {} }, i252 } %202, 1
  %205 = call fastcc { i64, i64, i64, ptr, { i128, [96 x i8] } } @"impl$f50"(i64 %113, i64 %109, i64 %41, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %204, { ptr, i32, i32, i32 } zeroinitializer)
  %206 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %205, 0
  %207 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %205, 1
  %208 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %205, 2
  %209 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %205, 3
  %210 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %205, 4
  store { i128, [96 x i8] } %210, ptr %26, align 16
  %211 = load i1, ptr %26, align 1
  switch i1 %211, label %272 [
    i1 false, label %274
    i1 true, label %284
  ]

212:                                              ; preds = %138
  br i1 false, label %213, label %368

213:                                              ; preds = %212
  unreachable

214:                                              ; preds = %138
  %215 = load { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } }, ptr %36, align 8
  %216 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %215, 1
  %217 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %216, 0
  %218 = extractvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %216, 1
  call void @"drop$467"({ { { { ptr, i32, i32, i32 } } }, {} } %217)
  %219 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %218)
  %220 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %219, 0
  %221 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %219, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %220)
  %222 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %221)
  %223 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %222, 0
  %224 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %222, 1
  %225 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %224, 0
  %226 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %225)
  %227 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %226, 0
  %228 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %226, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %227)
  %229 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %8, 0
  %230 = insertvalue { { {} }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %228, 1
  %231 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %229, 0
  %232 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %231, { { {} }, { { ptr, i32, i32, i32 } } } %230, 1
  %233 = call fastcc { i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f49"(i64 %173, i64 %174, i64 %41, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %232, { ptr, i32, i32, i32 } zeroinitializer)
  %234 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %233, 0
  %235 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %233, 1
  %236 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %233, 2
  %237 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %233, 3
  %238 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %233, 4
  store { i64, [72 x i8] } %238, ptr %38, align 8
  %239 = load i1, ptr %38, align 1
  switch i1 %239, label %251 [
    i1 false, label %253
    i1 true, label %261
  ]

240:                                              ; preds = %138
  %241 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %36, align 8
  %242 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %241, 1
  call void @"drop$284"({ ptr, i32, i32, i32 } %8)
  %243 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %242, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %243, ptr %37, align 8
  %244 = load { i64, [40 x i8] }, ptr %37, align 8
  %245 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %173, 0
  %246 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %245, i64 %174, 1
  %247 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %246, i64 %2, 2
  %248 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %247, i64 %41, 3
  %249 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %248, ptr %4, 4
  %250 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %249, { i64, [40 x i8] } %244, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %250

251:                                              ; preds = %214
  br i1 false, label %252, label %369

252:                                              ; preds = %251
  unreachable

253:                                              ; preds = %214
  %254 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } }, ptr %38, align 8
  %255 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %254, 1
  %256 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %257 = call ptr %256()
  %258 = call i64 @llvm.uadd.sat.i64(i64 %235, i64 0)
  %259 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %255, 0
  %260 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %255, 1
  call void @"drop$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %259)
  br label %295

261:                                              ; preds = %214
  %262 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %38, align 8
  %263 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %262, 1
  call void @"drop$3"({ ptr, i32, i32, i32 } %223)
  %264 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %263, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %264, ptr %39, align 8
  %265 = load { i64, [40 x i8] }, ptr %39, align 8
  %266 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %234, 0
  %267 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %266, i64 %235, 1
  %268 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %267, i64 %2, 2
  %269 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %268, i64 %236, 3
  %270 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %269, ptr %237, 4
  %271 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %270, { i64, [40 x i8] } %265, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %271

272:                                              ; preds = %177
  br i1 false, label %273, label %371

273:                                              ; preds = %272
  unreachable

274:                                              ; preds = %177
  %275 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } }, ptr %26, align 16
  %276 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %275, 1
  %277 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %278 = call ptr %277()
  %279 = load i64, ptr %278, align 8
  %280 = mul i64 %279, 5070
  %281 = call i64 @llvm.uadd.sat.i64(i64 %207, i64 %280)
  %282 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %276, 0
  %283 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %276, 1
  call void @"drop$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %282)
  br label %295

284:                                              ; preds = %177
  %285 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %26, align 8
  %286 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %285, 1
  call void @"drop$3"({ ptr, i32, i32, i32 } %194)
  %287 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %286, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %287, ptr %27, align 8
  %288 = load { i64, [40 x i8] }, ptr %27, align 8
  %289 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %206, 0
  %290 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %289, i64 %207, 1
  %291 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %290, i64 %2, 2
  %292 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %291, i64 %208, 3
  %293 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %292, ptr %209, 4
  %294 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %293, { i64, [40 x i8] } %288, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %294

295:                                              ; preds = %253, %274
  %296 = phi i64 [ %2, %274 ], [ %2, %253 ]
  %297 = phi { {} } [ %5, %274 ], [ %5, %253 ]
  %298 = phi { ptr, i32, i32, i32 } [ %283, %274 ], [ %260, %253 ]
  %299 = phi i64 [ %206, %274 ], [ %234, %253 ]
  %300 = phi i64 [ %281, %274 ], [ %258, %253 ]
  %301 = phi i64 [ %208, %274 ], [ %236, %253 ]
  %302 = phi ptr [ %209, %274 ], [ %237, %253 ]
  %303 = phi { ptr, i32, i32, i32 } [ %194, %274 ], [ %223, %253 ]
  %304 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %303, 0
  %305 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f46"(i64 %299, i64 %300, i64 %296, i64 %301, ptr %302, { {} } %297, { { ptr, i32, i32, i32 } } %304)
  %306 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, 0
  %307 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, 1
  %308 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, 2
  %309 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, 3
  %310 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, 4
  %311 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %305, 5
  store { i64, [24 x i8] } %311, ptr %28, align 8
  %312 = load i1, ptr %28, align 1
  switch i1 %312, label %313 [
    i1 false, label %315
    i1 true, label %333
  ]

313:                                              ; preds = %295
  br i1 false, label %314, label %370

314:                                              ; preds = %313
  unreachable

315:                                              ; preds = %295
  %316 = load { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } }, ptr %28, align 2
  %317 = extractvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %316, 1
  %318 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %319 = call ptr %318()
  %320 = call i64 @llvm.uadd.sat.i64(i64 %307, i64 0)
  %321 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %317, 0
  %322 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %321, 0
  %323 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %322, { ptr, i32, i32, i32 } %298, 1
  %324 = insertvalue { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %323, 0
  %325 = insertvalue { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } { i1 false, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef }, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %324, 1
  store { i1, { { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } } %325, ptr %30, align 8
  %326 = load { i64, [40 x i8] }, ptr %30, align 8
  %327 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %306, 0
  %328 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %327, i64 %320, 1
  %329 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %328, i64 %308, 2
  %330 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %329, i64 %309, 3
  %331 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %330, ptr %310, 4
  %332 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %331, { i64, [40 x i8] } %326, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %332

333:                                              ; preds = %295
  %334 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %28, align 8
  %335 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %334, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %298)
  %336 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %335, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %336, ptr %29, align 8
  %337 = load { i64, [40 x i8] }, ptr %29, align 8
  %338 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %306, 0
  %339 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %338, i64 %307, 1
  %340 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %339, i64 %308, 2
  %341 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %340, i64 %309, 3
  %342 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %341, ptr %310, 4
  %343 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %342, { i64, [40 x i8] } %337, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %343

344:                                              ; preds = %77
  %345 = phi { ptr, i32, i32, i32 } [ %8, %77 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %345)
  %346 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %108, 1
  %347 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %346, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %347, ptr %22, align 8
  %348 = load { i64, [40 x i8] }, ptr %22, align 8
  %349 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %46, 0
  %350 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %349, i64 %109, 1
  %351 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %350, i64 %2, 2
  %352 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %351, i64 %41, 3
  %353 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %352, ptr %4, 4
  %354 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %353, { i64, [40 x i8] } %348, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %354

355:                                              ; preds = %9
  %356 = phi { ptr, i32, i32, i32 } [ %8, %9 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %356)
  %357 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 1
  %358 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %357, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %358, ptr %16, align 8
  %359 = load { i64, [40 x i8] }, ptr %16, align 8
  %360 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %46, 0
  %361 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %360, i64 %59, 1
  %362 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %361, i64 %2, 2
  %363 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %362, i64 %41, 3
  %364 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %363, ptr %4, 4
  %365 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %364, { i64, [40 x i8] } %359, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %365

366:                                              ; preds = %117
  call void @puts(ptr @assert_msg_48)
  call void @abort()
  unreachable

367:                                              ; preds = %136
  call void @puts(ptr @assert_msg_49)
  call void @abort()
  unreachable

368:                                              ; preds = %212
  call void @puts(ptr @assert_msg_50)
  call void @abort()
  unreachable

369:                                              ; preds = %251
  call void @puts(ptr @assert_msg_51)
  call void @abort()
  unreachable

370:                                              ; preds = %313
  call void @puts(ptr @assert_msg_52)
  call void @abort()
  unreachable

371:                                              ; preds = %272
  call void @puts(ptr @assert_msg_53)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f22(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f22"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, { i128, i128 } %7, { ptr, i32, i32, i32 } %8)
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, 2
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, 3
  %15 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, 4
  %16 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %10, 5
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %11, 0
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %17, i64 %12, 1
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %18, i64 %13, 2
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %19, i64 %14, 3
  %21 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %20, ptr %15, 4
  %22 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %21, { i64, [40 x i8] } %16, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %22
}

define void @_mlir_ciface_f22(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f22(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, i252 %7, { i128, i128 } %8, { ptr, i32, i32, i32 } %9)
  store { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %11, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f23"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i16, [14 x i8] }, i64 1, align 2
  %4 = alloca { i16, [14 x i8] }, i64 1, align 2
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %254

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp ult i252 %19, 256
  %21 = add i64 %0, 2
  %22 = add i64 %0, 3
  %23 = select i1 %20, i64 %21, i64 %22
  %24 = trunc i252 %19 to i8
  br i1 %20, label %25, label %254

25:                                               ; preds = %10
  %26 = phi { ptr, i32, i32, i32 } [ %17, %10 ]
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %254

31:                                               ; preds = %25
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %41 = icmp ult i252 %40, 256
  %42 = add i64 %23, 2
  %43 = add i64 %23, 3
  %44 = select i1 %41, i64 %42, i64 %43
  %45 = trunc i252 %40 to i8
  br i1 %41, label %46, label %254

46:                                               ; preds = %31
  %47 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %52, label %254

52:                                               ; preds = %46
  %53 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %54 = load ptr, ptr %53, align 8
  %55 = zext i32 %48 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %54, i64 %56
  %58 = add i32 %48, 1
  %59 = insertvalue { ptr, i32, i32, i32 } %47, i32 %58, 1
  %60 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %60, ptr %57, i64 32, i1 false)
  %61 = load i252, ptr %60, align 16
  call void @free(ptr %60)
  %62 = icmp ult i252 %61, 256
  %63 = add i64 %44, 2
  %64 = add i64 %44, 3
  %65 = select i1 %62, i64 %63, i64 %64
  %66 = trunc i252 %61 to i8
  br i1 %62, label %67, label %254

67:                                               ; preds = %52
  %68 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  %69 = extractvalue { ptr, i32, i32, i32 } %68, 1
  %70 = extractvalue { ptr, i32, i32, i32 } %68, 2
  %71 = sub i32 %70, %69
  %72 = icmp uge i32 %71, 1
  br i1 %72, label %73, label %254

73:                                               ; preds = %67
  %74 = extractvalue { ptr, i32, i32, i32 } %68, 0
  %75 = load ptr, ptr %74, align 8
  %76 = zext i32 %69 to i64
  %77 = mul i64 %76, 32
  %78 = getelementptr inbounds i8, ptr %75, i64 %77
  %79 = add i32 %69, 1
  %80 = insertvalue { ptr, i32, i32, i32 } %68, i32 %79, 1
  %81 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %81, ptr %78, i64 32, i1 false)
  %82 = load i252, ptr %81, align 16
  call void @free(ptr %81)
  %83 = icmp ult i252 %82, 256
  %84 = add i64 %65, 2
  %85 = add i64 %65, 3
  %86 = select i1 %83, i64 %84, i64 %85
  %87 = trunc i252 %82 to i8
  br i1 %83, label %88, label %254

88:                                               ; preds = %73
  %89 = phi { ptr, i32, i32, i32 } [ %80, %73 ]
  %90 = extractvalue { ptr, i32, i32, i32 } %89, 1
  %91 = extractvalue { ptr, i32, i32, i32 } %89, 2
  %92 = sub i32 %91, %90
  %93 = icmp uge i32 %92, 1
  br i1 %93, label %94, label %254

94:                                               ; preds = %88
  %95 = extractvalue { ptr, i32, i32, i32 } %89, 0
  %96 = load ptr, ptr %95, align 8
  %97 = zext i32 %90 to i64
  %98 = mul i64 %97, 32
  %99 = getelementptr inbounds i8, ptr %96, i64 %98
  %100 = add i32 %90, 1
  %101 = insertvalue { ptr, i32, i32, i32 } %89, i32 %100, 1
  %102 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %102, ptr %99, i64 32, i1 false)
  %103 = load i252, ptr %102, align 16
  call void @free(ptr %102)
  %104 = icmp ult i252 %103, 256
  %105 = add i64 %86, 2
  %106 = add i64 %86, 3
  %107 = select i1 %104, i64 %105, i64 %106
  %108 = trunc i252 %103 to i8
  br i1 %104, label %109, label %254

109:                                              ; preds = %94
  %110 = phi { ptr, i32, i32, i32 } [ %101, %94 ]
  %111 = extractvalue { ptr, i32, i32, i32 } %110, 1
  %112 = extractvalue { ptr, i32, i32, i32 } %110, 2
  %113 = sub i32 %112, %111
  %114 = icmp uge i32 %113, 1
  br i1 %114, label %115, label %254

115:                                              ; preds = %109
  %116 = extractvalue { ptr, i32, i32, i32 } %110, 0
  %117 = load ptr, ptr %116, align 8
  %118 = zext i32 %111 to i64
  %119 = mul i64 %118, 32
  %120 = getelementptr inbounds i8, ptr %117, i64 %119
  %121 = add i32 %111, 1
  %122 = insertvalue { ptr, i32, i32, i32 } %110, i32 %121, 1
  %123 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %123, ptr %120, i64 32, i1 false)
  %124 = load i252, ptr %123, align 16
  call void @free(ptr %123)
  %125 = icmp ult i252 %124, 256
  %126 = add i64 %107, 2
  %127 = add i64 %107, 3
  %128 = select i1 %125, i64 %126, i64 %127
  %129 = trunc i252 %124 to i8
  br i1 %125, label %130, label %254

130:                                              ; preds = %115
  %131 = phi { ptr, i32, i32, i32 } [ %122, %115 ]
  %132 = extractvalue { ptr, i32, i32, i32 } %131, 1
  %133 = extractvalue { ptr, i32, i32, i32 } %131, 2
  %134 = sub i32 %133, %132
  %135 = icmp uge i32 %134, 1
  br i1 %135, label %136, label %254

136:                                              ; preds = %130
  %137 = extractvalue { ptr, i32, i32, i32 } %131, 0
  %138 = load ptr, ptr %137, align 8
  %139 = zext i32 %132 to i64
  %140 = mul i64 %139, 32
  %141 = getelementptr inbounds i8, ptr %138, i64 %140
  %142 = add i32 %132, 1
  %143 = insertvalue { ptr, i32, i32, i32 } %131, i32 %142, 1
  %144 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %144, ptr %141, i64 32, i1 false)
  %145 = load i252, ptr %144, align 16
  call void @free(ptr %144)
  %146 = icmp ult i252 %145, 256
  %147 = add i64 %128, 2
  %148 = add i64 %128, 3
  %149 = select i1 %146, i64 %147, i64 %148
  %150 = trunc i252 %145 to i8
  br i1 %146, label %151, label %254

151:                                              ; preds = %136
  %152 = phi { ptr, i32, i32, i32 } [ %143, %136 ]
  %153 = extractvalue { ptr, i32, i32, i32 } %152, 1
  %154 = extractvalue { ptr, i32, i32, i32 } %152, 2
  %155 = sub i32 %154, %153
  %156 = icmp uge i32 %155, 1
  br i1 %156, label %157, label %254

157:                                              ; preds = %151
  %158 = extractvalue { ptr, i32, i32, i32 } %152, 0
  %159 = load ptr, ptr %158, align 8
  %160 = zext i32 %153 to i64
  %161 = mul i64 %160, 32
  %162 = getelementptr inbounds i8, ptr %159, i64 %161
  %163 = add i32 %153, 1
  %164 = insertvalue { ptr, i32, i32, i32 } %152, i32 %163, 1
  %165 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %165, ptr %162, i64 32, i1 false)
  %166 = load i252, ptr %165, align 16
  call void @free(ptr %165)
  %167 = icmp ult i252 %166, 256
  %168 = add i64 %149, 2
  %169 = add i64 %149, 3
  %170 = select i1 %167, i64 %168, i64 %169
  %171 = trunc i252 %166 to i8
  br i1 %167, label %172, label %254

172:                                              ; preds = %157
  %173 = phi { ptr, i32, i32, i32 } [ %164, %157 ]
  %174 = extractvalue { ptr, i32, i32, i32 } %173, 1
  %175 = extractvalue { ptr, i32, i32, i32 } %173, 2
  %176 = sub i32 %175, %174
  %177 = icmp uge i32 %176, 1
  br i1 %177, label %178, label %254

178:                                              ; preds = %172
  %179 = extractvalue { ptr, i32, i32, i32 } %173, 0
  %180 = load ptr, ptr %179, align 8
  %181 = zext i32 %174 to i64
  %182 = mul i64 %181, 32
  %183 = getelementptr inbounds i8, ptr %180, i64 %182
  %184 = add i32 %174, 1
  %185 = insertvalue { ptr, i32, i32, i32 } %173, i32 %184, 1
  %186 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %186, ptr %183, i64 32, i1 false)
  %187 = load i252, ptr %186, align 16
  call void @free(ptr %186)
  %188 = icmp ult i252 %187, 65536
  %189 = add i64 %170, 2
  %190 = add i64 %170, 3
  %191 = select i1 %188, i64 %189, i64 %190
  %192 = trunc i252 %187 to i16
  br i1 %188, label %193, label %254

193:                                              ; preds = %178
  %194 = phi { ptr, i32, i32, i32 } [ %185, %178 ]
  %195 = extractvalue { ptr, i32, i32, i32 } %194, 1
  %196 = extractvalue { ptr, i32, i32, i32 } %194, 2
  %197 = sub i32 %196, %195
  %198 = icmp uge i32 %197, 1
  br i1 %198, label %199, label %254

199:                                              ; preds = %193
  %200 = extractvalue { ptr, i32, i32, i32 } %194, 0
  %201 = load ptr, ptr %200, align 8
  %202 = zext i32 %195 to i64
  %203 = mul i64 %202, 32
  %204 = getelementptr inbounds i8, ptr %201, i64 %203
  %205 = add i32 %195, 1
  %206 = insertvalue { ptr, i32, i32, i32 } %194, i32 %205, 1
  %207 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %207, ptr %204, i64 32, i1 false)
  %208 = load i252, ptr %207, align 16
  call void @free(ptr %207)
  %209 = icmp ult i252 %208, 65536
  %210 = add i64 %191, 2
  %211 = add i64 %191, 3
  %212 = select i1 %209, i64 %210, i64 %211
  %213 = trunc i252 %208 to i16
  br i1 %209, label %214, label %254

214:                                              ; preds = %199
  %215 = phi { ptr, i32, i32, i32 } [ %206, %199 ]
  %216 = extractvalue { ptr, i32, i32, i32 } %215, 1
  %217 = extractvalue { ptr, i32, i32, i32 } %215, 2
  %218 = sub i32 %217, %216
  %219 = icmp uge i32 %218, 1
  br i1 %219, label %220, label %254

220:                                              ; preds = %214
  %221 = extractvalue { ptr, i32, i32, i32 } %215, 0
  %222 = load ptr, ptr %221, align 8
  %223 = zext i32 %216 to i64
  %224 = mul i64 %223, 32
  %225 = getelementptr inbounds i8, ptr %222, i64 %224
  %226 = add i32 %216, 1
  %227 = insertvalue { ptr, i32, i32, i32 } %215, i32 %226, 1
  %228 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %228, ptr %225, i64 32, i1 false)
  %229 = load i252, ptr %228, align 16
  call void @free(ptr %228)
  %230 = icmp ult i252 %229, 65536
  %231 = add i64 %212, 2
  %232 = add i64 %212, 3
  %233 = select i1 %230, i64 %231, i64 %232
  %234 = trunc i252 %229 to i16
  br i1 %230, label %235, label %254

235:                                              ; preds = %220
  %236 = phi { ptr, i32, i32, i32 } [ %227, %220 ]
  %237 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %236, 0
  %238 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %24, 0
  %239 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %238, i8 %45, 1
  %240 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %239, i8 %66, 2
  %241 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %240, i8 %87, 3
  %242 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %241, i8 %108, 4
  %243 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %242, i8 %129, 5
  %244 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %243, i8 %150, 6
  %245 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %244, i8 %171, 7
  %246 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %245, i16 %192, 8
  %247 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %246, i16 %213, 9
  %248 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %247, i16 %234, 10
  %249 = insertvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } { i1 false, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %248, 1
  store { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %249, ptr %4, align 2
  %250 = load { i16, [14 x i8] }, ptr %4, align 2
  %251 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } undef, i64 %233, 0
  %252 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %251, { { ptr, i32, i32, i32 } } %237, 1
  %253 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %252, { i16, [14 x i8] } %250, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %253

254:                                              ; preds = %220, %214, %199, %193, %178, %172, %157, %151, %136, %130, %115, %109, %94, %88, %73, %67, %52, %46, %31, %25, %10, %2
  %255 = phi i64 [ %233, %220 ], [ %212, %214 ], [ %212, %199 ], [ %191, %193 ], [ %191, %178 ], [ %170, %172 ], [ %170, %157 ], [ %149, %151 ], [ %149, %136 ], [ %128, %130 ], [ %128, %115 ], [ %107, %109 ], [ %107, %94 ], [ %86, %88 ], [ %86, %73 ], [ %65, %67 ], [ %65, %52 ], [ %44, %46 ], [ %44, %31 ], [ %23, %25 ], [ %23, %10 ], [ %0, %2 ]
  %256 = phi { ptr, i32, i32, i32 } [ %227, %220 ], [ %215, %214 ], [ %206, %199 ], [ %194, %193 ], [ %185, %178 ], [ %173, %172 ], [ %164, %157 ], [ %152, %151 ], [ %143, %136 ], [ %131, %130 ], [ %122, %115 ], [ %110, %109 ], [ %101, %94 ], [ %89, %88 ], [ %80, %73 ], [ %68, %67 ], [ %59, %52 ], [ %47, %46 ], [ %38, %31 ], [ %26, %25 ], [ %17, %10 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %257 = load { i16, [14 x i8] }, ptr %3, align 2
  %258 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %256, 0
  %259 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } undef, i64 %255, 0
  %260 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %259, { { ptr, i32, i32, i32 } } %258, 1
  %261 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %260, { i16, [14 x i8] } %257, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %261
}

define private { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @f23(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f23"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %8, { i16, [14 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %9
}

define void @_mlir_ciface_f23(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @f23(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$440"({ { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 } } %0, 0
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$440"({ { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 } } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } %8, { { { ptr, i32, i32, i32 }, i252, i32 } } %7, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } %9
}

define private void @"drop$441"({ { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %0, 0
  call void @"drop$440"({ { { ptr, i32, i32, i32 }, i252, i32 } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } @"dup$441"({ { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$440"({ { { ptr, i32, i32, i32 }, i252, i32 } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %0, { { { ptr, i32, i32, i32 }, i252, i32 } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } undef, { { { ptr, i32, i32, i32 }, i252, i32 } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %6, { i1, [0 x i8] } %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %7, { i1, [0 x i8] } %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } undef, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %11, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %10, 1
  ret { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %12
}

define private void @"drop$442"({ i128, [96 x i8] } %0) {
  %2 = alloca { i128, [96 x i8] }, i64 1, align 16
  store { i128, [96 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %5, 1
  call void @"drop$441"({ { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [96 x i8] }, { i128, [96 x i8] } } @"dup$442"({ i128, [96 x i8] } %0) {
  %2 = alloca { i128, [96 x i8] }, i64 1, align 16
  store { i128, [96 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } @"dup$441"({ { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %5, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [96 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %5, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [96 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } undef, { i128, [96 x i8] } %11, 0
  %15 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } %14, { i128, [96 x i8] } %13, 1
  ret { { i128, [96 x i8] }, { i128, [96 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [96 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [96 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } undef, { i128, [96 x i8] } %23, 0
  %27 = insertvalue { { i128, [96 x i8] }, { i128, [96 x i8] } } %26, { i128, [96 x i8] } %25, 1
  ret { { i128, [96 x i8] }, { i128, [96 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$434"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 0
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } @"dup$434"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, { { ptr, i32, i32, i32 }, i252, i32 } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6, {} %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %11, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %10, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %12
}

define private void @"drop$435"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, 1
  call void @"drop$434"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$435"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } @"dup$434"({ { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %10, ptr %2, align 16
  %11 = load { i128, [80 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %12, ptr %2, align 16
  %13 = load { i128, [80 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %11, 0
  %15 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %14, { i128, [80 x i8] } %13, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [80 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [80 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %23, 0
  %27 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %26, { i128, [80 x i8] } %25, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %0)
  ret void
}

define private { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %0) {
  %2 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %0)
  %3 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, 0
  %4 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %2, 1
  %5 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %3, 0
  %6 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %5, { { ptr, i32, i32, i32 }, i252, i32 } %4, 1
  ret { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f24"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5) {
  %7 = alloca i256, i64 1, align 16
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca { i1, [47 x i8] }, i64 1, align 16
  %11 = alloca i64, i64 1, align 8
  %12 = alloca i252, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [96 x i8] }, i64 1, align 16
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = add i64 %2, 3
  %22 = zext i252 %5 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %7, align 16
  store i256 %22, ptr %8, align 16
  %23 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %23(ptr %9, ptr %7, ptr %8)
  %24 = load i256, ptr %9, align 16
  %25 = trunc i256 %24 to i252
  %26 = add i64 %0, 3
  %27 = sub i252 %25, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %28 = icmp ult i252 %25, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %29 = select i1 %28, i252 %25, i252 %27
  %30 = load ptr, ptr %3, align 8
  store i64 %1, ptr %11, align 8
  store i252 %29, ptr %12, align 16
  %31 = getelementptr inbounds ptr, ptr %3, i32 8
  %32 = load ptr, ptr %31, align 8
  call void %32(ptr %10, ptr %30, ptr %11, i32 0, ptr %12)
  %33 = load { i1, [47 x i8] }, ptr %10, align 1
  %34 = extractvalue { i1, [47 x i8] } %33, 0
  %35 = getelementptr inbounds i8, ptr %10, i32 16
  %36 = load i252, ptr %35, align 16
  %37 = getelementptr inbounds i8, ptr %10, i32 8
  %38 = load { ptr, i32, i32, i32 }, ptr %37, align 8
  %39 = load i64, ptr %11, align 8
  br i1 %34, label %154, label %40

40:                                               ; preds = %6
  %41 = phi i252 [ %36, %6 ]
  %42 = icmp eq i252 %41, 0
  br i1 %42, label %43, label %48

43:                                               ; preds = %40
  %44 = phi i64 [ %39, %40 ]
  %45 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %46 = call ptr %45()
  %47 = call i64 @llvm.uadd.sat.i64(i64 %44, i64 0)
  br label %55

48:                                               ; preds = %40
  %49 = phi i64 [ %39, %40 ]
  %50 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %51 = call ptr %50()
  %52 = load i64, ptr %51, align 8
  %53 = mul i64 %52, 100
  %54 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %53)
  br label %55

55:                                               ; preds = %43, %48
  %56 = phi i252 [ %5, %48 ], [ %5, %43 ]
  %57 = phi i64 [ %21, %48 ], [ %21, %43 ]
  %58 = phi ptr [ %3, %48 ], [ %3, %43 ]
  %59 = phi i64 [ %26, %48 ], [ %26, %43 ]
  %60 = phi i64 [ %54, %48 ], [ %47, %43 ]
  %61 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %48 ], [ { i1 true, [0 x i8] undef }, %43 ]
  %62 = extractvalue { i1, [0 x i8] } %61, 0
  %63 = xor i1 %62, true
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %141
  ]

64:                                               ; preds = %55
  br i1 false, label %65, label %164

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %55
  %67 = phi i252 [ %56, %55 ]
  %68 = call fastcc { i64, i64, { i128, [96 x i8] } } @"impl$f51"(i64 %59, i64 %60, i252 %67, { { { ptr, i32, i32, i32 }, i252, i32 } } zeroinitializer)
  %69 = extractvalue { i64, i64, { i128, [96 x i8] } } %68, 0
  %70 = extractvalue { i64, i64, { i128, [96 x i8] } } %68, 1
  %71 = extractvalue { i64, i64, { i128, [96 x i8] } } %68, 2
  store { i128, [96 x i8] } %71, ptr %15, align 16
  %72 = load i1, ptr %15, align 1
  switch i1 %72, label %73 [
    i1 false, label %75
    i1 true, label %81
  ]

73:                                               ; preds = %66
  br i1 false, label %74, label %165

74:                                               ; preds = %73
  unreachable

75:                                               ; preds = %66
  %76 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } }, ptr %15, align 16
  %77 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %76, 1
  %78 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %77, 0
  %79 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %77, 1
  %80 = extractvalue { i1, [0 x i8] } %79, 0
  switch i1 %80, label %91 [
    i1 false, label %93
    i1 true, label %130
  ]

81:                                               ; preds = %66
  %82 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %83 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %82, 1
  %84 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %83, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %84, ptr %16, align 8
  %85 = load { i64, [24 x i8] }, ptr %16, align 8
  %86 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %69, 0
  %87 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %86, i64 %70, 1
  %88 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, i64 %57, 2
  %89 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %88, ptr %58, 3
  %90 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %89, { i64, [24 x i8] } %85, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %90

91:                                               ; preds = %75
  br i1 false, label %92, label %166

92:                                               ; preds = %91
  unreachable

93:                                               ; preds = %75
  %94 = phi { { { ptr, i32, i32, i32 }, i252, i32 } } [ %78, %75 ]
  %95 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 } } %94, 0
  %96 = call fastcc { i64, { i128, [80 x i8] } } @"impl$f52"(i64 %69, { { ptr, i32, i32, i32 }, i252, i32 } %95, i252 43082822081847175470628674138746545522, i32 16)
  %97 = extractvalue { i64, { i128, [80 x i8] } } %96, 0
  %98 = extractvalue { i64, { i128, [80 x i8] } } %96, 1
  store { i128, [80 x i8] } %98, ptr %18, align 16
  %99 = load i1, ptr %18, align 1
  switch i1 %99, label %100 [
    i1 false, label %102
    i1 true, label %120
  ]

100:                                              ; preds = %93
  br i1 false, label %101, label %167

101:                                              ; preds = %100
  unreachable

102:                                              ; preds = %93
  %103 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %18, align 16
  %104 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %103, 1
  %105 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %104, 0
  %106 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %105)
  %107 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %106, 0
  %108 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %106, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %107)
  %109 = call fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f53"(i64 %97, i64 %70, { { ptr, i32, i32, i32 }, i252, i32 } %108)
  %110 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %109, 0
  %111 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %109, 1
  %112 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %109, 2
  %113 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %112, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %113, ptr %20, align 8
  %114 = load { i64, [24 x i8] }, ptr %20, align 8
  %115 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %110, 0
  %116 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, i64 %111, 1
  %117 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %116, i64 %57, 2
  %118 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %117, ptr %58, 3
  %119 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %118, { i64, [24 x i8] } %114, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %119

120:                                              ; preds = %93
  %121 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %122 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %121, 1
  %123 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %122, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %123, ptr %19, align 8
  %124 = load { i64, [24 x i8] }, ptr %19, align 8
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %97, 0
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %125, i64 %70, 1
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, i64 %57, 2
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, ptr %58, 3
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, { i64, [24 x i8] } %124, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %129

130:                                              ; preds = %75
  %131 = phi { { { ptr, i32, i32, i32 }, i252, i32 } } [ %78, %75 ]
  call void @"drop$440"({ { { ptr, i32, i32, i32 }, i252, i32 } } %131)
  %132 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f54"()
  %133 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %132, 0
  %134 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %133, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %134, ptr %17, align 8
  %135 = load { i64, [24 x i8] }, ptr %17, align 8
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %69, 0
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %70, 1
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, i64 %57, 2
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, ptr %58, 3
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, { i64, [24 x i8] } %135, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %140

141:                                              ; preds = %55
  %142 = phi i64 [ %60, %55 ]
  %143 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %144 = call ptr %143()
  %145 = load i64, ptr %144, align 8
  %146 = mul i64 %145, 34750
  %147 = call i64 @llvm.uadd.sat.i64(i64 %142, i64 %146)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %14, align 1
  %148 = load { i64, [24 x i8] }, ptr %14, align 8
  %149 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %59, 0
  %150 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, i64 %147, 1
  %151 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, i64 %57, 2
  %152 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %151, ptr %58, 3
  %153 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %152, { i64, [24 x i8] } %148, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %153

154:                                              ; preds = %6
  %155 = phi { ptr, i32, i32, i32 } [ %38, %6 ]
  %156 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %155, 1
  %157 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %156, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %157, ptr %13, align 8
  %158 = load { i64, [24 x i8] }, ptr %13, align 8
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %26, 0
  %160 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %159, i64 %39, 1
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %160, i64 %21, 2
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, ptr %3, 3
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, { i64, [24 x i8] } %158, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %163

164:                                              ; preds = %64
  call void @puts(ptr @assert_msg_54)
  call void @abort()
  unreachable

165:                                              ; preds = %73
  call void @puts(ptr @assert_msg_55)
  call void @abort()
  unreachable

166:                                              ; preds = %91
  call void @puts(ptr @assert_msg_56)
  call void @abort()
  unreachable

167:                                              ; preds = %100
  call void @puts(ptr @assert_msg_57)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f24(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f24"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f24(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f24(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i128, [16 x i8] } } @"impl$f25"(i64 %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1) {
  %3 = alloca { i128, [16 x i8] }, i64 1, align 16
  %4 = alloca { i128, [16 x i8] }, i64 1, align 16
  %5 = alloca { i128, [16 x i8] }, i64 1, align 16
  %6 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 0
  %7 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 1
  %8 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 2
  %9 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 3
  %10 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 4
  %11 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 5
  %12 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 6
  %13 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 7
  %14 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 8
  %15 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 9
  %16 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 10
  %17 = zext i8 %6 to i128
  %18 = zext i8 %7 to i128
  %19 = zext i128 %18 to i256
  %20 = mul i256 %19, 256
  %21 = trunc i256 %20 to i128
  %22 = lshr i256 %20, 128
  %23 = trunc i256 %22 to i128
  %24 = add i64 %0, 9
  %25 = zext i128 %23 to i252
  %26 = icmp eq i252 %25, 0
  br i1 %26, label %27, label %221

27:                                               ; preds = %2
  %28 = phi i64 [ %24, %2 ]
  %29 = phi i128 [ %17, %2 ]
  %30 = phi i128 [ %21, %2 ]
  %31 = add i64 %28, 1
  %32 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %29, i128 %30)
  %33 = extractvalue { i128, i1 } %32, 0
  %34 = extractvalue { i128, i1 } %32, 1
  br i1 %34, label %213, label %35

35:                                               ; preds = %27
  %36 = phi i8 [ %8, %27 ]
  %37 = zext i8 %36 to i128
  %38 = zext i128 %37 to i256
  %39 = mul i256 %38, 65536
  %40 = trunc i256 %39 to i128
  %41 = lshr i256 %39, 128
  %42 = trunc i256 %41 to i128
  %43 = add i64 %28, 10
  %44 = zext i128 %42 to i252
  %45 = icmp eq i252 %44, 0
  br i1 %45, label %46, label %221

46:                                               ; preds = %35
  %47 = phi i64 [ %43, %35 ]
  %48 = phi i128 [ %33, %35 ]
  %49 = phi i128 [ %40, %35 ]
  %50 = add i64 %47, 1
  %51 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %48, i128 %49)
  %52 = extractvalue { i128, i1 } %51, 0
  %53 = extractvalue { i128, i1 } %51, 1
  br i1 %53, label %213, label %54

54:                                               ; preds = %46
  %55 = phi i8 [ %9, %46 ]
  %56 = zext i8 %55 to i128
  %57 = zext i128 %56 to i256
  %58 = mul i256 %57, 16777216
  %59 = trunc i256 %58 to i128
  %60 = lshr i256 %58, 128
  %61 = trunc i256 %60 to i128
  %62 = add i64 %47, 10
  %63 = zext i128 %61 to i252
  %64 = icmp eq i252 %63, 0
  br i1 %64, label %65, label %221

65:                                               ; preds = %54
  %66 = phi i64 [ %62, %54 ]
  %67 = phi i128 [ %52, %54 ]
  %68 = phi i128 [ %59, %54 ]
  %69 = add i64 %66, 1
  %70 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %67, i128 %68)
  %71 = extractvalue { i128, i1 } %70, 0
  %72 = extractvalue { i128, i1 } %70, 1
  br i1 %72, label %213, label %73

73:                                               ; preds = %65
  %74 = phi i8 [ %10, %65 ]
  %75 = zext i8 %74 to i128
  %76 = zext i128 %75 to i256
  %77 = mul i256 %76, 4294967296
  %78 = trunc i256 %77 to i128
  %79 = lshr i256 %77, 128
  %80 = trunc i256 %79 to i128
  %81 = add i64 %66, 10
  %82 = zext i128 %80 to i252
  %83 = icmp eq i252 %82, 0
  br i1 %83, label %84, label %221

84:                                               ; preds = %73
  %85 = phi i64 [ %81, %73 ]
  %86 = phi i128 [ %71, %73 ]
  %87 = phi i128 [ %78, %73 ]
  %88 = add i64 %85, 1
  %89 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %86, i128 %87)
  %90 = extractvalue { i128, i1 } %89, 0
  %91 = extractvalue { i128, i1 } %89, 1
  br i1 %91, label %213, label %92

92:                                               ; preds = %84
  %93 = phi i8 [ %11, %84 ]
  %94 = zext i8 %93 to i128
  %95 = zext i128 %94 to i256
  %96 = mul i256 %95, 1099511627776
  %97 = trunc i256 %96 to i128
  %98 = lshr i256 %96, 128
  %99 = trunc i256 %98 to i128
  %100 = add i64 %85, 10
  %101 = zext i128 %99 to i252
  %102 = icmp eq i252 %101, 0
  br i1 %102, label %103, label %221

103:                                              ; preds = %92
  %104 = phi i64 [ %100, %92 ]
  %105 = phi i128 [ %90, %92 ]
  %106 = phi i128 [ %97, %92 ]
  %107 = add i64 %104, 1
  %108 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %105, i128 %106)
  %109 = extractvalue { i128, i1 } %108, 0
  %110 = extractvalue { i128, i1 } %108, 1
  br i1 %110, label %213, label %111

111:                                              ; preds = %103
  %112 = phi i8 [ %12, %103 ]
  %113 = zext i8 %112 to i128
  %114 = zext i128 %113 to i256
  %115 = mul i256 %114, 281474976710656
  %116 = trunc i256 %115 to i128
  %117 = lshr i256 %115, 128
  %118 = trunc i256 %117 to i128
  %119 = add i64 %104, 10
  %120 = zext i128 %118 to i252
  %121 = icmp eq i252 %120, 0
  br i1 %121, label %122, label %221

122:                                              ; preds = %111
  %123 = phi i64 [ %119, %111 ]
  %124 = phi i128 [ %109, %111 ]
  %125 = phi i128 [ %116, %111 ]
  %126 = add i64 %123, 1
  %127 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %124, i128 %125)
  %128 = extractvalue { i128, i1 } %127, 0
  %129 = extractvalue { i128, i1 } %127, 1
  br i1 %129, label %213, label %130

130:                                              ; preds = %122
  %131 = phi i8 [ %13, %122 ]
  %132 = zext i8 %131 to i128
  %133 = zext i128 %132 to i256
  %134 = mul i256 %133, 72057594037927936
  %135 = trunc i256 %134 to i128
  %136 = lshr i256 %134, 128
  %137 = trunc i256 %136 to i128
  %138 = add i64 %123, 10
  %139 = zext i128 %137 to i252
  %140 = icmp eq i252 %139, 0
  br i1 %140, label %141, label %221

141:                                              ; preds = %130
  %142 = phi i64 [ %138, %130 ]
  %143 = phi i128 [ %128, %130 ]
  %144 = phi i128 [ %135, %130 ]
  %145 = add i64 %142, 1
  %146 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %143, i128 %144)
  %147 = extractvalue { i128, i1 } %146, 0
  %148 = extractvalue { i128, i1 } %146, 1
  br i1 %148, label %213, label %149

149:                                              ; preds = %141
  %150 = phi i16 [ %14, %141 ]
  %151 = zext i16 %150 to i128
  %152 = zext i128 %151 to i256
  %153 = mul i256 %152, 18446744073709551616
  %154 = trunc i256 %153 to i128
  %155 = lshr i256 %153, 128
  %156 = trunc i256 %155 to i128
  %157 = add i64 %142, 10
  %158 = zext i128 %156 to i252
  %159 = icmp eq i252 %158, 0
  br i1 %159, label %160, label %221

160:                                              ; preds = %149
  %161 = phi i64 [ %157, %149 ]
  %162 = phi i128 [ %147, %149 ]
  %163 = phi i128 [ %154, %149 ]
  %164 = add i64 %161, 1
  %165 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %162, i128 %163)
  %166 = extractvalue { i128, i1 } %165, 0
  %167 = extractvalue { i128, i1 } %165, 1
  br i1 %167, label %213, label %168

168:                                              ; preds = %160
  %169 = phi i16 [ %15, %160 ]
  %170 = zext i16 %169 to i128
  %171 = zext i128 %170 to i256
  %172 = mul i256 %171, 1208925819614629174706176
  %173 = trunc i256 %172 to i128
  %174 = lshr i256 %172, 128
  %175 = trunc i256 %174 to i128
  %176 = add i64 %161, 10
  %177 = zext i128 %175 to i252
  %178 = icmp eq i252 %177, 0
  br i1 %178, label %179, label %221

179:                                              ; preds = %168
  %180 = phi i64 [ %176, %168 ]
  %181 = phi i128 [ %166, %168 ]
  %182 = phi i128 [ %173, %168 ]
  %183 = add i64 %180, 1
  %184 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %181, i128 %182)
  %185 = extractvalue { i128, i1 } %184, 0
  %186 = extractvalue { i128, i1 } %184, 1
  br i1 %186, label %213, label %187

187:                                              ; preds = %179
  %188 = phi i16 [ %16, %179 ]
  %189 = zext i16 %188 to i128
  %190 = zext i128 %189 to i256
  %191 = mul i256 %190, 79228162514264337593543950336
  %192 = trunc i256 %191 to i128
  %193 = lshr i256 %191, 128
  %194 = trunc i256 %193 to i128
  %195 = add i64 %180, 10
  %196 = zext i128 %194 to i252
  %197 = icmp eq i252 %196, 0
  br i1 %197, label %198, label %221

198:                                              ; preds = %187
  %199 = phi i64 [ %195, %187 ]
  %200 = phi i128 [ %185, %187 ]
  %201 = phi i128 [ %192, %187 ]
  %202 = add i64 %199, 1
  %203 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %200, i128 %201)
  %204 = extractvalue { i128, i1 } %203, 0
  %205 = extractvalue { i128, i1 } %203, 1
  br i1 %205, label %213, label %206

206:                                              ; preds = %198
  %207 = phi i128 [ %204, %198 ]
  %208 = insertvalue { i128 } undef, i128 %207, 0
  %209 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %208, 1
  store { i1, { i128 } } %209, ptr %5, align 16
  %210 = load { i128, [16 x i8] }, ptr %5, align 16
  %211 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %202, 0
  %212 = insertvalue { i64, { i128, [16 x i8] } } %211, { i128, [16 x i8] } %210, 1
  ret { i64, { i128, [16 x i8] } } %212

213:                                              ; preds = %198, %179, %160, %141, %122, %103, %84, %65, %46, %27
  %214 = phi i64 [ %202, %198 ], [ %183, %179 ], [ %164, %160 ], [ %145, %141 ], [ %126, %122 ], [ %107, %103 ], [ %88, %84 ], [ %69, %65 ], [ %50, %46 ], [ %31, %27 ]
  %215 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"()
  %216 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %215, 0
  %217 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %216, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %217, ptr %4, align 8
  %218 = load { i128, [16 x i8] }, ptr %4, align 16
  %219 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %214, 0
  %220 = insertvalue { i64, { i128, [16 x i8] } } %219, { i128, [16 x i8] } %218, 1
  ret { i64, { i128, [16 x i8] } } %220

221:                                              ; preds = %187, %168, %149, %130, %111, %92, %73, %54, %35, %2
  %222 = phi i64 [ %195, %187 ], [ %176, %168 ], [ %157, %149 ], [ %138, %130 ], [ %119, %111 ], [ %100, %92 ], [ %81, %73 ], [ %62, %54 ], [ %43, %35 ], [ %24, %2 ]
  %223 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %224 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %223, 0
  %225 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %224, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %225, ptr %3, align 8
  %226 = load { i128, [16 x i8] }, ptr %3, align 16
  %227 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %222, 0
  %228 = insertvalue { i64, { i128, [16 x i8] } } %227, { i128, [16 x i8] } %226, 1
  ret { i64, { i128, [16 x i8] } } %228
}

define private { i64, { i128, [16 x i8] } } @f25(i64 %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1) {
  %3 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f25"(i64 %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1)
  %4 = extractvalue { i64, { i128, [16 x i8] } } %3, 0
  %5 = extractvalue { i64, { i128, [16 x i8] } } %3, 1
  %6 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i128, [16 x i8] } } %6, { i128, [16 x i8] } %5, 1
  ret { i64, { i128, [16 x i8] } } %7
}

define void @_mlir_ciface_f25(ptr %0, i64 %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2) {
  %4 = call { i64, { i128, [16 x i8] } } @f25(i64 %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2)
  store { i64, { i128, [16 x i8] } } %4, ptr %0, align 16
  ret void
}

define private void @"drop$420"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$42"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$420"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$42"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$421"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$420"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$421"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$420"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$422"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$421"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$422"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$421"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f26"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [80 x i8] }, i64 1, align 16
  %5 = alloca { i128, [128 x i8] }, i64 1, align 16
  %6 = alloca { i64, [56 x i8] }, i64 1, align 8
  %7 = alloca { i128, [128 x i8] }, i64 1, align 16
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [128 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [128 x i8] }, i64 1, align 16
  %13 = extractvalue { { ptr, i32, i32, i32 } } %2, 0
  %14 = extractvalue { ptr, i32, i32, i32 } %13, 1
  %15 = extractvalue { ptr, i32, i32, i32 } %13, 2
  %16 = sub i32 %15, %14
  %17 = icmp uge i32 %16, 1
  br i1 %17, label %18, label %146

18:                                               ; preds = %3
  %19 = extractvalue { ptr, i32, i32, i32 } %13, 0
  %20 = load ptr, ptr %19, align 8
  %21 = zext i32 %14 to i64
  %22 = mul i64 %21, 32
  %23 = getelementptr inbounds i8, ptr %20, i64 %22
  %24 = add i32 %14, 1
  %25 = insertvalue { ptr, i32, i32, i32 } %13, i32 %24, 1
  %26 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %26, ptr %23, i64 32, i1 false)
  %27 = load i252, ptr %26, align 16
  call void @free(ptr %26)
  %28 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %25, 0
  %29 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f57"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %28, { ptr, i32, i32, i32 } zeroinitializer, i252 %27)
  %30 = extractvalue { i64, i64, { i64, [56 x i8] } } %29, 0
  %31 = extractvalue { i64, i64, { i64, [56 x i8] } } %29, 1
  %32 = extractvalue { i64, i64, { i64, [56 x i8] } } %29, 2
  store { i64, [56 x i8] } %32, ptr %6, align 8
  %33 = load i1, ptr %6, align 1
  switch i1 %33, label %34 [
    i1 false, label %36
    i1 true, label %43
  ]

34:                                               ; preds = %18
  br i1 false, label %35, label %166

35:                                               ; preds = %34
  unreachable

36:                                               ; preds = %18
  %37 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %6, align 8
  %38 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %37, 1
  %39 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %38, 0
  %40 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %38, 1
  %41 = extractvalue { { ptr, i32, i32, i32 } } %39, 0
  store { i64, [24 x i8] } %40, ptr %8, align 8
  %42 = load i1, ptr %8, align 1
  switch i1 %42, label %51 [
    i1 false, label %53
    i1 true, label %60
  ]

43:                                               ; preds = %18
  %44 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %45 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %44, 1
  %46 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %45, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %46, ptr %7, align 8
  %47 = load { i128, [128 x i8] }, ptr %7, align 16
  %48 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %30, 0
  %49 = insertvalue { i64, i64, { i128, [128 x i8] } } %48, i64 %31, 1
  %50 = insertvalue { i64, i64, { i128, [128 x i8] } } %49, { i128, [128 x i8] } %47, 2
  ret { i64, i64, { i128, [128 x i8] } } %50

51:                                               ; preds = %36
  br i1 false, label %52, label %167

52:                                               ; preds = %51
  unreachable

53:                                               ; preds = %36
  %54 = load { i1, { ptr, i32, i32, i32 } }, ptr %8, align 8
  %55 = extractvalue { i1, { ptr, i32, i32, i32 } } %54, 1
  %56 = extractvalue { ptr, i32, i32, i32 } %41, 1
  %57 = extractvalue { ptr, i32, i32, i32 } %41, 2
  %58 = sub i32 %57, %56
  %59 = icmp uge i32 %58, 1
  br i1 %59, label %66, label %126

60:                                               ; preds = %36
  %61 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %62 = call ptr %61()
  %63 = load i64, ptr %62, align 8
  %64 = mul i64 %63, 1910
  %65 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %64)
  br label %153

66:                                               ; preds = %53
  %67 = extractvalue { ptr, i32, i32, i32 } %41, 0
  %68 = load ptr, ptr %67, align 8
  %69 = zext i32 %56 to i64
  %70 = mul i64 %69, 32
  %71 = getelementptr inbounds i8, ptr %68, i64 %70
  %72 = add i32 %56, 1
  %73 = insertvalue { ptr, i32, i32, i32 } %41, i32 %72, 1
  %74 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %74, ptr %71, i64 32, i1 false)
  %75 = extractvalue { ptr, i32, i32, i32 } %41, 2
  %76 = sub i32 %75, %72
  %77 = icmp uge i32 %76, 1
  br i1 %77, label %78, label %119

78:                                               ; preds = %66
  %79 = extractvalue { ptr, i32, i32, i32 } %41, 0
  %80 = load ptr, ptr %79, align 8
  %81 = zext i32 %72 to i64
  %82 = mul i64 %81, 32
  %83 = getelementptr inbounds i8, ptr %80, i64 %82
  %84 = add i32 %56, 2
  %85 = insertvalue { ptr, i32, i32, i32 } %73, i32 %84, 1
  %86 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %86, ptr %83, i64 32, i1 false)
  %87 = load i252, ptr %86, align 16
  call void @free(ptr %86)
  %88 = icmp ult i252 %87, 4294967296
  %89 = add i64 %30, 2
  %90 = add i64 %30, 3
  %91 = select i1 %88, i64 %89, i64 %90
  %92 = trunc i252 %87 to i32
  br i1 %88, label %93, label %114

93:                                               ; preds = %78
  %94 = phi i64 [ %31, %78 ]
  %95 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %96 = call ptr %95()
  %97 = load i64, ptr %96, align 8
  %98 = mul i64 %97, 1170
  %99 = call i64 @llvm.uadd.sat.i64(i64 %94, i64 %98)
  %100 = load i252, ptr %74, align 16
  call void @free(ptr %74)
  %101 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %85, 0
  %102 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %55, 0
  %103 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %102, i252 %100, 1
  %104 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %103, i32 %92, 2
  %105 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } { i1 false, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %104, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %105, ptr %11, align 16
  %106 = load { i128, [80 x i8] }, ptr %11, align 16
  %107 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %101, 0
  %108 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %107, { i128, [80 x i8] } %106, 1
  %109 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %108, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %109, ptr %12, align 16
  %110 = load { i128, [128 x i8] }, ptr %12, align 16
  %111 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %91, 0
  %112 = insertvalue { i64, i64, { i128, [128 x i8] } } %111, i64 %99, 1
  %113 = insertvalue { i64, i64, { i128, [128 x i8] } } %112, { i128, [128 x i8] } %110, 2
  ret { i64, i64, { i128, [128 x i8] } } %113

114:                                              ; preds = %78
  %115 = phi ptr [ %74, %78 ]
  call void @"drop$555"(ptr %115)
  call void @"drop$42"({ ptr, i32, i32, i32 } %55)
  %116 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %117 = call ptr %116()
  %118 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 0)
  br label %133

119:                                              ; preds = %66
  %120 = phi ptr [ %74, %66 ]
  call void @"drop$555"(ptr %120)
  call void @"drop$42"({ ptr, i32, i32, i32 } %55)
  %121 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %122 = call ptr %121()
  %123 = load i64, ptr %122, align 8
  %124 = mul i64 %123, 1210
  %125 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %124)
  br label %133

126:                                              ; preds = %53
  %127 = phi { ptr, i32, i32, i32 } [ %55, %53 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %127)
  %128 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %129 = call ptr %128()
  %130 = load i64, ptr %129, align 8
  %131 = mul i64 %130, 1710
  %132 = call i64 @llvm.uadd.sat.i64(i64 %31, i64 %131)
  br label %133

133:                                              ; preds = %114, %119, %126
  %134 = phi i64 [ %30, %126 ], [ %30, %119 ], [ %91, %114 ]
  %135 = phi i64 [ %132, %126 ], [ %125, %119 ], [ %118, %114 ]
  %136 = phi { ptr, i32, i32, i32 } [ %41, %126 ], [ %73, %119 ], [ %85, %114 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %137 = load { i128, [80 x i8] }, ptr %9, align 16
  %138 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %136, 0
  %139 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %138, 0
  %140 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %139, { i128, [80 x i8] } %137, 1
  %141 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %140, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %141, ptr %10, align 16
  %142 = load { i128, [128 x i8] }, ptr %10, align 16
  %143 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %134, 0
  %144 = insertvalue { i64, i64, { i128, [128 x i8] } } %143, i64 %135, 1
  %145 = insertvalue { i64, i64, { i128, [128 x i8] } } %144, { i128, [128 x i8] } %142, 2
  ret { i64, i64, { i128, [128 x i8] } } %145

146:                                              ; preds = %3
  %147 = phi i64 [ %1, %3 ]
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = load i64, ptr %149, align 8
  %151 = mul i64 %150, 5280
  %152 = call i64 @llvm.uadd.sat.i64(i64 %147, i64 %151)
  br label %153

153:                                              ; preds = %60, %146
  %154 = phi i64 [ %0, %146 ], [ %30, %60 ]
  %155 = phi i64 [ %152, %146 ], [ %65, %60 ]
  %156 = phi { ptr, i32, i32, i32 } [ %13, %146 ], [ %41, %60 ]
  %157 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %156, 0
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %158 = load { i128, [80 x i8] }, ptr %4, align 16
  %159 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, { { ptr, i32, i32, i32 } } %157, 0
  %160 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %159, { i128, [80 x i8] } %158, 1
  %161 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %160, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %161, ptr %5, align 16
  %162 = load { i128, [128 x i8] }, ptr %5, align 16
  %163 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %154, 0
  %164 = insertvalue { i64, i64, { i128, [128 x i8] } } %163, i64 %155, 1
  %165 = insertvalue { i64, i64, { i128, [128 x i8] } } %164, { i128, [128 x i8] } %162, 2
  ret { i64, i64, { i128, [128 x i8] } } %165

166:                                              ; preds = %34
  call void @puts(ptr @assert_msg_58)
  call void @abort()
  unreachable

167:                                              ; preds = %51
  call void @puts(ptr @assert_msg_59)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [128 x i8] } } @f26(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f26"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [128 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [128 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [128 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [128 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [128 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [128 x i8] } } %9, { i128, [128 x i8] } %7, 2
  ret { i64, i64, { i128, [128 x i8] } } %10
}

define void @_mlir_ciface_f26(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [128 x i8] } } @f26(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [128 x i8] } } %5, ptr %0, align 16
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f27"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i16, [14 x i8] }, i64 1, align 2
  %4 = alloca { i16, [14 x i8] }, i64 1, align 2
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %317

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp sge i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %21 = icmp slt i252 %19, 128
  %22 = and i1 %20, %21
  %23 = icmp slt i252 %19, 0
  br i1 %23, label %24, label %26

24:                                               ; preds = %10
  %25 = sub i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %27

26:                                               ; preds = %10
  br label %27

27:                                               ; preds = %24, %26
  %28 = phi i252 [ %19, %26 ], [ %25, %24 ]
  br label %29

29:                                               ; preds = %27
  %30 = add i64 %0, 2
  %31 = add i64 %0, 3
  %32 = select i1 %22, i64 %30, i64 %31
  %33 = trunc i252 %28 to i8
  br i1 %22, label %34, label %317

34:                                               ; preds = %29
  %35 = phi { ptr, i32, i32, i32 } [ %17, %29 ]
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %317

40:                                               ; preds = %34
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = icmp sge i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %51 = icmp slt i252 %49, 128
  %52 = and i1 %50, %51
  %53 = icmp slt i252 %49, 0
  br i1 %53, label %54, label %56

54:                                               ; preds = %40
  %55 = sub i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %57

56:                                               ; preds = %40
  br label %57

57:                                               ; preds = %54, %56
  %58 = phi i252 [ %49, %56 ], [ %55, %54 ]
  br label %59

59:                                               ; preds = %57
  %60 = add i64 %32, 2
  %61 = add i64 %32, 3
  %62 = select i1 %52, i64 %60, i64 %61
  %63 = trunc i252 %58 to i8
  br i1 %52, label %64, label %317

64:                                               ; preds = %59
  %65 = phi { ptr, i32, i32, i32 } [ %47, %59 ]
  %66 = extractvalue { ptr, i32, i32, i32 } %65, 1
  %67 = extractvalue { ptr, i32, i32, i32 } %65, 2
  %68 = sub i32 %67, %66
  %69 = icmp uge i32 %68, 1
  br i1 %69, label %70, label %317

70:                                               ; preds = %64
  %71 = extractvalue { ptr, i32, i32, i32 } %65, 0
  %72 = load ptr, ptr %71, align 8
  %73 = zext i32 %66 to i64
  %74 = mul i64 %73, 32
  %75 = getelementptr inbounds i8, ptr %72, i64 %74
  %76 = add i32 %66, 1
  %77 = insertvalue { ptr, i32, i32, i32 } %65, i32 %76, 1
  %78 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %78, ptr %75, i64 32, i1 false)
  %79 = load i252, ptr %78, align 16
  call void @free(ptr %78)
  %80 = icmp sge i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %81 = icmp slt i252 %79, 128
  %82 = and i1 %80, %81
  %83 = icmp slt i252 %79, 0
  br i1 %83, label %84, label %86

84:                                               ; preds = %70
  %85 = sub i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %87

86:                                               ; preds = %70
  br label %87

87:                                               ; preds = %84, %86
  %88 = phi i252 [ %79, %86 ], [ %85, %84 ]
  br label %89

89:                                               ; preds = %87
  %90 = add i64 %62, 2
  %91 = add i64 %62, 3
  %92 = select i1 %82, i64 %90, i64 %91
  %93 = trunc i252 %88 to i8
  br i1 %82, label %94, label %317

94:                                               ; preds = %89
  %95 = phi { ptr, i32, i32, i32 } [ %77, %89 ]
  %96 = extractvalue { ptr, i32, i32, i32 } %95, 1
  %97 = extractvalue { ptr, i32, i32, i32 } %95, 2
  %98 = sub i32 %97, %96
  %99 = icmp uge i32 %98, 1
  br i1 %99, label %100, label %317

100:                                              ; preds = %94
  %101 = extractvalue { ptr, i32, i32, i32 } %95, 0
  %102 = load ptr, ptr %101, align 8
  %103 = zext i32 %96 to i64
  %104 = mul i64 %103, 32
  %105 = getelementptr inbounds i8, ptr %102, i64 %104
  %106 = add i32 %96, 1
  %107 = insertvalue { ptr, i32, i32, i32 } %95, i32 %106, 1
  %108 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %108, ptr %105, i64 32, i1 false)
  %109 = load i252, ptr %108, align 16
  call void @free(ptr %108)
  %110 = icmp sge i252 %109, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %111 = icmp slt i252 %109, 128
  %112 = and i1 %110, %111
  %113 = icmp slt i252 %109, 0
  br i1 %113, label %114, label %116

114:                                              ; preds = %100
  %115 = sub i252 %109, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %117

116:                                              ; preds = %100
  br label %117

117:                                              ; preds = %114, %116
  %118 = phi i252 [ %109, %116 ], [ %115, %114 ]
  br label %119

119:                                              ; preds = %117
  %120 = add i64 %92, 2
  %121 = add i64 %92, 3
  %122 = select i1 %112, i64 %120, i64 %121
  %123 = trunc i252 %118 to i8
  br i1 %112, label %124, label %317

124:                                              ; preds = %119
  %125 = phi { ptr, i32, i32, i32 } [ %107, %119 ]
  %126 = extractvalue { ptr, i32, i32, i32 } %125, 1
  %127 = extractvalue { ptr, i32, i32, i32 } %125, 2
  %128 = sub i32 %127, %126
  %129 = icmp uge i32 %128, 1
  br i1 %129, label %130, label %317

130:                                              ; preds = %124
  %131 = extractvalue { ptr, i32, i32, i32 } %125, 0
  %132 = load ptr, ptr %131, align 8
  %133 = zext i32 %126 to i64
  %134 = mul i64 %133, 32
  %135 = getelementptr inbounds i8, ptr %132, i64 %134
  %136 = add i32 %126, 1
  %137 = insertvalue { ptr, i32, i32, i32 } %125, i32 %136, 1
  %138 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %138, ptr %135, i64 32, i1 false)
  %139 = load i252, ptr %138, align 16
  call void @free(ptr %138)
  %140 = icmp ult i252 %139, 256
  %141 = add i64 %122, 2
  %142 = add i64 %122, 3
  %143 = select i1 %140, i64 %141, i64 %142
  %144 = trunc i252 %139 to i8
  br i1 %140, label %145, label %317

145:                                              ; preds = %130
  %146 = phi { ptr, i32, i32, i32 } [ %137, %130 ]
  %147 = extractvalue { ptr, i32, i32, i32 } %146, 1
  %148 = extractvalue { ptr, i32, i32, i32 } %146, 2
  %149 = sub i32 %148, %147
  %150 = icmp uge i32 %149, 1
  br i1 %150, label %151, label %317

151:                                              ; preds = %145
  %152 = extractvalue { ptr, i32, i32, i32 } %146, 0
  %153 = load ptr, ptr %152, align 8
  %154 = zext i32 %147 to i64
  %155 = mul i64 %154, 32
  %156 = getelementptr inbounds i8, ptr %153, i64 %155
  %157 = add i32 %147, 1
  %158 = insertvalue { ptr, i32, i32, i32 } %146, i32 %157, 1
  %159 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %159, ptr %156, i64 32, i1 false)
  %160 = load i252, ptr %159, align 16
  call void @free(ptr %159)
  %161 = icmp ult i252 %160, 256
  %162 = add i64 %143, 2
  %163 = add i64 %143, 3
  %164 = select i1 %161, i64 %162, i64 %163
  %165 = trunc i252 %160 to i8
  br i1 %161, label %166, label %317

166:                                              ; preds = %151
  %167 = phi { ptr, i32, i32, i32 } [ %158, %151 ]
  %168 = extractvalue { ptr, i32, i32, i32 } %167, 1
  %169 = extractvalue { ptr, i32, i32, i32 } %167, 2
  %170 = sub i32 %169, %168
  %171 = icmp uge i32 %170, 1
  br i1 %171, label %172, label %317

172:                                              ; preds = %166
  %173 = extractvalue { ptr, i32, i32, i32 } %167, 0
  %174 = load ptr, ptr %173, align 8
  %175 = zext i32 %168 to i64
  %176 = mul i64 %175, 32
  %177 = getelementptr inbounds i8, ptr %174, i64 %176
  %178 = add i32 %168, 1
  %179 = insertvalue { ptr, i32, i32, i32 } %167, i32 %178, 1
  %180 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %180, ptr %177, i64 32, i1 false)
  %181 = load i252, ptr %180, align 16
  call void @free(ptr %180)
  %182 = icmp ult i252 %181, 256
  %183 = add i64 %164, 2
  %184 = add i64 %164, 3
  %185 = select i1 %182, i64 %183, i64 %184
  %186 = trunc i252 %181 to i8
  br i1 %182, label %187, label %317

187:                                              ; preds = %172
  %188 = phi { ptr, i32, i32, i32 } [ %179, %172 ]
  %189 = extractvalue { ptr, i32, i32, i32 } %188, 1
  %190 = extractvalue { ptr, i32, i32, i32 } %188, 2
  %191 = sub i32 %190, %189
  %192 = icmp uge i32 %191, 1
  br i1 %192, label %193, label %317

193:                                              ; preds = %187
  %194 = extractvalue { ptr, i32, i32, i32 } %188, 0
  %195 = load ptr, ptr %194, align 8
  %196 = zext i32 %189 to i64
  %197 = mul i64 %196, 32
  %198 = getelementptr inbounds i8, ptr %195, i64 %197
  %199 = add i32 %189, 1
  %200 = insertvalue { ptr, i32, i32, i32 } %188, i32 %199, 1
  %201 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %201, ptr %198, i64 32, i1 false)
  %202 = load i252, ptr %201, align 16
  call void @free(ptr %201)
  %203 = icmp ult i252 %202, 256
  %204 = add i64 %185, 2
  %205 = add i64 %185, 3
  %206 = select i1 %203, i64 %204, i64 %205
  %207 = trunc i252 %202 to i8
  br i1 %203, label %208, label %317

208:                                              ; preds = %193
  %209 = phi { ptr, i32, i32, i32 } [ %200, %193 ]
  %210 = extractvalue { ptr, i32, i32, i32 } %209, 1
  %211 = extractvalue { ptr, i32, i32, i32 } %209, 2
  %212 = sub i32 %211, %210
  %213 = icmp uge i32 %212, 1
  br i1 %213, label %214, label %317

214:                                              ; preds = %208
  %215 = extractvalue { ptr, i32, i32, i32 } %209, 0
  %216 = load ptr, ptr %215, align 8
  %217 = zext i32 %210 to i64
  %218 = mul i64 %217, 32
  %219 = getelementptr inbounds i8, ptr %216, i64 %218
  %220 = add i32 %210, 1
  %221 = insertvalue { ptr, i32, i32, i32 } %209, i32 %220, 1
  %222 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %222, ptr %219, i64 32, i1 false)
  %223 = load i252, ptr %222, align 16
  call void @free(ptr %222)
  %224 = icmp sge i252 %223, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %225 = icmp slt i252 %223, 32768
  %226 = and i1 %224, %225
  %227 = icmp slt i252 %223, 0
  br i1 %227, label %228, label %230

228:                                              ; preds = %214
  %229 = sub i252 %223, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %231

230:                                              ; preds = %214
  br label %231

231:                                              ; preds = %228, %230
  %232 = phi i252 [ %223, %230 ], [ %229, %228 ]
  br label %233

233:                                              ; preds = %231
  %234 = add i64 %206, 2
  %235 = add i64 %206, 3
  %236 = select i1 %226, i64 %234, i64 %235
  %237 = trunc i252 %232 to i16
  br i1 %226, label %238, label %317

238:                                              ; preds = %233
  %239 = phi { ptr, i32, i32, i32 } [ %221, %233 ]
  %240 = extractvalue { ptr, i32, i32, i32 } %239, 1
  %241 = extractvalue { ptr, i32, i32, i32 } %239, 2
  %242 = sub i32 %241, %240
  %243 = icmp uge i32 %242, 1
  br i1 %243, label %244, label %317

244:                                              ; preds = %238
  %245 = extractvalue { ptr, i32, i32, i32 } %239, 0
  %246 = load ptr, ptr %245, align 8
  %247 = zext i32 %240 to i64
  %248 = mul i64 %247, 32
  %249 = getelementptr inbounds i8, ptr %246, i64 %248
  %250 = add i32 %240, 1
  %251 = insertvalue { ptr, i32, i32, i32 } %239, i32 %250, 1
  %252 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %252, ptr %249, i64 32, i1 false)
  %253 = load i252, ptr %252, align 16
  call void @free(ptr %252)
  %254 = icmp sge i252 %253, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %255 = icmp slt i252 %253, 32768
  %256 = and i1 %254, %255
  %257 = icmp slt i252 %253, 0
  br i1 %257, label %258, label %260

258:                                              ; preds = %244
  %259 = sub i252 %253, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %261

260:                                              ; preds = %244
  br label %261

261:                                              ; preds = %258, %260
  %262 = phi i252 [ %253, %260 ], [ %259, %258 ]
  br label %263

263:                                              ; preds = %261
  %264 = add i64 %236, 2
  %265 = add i64 %236, 3
  %266 = select i1 %256, i64 %264, i64 %265
  %267 = trunc i252 %262 to i16
  br i1 %256, label %268, label %317

268:                                              ; preds = %263
  %269 = phi { ptr, i32, i32, i32 } [ %251, %263 ]
  %270 = extractvalue { ptr, i32, i32, i32 } %269, 1
  %271 = extractvalue { ptr, i32, i32, i32 } %269, 2
  %272 = sub i32 %271, %270
  %273 = icmp uge i32 %272, 1
  br i1 %273, label %274, label %317

274:                                              ; preds = %268
  %275 = extractvalue { ptr, i32, i32, i32 } %269, 0
  %276 = load ptr, ptr %275, align 8
  %277 = zext i32 %270 to i64
  %278 = mul i64 %277, 32
  %279 = getelementptr inbounds i8, ptr %276, i64 %278
  %280 = add i32 %270, 1
  %281 = insertvalue { ptr, i32, i32, i32 } %269, i32 %280, 1
  %282 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %282, ptr %279, i64 32, i1 false)
  %283 = load i252, ptr %282, align 16
  call void @free(ptr %282)
  %284 = icmp sge i252 %283, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %285 = icmp slt i252 %283, 32768
  %286 = and i1 %284, %285
  %287 = icmp slt i252 %283, 0
  br i1 %287, label %288, label %290

288:                                              ; preds = %274
  %289 = sub i252 %283, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %291

290:                                              ; preds = %274
  br label %291

291:                                              ; preds = %288, %290
  %292 = phi i252 [ %283, %290 ], [ %289, %288 ]
  br label %293

293:                                              ; preds = %291
  %294 = add i64 %266, 2
  %295 = add i64 %266, 3
  %296 = select i1 %286, i64 %294, i64 %295
  %297 = trunc i252 %292 to i16
  br i1 %286, label %298, label %317

298:                                              ; preds = %293
  %299 = phi { ptr, i32, i32, i32 } [ %281, %293 ]
  %300 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %299, 0
  %301 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %33, 0
  %302 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %301, i8 %63, 1
  %303 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %302, i8 %93, 2
  %304 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %303, i8 %123, 3
  %305 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %304, i8 %144, 4
  %306 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %305, i8 %165, 5
  %307 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %306, i8 %186, 6
  %308 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %307, i8 %207, 7
  %309 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %308, i16 %237, 8
  %310 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %309, i16 %267, 9
  %311 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %310, i16 %297, 10
  %312 = insertvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } { i1 false, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %311, 1
  store { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %312, ptr %4, align 2
  %313 = load { i16, [14 x i8] }, ptr %4, align 2
  %314 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } undef, i64 %296, 0
  %315 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %314, { { ptr, i32, i32, i32 } } %300, 1
  %316 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %315, { i16, [14 x i8] } %313, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %316

317:                                              ; preds = %293, %268, %263, %238, %233, %208, %193, %187, %172, %166, %151, %145, %130, %124, %119, %94, %89, %64, %59, %34, %29, %2
  %318 = phi i64 [ %296, %293 ], [ %266, %268 ], [ %266, %263 ], [ %236, %238 ], [ %236, %233 ], [ %206, %208 ], [ %206, %193 ], [ %185, %187 ], [ %185, %172 ], [ %164, %166 ], [ %164, %151 ], [ %143, %145 ], [ %143, %130 ], [ %122, %124 ], [ %122, %119 ], [ %92, %94 ], [ %92, %89 ], [ %62, %64 ], [ %62, %59 ], [ %32, %34 ], [ %32, %29 ], [ %0, %2 ]
  %319 = phi { ptr, i32, i32, i32 } [ %281, %293 ], [ %269, %268 ], [ %251, %263 ], [ %239, %238 ], [ %221, %233 ], [ %209, %208 ], [ %200, %193 ], [ %188, %187 ], [ %179, %172 ], [ %167, %166 ], [ %158, %151 ], [ %146, %145 ], [ %137, %130 ], [ %125, %124 ], [ %107, %119 ], [ %95, %94 ], [ %77, %89 ], [ %65, %64 ], [ %47, %59 ], [ %35, %34 ], [ %17, %29 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %320 = load { i16, [14 x i8] }, ptr %3, align 2
  %321 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %319, 0
  %322 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } undef, i64 %318, 0
  %323 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %322, { { ptr, i32, i32, i32 } } %321, 1
  %324 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %323, { i16, [14 x i8] } %320, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %324
}

define private { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @f27(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f27"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %8, { i16, [14 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %9
}

define void @_mlir_ciface_f27(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @f27(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$417"({ i128, [160 x i8] } %0) {
  %2 = alloca { i128, [160 x i8] }, i64 1, align 16
  store { i128, [160 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i128, [144 x i8] } }, ptr %2, align 16
  %6 = extractvalue { i1, { i128, [144 x i8] } } %5, 1
  call void @"drop$140"({ i128, [144 x i8] } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [160 x i8] }, { i128, [160 x i8] } } @"dup$417"({ i128, [160 x i8] } %0) {
  %2 = alloca { i128, [160 x i8] }, i64 1, align 16
  store { i128, [160 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i128, [144 x i8] } }, ptr %2, align 16
  %6 = extractvalue { i1, { i128, [144 x i8] } } %5, 1
  %7 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$140"({ i128, [144 x i8] } %6)
  %8 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %7, 0
  %9 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %7, 1
  %10 = insertvalue { i1, { i128, [144 x i8] } } %5, { i128, [144 x i8] } %8, 1
  store { i1, { i128, [144 x i8] } } %10, ptr %2, align 16
  %11 = load { i128, [160 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { i128, [144 x i8] } } %5, { i128, [144 x i8] } %9, 1
  store { i1, { i128, [144 x i8] } } %12, ptr %2, align 16
  %13 = load { i128, [160 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } undef, { i128, [160 x i8] } %11, 0
  %15 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %14, { i128, [160 x i8] } %13, 1
  ret { { i128, [160 x i8] }, { i128, [160 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [160 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [160 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } undef, { i128, [160 x i8] } %20, 0
  %24 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %23, { i128, [160 x i8] } %22, 1
  ret { { i128, [160 x i8] }, { i128, [160 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$418"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 1
  call void @"drop$417"({ i128, [160 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } @"dup$418"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %0, 1
  %9 = call { { i128, [160 x i8] }, { i128, [160 x i8] } } @"dup$417"({ i128, [160 x i8] } %8)
  %10 = extractvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %9, 0
  %11 = extractvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %6, { i128, [160 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %7, { i128, [160 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %15
}

define private void @"drop$419"({ i128, [208 x i8] } %0) {
  %2 = alloca { i128, [208 x i8] }, i64 1, align 16
  store { i128, [208 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, 1
  call void @"drop$418"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [208 x i8] }, { i128, [208 x i8] } } @"dup$419"({ i128, [208 x i8] } %0) {
  %2 = alloca { i128, [208 x i8] }, i64 1, align 16
  store { i128, [208 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } @"dup$418"({ { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [208 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [208 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } undef, { i128, [208 x i8] } %11, 0
  %15 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } %14, { i128, [208 x i8] } %13, 1
  ret { { i128, [208 x i8] }, { i128, [208 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [208 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [208 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } undef, { i128, [208 x i8] } %23, 0
  %27 = insertvalue { { i128, [208 x i8] }, { i128, [208 x i8] } } %26, { i128, [208 x i8] } %25, 1
  ret { { i128, [208 x i8] }, { i128, [208 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f28"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i128, [208 x i8] }, i64 1, align 16
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i128, [160 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %19

19:                                               ; preds = %129, %5
  %20 = phi i64 [ %60, %129 ], [ %0, %5 ]
  %21 = phi i64 [ %89, %129 ], [ %1, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %69, %129 ], [ %2, %5 ]
  %23 = phi { ptr, i32, i32, i32 } [ %138, %129 ], [ %3, %5 ]
  %24 = phi i252 [ %145, %129 ], [ %4, %5 ]
  %25 = add i64 %20, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 28110
  %30 = icmp uge i64 %21, %29
  %31 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %29)
  br i1 %30, label %32, label %187

32:                                               ; preds = %19
  %33 = phi i252 [ %24, %19 ]
  %34 = icmp eq i252 %33, 0
  br i1 %34, label %35, label %57

35:                                               ; preds = %32
  %36 = phi i64 [ %31, %32 ]
  %37 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %38 = call ptr %37()
  %39 = load i64, ptr %38, align 8
  %40 = mul i64 %39, 29010
  %41 = call i64 @llvm.uadd.sat.i64(i64 %36, i64 %40)
  %42 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %23, 1
  store { i1, { ptr, i32, i32, i32 } } %42, ptr %17, align 8
  %43 = load { i64, [24 x i8] }, ptr %17, align 8
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %22, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %43, 1
  %46 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %45, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, ptr %18, align 8
  %47 = load { i64, [56 x i8] }, ptr %18, align 8
  %48 = extractvalue { ptr, ptr, i64 } %9, 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp eq i64 %49, 0
  %51 = sub i64 %49, 1
  %52 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %51, ptr %52, align 8
  br i1 %50, label %53, label %166

53:                                               ; preds = %35
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, i64 %41, 1
  %56 = insertvalue { i64, i64, { i64, [56 x i8] } } %55, { i64, [56 x i8] } %47, 2
  ret { i64, i64, { i64, [56 x i8] } } %56

57:                                               ; preds = %32
  %58 = phi i64 [ %25, %32 ]
  %59 = call fastcc { i64, i64, { i128, [208 x i8] } } @"impl$f58"(i64 %58, i64 %31, { { ptr, i32, i32, i32 } } %22)
  %60 = extractvalue { i64, i64, { i128, [208 x i8] } } %59, 0
  %61 = extractvalue { i64, i64, { i128, [208 x i8] } } %59, 1
  %62 = extractvalue { i64, i64, { i128, [208 x i8] } } %59, 2
  store { i128, [208 x i8] } %62, ptr %12, align 16
  %63 = load i1, ptr %12, align 1
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %72
  ]

64:                                               ; preds = %57
  br i1 false, label %65, label %202

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %57
  %67 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } }, ptr %12, align 16
  %68 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %67, 1
  %69 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %68, 1
  store { i128, [160 x i8] } %70, ptr %14, align 16
  %71 = load i1, ptr %14, align 1
  switch i1 %71, label %82 [
    i1 false, label %84
    i1 true, label %150
  ]

72:                                               ; preds = %57
  %73 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %74 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %73, 1
  call void @"drop$292"({ ptr, i32, i32, i32 } %23)
  %75 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %74, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %75, ptr %13, align 8
  %76 = load { i64, [56 x i8] }, ptr %13, align 8
  %77 = extractvalue { ptr, ptr, i64 } %9, 1
  %78 = load i64, ptr %77, align 8
  %79 = icmp eq i64 %78, 0
  %80 = sub i64 %78, 1
  %81 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %80, ptr %81, align 8
  br i1 %79, label %183, label %166

82:                                               ; preds = %66
  br i1 false, label %83, label %203

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %66
  %85 = load { i1, { i128, [144 x i8] } }, ptr %14, align 16
  %86 = extractvalue { i1, { i128, [144 x i8] } } %85, 1
  %87 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %88 = call ptr %87()
  %89 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 0)
  %90 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %91 = icmp eq i32 %90, 0
  br i1 %91, label %92, label %106

92:                                               ; preds = %84
  %93 = shl i32 %90, 1
  %94 = call i32 @llvm.umin.i32(i32 %93, i32 1024)
  %95 = add i32 %94, %90
  %96 = call i32 @llvm.umax.i32(i32 %95, i32 8)
  %97 = zext i32 %96 to i64
  %98 = mul i64 %97, 160
  %99 = add i64 %98, 16
  %100 = call ptr @realloc(ptr null, i64 %99)
  store i32 1, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %100, i32 4
  store i32 0, ptr %101, align 4
  %102 = getelementptr inbounds i8, ptr %100, i32 16
  %103 = call ptr @realloc(ptr null, i64 8)
  store ptr %102, ptr %103, align 8
  %104 = insertvalue { ptr, i32, i32, i32 } %23, ptr %103, 0
  %105 = insertvalue { ptr, i32, i32, i32 } %104, i32 %96, 3
  br label %127

106:                                              ; preds = %84
  %107 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %108 = icmp ult i32 %107, %90
  br i1 %108, label %109, label %110

109:                                              ; preds = %106
  br label %124

110:                                              ; preds = %106
  %111 = shl i32 %90, 1
  %112 = call i32 @llvm.umin.i32(i32 %111, i32 1024)
  %113 = add i32 %112, %90
  %114 = call i32 @llvm.umax.i32(i32 %113, i32 8)
  %115 = zext i32 %114 to i64
  %116 = mul i64 %115, 160
  %117 = add i64 %116, 16
  %118 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %119 = load ptr, ptr %118, align 8
  %120 = getelementptr inbounds i8, ptr %119, i32 -16
  %121 = call ptr @realloc(ptr %120, i64 %117)
  %122 = getelementptr inbounds i8, ptr %121, i32 16
  store ptr %122, ptr %118, align 8
  %123 = insertvalue { ptr, i32, i32, i32 } %23, i32 %114, 3
  br label %124

124:                                              ; preds = %109, %110
  %125 = phi { ptr, i32, i32, i32 } [ %123, %110 ], [ %23, %109 ]
  br label %126

126:                                              ; preds = %124
  br label %127

127:                                              ; preds = %92, %126
  %128 = phi { ptr, i32, i32, i32 } [ %125, %126 ], [ %105, %92 ]
  br label %129

129:                                              ; preds = %127
  %130 = extractvalue { ptr, i32, i32, i32 } %128, 0
  %131 = load ptr, ptr %130, align 8
  %132 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %133 = zext i32 %132 to i64
  %134 = mul i64 %133, 160
  %135 = getelementptr inbounds i8, ptr %131, i64 %134
  store { i128, [144 x i8] } %86, ptr %135, align 16
  %136 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %137 = add i32 %136, 1
  %138 = insertvalue { ptr, i32, i32, i32 } %128, i32 %137, 2
  %139 = getelementptr inbounds i8, ptr %131, i32 -12
  store i32 %137, ptr %139, align 4
  %140 = zext i252 %33 to i256
  %141 = sub i256 %140, 1
  %142 = add i256 %140, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %143 = icmp ult i256 %140, 1
  %144 = select i1 %143, i256 %142, i256 %141
  %145 = trunc i256 %144 to i252
  %146 = extractvalue { ptr, ptr, i64 } %9, 1
  %147 = load i64, ptr %146, align 8
  %148 = add i64 %147, 1
  %149 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %148, ptr %149, align 8
  br label %19

150:                                              ; preds = %66
  call void @"drop$292"({ ptr, i32, i32, i32 } %23)
  %151 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %152 = call ptr %151()
  %153 = load i64, ptr %152, align 8
  %154 = mul i64 %153, 3470
  %155 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 %154)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %15, align 1
  %156 = load { i64, [24 x i8] }, ptr %15, align 8
  %157 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %69, 0
  %158 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %156, 1
  %159 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %158, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %159, ptr %16, align 8
  %160 = load { i64, [56 x i8] }, ptr %16, align 8
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %179, label %166

166:                                              ; preds = %166, %35, %150, %72, %187
  %167 = phi i64 [ %25, %187 ], [ %167, %166 ], [ %60, %150 ], [ %60, %72 ], [ %25, %35 ]
  %168 = phi i64 [ %21, %187 ], [ %168, %166 ], [ %155, %150 ], [ %61, %72 ], [ %41, %35 ]
  %169 = phi { i64, [56 x i8] } [ %192, %187 ], [ %169, %166 ], [ %160, %150 ], [ %76, %72 ], [ %47, %35 ]
  %170 = extractvalue { ptr, ptr, i64 } %9, 1
  %171 = load i64, ptr %170, align 8
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %171, 1
  %174 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %173, ptr %174, align 8
  br i1 %172, label %175, label %166

175:                                              ; preds = %166
  %176 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %177 = insertvalue { i64, i64, { i64, [56 x i8] } } %176, i64 %168, 1
  %178 = insertvalue { i64, i64, { i64, [56 x i8] } } %177, { i64, [56 x i8] } %169, 2
  ret { i64, i64, { i64, [56 x i8] } } %178

179:                                              ; preds = %150
  %180 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %181 = insertvalue { i64, i64, { i64, [56 x i8] } } %180, i64 %155, 1
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } %181, { i64, [56 x i8] } %160, 2
  ret { i64, i64, { i64, [56 x i8] } } %182

183:                                              ; preds = %72
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %185 = insertvalue { i64, i64, { i64, [56 x i8] } } %184, i64 %61, 1
  %186 = insertvalue { i64, i64, { i64, [56 x i8] } } %185, { i64, [56 x i8] } %76, 2
  ret { i64, i64, { i64, [56 x i8] } } %186

187:                                              ; preds = %19
  %188 = phi { ptr, i32, i32, i32 } [ %23, %19 ]
  call void @"drop$292"({ ptr, i32, i32, i32 } %188)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %22)
  %189 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %190 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %189, 0
  %191 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %190, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %191, ptr %11, align 8
  %192 = load { i64, [56 x i8] }, ptr %11, align 8
  %193 = extractvalue { ptr, ptr, i64 } %9, 1
  %194 = load i64, ptr %193, align 8
  %195 = icmp eq i64 %194, 0
  %196 = sub i64 %194, 1
  %197 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %196, ptr %197, align 8
  br i1 %195, label %198, label %166

198:                                              ; preds = %187
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %200 = insertvalue { i64, i64, { i64, [56 x i8] } } %199, i64 %21, 1
  %201 = insertvalue { i64, i64, { i64, [56 x i8] } } %200, { i64, [56 x i8] } %192, 2
  ret { i64, i64, { i64, [56 x i8] } } %201

202:                                              ; preds = %64
  call void @puts(ptr @assert_msg_60)
  call void @abort()
  unreachable

203:                                              ; preds = %82
  call void @puts(ptr @assert_msg_61)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f28(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f28"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f28(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f28(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$293"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$292"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$293"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$294"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$293"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$294"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$293"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { i3, [0 x i8] } %5, i32 %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca i256, i64 1, align 16
  %17 = alloca i256, i64 1, align 16
  %18 = alloca i256, i64 1, align 16
  %19 = alloca { i128, [16 x i8] }, i64 1, align 16
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i1, [31 x i8] }, i64 1, align 8
  %22 = alloca i64, i64 1, align 8
  %23 = alloca i252, i64 1, align 16
  %24 = alloca i252, i64 1, align 16
  %25 = alloca { i64, [24 x i8] }, i64 1, align 8
  %26 = alloca { i1, [47 x i8] }, i64 1, align 16
  %27 = alloca i64, i64 1, align 8
  %28 = alloca i252, i64 1, align 16
  %29 = alloca { i64, [24 x i8] }, i64 1, align 8
  %30 = alloca { i64, [24 x i8] }, i64 1, align 8
  %31 = alloca { i64, [24 x i8] }, i64 1, align 8
  %32 = alloca { i64, [24 x i8] }, i64 1, align 8
  %33 = alloca { i1, [31 x i8] }, i64 1, align 8
  %34 = alloca i64, i64 1, align 8
  %35 = alloca i252, i64 1, align 16
  %36 = alloca i252, i64 1, align 16
  %37 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %38 = alloca { i64, [24 x i8] }, i64 1, align 8
  %39 = alloca { i64, [24 x i8] }, i64 1, align 8
  %40 = alloca { i64, [56 x i8] }, i64 1, align 8
  %41 = alloca { i64, [24 x i8] }, i64 1, align 8
  %42 = alloca { i64, [24 x i8] }, i64 1, align 8
  %43 = load ptr, ptr %3, align 8
  store i64 %1, ptr %12, align 8
  %44 = getelementptr inbounds ptr, ptr %3, i32 3
  %45 = load ptr, ptr %44, align 8
  call void %45(ptr %11, ptr %43, ptr %12)
  %46 = load { i1, [31 x i8] }, ptr %11, align 1
  %47 = extractvalue { i1, [31 x i8] } %46, 0
  %48 = getelementptr inbounds i8, ptr %11, i32 8
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr inbounds i8, ptr %11, i32 8
  %51 = load { ptr, i32, i32, i32 }, ptr %50, align 8
  %52 = load i64, ptr %12, align 8
  br i1 %47, label %426, label %53

53:                                               ; preds = %10
  %54 = phi ptr [ %49, %10 ]
  %55 = load { ptr, ptr, i252, i252, i252 }, ptr %54, align 16
  call void @free(ptr %54)
  %56 = extractvalue { ptr, ptr, i252, i252, i252 } %55, 0
  %57 = extractvalue { ptr, ptr, i252, i252, i252 } %55, 1
  %58 = extractvalue { ptr, ptr, i252, i252, i252 } %55, 2
  call void @"drop$520"(ptr %56)
  call void @"drop$519"(ptr %57)
  %59 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f24"(i64 %0, i64 %52, i64 %2, ptr %3, { {} } %4, i252 %58)
  %60 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, 0
  %61 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, 1
  %62 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, 2
  %63 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, 3
  %64 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %59, 4
  store { i64, [24 x i8] } %64, ptr %14, align 8
  %65 = load i1, ptr %14, align 1
  switch i1 %65, label %66 [
    i1 false, label %68
    i1 true, label %70
  ]

66:                                               ; preds = %53
  br i1 false, label %67, label %436

67:                                               ; preds = %66
  unreachable

68:                                               ; preds = %53
  %69 = extractvalue { i3, [0 x i8] } %5, 0
  switch i3 %69, label %82 [
    i3 0, label %84
    i3 1, label %91
    i3 2, label %102
    i3 3, label %113
    i3 -4, label %124
    i3 -3, label %135
    i3 -2, label %146
  ]

70:                                               ; preds = %53
  %71 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %72 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %71, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %7)
  call void @"drop$292"({ ptr, i32, i32, i32 } %9)
  %73 = extractvalue { {}, { ptr, i32, i32, i32 } } %72, 1
  %74 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %73, 1
  %75 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %74, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %75, ptr %15, align 8
  %76 = load { i64, [24 x i8] }, ptr %15, align 8
  %77 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %60, 0
  %78 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, i64 %61, 1
  %79 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %78, i64 %62, 2
  %80 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %79, ptr %63, 3
  %81 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, { i64, [24 x i8] } %76, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %81

82:                                               ; preds = %68
  br i1 false, label %83, label %437

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %68
  %85 = phi i64 [ %61, %68 ]
  %86 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %87 = call ptr %86()
  %88 = load i64, ptr %87, align 8
  %89 = mul i64 %88, 90
  %90 = call i64 @llvm.uadd.sat.i64(i64 %85, i64 %89)
  br label %159

91:                                               ; preds = %68
  %92 = phi i64 [ %61, %68 ]
  %93 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %94 = call ptr %93()
  %95 = call i64 @llvm.uadd.sat.i64(i64 %92, i64 0)
  %96 = zext i32 %6 to i256
  %97 = add i256 %96, 4294967296
  %98 = add i256 %96, -3618502788666131213697322783095070105623107215331596699973092056131577053185
  %99 = icmp uge i256 %97, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %100 = select i1 %99, i256 %98, i256 %97
  %101 = trunc i256 %100 to i252
  br label %159

102:                                              ; preds = %68
  %103 = phi i64 [ %61, %68 ]
  %104 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %105 = call ptr %104()
  %106 = call i64 @llvm.uadd.sat.i64(i64 %103, i64 0)
  %107 = zext i32 %6 to i256
  %108 = add i256 %107, 8589934592
  %109 = add i256 %107, -3618502788666131213697322783095070105623107215331596699973092056127282085889
  %110 = icmp uge i256 %108, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %111 = select i1 %110, i256 %109, i256 %108
  %112 = trunc i256 %111 to i252
  br label %159

113:                                              ; preds = %68
  %114 = phi i64 [ %61, %68 ]
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = call i64 @llvm.uadd.sat.i64(i64 %114, i64 0)
  %118 = zext i32 %6 to i256
  %119 = add i256 %118, 12884901888
  %120 = add i256 %118, -3618502788666131213697322783095070105623107215331596699973092056122987118593
  %121 = icmp uge i256 %119, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %122 = select i1 %121, i256 %120, i256 %119
  %123 = trunc i256 %122 to i252
  br label %159

124:                                              ; preds = %68
  %125 = phi i64 [ %61, %68 ]
  %126 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %127 = call ptr %126()
  %128 = call i64 @llvm.uadd.sat.i64(i64 %125, i64 0)
  %129 = zext i32 %6 to i256
  %130 = add i256 %129, 17179869184
  %131 = add i256 %129, -3618502788666131213697322783095070105623107215331596699973092056118692151297
  %132 = icmp uge i256 %130, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %133 = select i1 %132, i256 %131, i256 %130
  %134 = trunc i256 %133 to i252
  br label %159

135:                                              ; preds = %68
  %136 = phi i64 [ %61, %68 ]
  %137 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %138 = call ptr %137()
  %139 = call i64 @llvm.uadd.sat.i64(i64 %136, i64 0)
  %140 = zext i32 %6 to i256
  %141 = add i256 %140, 21474836480
  %142 = add i256 %140, -3618502788666131213697322783095070105623107215331596699973092056114397184001
  %143 = icmp uge i256 %141, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %144 = select i1 %143, i256 %142, i256 %141
  %145 = trunc i256 %144 to i252
  br label %159

146:                                              ; preds = %68
  %147 = phi i64 [ %61, %68 ]
  %148 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %149 = call ptr %148()
  %150 = load i64, ptr %149, align 8
  %151 = mul i64 %150, 100
  %152 = call i64 @llvm.uadd.sat.i64(i64 %147, i64 %151)
  %153 = zext i32 %6 to i256
  %154 = add i256 %153, 25769803776
  %155 = add i256 %153, -3618502788666131213697322783095070105623107215331596699973092056110102216705
  %156 = icmp uge i256 %154, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %157 = select i1 %156, i256 %155, i256 %154
  %158 = trunc i256 %157 to i252
  br label %159

159:                                              ; preds = %84, %91, %102, %113, %124, %135, %146
  %160 = phi { i3, [0 x i8] } [ %5, %146 ], [ %5, %135 ], [ %5, %124 ], [ %5, %113 ], [ %5, %102 ], [ %5, %91 ], [ %5, %84 ]
  %161 = phi i32 [ %6, %146 ], [ %6, %135 ], [ %6, %124 ], [ %6, %113 ], [ %6, %102 ], [ %6, %91 ], [ %6, %84 ]
  %162 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %7, %146 ], [ %7, %135 ], [ %7, %124 ], [ %7, %113 ], [ %7, %102 ], [ %7, %91 ], [ %7, %84 ]
  %163 = phi { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } [ %8, %146 ], [ %8, %135 ], [ %8, %124 ], [ %8, %113 ], [ %8, %102 ], [ %8, %91 ], [ %8, %84 ]
  %164 = phi { ptr, i32, i32, i32 } [ %9, %146 ], [ %9, %135 ], [ %9, %124 ], [ %9, %113 ], [ %9, %102 ], [ %9, %91 ], [ %9, %84 ]
  %165 = phi { {} } [ %4, %146 ], [ %4, %135 ], [ %4, %124 ], [ %4, %113 ], [ %4, %102 ], [ %4, %91 ], [ %4, %84 ]
  %166 = phi i64 [ %60, %146 ], [ %60, %135 ], [ %60, %124 ], [ %60, %113 ], [ %60, %102 ], [ %60, %91 ], [ %60, %84 ]
  %167 = phi i64 [ %62, %146 ], [ %62, %135 ], [ %62, %124 ], [ %62, %113 ], [ %62, %102 ], [ %62, %91 ], [ %62, %84 ]
  %168 = phi ptr [ %63, %146 ], [ %63, %135 ], [ %63, %124 ], [ %63, %113 ], [ %63, %102 ], [ %63, %91 ], [ %63, %84 ]
  %169 = phi i64 [ %152, %146 ], [ %139, %135 ], [ %128, %124 ], [ %117, %113 ], [ %106, %102 ], [ %95, %91 ], [ %90, %84 ]
  %170 = phi i252 [ %158, %146 ], [ %145, %135 ], [ %134, %124 ], [ %123, %113 ], [ %112, %102 ], [ %101, %91 ], [ 0, %84 ]
  %171 = add i64 %167, 3
  %172 = zext i252 %170 to i256
  store i256 1555170125836447351353653902862745931305207776976209346350698701924491819, ptr %16, align 16
  store i256 %172, ptr %17, align 16
  %173 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %173(ptr %18, ptr %16, ptr %17)
  %174 = load i256, ptr %18, align 16
  %175 = trunc i256 %174 to i252
  %176 = add i64 %166, 3
  %177 = sub i252 %175, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %178 = icmp ult i252 %175, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %179 = select i1 %178, i252 %175, i252 %177
  %180 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f59"(i64 %176, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %163)
  %181 = extractvalue { i64, { i128, [16 x i8] } } %180, 0
  %182 = extractvalue { i64, { i128, [16 x i8] } } %180, 1
  store { i128, [16 x i8] } %182, ptr %19, align 16
  %183 = load i1, ptr %19, align 1
  switch i1 %183, label %184 [
    i1 false, label %186
    i1 true, label %199
  ]

184:                                              ; preds = %159
  br i1 false, label %185, label %438

185:                                              ; preds = %184
  unreachable

186:                                              ; preds = %159
  %187 = load { i1, { i128 } }, ptr %19, align 16
  %188 = extractvalue { i1, { i128 } } %187, 1
  %189 = extractvalue { i128 } %188, 0
  %190 = zext i128 %189 to i252
  %191 = load ptr, ptr %168, align 8
  store i64 %169, ptr %22, align 8
  store i252 %179, ptr %23, align 16
  store i252 %190, ptr %24, align 16
  %192 = getelementptr inbounds ptr, ptr %168, i32 9
  %193 = load ptr, ptr %192, align 8
  call void %193(ptr %21, ptr %191, ptr %22, i32 0, ptr %23, ptr %24)
  %194 = load { i1, [31 x i8] }, ptr %21, align 1
  %195 = extractvalue { i1, [31 x i8] } %194, 0
  %196 = getelementptr inbounds i8, ptr %21, i32 8
  %197 = load { ptr, i32, i32, i32 }, ptr %196, align 8
  %198 = load i64, ptr %22, align 8
  br i1 %195, label %416, label %211

199:                                              ; preds = %159
  %200 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %201 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %200, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %162)
  call void @"drop$292"({ ptr, i32, i32, i32 } %164)
  %202 = extractvalue { {}, { ptr, i32, i32, i32 } } %201, 1
  %203 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %202, 1
  %204 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %203, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %204, ptr %20, align 8
  %205 = load { i64, [24 x i8] }, ptr %20, align 8
  %206 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %181, 0
  %207 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %206, i64 %169, 1
  %208 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %207, i64 %171, 2
  %209 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %208, ptr %168, 3
  %210 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %209, { i64, [24 x i8] } %205, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %210

211:                                              ; preds = %186
  %212 = phi i252 [ 814182874304483309791743286124228493744277863724345952005546811777229850325, %186 ]
  %213 = load ptr, ptr %168, align 8
  store i64 %198, ptr %27, align 8
  store i252 %212, ptr %28, align 16
  %214 = getelementptr inbounds ptr, ptr %168, i32 8
  %215 = load ptr, ptr %214, align 8
  call void %215(ptr %26, ptr %213, ptr %27, i32 0, ptr %28)
  %216 = load { i1, [47 x i8] }, ptr %26, align 1
  %217 = extractvalue { i1, [47 x i8] } %216, 0
  %218 = getelementptr inbounds i8, ptr %26, i32 16
  %219 = load i252, ptr %218, align 16
  %220 = getelementptr inbounds i8, ptr %26, i32 8
  %221 = load { ptr, i32, i32, i32 }, ptr %220, align 8
  %222 = load i64, ptr %27, align 8
  br i1 %217, label %406, label %223

223:                                              ; preds = %211
  %224 = phi i252 [ %219, %211 ]
  %225 = add i64 %181, 3
  %226 = icmp ult i252 %224, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %226, label %227, label %393

227:                                              ; preds = %223
  %228 = phi { ptr, i32, i32, i32 } [ %164, %223 ]
  %229 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %228)
  %230 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %229, 0
  %231 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %229, 1
  call void @"drop$292"({ ptr, i32, i32, i32 } %230)
  %232 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$293"({ ptr, i32, i32, i32 } %231)
  %233 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %232, 0
  %234 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %232, 1
  %235 = extractvalue { ptr, i32, i32, i32 } %234, 1
  %236 = extractvalue { ptr, i32, i32, i32 } %234, 2
  %237 = sub i32 %236, %235
  call void @"drop$293"({ ptr, i32, i32, i32 } %234)
  %238 = zext i32 %237 to i252
  %239 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %239, align 4
  %240 = getelementptr inbounds i8, ptr %239, i32 4
  store i32 0, ptr %240, align 4
  %241 = getelementptr inbounds i8, ptr %239, i32 16
  %242 = call ptr @realloc(ptr null, i64 8)
  store ptr %241, ptr %242, align 8
  %243 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %242, 0
  %244 = insertvalue { ptr, i32, i32, i32 } %243, i32 8, 3
  %245 = load ptr, ptr %242, align 8
  store i252 %238, ptr %245, align 16
  %246 = insertvalue { ptr, i32, i32, i32 } %244, i32 1, 2
  %247 = getelementptr inbounds i8, ptr %245, i32 -12
  store i32 1, ptr %247, align 4
  %248 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %233, 0
  %249 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f60"(i64 %225, i64 %222, { { ptr, i32, i32, i32 } } %248, { ptr, i32, i32, i32 } %246)
  %250 = extractvalue { i64, i64, { i64, [24 x i8] } } %249, 0
  %251 = extractvalue { i64, i64, { i64, [24 x i8] } } %249, 1
  %252 = extractvalue { i64, i64, { i64, [24 x i8] } } %249, 2
  store { i64, [24 x i8] } %252, ptr %31, align 8
  %253 = load i1, ptr %31, align 1
  switch i1 %253, label %254 [
    i1 false, label %256
    i1 true, label %274
  ]

254:                                              ; preds = %227
  br i1 false, label %255, label %439

255:                                              ; preds = %254
  unreachable

256:                                              ; preds = %227
  %257 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %31, align 8
  %258 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %257, 1
  %259 = extractvalue { { ptr, i32, i32, i32 }, {} } %258, 0
  %260 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %259)
  %261 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %260, 0
  %262 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %260, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %261)
  %263 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %262, 0
  %264 = load ptr, ptr %168, align 8
  store i64 %251, ptr %34, align 8
  store i252 %224, ptr %35, align 16
  store i252 1043237155915217200023777142698719717442160588069512551429544266543089341477, ptr %36, align 16
  store { { ptr, i32, i32, i32 } } %263, ptr %37, align 8
  %265 = getelementptr inbounds ptr, ptr %168, i32 7
  %266 = load ptr, ptr %265, align 8
  call void %266(ptr %33, ptr %264, ptr %34, ptr %35, ptr %36, ptr %37)
  %267 = load { i1, [31 x i8] }, ptr %33, align 1
  %268 = extractvalue { i1, [31 x i8] } %267, 0
  %269 = getelementptr inbounds i8, ptr %33, i32 8
  %270 = load { { ptr, i32, i32, i32 } }, ptr %269, align 8
  %271 = getelementptr inbounds i8, ptr %33, i32 8
  %272 = load { ptr, i32, i32, i32 }, ptr %271, align 8
  %273 = load i64, ptr %34, align 8
  br i1 %268, label %383, label %286

274:                                              ; preds = %227
  %275 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %31, align 8
  %276 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %275, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %162)
  %277 = extractvalue { {}, { ptr, i32, i32, i32 } } %276, 1
  %278 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %277, 1
  %279 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %278, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %279, ptr %32, align 8
  %280 = load { i64, [24 x i8] }, ptr %32, align 8
  %281 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %250, 0
  %282 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %281, i64 %251, 1
  %283 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %282, i64 %171, 2
  %284 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %283, ptr %168, 3
  %285 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %284, { i64, [24 x i8] } %280, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %285

286:                                              ; preds = %256
  %287 = phi { { ptr, i32, i32, i32 } } [ %270, %256 ]
  %288 = extractvalue { { ptr, i32, i32, i32 } } %287, 0
  %289 = extractvalue { ptr, i32, i32, i32 } %288, 1
  %290 = extractvalue { ptr, i32, i32, i32 } %288, 2
  %291 = sub i32 %290, %289
  %292 = icmp uge i32 %291, 1
  br i1 %292, label %293, label %357

293:                                              ; preds = %286
  %294 = extractvalue { ptr, i32, i32, i32 } %288, 0
  %295 = load ptr, ptr %294, align 8
  %296 = zext i32 %289 to i64
  %297 = mul i64 %296, 32
  %298 = getelementptr inbounds i8, ptr %295, i64 %297
  %299 = add i32 %289, 1
  %300 = insertvalue { ptr, i32, i32, i32 } %288, i32 %299, 1
  %301 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %301, ptr %298, i64 32, i1 false)
  %302 = load i252, ptr %301, align 16
  call void @free(ptr %301)
  %303 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %300, 0
  %304 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f48"(i64 %250, i64 %273, { { ptr, i32, i32, i32 } } %303, { ptr, i32, i32, i32 } zeroinitializer, i252 %302)
  %305 = extractvalue { i64, i64, { i64, [56 x i8] } } %304, 0
  %306 = extractvalue { i64, i64, { i64, [56 x i8] } } %304, 1
  %307 = extractvalue { i64, i64, { i64, [56 x i8] } } %304, 2
  store { i64, [56 x i8] } %307, ptr %40, align 8
  %308 = load i1, ptr %40, align 1
  switch i1 %308, label %309 [
    i1 false, label %311
    i1 true, label %317
  ]

309:                                              ; preds = %293
  br i1 false, label %310, label %440

310:                                              ; preds = %309
  unreachable

311:                                              ; preds = %293
  %312 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %40, align 8
  %313 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %312, 1
  %314 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %313, 0
  %315 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %313, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %314)
  store { i64, [24 x i8] } %315, ptr %42, align 8
  %316 = load i1, ptr %42, align 1
  switch i1 %316, label %329 [
    i1 false, label %331
    i1 true, label %348
  ]

317:                                              ; preds = %293
  %318 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %40, align 8
  %319 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %318, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %162)
  %320 = extractvalue { {}, { ptr, i32, i32, i32 } } %319, 1
  %321 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %320, 1
  %322 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %321, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %322, ptr %41, align 8
  %323 = load { i64, [24 x i8] }, ptr %41, align 8
  %324 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %305, 0
  %325 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %324, i64 %306, 1
  %326 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %325, i64 %171, 2
  %327 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, ptr %168, 3
  %328 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %327, { i64, [24 x i8] } %323, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %328

329:                                              ; preds = %311
  br i1 false, label %330, label %441

330:                                              ; preds = %329
  unreachable

331:                                              ; preds = %311
  %332 = load { i1, { ptr, i32, i32, i32 } }, ptr %42, align 8
  %333 = extractvalue { i1, { ptr, i32, i32, i32 } } %332, 1
  %334 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %335 = call ptr %334()
  %336 = call i64 @llvm.uadd.sat.i64(i64 %306, i64 0)
  %337 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %305, i64 %336, i64 %171, ptr %168, { {} } %165, { i3, [0 x i8] } %160, i32 %161, { { ptr, i32, i32, i32 }, i252, i32 } %162, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %163, { ptr, i32, i32, i32 } %333)
  %338 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %337, 0
  %339 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %337, 1
  %340 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %337, 2
  %341 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %337, 3
  %342 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %337, 4
  %343 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %338, 0
  %344 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %343, i64 %339, 1
  %345 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %344, i64 %340, 2
  %346 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %345, ptr %341, 3
  %347 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %346, { i64, [24 x i8] } %342, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %347

348:                                              ; preds = %311
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %162)
  %349 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %350 = call ptr %349()
  %351 = getelementptr inbounds i64, ptr %350, i32 1
  %352 = load i64, ptr %351, align 8
  %353 = load i64, ptr %350, align 8
  %354 = mul i64 %353, 119660
  %355 = add i64 %352, %354
  %356 = call i64 @llvm.uadd.sat.i64(i64 %306, i64 %355)
  br label %367

357:                                              ; preds = %286
  %358 = phi { ptr, i32, i32, i32 } [ %288, %286 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %358)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %162)
  %359 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %360 = call ptr %359()
  %361 = getelementptr inbounds i64, ptr %360, i32 1
  %362 = load i64, ptr %361, align 8
  %363 = load i64, ptr %360, align 8
  %364 = mul i64 %363, 122930
  %365 = add i64 %362, %364
  %366 = call i64 @llvm.uadd.sat.i64(i64 %273, i64 %365)
  br label %367

367:                                              ; preds = %348, %357
  %368 = phi i64 [ %171, %357 ], [ %171, %348 ]
  %369 = phi ptr [ %168, %357 ], [ %168, %348 ]
  %370 = phi i64 [ %250, %357 ], [ %305, %348 ]
  %371 = phi i64 [ %366, %357 ], [ %356, %348 ]
  %372 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"()
  %373 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %372, 0
  %374 = extractvalue { {}, { ptr, i32, i32, i32 } } %373, 1
  %375 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %374, 1
  %376 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %375, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %376, ptr %39, align 8
  %377 = load { i64, [24 x i8] }, ptr %39, align 8
  %378 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %370, 0
  %379 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %378, i64 %371, 1
  %380 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %379, i64 %368, 2
  %381 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %380, ptr %369, 3
  %382 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %381, { i64, [24 x i8] } %377, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %382

383:                                              ; preds = %256
  %384 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %162, %256 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %384)
  %385 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %272, 1
  %386 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %385, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %386, ptr %38, align 8
  %387 = load { i64, [24 x i8] }, ptr %38, align 8
  %388 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %250, 0
  %389 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %388, i64 %273, 1
  %390 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %389, i64 %171, 2
  %391 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %390, ptr %168, 3
  %392 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %391, { i64, [24 x i8] } %387, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %392

393:                                              ; preds = %223
  %394 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %162, %223 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %394)
  call void @"drop$292"({ ptr, i32, i32, i32 } %164)
  %395 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f62"()
  %396 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %395, 0
  %397 = extractvalue { {}, { ptr, i32, i32, i32 } } %396, 1
  %398 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %397, 1
  %399 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %398, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %399, ptr %30, align 8
  %400 = load { i64, [24 x i8] }, ptr %30, align 8
  %401 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %225, 0
  %402 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %401, i64 %222, 1
  %403 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %402, i64 %171, 2
  %404 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %403, ptr %168, 3
  %405 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %404, { i64, [24 x i8] } %400, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %405

406:                                              ; preds = %211
  %407 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %162, %211 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %407)
  call void @"drop$292"({ ptr, i32, i32, i32 } %164)
  %408 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %221, 1
  %409 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %408, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %409, ptr %29, align 8
  %410 = load { i64, [24 x i8] }, ptr %29, align 8
  %411 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %181, 0
  %412 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %411, i64 %222, 1
  %413 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %412, i64 %171, 2
  %414 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %413, ptr %168, 3
  %415 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %414, { i64, [24 x i8] } %410, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %415

416:                                              ; preds = %186
  %417 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %162, %186 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %417)
  call void @"drop$292"({ ptr, i32, i32, i32 } %164)
  %418 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %197, 1
  %419 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %418, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %419, ptr %25, align 8
  %420 = load { i64, [24 x i8] }, ptr %25, align 8
  %421 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %181, 0
  %422 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %421, i64 %198, 1
  %423 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %422, i64 %171, 2
  %424 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %423, ptr %168, 3
  %425 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %424, { i64, [24 x i8] } %420, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %425

426:                                              ; preds = %10
  %427 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %7, %10 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %427)
  call void @"drop$292"({ ptr, i32, i32, i32 } %9)
  %428 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %51, 1
  %429 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %428, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %429, ptr %13, align 8
  %430 = load { i64, [24 x i8] }, ptr %13, align 8
  %431 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %432 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %431, i64 %52, 1
  %433 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %432, i64 %2, 2
  %434 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %433, ptr %3, 3
  %435 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %434, { i64, [24 x i8] } %430, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %435

436:                                              ; preds = %66
  call void @puts(ptr @assert_msg_62)
  call void @abort()
  unreachable

437:                                              ; preds = %82
  call void @puts(ptr @assert_msg_63)
  call void @abort()
  unreachable

438:                                              ; preds = %184
  call void @puts(ptr @assert_msg_64)
  call void @abort()
  unreachable

439:                                              ; preds = %254
  call void @puts(ptr @assert_msg_65)
  call void @abort()
  unreachable

440:                                              ; preds = %309
  call void @puts(ptr @assert_msg_66)
  call void @abort()
  unreachable

441:                                              ; preds = %329
  call void @puts(ptr @assert_msg_67)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f29(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { i3, [0 x i8] } %5, i32 %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f29"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { i3, [0 x i8] } %5, i32 %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %8, { ptr, i32, i32, i32 } %9)
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 0
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 1
  %14 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 2
  %15 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 3
  %16 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 4
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %12, 0
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %13, 1
  %19 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %14, 2
  %20 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %19, ptr %15, 3
  %21 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %20, { i64, [24 x i8] } %16, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %21
}

define void @_mlir_ciface_f29(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { i3, [0 x i8] } %6, i32 %7, { { ptr, i32, i32, i32 }, i252, i32 } %8, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %9, { ptr, i32, i32, i32 } %10) {
  %12 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f29(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { i3, [0 x i8] } %6, i32 %7, { { ptr, i32, i32, i32 }, i252, i32 } %8, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %9, { ptr, i32, i32, i32 } %10)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f30"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 485748461484230571791265682659113160264223489397539653310998840191492917)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f30() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f30"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f30(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f30()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f31"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 485748461484230571791265682659113160264223489397539653310998840191492916)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f31() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f31"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f31(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f31()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$404"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %5, 1
  call void @"drop$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$404"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %5, 1
  %7 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %6)
  %8 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %8, 1
  store { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %10, ptr %2, align 16
  %11 = load { i128, [144 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %9, 1
  store { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %12, ptr %2, align 16
  %13 = load { i128, [144 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %11, 0
  %15 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %14, { i128, [144 x i8] } %13, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [144 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [144 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %20, 0
  %24 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %23, { i128, [144 x i8] } %22, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$405"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  call void @"drop$404"({ i128, [144 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$405"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  %9 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$404"({ i128, [144 x i8] } %8)
  %10 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 0
  %11 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6, { i128, [144 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %7, { i128, [144 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %15
}

define private void @"drop$406"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  call void @"drop$405"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [192 x i8] }, { i128, [192 x i8] } } @"dup$406"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$405"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [192 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [192 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %11, 0
  %15 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %14, { i128, [192 x i8] } %13, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [192 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [192 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %23, 0
  %27 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %26, { i128, [192 x i8] } %25, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f32"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i128, [192 x i8] }, i64 1, align 16
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i128, [144 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %19

19:                                               ; preds = %129, %5
  %20 = phi i64 [ %60, %129 ], [ %0, %5 ]
  %21 = phi i64 [ %89, %129 ], [ %1, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %69, %129 ], [ %2, %5 ]
  %23 = phi { ptr, i32, i32, i32 } [ %138, %129 ], [ %3, %5 ]
  %24 = phi i252 [ %145, %129 ], [ %4, %5 ]
  %25 = add i64 %20, 1
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 37680
  %30 = icmp uge i64 %21, %29
  %31 = call i64 @llvm.usub.sat.i64(i64 %21, i64 %29)
  br i1 %30, label %32, label %187

32:                                               ; preds = %19
  %33 = phi i252 [ %24, %19 ]
  %34 = icmp eq i252 %33, 0
  br i1 %34, label %35, label %57

35:                                               ; preds = %32
  %36 = phi i64 [ %31, %32 ]
  %37 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %38 = call ptr %37()
  %39 = load i64, ptr %38, align 8
  %40 = mul i64 %39, 38580
  %41 = call i64 @llvm.uadd.sat.i64(i64 %36, i64 %40)
  %42 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %23, 1
  store { i1, { ptr, i32, i32, i32 } } %42, ptr %17, align 8
  %43 = load { i64, [24 x i8] }, ptr %17, align 8
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %22, 0
  %45 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %43, 1
  %46 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %45, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %46, ptr %18, align 8
  %47 = load { i64, [56 x i8] }, ptr %18, align 8
  %48 = extractvalue { ptr, ptr, i64 } %9, 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp eq i64 %49, 0
  %51 = sub i64 %49, 1
  %52 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %51, ptr %52, align 8
  br i1 %50, label %53, label %166

53:                                               ; preds = %35
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, i64 %41, 1
  %56 = insertvalue { i64, i64, { i64, [56 x i8] } } %55, { i64, [56 x i8] } %47, 2
  ret { i64, i64, { i64, [56 x i8] } } %56

57:                                               ; preds = %32
  %58 = phi i64 [ %25, %32 ]
  %59 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f63"(i64 %58, i64 %31, { { ptr, i32, i32, i32 } } %22)
  %60 = extractvalue { i64, i64, { i128, [192 x i8] } } %59, 0
  %61 = extractvalue { i64, i64, { i128, [192 x i8] } } %59, 1
  %62 = extractvalue { i64, i64, { i128, [192 x i8] } } %59, 2
  store { i128, [192 x i8] } %62, ptr %12, align 16
  %63 = load i1, ptr %12, align 1
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %72
  ]

64:                                               ; preds = %57
  br i1 false, label %65, label %202

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %57
  %67 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %12, align 16
  %68 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %67, 1
  %69 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %68, 1
  store { i128, [144 x i8] } %70, ptr %14, align 16
  %71 = load i1, ptr %14, align 1
  switch i1 %71, label %82 [
    i1 false, label %84
    i1 true, label %150
  ]

72:                                               ; preds = %57
  %73 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %74 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %73, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %23)
  %75 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %74, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %75, ptr %13, align 8
  %76 = load { i64, [56 x i8] }, ptr %13, align 8
  %77 = extractvalue { ptr, ptr, i64 } %9, 1
  %78 = load i64, ptr %77, align 8
  %79 = icmp eq i64 %78, 0
  %80 = sub i64 %78, 1
  %81 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %80, ptr %81, align 8
  br i1 %79, label %183, label %166

82:                                               ; preds = %66
  br i1 false, label %83, label %203

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %66
  %85 = load { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } }, ptr %14, align 16
  %86 = extractvalue { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %85, 1
  %87 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %88 = call ptr %87()
  %89 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 0)
  %90 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %91 = icmp eq i32 %90, 0
  br i1 %91, label %92, label %106

92:                                               ; preds = %84
  %93 = shl i32 %90, 1
  %94 = call i32 @llvm.umin.i32(i32 %93, i32 1024)
  %95 = add i32 %94, %90
  %96 = call i32 @llvm.umax.i32(i32 %95, i32 8)
  %97 = zext i32 %96 to i64
  %98 = mul i64 %97, 144
  %99 = add i64 %98, 16
  %100 = call ptr @realloc(ptr null, i64 %99)
  store i32 1, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %100, i32 4
  store i32 0, ptr %101, align 4
  %102 = getelementptr inbounds i8, ptr %100, i32 16
  %103 = call ptr @realloc(ptr null, i64 8)
  store ptr %102, ptr %103, align 8
  %104 = insertvalue { ptr, i32, i32, i32 } %23, ptr %103, 0
  %105 = insertvalue { ptr, i32, i32, i32 } %104, i32 %96, 3
  br label %127

106:                                              ; preds = %84
  %107 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %108 = icmp ult i32 %107, %90
  br i1 %108, label %109, label %110

109:                                              ; preds = %106
  br label %124

110:                                              ; preds = %106
  %111 = shl i32 %90, 1
  %112 = call i32 @llvm.umin.i32(i32 %111, i32 1024)
  %113 = add i32 %112, %90
  %114 = call i32 @llvm.umax.i32(i32 %113, i32 8)
  %115 = zext i32 %114 to i64
  %116 = mul i64 %115, 144
  %117 = add i64 %116, 16
  %118 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %119 = load ptr, ptr %118, align 8
  %120 = getelementptr inbounds i8, ptr %119, i32 -16
  %121 = call ptr @realloc(ptr %120, i64 %117)
  %122 = getelementptr inbounds i8, ptr %121, i32 16
  store ptr %122, ptr %118, align 8
  %123 = insertvalue { ptr, i32, i32, i32 } %23, i32 %114, 3
  br label %124

124:                                              ; preds = %109, %110
  %125 = phi { ptr, i32, i32, i32 } [ %123, %110 ], [ %23, %109 ]
  br label %126

126:                                              ; preds = %124
  br label %127

127:                                              ; preds = %92, %126
  %128 = phi { ptr, i32, i32, i32 } [ %125, %126 ], [ %105, %92 ]
  br label %129

129:                                              ; preds = %127
  %130 = extractvalue { ptr, i32, i32, i32 } %128, 0
  %131 = load ptr, ptr %130, align 8
  %132 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %133 = zext i32 %132 to i64
  %134 = mul i64 %133, 144
  %135 = getelementptr inbounds i8, ptr %131, i64 %134
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %86, ptr %135, align 16
  %136 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %137 = add i32 %136, 1
  %138 = insertvalue { ptr, i32, i32, i32 } %128, i32 %137, 2
  %139 = getelementptr inbounds i8, ptr %131, i32 -12
  store i32 %137, ptr %139, align 4
  %140 = zext i252 %33 to i256
  %141 = sub i256 %140, 1
  %142 = add i256 %140, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %143 = icmp ult i256 %140, 1
  %144 = select i1 %143, i256 %142, i256 %141
  %145 = trunc i256 %144 to i252
  %146 = extractvalue { ptr, ptr, i64 } %9, 1
  %147 = load i64, ptr %146, align 8
  %148 = add i64 %147, 1
  %149 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %148, ptr %149, align 8
  br label %19

150:                                              ; preds = %66
  call void @"drop$286"({ ptr, i32, i32, i32 } %23)
  %151 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %152 = call ptr %151()
  %153 = load i64, ptr %152, align 8
  %154 = mul i64 %153, 4170
  %155 = call i64 @llvm.uadd.sat.i64(i64 %61, i64 %154)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %15, align 1
  %156 = load { i64, [24 x i8] }, ptr %15, align 8
  %157 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %69, 0
  %158 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %156, 1
  %159 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %158, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %159, ptr %16, align 8
  %160 = load { i64, [56 x i8] }, ptr %16, align 8
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %179, label %166

166:                                              ; preds = %166, %35, %150, %72, %187
  %167 = phi i64 [ %25, %187 ], [ %167, %166 ], [ %60, %150 ], [ %60, %72 ], [ %25, %35 ]
  %168 = phi i64 [ %21, %187 ], [ %168, %166 ], [ %155, %150 ], [ %61, %72 ], [ %41, %35 ]
  %169 = phi { i64, [56 x i8] } [ %192, %187 ], [ %169, %166 ], [ %160, %150 ], [ %76, %72 ], [ %47, %35 ]
  %170 = extractvalue { ptr, ptr, i64 } %9, 1
  %171 = load i64, ptr %170, align 8
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %171, 1
  %174 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %173, ptr %174, align 8
  br i1 %172, label %175, label %166

175:                                              ; preds = %166
  %176 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %177 = insertvalue { i64, i64, { i64, [56 x i8] } } %176, i64 %168, 1
  %178 = insertvalue { i64, i64, { i64, [56 x i8] } } %177, { i64, [56 x i8] } %169, 2
  ret { i64, i64, { i64, [56 x i8] } } %178

179:                                              ; preds = %150
  %180 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %181 = insertvalue { i64, i64, { i64, [56 x i8] } } %180, i64 %155, 1
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } %181, { i64, [56 x i8] } %160, 2
  ret { i64, i64, { i64, [56 x i8] } } %182

183:                                              ; preds = %72
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %60, 0
  %185 = insertvalue { i64, i64, { i64, [56 x i8] } } %184, i64 %61, 1
  %186 = insertvalue { i64, i64, { i64, [56 x i8] } } %185, { i64, [56 x i8] } %76, 2
  ret { i64, i64, { i64, [56 x i8] } } %186

187:                                              ; preds = %19
  %188 = phi { ptr, i32, i32, i32 } [ %23, %19 ]
  call void @"drop$286"({ ptr, i32, i32, i32 } %188)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %22)
  %189 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %190 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %189, 0
  %191 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %190, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %191, ptr %11, align 8
  %192 = load { i64, [56 x i8] }, ptr %11, align 8
  %193 = extractvalue { ptr, ptr, i64 } %9, 1
  %194 = load i64, ptr %193, align 8
  %195 = icmp eq i64 %194, 0
  %196 = sub i64 %194, 1
  %197 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %196, ptr %197, align 8
  br i1 %195, label %198, label %166

198:                                              ; preds = %187
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %25, 0
  %200 = insertvalue { i64, i64, { i64, [56 x i8] } } %199, i64 %21, 1
  %201 = insertvalue { i64, i64, { i64, [56 x i8] } } %200, { i64, [56 x i8] } %192, 2
  ret { i64, i64, { i64, [56 x i8] } } %201

202:                                              ; preds = %64
  call void @puts(ptr @assert_msg_68)
  call void @abort()
  unreachable

203:                                              ; preds = %82
  call void @puts(ptr @assert_msg_69)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f32(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f32"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f32(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f32(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$300"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$286"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$300"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$286"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$289"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -4
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 24
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { ptr, i32, i32, i32 }, ptr %22, align 8
  call void @"drop$292"({ ptr, i32, i32, i32 } %23)
  %24 = add i64 %19, 24
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$289"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$400"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$300"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$400"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$300"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$401"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$400"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$401"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$400"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$402"({ { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$401"({ { { ptr, i32, i32, i32 } } } %2)
  %3 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$289"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } @"dup$402"({ { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$401"({ { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0, { { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$289"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } undef, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %17, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$403"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$402"({ { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$403"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } @"dup$402"({ { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$290"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$289"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$290"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$289"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$399"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$290"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$399"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$290"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$394"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$286"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$394"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$286"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$395"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$394"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$351"({ { ptr, i32, i32, i32 } } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$395"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$394"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  %9 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$351"({ { ptr, i32, i32, i32 } } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, { { ptr, i32, i32, i32 } } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7, { { ptr, i32, i32, i32 } } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %15
}

define private void @"drop$396"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0, 0
  call void @"drop$395"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } @"dup$396"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$395"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %6, { {} } %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %7, { {} } %8, 1
  %11 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %0, 2
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %9, {} %11, 2
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %10, {} %11, 2
  %14 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } undef, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %12, 0
  %15 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %14, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %13, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %15
}

define private void @"drop$397"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %5, 1
  call void @"drop$396"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$397"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } @"dup$396"({ { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %5, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f33"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { ptr, i32, i32, i32 } %5) {
  %7 = alloca { i1, [31 x i8] }, i64 1, align 8
  %8 = alloca i64, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [48 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i1, [47 x i8] }, i64 1, align 16
  %15 = alloca i64, i64 1, align 8
  %16 = alloca i252, i64 1, align 16
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i1, [31 x i8] }, i64 1, align 8
  %22 = alloca i64, i64 1, align 8
  %23 = alloca i252, i64 1, align 16
  %24 = alloca i252, i64 1, align 16
  %25 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = alloca { i64, [24 x i8] }, i64 1, align 8
  %28 = alloca { i64, [56 x i8] }, i64 1, align 8
  %29 = alloca { i64, [24 x i8] }, i64 1, align 8
  %30 = alloca { i64, [24 x i8] }, i64 1, align 8
  %31 = alloca { i64, [48 x i8] }, i64 1, align 8
  %32 = alloca { i64, [24 x i8] }, i64 1, align 8
  %33 = alloca { i64, [24 x i8] }, i64 1, align 8
  %34 = load ptr, ptr %3, align 8
  store i64 %1, ptr %8, align 8
  %35 = getelementptr inbounds ptr, ptr %3, i32 3
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %7, ptr %34, ptr %8)
  %37 = load { i1, [31 x i8] }, ptr %7, align 1
  %38 = extractvalue { i1, [31 x i8] } %37, 0
  %39 = getelementptr inbounds i8, ptr %7, i32 8
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr inbounds i8, ptr %7, i32 8
  %42 = load { ptr, i32, i32, i32 }, ptr %41, align 8
  %43 = load i64, ptr %8, align 8
  br i1 %38, label %319, label %44

44:                                               ; preds = %6
  %45 = phi ptr [ %40, %6 ]
  %46 = load { ptr, ptr, i252, i252, i252 }, ptr %45, align 16
  call void @free(ptr %45)
  %47 = extractvalue { ptr, ptr, i252, i252, i252 } %46, 0
  %48 = extractvalue { ptr, ptr, i252, i252, i252 } %46, 1
  %49 = extractvalue { ptr, ptr, i252, i252, i252 } %46, 2
  call void @"drop$520"(ptr %47)
  call void @"drop$519"(ptr %48)
  %50 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f24"(i64 %0, i64 %43, i64 %2, ptr %3, { {} } %4, i252 %49)
  %51 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 0
  %52 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 1
  %53 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 2
  %54 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 3
  %55 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 4
  store { i64, [24 x i8] } %55, ptr %10, align 8
  %56 = load i1, ptr %10, align 1
  switch i1 %56, label %57 [
    i1 false, label %59
    i1 true, label %70
  ]

57:                                               ; preds = %44
  br i1 false, label %58, label %329

58:                                               ; preds = %57
  unreachable

59:                                               ; preds = %44
  %60 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$286"({ ptr, i32, i32, i32 } %5)
  %61 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %60, 0
  %62 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %60, 1
  %63 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 0
  %64 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %63, 0
  %65 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f64"(i64 %51, i64 %52, { { { ptr, i32, i32, i32 } } } %64, { ptr, i32, i32, i32 } zeroinitializer)
  %66 = extractvalue { i64, i64, { i64, [48 x i8] } } %65, 0
  %67 = extractvalue { i64, i64, { i64, [48 x i8] } } %65, 1
  %68 = extractvalue { i64, i64, { i64, [48 x i8] } } %65, 2
  store { i64, [48 x i8] } %68, ptr %12, align 8
  %69 = load i1, ptr %12, align 1
  switch i1 %69, label %82 [
    i1 false, label %84
    i1 true, label %97
  ]

70:                                               ; preds = %44
  %71 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %72 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %71, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %5)
  %73 = extractvalue { {}, { ptr, i32, i32, i32 } } %72, 1
  %74 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %73, 1
  %75 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %74, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %75, ptr %11, align 8
  %76 = load { i64, [24 x i8] }, ptr %11, align 8
  %77 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %51, 0
  %78 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %77, i64 %52, 1
  %79 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %78, i64 %53, 2
  %80 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %79, ptr %54, 3
  %81 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, { i64, [24 x i8] } %76, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %81

82:                                               ; preds = %59
  br i1 false, label %83, label %330

83:                                               ; preds = %82
  unreachable

84:                                               ; preds = %59
  %85 = load { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } }, ptr %12, align 8
  %86 = extractvalue { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %85, 1
  %87 = load ptr, ptr %54, align 8
  store i64 %67, ptr %15, align 8
  store i252 814182874304483309791743286124228493744277863724345952005546811777229850325, ptr %16, align 16
  %88 = getelementptr inbounds ptr, ptr %54, i32 8
  %89 = load ptr, ptr %88, align 8
  call void %89(ptr %14, ptr %87, ptr %15, i32 0, ptr %16)
  %90 = load { i1, [47 x i8] }, ptr %14, align 1
  %91 = extractvalue { i1, [47 x i8] } %90, 0
  %92 = getelementptr inbounds i8, ptr %14, i32 16
  %93 = load i252, ptr %92, align 16
  %94 = getelementptr inbounds i8, ptr %14, i32 8
  %95 = load { ptr, i32, i32, i32 }, ptr %94, align 8
  %96 = load i64, ptr %15, align 8
  br i1 %91, label %309, label %107

97:                                               ; preds = %59
  %98 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %99 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %98, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %61)
  %100 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %99, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %100, ptr %13, align 8
  %101 = load { i64, [24 x i8] }, ptr %13, align 8
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %66, 0
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, i64 %67, 1
  %104 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %103, i64 %53, 2
  %105 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %104, ptr %54, 3
  %106 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %105, { i64, [24 x i8] } %101, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %106

107:                                              ; preds = %84
  %108 = phi i64 [ %66, %84 ]
  %109 = phi i252 [ %93, %84 ]
  %110 = add i64 %108, 3
  %111 = icmp ult i252 %109, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %111, label %112, label %296

112:                                              ; preds = %107
  %113 = phi { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } [ %86, %107 ]
  %114 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %113, 0
  %115 = extractvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %113, 1
  call void @"drop$401"({ { { ptr, i32, i32, i32 } } } %114)
  %116 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$289"({ ptr, i32, i32, i32 } %115)
  %117 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %116, 0
  %118 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %116, 1
  call void @"drop$289"({ ptr, i32, i32, i32 } %117)
  %119 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$290"({ ptr, i32, i32, i32 } %118)
  %120 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %119, 0
  %121 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %119, 1
  %122 = extractvalue { ptr, i32, i32, i32 } %121, 1
  %123 = extractvalue { ptr, i32, i32, i32 } %121, 2
  %124 = sub i32 %123, %122
  call void @"drop$290"({ ptr, i32, i32, i32 } %121)
  %125 = zext i32 %124 to i252
  %126 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %126, align 4
  %127 = getelementptr inbounds i8, ptr %126, i32 4
  store i32 0, ptr %127, align 4
  %128 = getelementptr inbounds i8, ptr %126, i32 16
  %129 = call ptr @realloc(ptr null, i64 8)
  store ptr %128, ptr %129, align 8
  %130 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %129, 0
  %131 = insertvalue { ptr, i32, i32, i32 } %130, i32 8, 3
  %132 = load ptr, ptr %129, align 8
  store i252 %125, ptr %132, align 16
  %133 = insertvalue { ptr, i32, i32, i32 } %131, i32 1, 2
  %134 = getelementptr inbounds i8, ptr %132, i32 -12
  store i32 1, ptr %134, align 4
  %135 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %120, 0
  %136 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f65"(i64 %110, i64 %96, { { ptr, i32, i32, i32 } } %135, { ptr, i32, i32, i32 } %133)
  %137 = extractvalue { i64, i64, { i64, [24 x i8] } } %136, 0
  %138 = extractvalue { i64, i64, { i64, [24 x i8] } } %136, 1
  %139 = extractvalue { i64, i64, { i64, [24 x i8] } } %136, 2
  store { i64, [24 x i8] } %139, ptr %19, align 8
  %140 = load i1, ptr %19, align 1
  switch i1 %140, label %141 [
    i1 false, label %143
    i1 true, label %161
  ]

141:                                              ; preds = %112
  br i1 false, label %142, label %331

142:                                              ; preds = %141
  unreachable

143:                                              ; preds = %112
  %144 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %19, align 8
  %145 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %144, 1
  %146 = extractvalue { { ptr, i32, i32, i32 }, {} } %145, 0
  %147 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %146)
  %148 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 0
  %149 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %147, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %148)
  %150 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %149, 0
  %151 = load ptr, ptr %54, align 8
  store i64 %138, ptr %22, align 8
  store i252 %109, ptr %23, align 16
  store i252 1069612565676098049371670206424910990441854040853550367722962445535705485641, ptr %24, align 16
  store { { ptr, i32, i32, i32 } } %150, ptr %25, align 8
  %152 = getelementptr inbounds ptr, ptr %54, i32 7
  %153 = load ptr, ptr %152, align 8
  call void %153(ptr %21, ptr %151, ptr %22, ptr %23, ptr %24, ptr %25)
  %154 = load { i1, [31 x i8] }, ptr %21, align 1
  %155 = extractvalue { i1, [31 x i8] } %154, 0
  %156 = getelementptr inbounds i8, ptr %21, i32 8
  %157 = load { { ptr, i32, i32, i32 } }, ptr %156, align 8
  %158 = getelementptr inbounds i8, ptr %21, i32 8
  %159 = load { ptr, i32, i32, i32 }, ptr %158, align 8
  %160 = load i64, ptr %22, align 8
  br i1 %155, label %286, label %173

161:                                              ; preds = %112
  %162 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %163 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %162, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %61)
  %164 = extractvalue { {}, { ptr, i32, i32, i32 } } %163, 1
  %165 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %164, 1
  %166 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %165, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %166, ptr %20, align 8
  %167 = load { i64, [24 x i8] }, ptr %20, align 8
  %168 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %137, 0
  %169 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %168, i64 %138, 1
  %170 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %169, i64 %53, 2
  %171 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %170, ptr %54, 3
  %172 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %171, { i64, [24 x i8] } %167, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %172

173:                                              ; preds = %143
  %174 = phi { { ptr, i32, i32, i32 } } [ %157, %143 ]
  %175 = extractvalue { { ptr, i32, i32, i32 } } %174, 0
  %176 = extractvalue { ptr, i32, i32, i32 } %175, 1
  %177 = extractvalue { ptr, i32, i32, i32 } %175, 2
  %178 = sub i32 %177, %176
  %179 = icmp uge i32 %178, 1
  br i1 %179, label %180, label %263

180:                                              ; preds = %173
  %181 = extractvalue { ptr, i32, i32, i32 } %175, 0
  %182 = load ptr, ptr %181, align 8
  %183 = zext i32 %176 to i64
  %184 = mul i64 %183, 32
  %185 = getelementptr inbounds i8, ptr %182, i64 %184
  %186 = add i32 %176, 1
  %187 = insertvalue { ptr, i32, i32, i32 } %175, i32 %186, 1
  %188 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %188, ptr %185, i64 32, i1 false)
  %189 = load i252, ptr %188, align 16
  call void @free(ptr %188)
  %190 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %187, 0
  %191 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f18"(i64 %137, i64 %160, { { ptr, i32, i32, i32 } } %190, { ptr, i32, i32, i32 } zeroinitializer, i252 %189)
  %192 = extractvalue { i64, i64, { i64, [56 x i8] } } %191, 0
  %193 = extractvalue { i64, i64, { i64, [56 x i8] } } %191, 1
  %194 = extractvalue { i64, i64, { i64, [56 x i8] } } %191, 2
  store { i64, [56 x i8] } %194, ptr %28, align 8
  %195 = load i1, ptr %28, align 1
  switch i1 %195, label %196 [
    i1 false, label %198
    i1 true, label %204
  ]

196:                                              ; preds = %180
  br i1 false, label %197, label %332

197:                                              ; preds = %196
  unreachable

198:                                              ; preds = %180
  %199 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %28, align 8
  %200 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %199, 1
  %201 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %200, 0
  %202 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %200, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %201)
  store { i64, [24 x i8] } %202, ptr %30, align 8
  %203 = load i1, ptr %30, align 1
  switch i1 %203, label %216 [
    i1 false, label %218
    i1 true, label %232
  ]

204:                                              ; preds = %180
  %205 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %28, align 8
  %206 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %205, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %61)
  %207 = extractvalue { {}, { ptr, i32, i32, i32 } } %206, 1
  %208 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %207, 1
  %209 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %208, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %209, ptr %29, align 8
  %210 = load { i64, [24 x i8] }, ptr %29, align 8
  %211 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %192, 0
  %212 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %211, i64 %193, 1
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %212, i64 %53, 2
  %214 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %213, ptr %54, 3
  %215 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %214, { i64, [24 x i8] } %210, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %215

216:                                              ; preds = %198
  br i1 false, label %217, label %333

217:                                              ; preds = %216
  unreachable

218:                                              ; preds = %198
  %219 = load { i1, { ptr, i32, i32, i32 } }, ptr %30, align 8
  %220 = extractvalue { i1, { ptr, i32, i32, i32 } } %219, 1
  %221 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %61, 0
  %222 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %220, 0
  %223 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %221, 0
  %224 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %223, { { ptr, i32, i32, i32 } } %222, 1
  %225 = call fastcc { i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f66"(i64 %192, i64 %193, i64 %53, ptr %54, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %224, { {} } %4)
  %226 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %225, 0
  %227 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %225, 1
  %228 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %225, 2
  %229 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %225, 3
  %230 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %225, 4
  store { i64, [48 x i8] } %230, ptr %31, align 8
  %231 = load i1, ptr %31, align 1
  switch i1 %231, label %238 [
    i1 false, label %240
    i1 true, label %253
  ]

232:                                              ; preds = %198
  call void @"drop$286"({ ptr, i32, i32, i32 } %61)
  %233 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %234 = call ptr %233()
  %235 = load i64, ptr %234, align 8
  %236 = mul i64 %235, 3010
  %237 = call i64 @llvm.uadd.sat.i64(i64 %193, i64 %236)
  br label %270

238:                                              ; preds = %218
  br i1 false, label %239, label %334

239:                                              ; preds = %238
  unreachable

240:                                              ; preds = %218
  %241 = load { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } }, ptr %31, align 8
  %242 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %241, 1
  %243 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %244 = call ptr %243()
  %245 = call i64 @llvm.uadd.sat.i64(i64 %227, i64 0)
  %246 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %242, 0
  call void @"drop$395"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %246)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %33, align 1
  %247 = load { i64, [24 x i8] }, ptr %33, align 8
  %248 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %226, 0
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %248, i64 %245, 1
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, i64 %228, 2
  %251 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %250, ptr %229, 3
  %252 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %251, { i64, [24 x i8] } %247, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %252

253:                                              ; preds = %218
  %254 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %31, align 8
  %255 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %254, 1
  %256 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %255, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %256, ptr %32, align 8
  %257 = load { i64, [24 x i8] }, ptr %32, align 8
  %258 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %226, 0
  %259 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %258, i64 %227, 1
  %260 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %259, i64 %228, 2
  %261 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %260, ptr %229, 3
  %262 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %261, { i64, [24 x i8] } %257, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %262

263:                                              ; preds = %173
  %264 = phi { ptr, i32, i32, i32 } [ %175, %173 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %264)
  call void @"drop$286"({ ptr, i32, i32, i32 } %61)
  %265 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %266 = call ptr %265()
  %267 = load i64, ptr %266, align 8
  %268 = mul i64 %267, 6280
  %269 = call i64 @llvm.uadd.sat.i64(i64 %160, i64 %268)
  br label %270

270:                                              ; preds = %232, %263
  %271 = phi ptr [ %54, %263 ], [ %54, %232 ]
  %272 = phi i64 [ %53, %263 ], [ %53, %232 ]
  %273 = phi i64 [ %137, %263 ], [ %192, %232 ]
  %274 = phi i64 [ %269, %263 ], [ %237, %232 ]
  %275 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"()
  %276 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %275, 0
  %277 = extractvalue { {}, { ptr, i32, i32, i32 } } %276, 1
  %278 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %277, 1
  %279 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %278, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %279, ptr %27, align 8
  %280 = load { i64, [24 x i8] }, ptr %27, align 8
  %281 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %273, 0
  %282 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %281, i64 %274, 1
  %283 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %282, i64 %272, 2
  %284 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %283, ptr %271, 3
  %285 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %284, { i64, [24 x i8] } %280, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %285

286:                                              ; preds = %143
  %287 = phi { ptr, i32, i32, i32 } [ %61, %143 ]
  call void @"drop$286"({ ptr, i32, i32, i32 } %287)
  %288 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %159, 1
  %289 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %288, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %289, ptr %26, align 8
  %290 = load { i64, [24 x i8] }, ptr %26, align 8
  %291 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %137, 0
  %292 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %291, i64 %160, 1
  %293 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %292, i64 %53, 2
  %294 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %293, ptr %54, 3
  %295 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %294, { i64, [24 x i8] } %290, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %295

296:                                              ; preds = %107
  %297 = phi { ptr, i32, i32, i32 } [ %61, %107 ]
  call void @"drop$286"({ ptr, i32, i32, i32 } %297)
  call void @"drop$402"({ { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %86)
  %298 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f62"()
  %299 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %298, 0
  %300 = extractvalue { {}, { ptr, i32, i32, i32 } } %299, 1
  %301 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %300, 1
  %302 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %301, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %302, ptr %18, align 8
  %303 = load { i64, [24 x i8] }, ptr %18, align 8
  %304 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %110, 0
  %305 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %304, i64 %96, 1
  %306 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %305, i64 %53, 2
  %307 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %306, ptr %54, 3
  %308 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %307, { i64, [24 x i8] } %303, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %308

309:                                              ; preds = %84
  %310 = phi { ptr, i32, i32, i32 } [ %61, %84 ]
  call void @"drop$286"({ ptr, i32, i32, i32 } %310)
  call void @"drop$402"({ { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %86)
  %311 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %95, 1
  %312 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %311, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %312, ptr %17, align 8
  %313 = load { i64, [24 x i8] }, ptr %17, align 8
  %314 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %66, 0
  %315 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %314, i64 %96, 1
  %316 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %315, i64 %53, 2
  %317 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %316, ptr %54, 3
  %318 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %317, { i64, [24 x i8] } %313, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %318

319:                                              ; preds = %6
  %320 = phi { ptr, i32, i32, i32 } [ %5, %6 ]
  call void @"drop$286"({ ptr, i32, i32, i32 } %320)
  %321 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %42, 1
  %322 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %321, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %322, ptr %9, align 8
  %323 = load { i64, [24 x i8] }, ptr %9, align 8
  %324 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %325 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %324, i64 %43, 1
  %326 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %325, i64 %2, 2
  %327 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %326, ptr %3, 3
  %328 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %327, { i64, [24 x i8] } %323, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %328

329:                                              ; preds = %57
  call void @puts(ptr @assert_msg_70)
  call void @abort()
  unreachable

330:                                              ; preds = %82
  call void @puts(ptr @assert_msg_71)
  call void @abort()
  unreachable

331:                                              ; preds = %141
  call void @puts(ptr @assert_msg_72)
  call void @abort()
  unreachable

332:                                              ; preds = %196
  call void @puts(ptr @assert_msg_73)
  call void @abort()
  unreachable

333:                                              ; preds = %216
  call void @puts(ptr @assert_msg_74)
  call void @abort()
  unreachable

334:                                              ; preds = %238
  call void @puts(ptr @assert_msg_75)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f33(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f33"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { ptr, i32, i32, i32 } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f33(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f33(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { ptr, i32, i32, i32 } %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5) {
  %7 = alloca i256, i64 1, align 16
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca { i1, [47 x i8] }, i64 1, align 16
  %11 = alloca i64, i64 1, align 8
  %12 = alloca i252, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [96 x i8] }, i64 1, align 16
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = add i64 %2, 3
  %22 = zext i252 %5 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %7, align 16
  store i256 %22, ptr %8, align 16
  %23 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %23(ptr %9, ptr %7, ptr %8)
  %24 = load i256, ptr %9, align 16
  %25 = trunc i256 %24 to i252
  %26 = add i64 %0, 3
  %27 = sub i252 %25, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %28 = icmp ult i252 %25, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %29 = select i1 %28, i252 %25, i252 %27
  %30 = load ptr, ptr %3, align 8
  store i64 %1, ptr %11, align 8
  store i252 %29, ptr %12, align 16
  %31 = getelementptr inbounds ptr, ptr %3, i32 8
  %32 = load ptr, ptr %31, align 8
  call void %32(ptr %10, ptr %30, ptr %11, i32 0, ptr %12)
  %33 = load { i1, [47 x i8] }, ptr %10, align 1
  %34 = extractvalue { i1, [47 x i8] } %33, 0
  %35 = getelementptr inbounds i8, ptr %10, i32 16
  %36 = load i252, ptr %35, align 16
  %37 = getelementptr inbounds i8, ptr %10, i32 8
  %38 = load { ptr, i32, i32, i32 }, ptr %37, align 8
  %39 = load i64, ptr %11, align 8
  br i1 %34, label %154, label %40

40:                                               ; preds = %6
  %41 = phi i252 [ %36, %6 ]
  %42 = icmp eq i252 %41, 0
  br i1 %42, label %43, label %48

43:                                               ; preds = %40
  %44 = phi i64 [ %39, %40 ]
  %45 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %46 = call ptr %45()
  %47 = call i64 @llvm.uadd.sat.i64(i64 %44, i64 0)
  br label %55

48:                                               ; preds = %40
  %49 = phi i64 [ %39, %40 ]
  %50 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %51 = call ptr %50()
  %52 = load i64, ptr %51, align 8
  %53 = mul i64 %52, 100
  %54 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %53)
  br label %55

55:                                               ; preds = %43, %48
  %56 = phi i252 [ %5, %48 ], [ %5, %43 ]
  %57 = phi i64 [ %21, %48 ], [ %21, %43 ]
  %58 = phi ptr [ %3, %48 ], [ %3, %43 ]
  %59 = phi i64 [ %26, %48 ], [ %26, %43 ]
  %60 = phi i64 [ %54, %48 ], [ %47, %43 ]
  %61 = phi { i1, [0 x i8] } [ { i1 false, [0 x i8] undef }, %48 ], [ { i1 true, [0 x i8] undef }, %43 ]
  %62 = extractvalue { i1, [0 x i8] } %61, 0
  %63 = xor i1 %62, true
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %141
  ]

64:                                               ; preds = %55
  br i1 false, label %65, label %164

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %55
  %67 = phi i252 [ %56, %55 ]
  %68 = call fastcc { i64, i64, { i128, [96 x i8] } } @"impl$f51"(i64 %59, i64 %60, i252 %67, { { { ptr, i32, i32, i32 }, i252, i32 } } zeroinitializer)
  %69 = extractvalue { i64, i64, { i128, [96 x i8] } } %68, 0
  %70 = extractvalue { i64, i64, { i128, [96 x i8] } } %68, 1
  %71 = extractvalue { i64, i64, { i128, [96 x i8] } } %68, 2
  store { i128, [96 x i8] } %71, ptr %15, align 16
  %72 = load i1, ptr %15, align 1
  switch i1 %72, label %73 [
    i1 false, label %75
    i1 true, label %81
  ]

73:                                               ; preds = %66
  br i1 false, label %74, label %165

74:                                               ; preds = %73
  unreachable

75:                                               ; preds = %66
  %76 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } }, ptr %15, align 16
  %77 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %76, 1
  %78 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %77, 0
  %79 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %77, 1
  %80 = extractvalue { i1, [0 x i8] } %79, 0
  switch i1 %80, label %91 [
    i1 false, label %93
    i1 true, label %130
  ]

81:                                               ; preds = %66
  %82 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %83 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %82, 1
  %84 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %83, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %84, ptr %16, align 8
  %85 = load { i64, [24 x i8] }, ptr %16, align 8
  %86 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %69, 0
  %87 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %86, i64 %70, 1
  %88 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %87, i64 %57, 2
  %89 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %88, ptr %58, 3
  %90 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %89, { i64, [24 x i8] } %85, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %90

91:                                               ; preds = %75
  br i1 false, label %92, label %166

92:                                               ; preds = %91
  unreachable

93:                                               ; preds = %75
  %94 = phi { { { ptr, i32, i32, i32 }, i252, i32 } } [ %78, %75 ]
  %95 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 } } %94, 0
  %96 = call fastcc { i64, { i128, [80 x i8] } } @"impl$f52"(i64 %69, { { ptr, i32, i32, i32 }, i252, i32 } %95, i252 43082822081847175470628674138746545522, i32 16)
  %97 = extractvalue { i64, { i128, [80 x i8] } } %96, 0
  %98 = extractvalue { i64, { i128, [80 x i8] } } %96, 1
  store { i128, [80 x i8] } %98, ptr %18, align 16
  %99 = load i1, ptr %18, align 1
  switch i1 %99, label %100 [
    i1 false, label %102
    i1 true, label %120
  ]

100:                                              ; preds = %93
  br i1 false, label %101, label %167

101:                                              ; preds = %100
  unreachable

102:                                              ; preds = %93
  %103 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %18, align 16
  %104 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %103, 1
  %105 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %104, 0
  %106 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %105)
  %107 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %106, 0
  %108 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %106, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %107)
  %109 = call fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f53"(i64 %97, i64 %70, { { ptr, i32, i32, i32 }, i252, i32 } %108)
  %110 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %109, 0
  %111 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %109, 1
  %112 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %109, 2
  %113 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %112, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %113, ptr %20, align 8
  %114 = load { i64, [24 x i8] }, ptr %20, align 8
  %115 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %110, 0
  %116 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %115, i64 %111, 1
  %117 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %116, i64 %57, 2
  %118 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %117, ptr %58, 3
  %119 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %118, { i64, [24 x i8] } %114, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %119

120:                                              ; preds = %93
  %121 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %122 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %121, 1
  %123 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %122, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %123, ptr %19, align 8
  %124 = load { i64, [24 x i8] }, ptr %19, align 8
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %97, 0
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %125, i64 %70, 1
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, i64 %57, 2
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, ptr %58, 3
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, { i64, [24 x i8] } %124, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %129

130:                                              ; preds = %75
  %131 = phi { { { ptr, i32, i32, i32 }, i252, i32 } } [ %78, %75 ]
  call void @"drop$440"({ { { ptr, i32, i32, i32 }, i252, i32 } } %131)
  %132 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f54"()
  %133 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %132, 0
  %134 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %133, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %134, ptr %17, align 8
  %135 = load { i64, [24 x i8] }, ptr %17, align 8
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %69, 0
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %70, 1
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, i64 %57, 2
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, ptr %58, 3
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, { i64, [24 x i8] } %135, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %140

141:                                              ; preds = %55
  %142 = phi i64 [ %60, %55 ]
  %143 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %144 = call ptr %143()
  %145 = load i64, ptr %144, align 8
  %146 = mul i64 %145, 34750
  %147 = call i64 @llvm.uadd.sat.i64(i64 %142, i64 %146)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %14, align 1
  %148 = load { i64, [24 x i8] }, ptr %14, align 8
  %149 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %59, 0
  %150 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %149, i64 %147, 1
  %151 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %150, i64 %57, 2
  %152 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %151, ptr %58, 3
  %153 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %152, { i64, [24 x i8] } %148, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %153

154:                                              ; preds = %6
  %155 = phi { ptr, i32, i32, i32 } [ %38, %6 ]
  %156 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %155, 1
  %157 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %156, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %157, ptr %13, align 8
  %158 = load { i64, [24 x i8] }, ptr %13, align 8
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %26, 0
  %160 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %159, i64 %39, 1
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %160, i64 %21, 2
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %161, ptr %3, 3
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %162, { i64, [24 x i8] } %158, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %163

164:                                              ; preds = %64
  call void @puts(ptr @assert_msg_76)
  call void @abort()
  unreachable

165:                                              ; preds = %73
  call void @puts(ptr @assert_msg_77)
  call void @abort()
  unreachable

166:                                              ; preds = %91
  call void @puts(ptr @assert_msg_78)
  call void @abort()
  unreachable

167:                                              ; preds = %100
  call void @puts(ptr @assert_msg_79)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f34(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f34"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f34(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f34(i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f35"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5, { i1, [0 x i8] } %6) {
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca i256, i64 1, align 16
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca i252, i64 1, align 16
  %14 = alloca i252, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i128, [32 x i8] }, i64 1, align 16
  %17 = alloca { i128, [32 x i8] }, i64 1, align 16
  %18 = alloca { i1, [31 x i8] }, i64 1, align 8
  %19 = alloca i64, i64 1, align 8
  %20 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %21 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca { i128, [32 x i8] }, i64 1, align 16
  %25 = alloca { i128, [32 x i8] }, i64 1, align 16
  %26 = alloca { i1, [31 x i8] }, i64 1, align 8
  %27 = alloca i64, i64 1, align 8
  %28 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %29 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %30 = alloca { i64, [24 x i8] }, i64 1, align 8
  %31 = add i64 %2, 3
  %32 = zext i252 %5 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %8, align 16
  store i256 %32, ptr %9, align 16
  %33 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %33(ptr %10, ptr %8, ptr %9)
  %34 = load i256, ptr %10, align 16
  %35 = trunc i256 %34 to i252
  %36 = add i64 %0, 3
  %37 = sub i252 %35, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %38 = icmp ult i252 %35, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %39 = select i1 %38, i252 %35, i252 %37
  %40 = extractvalue { i1, [0 x i8] } %6, 0
  %41 = zext i1 %40 to i252
  %42 = load ptr, ptr %3, align 8
  store i64 %1, ptr %12, align 8
  store i252 %39, ptr %13, align 16
  store i252 %41, ptr %14, align 16
  %43 = getelementptr inbounds ptr, ptr %3, i32 9
  %44 = load ptr, ptr %43, align 8
  call void %44(ptr %11, ptr %42, ptr %12, i32 0, ptr %13, ptr %14)
  %45 = load { i1, [31 x i8] }, ptr %11, align 1
  %46 = extractvalue { i1, [31 x i8] } %45, 0
  %47 = getelementptr inbounds i8, ptr %11, i32 8
  %48 = load { ptr, i32, i32, i32 }, ptr %47, align 8
  %49 = load i64, ptr %12, align 8
  br i1 %46, label %244, label %50

50:                                               ; preds = %7
  %51 = phi { i1, [0 x i8] } [ %6, %7 ]
  %52 = extractvalue { i1, [0 x i8] } %51, 0
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %143
  ]

53:                                               ; preds = %50
  br i1 false, label %54, label %254

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %50
  %56 = phi i252 [ %5, %50 ]
  %57 = insertvalue { i252 } undef, i252 %56, 0
  %58 = insertvalue { i1, { i252 } } { i1 true, { i252 } undef }, { i252 } %57, 1
  store { i1, { i252 } } %58, ptr %24, align 16
  %59 = load { i128, [32 x i8] }, ptr %24, align 16
  store { i128, [32 x i8] } %59, ptr %25, align 16
  %60 = load i1, ptr %25, align 1
  switch i1 %60, label %61 [
    i1 false, label %63
    i1 true, label %83
  ]

61:                                               ; preds = %55
  br i1 false, label %62, label %255

62:                                               ; preds = %61
  unreachable

63:                                               ; preds = %55
  %64 = load { i1, { i252 } }, ptr %25, align 16
  %65 = extractvalue { i1, { i252 } } %64, 1
  %66 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %67 = call ptr %66()
  %68 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 0)
  %69 = extractvalue { i252 } %65, 0
  %70 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %70, align 4
  %71 = getelementptr inbounds i8, ptr %70, i32 4
  store i32 0, ptr %71, align 4
  %72 = getelementptr inbounds i8, ptr %70, i32 16
  %73 = call ptr @realloc(ptr null, i64 8)
  store ptr %72, ptr %73, align 8
  %74 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %73, 0
  %75 = insertvalue { ptr, i32, i32, i32 } %74, i32 8, 3
  %76 = load ptr, ptr %73, align 8
  store i252 589022817552792543318509852632045264175748210744615699137722900036442648072, ptr %76, align 16
  %77 = insertvalue { ptr, i32, i32, i32 } %75, i32 1, 2
  %78 = getelementptr inbounds i8, ptr %76, i32 -12
  store i32 1, ptr %78, align 4
  %79 = load ptr, ptr %73, align 8
  %80 = getelementptr inbounds i8, ptr %79, i32 32
  store i252 %69, ptr %80, align 16
  %81 = insertvalue { ptr, i32, i32, i32 } %77, i32 2, 2
  %82 = getelementptr inbounds i8, ptr %79, i32 -12
  store i32 2, ptr %82, align 4
  br label %105

83:                                               ; preds = %55
  %84 = load { i1, { i252 } }, ptr %25, align 16
  %85 = extractvalue { i1, { i252 } } %84, 1
  %86 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %87 = call ptr %86()
  %88 = load i64, ptr %87, align 8
  %89 = mul i64 %88, 100
  %90 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %89)
  %91 = extractvalue { i252 } %85, 0
  %92 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %92, align 4
  %93 = getelementptr inbounds i8, ptr %92, i32 4
  store i32 0, ptr %93, align 4
  %94 = getelementptr inbounds i8, ptr %92, i32 16
  %95 = call ptr @realloc(ptr null, i64 8)
  store ptr %94, ptr %95, align 8
  %96 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %95, 0
  %97 = insertvalue { ptr, i32, i32, i32 } %96, i32 8, 3
  %98 = load ptr, ptr %95, align 8
  store i252 592812847939322677565668720816539444019393425324860683642110029332411209997, ptr %98, align 16
  %99 = insertvalue { ptr, i32, i32, i32 } %97, i32 1, 2
  %100 = getelementptr inbounds i8, ptr %98, i32 -12
  store i32 1, ptr %100, align 4
  %101 = load ptr, ptr %95, align 8
  %102 = getelementptr inbounds i8, ptr %101, i32 32
  store i252 %91, ptr %102, align 16
  %103 = insertvalue { ptr, i32, i32, i32 } %99, i32 2, 2
  %104 = getelementptr inbounds i8, ptr %101, i32 -12
  store i32 2, ptr %104, align 4
  br label %105

105:                                              ; preds = %63, %83
  %106 = phi i64 [ %31, %83 ], [ %31, %63 ]
  %107 = phi i64 [ %36, %83 ], [ %36, %63 ]
  %108 = phi ptr [ %3, %83 ], [ %3, %63 ]
  %109 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %83 ], [ zeroinitializer, %63 ]
  %110 = phi i64 [ %90, %83 ], [ %68, %63 ]
  %111 = phi { ptr, i32, i32, i32 } [ %103, %83 ], [ %81, %63 ]
  %112 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %111)
  %113 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %112, 0
  %114 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %112, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %113)
  %115 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %109)
  %116 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %115, 0
  %117 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %115, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %116)
  %118 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %114, 0
  %119 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %117, 0
  %120 = load ptr, ptr %108, align 8
  store i64 %110, ptr %27, align 8
  store { { ptr, i32, i32, i32 } } %118, ptr %28, align 8
  store { { ptr, i32, i32, i32 } } %119, ptr %29, align 8
  %121 = getelementptr inbounds ptr, ptr %108, i32 10
  %122 = load ptr, ptr %121, align 8
  call void %122(ptr %26, ptr %120, ptr %27, ptr %28, ptr %29)
  %123 = load { i1, [31 x i8] }, ptr %26, align 1
  %124 = extractvalue { i1, [31 x i8] } %123, 0
  %125 = getelementptr inbounds i8, ptr %26, i32 8
  %126 = load { ptr, i32, i32, i32 }, ptr %125, align 8
  %127 = load i64, ptr %27, align 8
  br i1 %124, label %133, label %128

128:                                              ; preds = %105
  %129 = phi i64 [ %127, %105 ]
  %130 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %131 = call ptr %130()
  %132 = call i64 @llvm.uadd.sat.i64(i64 %129, i64 0)
  br label %223

133:                                              ; preds = %105
  %134 = phi { ptr, i32, i32, i32 } [ %126, %105 ]
  %135 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %134, 1
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %30, align 8
  %137 = load { i64, [24 x i8] }, ptr %30, align 8
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %107, 0
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, i64 %127, 1
  %140 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %139, i64 %106, 2
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %140, ptr %108, 3
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, { i64, [24 x i8] } %137, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %142

143:                                              ; preds = %50
  %144 = phi i252 [ %5, %50 ]
  %145 = insertvalue { i252 } undef, i252 %144, 0
  %146 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %145, 1
  store { i1, { i252 } } %146, ptr %16, align 16
  %147 = load { i128, [32 x i8] }, ptr %16, align 16
  store { i128, [32 x i8] } %147, ptr %17, align 16
  %148 = load i1, ptr %17, align 1
  switch i1 %148, label %149 [
    i1 false, label %151
    i1 true, label %173
  ]

149:                                              ; preds = %143
  br i1 false, label %150, label %256

150:                                              ; preds = %149
  unreachable

151:                                              ; preds = %143
  %152 = load { i1, { i252 } }, ptr %17, align 16
  %153 = extractvalue { i1, { i252 } } %152, 1
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = load i64, ptr %155, align 8
  %157 = mul i64 %156, 100
  %158 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %157)
  %159 = extractvalue { i252 } %153, 0
  %160 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %160, align 4
  %161 = getelementptr inbounds i8, ptr %160, i32 4
  store i32 0, ptr %161, align 4
  %162 = getelementptr inbounds i8, ptr %160, i32 16
  %163 = call ptr @realloc(ptr null, i64 8)
  store ptr %162, ptr %163, align 8
  %164 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %163, 0
  %165 = insertvalue { ptr, i32, i32, i32 } %164, i32 8, 3
  %166 = load ptr, ptr %163, align 8
  store i252 589022817552792543318509852632045264175748210744615699137722900036442648072, ptr %166, align 16
  %167 = insertvalue { ptr, i32, i32, i32 } %165, i32 1, 2
  %168 = getelementptr inbounds i8, ptr %166, i32 -12
  store i32 1, ptr %168, align 4
  %169 = load ptr, ptr %163, align 8
  %170 = getelementptr inbounds i8, ptr %169, i32 32
  store i252 %159, ptr %170, align 16
  %171 = insertvalue { ptr, i32, i32, i32 } %167, i32 2, 2
  %172 = getelementptr inbounds i8, ptr %169, i32 -12
  store i32 2, ptr %172, align 4
  br label %195

173:                                              ; preds = %143
  %174 = load { i1, { i252 } }, ptr %17, align 16
  %175 = extractvalue { i1, { i252 } } %174, 1
  %176 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %177 = call ptr %176()
  %178 = load i64, ptr %177, align 8
  %179 = mul i64 %178, 200
  %180 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 %179)
  %181 = extractvalue { i252 } %175, 0
  %182 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %182, align 4
  %183 = getelementptr inbounds i8, ptr %182, i32 4
  store i32 0, ptr %183, align 4
  %184 = getelementptr inbounds i8, ptr %182, i32 16
  %185 = call ptr @realloc(ptr null, i64 8)
  store ptr %184, ptr %185, align 8
  %186 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %185, 0
  %187 = insertvalue { ptr, i32, i32, i32 } %186, i32 8, 3
  %188 = load ptr, ptr %185, align 8
  store i252 592812847939322677565668720816539444019393425324860683642110029332411209997, ptr %188, align 16
  %189 = insertvalue { ptr, i32, i32, i32 } %187, i32 1, 2
  %190 = getelementptr inbounds i8, ptr %188, i32 -12
  store i32 1, ptr %190, align 4
  %191 = load ptr, ptr %185, align 8
  %192 = getelementptr inbounds i8, ptr %191, i32 32
  store i252 %181, ptr %192, align 16
  %193 = insertvalue { ptr, i32, i32, i32 } %189, i32 2, 2
  %194 = getelementptr inbounds i8, ptr %191, i32 -12
  store i32 2, ptr %194, align 4
  br label %195

195:                                              ; preds = %151, %173
  %196 = phi i64 [ %31, %173 ], [ %31, %151 ]
  %197 = phi i64 [ %36, %173 ], [ %36, %151 ]
  %198 = phi ptr [ %3, %173 ], [ %3, %151 ]
  %199 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %173 ], [ zeroinitializer, %151 ]
  %200 = phi i64 [ %180, %173 ], [ %158, %151 ]
  %201 = phi { ptr, i32, i32, i32 } [ %193, %173 ], [ %171, %151 ]
  %202 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %201)
  %203 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %202, 0
  %204 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %202, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %203)
  %205 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %199)
  %206 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %205, 0
  %207 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %205, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %206)
  %208 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %204, 0
  %209 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %207, 0
  %210 = load ptr, ptr %198, align 8
  store i64 %200, ptr %19, align 8
  store { { ptr, i32, i32, i32 } } %208, ptr %20, align 8
  store { { ptr, i32, i32, i32 } } %209, ptr %21, align 8
  %211 = getelementptr inbounds ptr, ptr %198, i32 10
  %212 = load ptr, ptr %211, align 8
  call void %212(ptr %18, ptr %210, ptr %19, ptr %20, ptr %21)
  %213 = load { i1, [31 x i8] }, ptr %18, align 1
  %214 = extractvalue { i1, [31 x i8] } %213, 0
  %215 = getelementptr inbounds i8, ptr %18, i32 8
  %216 = load { ptr, i32, i32, i32 }, ptr %215, align 8
  %217 = load i64, ptr %19, align 8
  br i1 %214, label %234, label %218

218:                                              ; preds = %195
  %219 = phi i64 [ %217, %195 ]
  %220 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %221 = call ptr %220()
  %222 = call i64 @llvm.uadd.sat.i64(i64 %219, i64 0)
  br label %223

223:                                              ; preds = %128, %218
  %224 = phi i64 [ %196, %218 ], [ %106, %128 ]
  %225 = phi i64 [ %197, %218 ], [ %107, %128 ]
  %226 = phi i64 [ %222, %218 ], [ %132, %128 ]
  %227 = phi ptr [ %198, %218 ], [ %108, %128 ]
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %23, align 1
  %228 = load { i64, [24 x i8] }, ptr %23, align 8
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %225, 0
  %230 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %229, i64 %226, 1
  %231 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %230, i64 %224, 2
  %232 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %231, ptr %227, 3
  %233 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %232, { i64, [24 x i8] } %228, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %233

234:                                              ; preds = %195
  %235 = phi { ptr, i32, i32, i32 } [ %216, %195 ]
  %236 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %235, 1
  %237 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %236, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %237, ptr %22, align 8
  %238 = load { i64, [24 x i8] }, ptr %22, align 8
  %239 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %197, 0
  %240 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %239, i64 %217, 1
  %241 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %240, i64 %196, 2
  %242 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %241, ptr %198, 3
  %243 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %242, { i64, [24 x i8] } %238, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %243

244:                                              ; preds = %7
  %245 = phi { ptr, i32, i32, i32 } [ %48, %7 ]
  %246 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %245, 1
  %247 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %246, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %247, ptr %15, align 8
  %248 = load { i64, [24 x i8] }, ptr %15, align 8
  %249 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %36, 0
  %250 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %249, i64 %49, 1
  %251 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %250, i64 %31, 2
  %252 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %251, ptr %3, 3
  %253 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %252, { i64, [24 x i8] } %248, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %253

254:                                              ; preds = %53
  call void @puts(ptr @assert_msg_80)
  call void @abort()
  unreachable

255:                                              ; preds = %61
  call void @puts(ptr @assert_msg_81)
  call void @abort()
  unreachable

256:                                              ; preds = %149
  call void @puts(ptr @assert_msg_82)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f35(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5, { i1, [0 x i8] } %6) {
  %8 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f35"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5, { i1, [0 x i8] } %6)
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 4
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %9, 0
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 1
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %11, 2
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, ptr %12, 3
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, { i64, [24 x i8] } %13, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %18
}

define void @_mlir_ciface_f35(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6, { i1, [0 x i8] } %7) {
  %9 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f35(i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6, { i1, [0 x i8] } %7)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f36"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5) {
  %7 = alloca i256, i64 1, align 16
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca { i1, [31 x i8] }, i64 1, align 8
  %11 = alloca i64, i64 1, align 8
  %12 = alloca i252, i64 1, align 16
  %13 = alloca i252, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [32 x i8] }, i64 1, align 16
  %16 = alloca { i128, [32 x i8] }, i64 1, align 16
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %20 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = add i64 %2, 3
  %24 = zext i252 %5 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %7, align 16
  store i256 %24, ptr %8, align 16
  %25 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %25(ptr %9, ptr %7, ptr %8)
  %26 = load i256, ptr %9, align 16
  %27 = trunc i256 %26 to i252
  %28 = add i64 %0, 3
  %29 = sub i252 %27, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %30 = icmp ult i252 %27, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %31 = select i1 %30, i252 %27, i252 %29
  %32 = load ptr, ptr %3, align 8
  store i64 %1, ptr %11, align 8
  store i252 %31, ptr %12, align 16
  store i252 1, ptr %13, align 16
  %33 = getelementptr inbounds ptr, ptr %3, i32 9
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %10, ptr %32, ptr %11, i32 0, ptr %12, ptr %13)
  %35 = load { i1, [31 x i8] }, ptr %10, align 1
  %36 = extractvalue { i1, [31 x i8] } %35, 0
  %37 = getelementptr inbounds i8, ptr %10, i32 8
  %38 = load { ptr, i32, i32, i32 }, ptr %37, align 8
  %39 = load i64, ptr %11, align 8
  br i1 %36, label %136, label %40

40:                                               ; preds = %6
  %41 = phi i252 [ %5, %6 ]
  %42 = insertvalue { i252 } undef, i252 %41, 0
  %43 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %42, 1
  store { i1, { i252 } } %43, ptr %15, align 16
  %44 = load { i128, [32 x i8] }, ptr %15, align 16
  store { i128, [32 x i8] } %44, ptr %16, align 16
  %45 = load i1, ptr %16, align 1
  switch i1 %45, label %46 [
    i1 false, label %48
    i1 true, label %68
  ]

46:                                               ; preds = %40
  br i1 false, label %47, label %146

47:                                               ; preds = %46
  unreachable

48:                                               ; preds = %40
  %49 = load { i1, { i252 } }, ptr %16, align 16
  %50 = extractvalue { i1, { i252 } } %49, 1
  %51 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %52 = call ptr %51()
  %53 = call i64 @llvm.uadd.sat.i64(i64 %39, i64 0)
  %54 = extractvalue { i252 } %50, 0
  %55 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %55, i32 4
  store i32 0, ptr %56, align 4
  %57 = getelementptr inbounds i8, ptr %55, i32 16
  %58 = call ptr @realloc(ptr null, i64 8)
  store ptr %57, ptr %58, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %58, 0
  %60 = insertvalue { ptr, i32, i32, i32 } %59, i32 8, 3
  %61 = load ptr, ptr %58, align 8
  store i252 589022817552792543318509852632045264175748210744615699137722900036442648072, ptr %61, align 16
  %62 = insertvalue { ptr, i32, i32, i32 } %60, i32 1, 2
  %63 = getelementptr inbounds i8, ptr %61, i32 -12
  store i32 1, ptr %63, align 4
  %64 = load ptr, ptr %58, align 8
  %65 = getelementptr inbounds i8, ptr %64, i32 32
  store i252 %54, ptr %65, align 16
  %66 = insertvalue { ptr, i32, i32, i32 } %62, i32 2, 2
  %67 = getelementptr inbounds i8, ptr %64, i32 -12
  store i32 2, ptr %67, align 4
  br label %90

68:                                               ; preds = %40
  %69 = load { i1, { i252 } }, ptr %16, align 16
  %70 = extractvalue { i1, { i252 } } %69, 1
  %71 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %72 = call ptr %71()
  %73 = load i64, ptr %72, align 8
  %74 = mul i64 %73, 100
  %75 = call i64 @llvm.uadd.sat.i64(i64 %39, i64 %74)
  %76 = extractvalue { i252 } %70, 0
  %77 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %77, i32 4
  store i32 0, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %77, i32 16
  %80 = call ptr @realloc(ptr null, i64 8)
  store ptr %79, ptr %80, align 8
  %81 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %80, 0
  %82 = insertvalue { ptr, i32, i32, i32 } %81, i32 8, 3
  %83 = load ptr, ptr %80, align 8
  store i252 592812847939322677565668720816539444019393425324860683642110029332411209997, ptr %83, align 16
  %84 = insertvalue { ptr, i32, i32, i32 } %82, i32 1, 2
  %85 = getelementptr inbounds i8, ptr %83, i32 -12
  store i32 1, ptr %85, align 4
  %86 = load ptr, ptr %80, align 8
  %87 = getelementptr inbounds i8, ptr %86, i32 32
  store i252 %76, ptr %87, align 16
  %88 = insertvalue { ptr, i32, i32, i32 } %84, i32 2, 2
  %89 = getelementptr inbounds i8, ptr %86, i32 -12
  store i32 2, ptr %89, align 4
  br label %90

90:                                               ; preds = %48, %68
  %91 = phi i64 [ %23, %68 ], [ %23, %48 ]
  %92 = phi i64 [ %28, %68 ], [ %28, %48 ]
  %93 = phi ptr [ %3, %68 ], [ %3, %48 ]
  %94 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %68 ], [ zeroinitializer, %48 ]
  %95 = phi i64 [ %75, %68 ], [ %53, %48 ]
  %96 = phi { ptr, i32, i32, i32 } [ %88, %68 ], [ %66, %48 ]
  %97 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %96)
  %98 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 0
  %99 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %98)
  %100 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %94)
  %101 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %100, 0
  %102 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %100, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %101)
  %103 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %99, 0
  %104 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %102, 0
  %105 = load ptr, ptr %93, align 8
  store i64 %95, ptr %18, align 8
  store { { ptr, i32, i32, i32 } } %103, ptr %19, align 8
  store { { ptr, i32, i32, i32 } } %104, ptr %20, align 8
  %106 = getelementptr inbounds ptr, ptr %93, i32 10
  %107 = load ptr, ptr %106, align 8
  call void %107(ptr %17, ptr %105, ptr %18, ptr %19, ptr %20)
  %108 = load { i1, [31 x i8] }, ptr %17, align 1
  %109 = extractvalue { i1, [31 x i8] } %108, 0
  %110 = getelementptr inbounds i8, ptr %17, i32 8
  %111 = load { ptr, i32, i32, i32 }, ptr %110, align 8
  %112 = load i64, ptr %18, align 8
  br i1 %109, label %126, label %113

113:                                              ; preds = %90
  %114 = phi i64 [ %112, %90 ]
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 10
  %119 = call i64 @llvm.uadd.sat.i64(i64 %114, i64 %118)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %22, align 1
  %120 = load { i64, [24 x i8] }, ptr %22, align 8
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %92, 0
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, i64 %119, 1
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, i64 %91, 2
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, ptr %93, 3
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, { i64, [24 x i8] } %120, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %125

126:                                              ; preds = %90
  %127 = phi { ptr, i32, i32, i32 } [ %111, %90 ]
  %128 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %127, 1
  %129 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %128, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %129, ptr %21, align 8
  %130 = load { i64, [24 x i8] }, ptr %21, align 8
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %92, 0
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %112, 1
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %132, i64 %91, 2
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %133, ptr %93, 3
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, { i64, [24 x i8] } %130, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %135

136:                                              ; preds = %6
  %137 = phi { ptr, i32, i32, i32 } [ %38, %6 ]
  %138 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %137, 1
  %139 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %138, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %139, ptr %14, align 8
  %140 = load { i64, [24 x i8] }, ptr %14, align 8
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %28, 0
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, i64 %39, 1
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, i64 %23, 2
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, ptr %3, 3
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, { i64, [24 x i8] } %140, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %145

146:                                              ; preds = %46
  call void @puts(ptr @assert_msg_83)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f36(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f36"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f36(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f36(i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f37"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5) {
  %7 = alloca i256, i64 1, align 16
  %8 = alloca i256, i64 1, align 16
  %9 = alloca i256, i64 1, align 16
  %10 = alloca { i1, [31 x i8] }, i64 1, align 8
  %11 = alloca i64, i64 1, align 8
  %12 = alloca i252, i64 1, align 16
  %13 = alloca i252, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [32 x i8] }, i64 1, align 16
  %16 = alloca { i128, [32 x i8] }, i64 1, align 16
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %20 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = add i64 %2, 3
  %24 = zext i252 %5 to i256
  store i256 812102049625239328877059852472148005149345189321026021198012755869152925610, ptr %7, align 16
  store i256 %24, ptr %8, align 16
  %25 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %25(ptr %9, ptr %7, ptr %8)
  %26 = load i256, ptr %9, align 16
  %27 = trunc i256 %26 to i252
  %28 = add i64 %0, 3
  %29 = sub i252 %27, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %30 = icmp ult i252 %27, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %31 = select i1 %30, i252 %27, i252 %29
  %32 = load ptr, ptr %3, align 8
  store i64 %1, ptr %11, align 8
  store i252 %31, ptr %12, align 16
  store i252 0, ptr %13, align 16
  %33 = getelementptr inbounds ptr, ptr %3, i32 9
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr %10, ptr %32, ptr %11, i32 0, ptr %12, ptr %13)
  %35 = load { i1, [31 x i8] }, ptr %10, align 1
  %36 = extractvalue { i1, [31 x i8] } %35, 0
  %37 = getelementptr inbounds i8, ptr %10, i32 8
  %38 = load { ptr, i32, i32, i32 }, ptr %37, align 8
  %39 = load i64, ptr %11, align 8
  br i1 %36, label %136, label %40

40:                                               ; preds = %6
  %41 = phi i252 [ %5, %6 ]
  %42 = insertvalue { i252 } undef, i252 %41, 0
  %43 = insertvalue { i1, { i252 } } { i1 true, { i252 } undef }, { i252 } %42, 1
  store { i1, { i252 } } %43, ptr %15, align 16
  %44 = load { i128, [32 x i8] }, ptr %15, align 16
  store { i128, [32 x i8] } %44, ptr %16, align 16
  %45 = load i1, ptr %16, align 1
  switch i1 %45, label %46 [
    i1 false, label %48
    i1 true, label %68
  ]

46:                                               ; preds = %40
  br i1 false, label %47, label %146

47:                                               ; preds = %46
  unreachable

48:                                               ; preds = %40
  %49 = load { i1, { i252 } }, ptr %16, align 16
  %50 = extractvalue { i1, { i252 } } %49, 1
  %51 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %52 = call ptr %51()
  %53 = call i64 @llvm.uadd.sat.i64(i64 %39, i64 0)
  %54 = extractvalue { i252 } %50, 0
  %55 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %55, i32 4
  store i32 0, ptr %56, align 4
  %57 = getelementptr inbounds i8, ptr %55, i32 16
  %58 = call ptr @realloc(ptr null, i64 8)
  store ptr %57, ptr %58, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %58, 0
  %60 = insertvalue { ptr, i32, i32, i32 } %59, i32 8, 3
  %61 = load ptr, ptr %58, align 8
  store i252 589022817552792543318509852632045264175748210744615699137722900036442648072, ptr %61, align 16
  %62 = insertvalue { ptr, i32, i32, i32 } %60, i32 1, 2
  %63 = getelementptr inbounds i8, ptr %61, i32 -12
  store i32 1, ptr %63, align 4
  %64 = load ptr, ptr %58, align 8
  %65 = getelementptr inbounds i8, ptr %64, i32 32
  store i252 %54, ptr %65, align 16
  %66 = insertvalue { ptr, i32, i32, i32 } %62, i32 2, 2
  %67 = getelementptr inbounds i8, ptr %64, i32 -12
  store i32 2, ptr %67, align 4
  br label %90

68:                                               ; preds = %40
  %69 = load { i1, { i252 } }, ptr %16, align 16
  %70 = extractvalue { i1, { i252 } } %69, 1
  %71 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %72 = call ptr %71()
  %73 = load i64, ptr %72, align 8
  %74 = mul i64 %73, 100
  %75 = call i64 @llvm.uadd.sat.i64(i64 %39, i64 %74)
  %76 = extractvalue { i252 } %70, 0
  %77 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %77, i32 4
  store i32 0, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %77, i32 16
  %80 = call ptr @realloc(ptr null, i64 8)
  store ptr %79, ptr %80, align 8
  %81 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %80, 0
  %82 = insertvalue { ptr, i32, i32, i32 } %81, i32 8, 3
  %83 = load ptr, ptr %80, align 8
  store i252 592812847939322677565668720816539444019393425324860683642110029332411209997, ptr %83, align 16
  %84 = insertvalue { ptr, i32, i32, i32 } %82, i32 1, 2
  %85 = getelementptr inbounds i8, ptr %83, i32 -12
  store i32 1, ptr %85, align 4
  %86 = load ptr, ptr %80, align 8
  %87 = getelementptr inbounds i8, ptr %86, i32 32
  store i252 %76, ptr %87, align 16
  %88 = insertvalue { ptr, i32, i32, i32 } %84, i32 2, 2
  %89 = getelementptr inbounds i8, ptr %86, i32 -12
  store i32 2, ptr %89, align 4
  br label %90

90:                                               ; preds = %48, %68
  %91 = phi i64 [ %23, %68 ], [ %23, %48 ]
  %92 = phi i64 [ %28, %68 ], [ %28, %48 ]
  %93 = phi ptr [ %3, %68 ], [ %3, %48 ]
  %94 = phi { ptr, i32, i32, i32 } [ zeroinitializer, %68 ], [ zeroinitializer, %48 ]
  %95 = phi i64 [ %75, %68 ], [ %53, %48 ]
  %96 = phi { ptr, i32, i32, i32 } [ %88, %68 ], [ %66, %48 ]
  %97 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %96)
  %98 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 0
  %99 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %98)
  %100 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %94)
  %101 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %100, 0
  %102 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %100, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %101)
  %103 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %99, 0
  %104 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %102, 0
  %105 = load ptr, ptr %93, align 8
  store i64 %95, ptr %18, align 8
  store { { ptr, i32, i32, i32 } } %103, ptr %19, align 8
  store { { ptr, i32, i32, i32 } } %104, ptr %20, align 8
  %106 = getelementptr inbounds ptr, ptr %93, i32 10
  %107 = load ptr, ptr %106, align 8
  call void %107(ptr %17, ptr %105, ptr %18, ptr %19, ptr %20)
  %108 = load { i1, [31 x i8] }, ptr %17, align 1
  %109 = extractvalue { i1, [31 x i8] } %108, 0
  %110 = getelementptr inbounds i8, ptr %17, i32 8
  %111 = load { ptr, i32, i32, i32 }, ptr %110, align 8
  %112 = load i64, ptr %18, align 8
  br i1 %109, label %126, label %113

113:                                              ; preds = %90
  %114 = phi i64 [ %112, %90 ]
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 10
  %119 = call i64 @llvm.uadd.sat.i64(i64 %114, i64 %118)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %22, align 1
  %120 = load { i64, [24 x i8] }, ptr %22, align 8
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %92, 0
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, i64 %119, 1
  %123 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %122, i64 %91, 2
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %123, ptr %93, 3
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, { i64, [24 x i8] } %120, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %125

126:                                              ; preds = %90
  %127 = phi { ptr, i32, i32, i32 } [ %111, %90 ]
  %128 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %127, 1
  %129 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %128, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %129, ptr %21, align 8
  %130 = load { i64, [24 x i8] }, ptr %21, align 8
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %92, 0
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %112, 1
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %132, i64 %91, 2
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %133, ptr %93, 3
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %134, { i64, [24 x i8] } %130, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %135

136:                                              ; preds = %6
  %137 = phi { ptr, i32, i32, i32 } [ %38, %6 ]
  %138 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %137, 1
  %139 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %138, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %139, ptr %14, align 8
  %140 = load { i64, [24 x i8] }, ptr %14, align 8
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %28, 0
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, i64 %39, 1
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, i64 %23, 2
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, ptr %3, 3
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, { i64, [24 x i8] } %140, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %145

146:                                              ; preds = %46
  call void @puts(ptr @assert_msg_84)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f37(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f37"(i64 %0, i64 %1, i64 %2, ptr %3, {} %4, i252 %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f37(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f37(i64 %1, i64 %2, i64 %3, ptr %4, {} %5, i252 %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f38"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %117, %5
  %17 = phi i64 [ %71, %117 ], [ %0, %5 ]
  %18 = phi i64 [ %77, %117 ], [ %1, %5 ]
  %19 = phi { { ptr, i32, i32, i32 } } [ %134, %117 ], [ %2, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %126, %117 ], [ %3, %5 ]
  %21 = phi i252 [ %133, %117 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 2680
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %185

29:                                               ; preds = %16
  %30 = phi i252 [ %21, %16 ]
  %31 = icmp eq i252 %30, 0
  br i1 %31, label %32, label %54

32:                                               ; preds = %29
  %33 = phi i64 [ %28, %29 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = load i64, ptr %35, align 8
  %37 = mul i64 %36, 3580
  %38 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %37)
  %39 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %20, 1
  store { i1, { ptr, i32, i32, i32 } } %39, ptr %14, align 8
  %40 = load { i64, [24 x i8] }, ptr %14, align 8
  %41 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %19, 0
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %41, { i64, [24 x i8] } %40, 1
  %43 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %43, ptr %15, align 8
  %44 = load { i64, [56 x i8] }, ptr %15, align 8
  %45 = extractvalue { ptr, ptr, i64 } %9, 1
  %46 = load i64, ptr %45, align 8
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %46, 1
  %49 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %48, ptr %49, align 8
  br i1 %47, label %50, label %139

50:                                               ; preds = %32
  %51 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } %51, i64 %38, 1
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, { i64, [56 x i8] } %44, 2
  ret { i64, i64, { i64, [56 x i8] } } %53

54:                                               ; preds = %29
  %55 = phi { { ptr, i32, i32, i32 } } [ %19, %29 ]
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %159

61:                                               ; preds = %54
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %71 = add i64 %17, 4
  %72 = icmp ult i252 %70, -3618502788666131106986593281521497120414687020801267626233049500247285301248
  br i1 %72, label %73, label %152

73:                                               ; preds = %61
  %74 = phi i64 [ %28, %61 ]
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %74, i64 0)
  %78 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %94

80:                                               ; preds = %73
  %81 = shl i32 %78, 1
  %82 = call i32 @llvm.umin.i32(i32 %81, i32 1024)
  %83 = add i32 %82, %78
  %84 = call i32 @llvm.umax.i32(i32 %83, i32 8)
  %85 = zext i32 %84 to i64
  %86 = mul i64 %85, 32
  %87 = add i64 %86, 16
  %88 = call ptr @realloc(ptr null, i64 %87)
  store i32 1, ptr %88, align 4
  %89 = getelementptr inbounds i8, ptr %88, i32 4
  store i32 0, ptr %89, align 4
  %90 = getelementptr inbounds i8, ptr %88, i32 16
  %91 = call ptr @realloc(ptr null, i64 8)
  store ptr %90, ptr %91, align 8
  %92 = insertvalue { ptr, i32, i32, i32 } %20, ptr %91, 0
  %93 = insertvalue { ptr, i32, i32, i32 } %92, i32 %84, 3
  br label %115

94:                                               ; preds = %73
  %95 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %96 = icmp ult i32 %95, %78
  br i1 %96, label %97, label %98

97:                                               ; preds = %94
  br label %112

98:                                               ; preds = %94
  %99 = shl i32 %78, 1
  %100 = call i32 @llvm.umin.i32(i32 %99, i32 1024)
  %101 = add i32 %100, %78
  %102 = call i32 @llvm.umax.i32(i32 %101, i32 8)
  %103 = zext i32 %102 to i64
  %104 = mul i64 %103, 32
  %105 = add i64 %104, 16
  %106 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr inbounds i8, ptr %107, i32 -16
  %109 = call ptr @realloc(ptr %108, i64 %105)
  %110 = getelementptr inbounds i8, ptr %109, i32 16
  store ptr %110, ptr %106, align 8
  %111 = insertvalue { ptr, i32, i32, i32 } %20, i32 %102, 3
  br label %112

112:                                              ; preds = %97, %98
  %113 = phi { ptr, i32, i32, i32 } [ %111, %98 ], [ %20, %97 ]
  br label %114

114:                                              ; preds = %112
  br label %115

115:                                              ; preds = %80, %114
  %116 = phi { ptr, i32, i32, i32 } [ %113, %114 ], [ %93, %80 ]
  br label %117

117:                                              ; preds = %115
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %119 = load ptr, ptr %118, align 8
  %120 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %121 = zext i32 %120 to i64
  %122 = mul i64 %121, 32
  %123 = getelementptr inbounds i8, ptr %119, i64 %122
  store i252 %70, ptr %123, align 16
  %124 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %125 = add i32 %124, 1
  %126 = insertvalue { ptr, i32, i32, i32 } %116, i32 %125, 2
  %127 = getelementptr inbounds i8, ptr %119, i32 -12
  store i32 %125, ptr %127, align 4
  %128 = zext i252 %30 to i256
  %129 = sub i256 %128, 1
  %130 = add i256 %128, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %131 = icmp ult i256 %128, 1
  %132 = select i1 %131, i256 %130, i256 %129
  %133 = trunc i256 %132 to i252
  %134 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %135 = extractvalue { ptr, ptr, i64 } %9, 1
  %136 = load i64, ptr %135, align 8
  %137 = add i64 %136, 1
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %137, ptr %138, align 8
  br label %16

139:                                              ; preds = %139, %32, %166, %185
  %140 = phi i64 [ %22, %185 ], [ %167, %166 ], [ %140, %139 ], [ %22, %32 ]
  %141 = phi i64 [ %18, %185 ], [ %168, %166 ], [ %141, %139 ], [ %38, %32 ]
  %142 = phi { i64, [56 x i8] } [ %190, %185 ], [ %175, %166 ], [ %142, %139 ], [ %44, %32 ]
  %143 = extractvalue { ptr, ptr, i64 } %9, 1
  %144 = load i64, ptr %143, align 8
  %145 = icmp eq i64 %144, 0
  %146 = sub i64 %144, 1
  %147 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %146, ptr %147, align 8
  br i1 %145, label %148, label %139

148:                                              ; preds = %139
  %149 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %140, 0
  %150 = insertvalue { i64, i64, { i64, [56 x i8] } } %149, i64 %141, 1
  %151 = insertvalue { i64, i64, { i64, [56 x i8] } } %150, { i64, [56 x i8] } %142, 2
  ret { i64, i64, { i64, [56 x i8] } } %151

152:                                              ; preds = %61
  %153 = phi { ptr, i32, i32, i32 } [ %20, %61 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %153)
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = load i64, ptr %155, align 8
  %157 = mul i64 %156, 1670
  %158 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %157)
  br label %166

159:                                              ; preds = %54
  %160 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %160)
  %161 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %162 = call ptr %161()
  %163 = load i64, ptr %162, align 8
  %164 = mul i64 %163, 2880
  %165 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %164)
  br label %166

166:                                              ; preds = %152, %159
  %167 = phi i64 [ %22, %159 ], [ %71, %152 ]
  %168 = phi i64 [ %165, %159 ], [ %158, %152 ]
  %169 = phi { ptr, i32, i32, i32 } [ %56, %159 ], [ %68, %152 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %170 = load { i64, [24 x i8] }, ptr %12, align 8
  %171 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %169, 0
  %172 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %171, 0
  %173 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %172, { i64, [24 x i8] } %170, 1
  %174 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %173, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %174, ptr %13, align 8
  %175 = load { i64, [56 x i8] }, ptr %13, align 8
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %139

181:                                              ; preds = %166
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %168, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184

185:                                              ; preds = %16
  %186 = phi { ptr, i32, i32, i32 } [ %20, %16 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %186)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %19)
  %187 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %188 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %187, 0
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %11, align 8
  %190 = load { i64, [56 x i8] }, ptr %11, align 8
  %191 = extractvalue { ptr, ptr, i64 } %9, 1
  %192 = load i64, ptr %191, align 8
  %193 = icmp eq i64 %192, 0
  %194 = sub i64 %192, 1
  %195 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %194, ptr %195, align 8
  br i1 %193, label %196, label %139

196:                                              ; preds = %185
  %197 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %198 = insertvalue { i64, i64, { i64, [56 x i8] } } %197, i64 %18, 1
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } %198, { i64, [56 x i8] } %190, 2
  ret { i64, i64, { i64, [56 x i8] } } %199
}

define private { i64, i64, { i64, [56 x i8] } } @f38(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f38"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f38(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f38(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$382"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$382"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f39"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %59, %6
  %17 = phi i64 [ %51, %59 ], [ %0, %6 ]
  %18 = phi i64 [ %64, %59 ], [ %1, %6 ]
  %19 = phi i64 [ %53, %59 ], [ %2, %6 ]
  %20 = phi ptr [ %54, %59 ], [ %3, %6 ]
  %21 = phi { { ptr, i32, i32, i32 } } [ %66, %59 ], [ %4, %6 ]
  %22 = phi {} [ %65, %59 ], [ %5, %6 ]
  %23 = add i64 %17, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = getelementptr inbounds i64, ptr %25, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %25, align 8
  %29 = mul i64 %28, 28490
  %30 = add i64 %27, %29
  %31 = icmp uge i64 %18, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %30)
  br i1 %31, label %33, label %129

33:                                               ; preds = %16
  %34 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  %35 = extractvalue { { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %104

40:                                               ; preds = %33
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f36"(i64 %23, i64 %32, i64 %19, ptr %20, {} %22, i252 %49)
  %51 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 0
  %52 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 1
  %53 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 2
  %54 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 3
  %55 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 4
  store { i64, [24 x i8] } %55, ptr %14, align 8
  %56 = load i1, ptr %14, align 1
  switch i1 %56, label %57 [
    i1 false, label %59
    i1 true, label %71
  ]

57:                                               ; preds = %40
  br i1 false, label %58, label %146

58:                                               ; preds = %57
  unreachable

59:                                               ; preds = %40
  %60 = load { i1, { {}, {} } }, ptr %14, align 1
  %61 = extractvalue { i1, { {}, {} } } %60, 1
  %62 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %63 = call ptr %62()
  %64 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 0)
  %65 = extractvalue { {}, {} } %61, 0
  %66 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %47, 0
  %67 = extractvalue { ptr, ptr, i64 } %10, 1
  %68 = load i64, ptr %67, align 8
  %69 = add i64 %68, 1
  %70 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %69, ptr %70, align 8
  br label %16

71:                                               ; preds = %40
  %72 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %73 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %72, 1
  call void @"drop$377"({ ptr, i32, i32, i32 } %47)
  %74 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %73, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %74, ptr %15, align 8
  %75 = load { i64, [24 x i8] }, ptr %15, align 8
  %76 = extractvalue { ptr, ptr, i64 } %10, 1
  %77 = load i64, ptr %76, align 8
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %77, 1
  %80 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %79, ptr %80, align 8
  br i1 %78, label %98, label %81

81:                                               ; preds = %81, %71, %104, %129
  %82 = phi i64 [ %23, %129 ], [ %23, %104 ], [ %82, %81 ], [ %51, %71 ]
  %83 = phi i64 [ %18, %129 ], [ %113, %104 ], [ %83, %81 ], [ %52, %71 ]
  %84 = phi i64 [ %19, %129 ], [ %19, %104 ], [ %84, %81 ], [ %53, %71 ]
  %85 = phi ptr [ %20, %129 ], [ %20, %104 ], [ %85, %81 ], [ %54, %71 ]
  %86 = phi { i64, [24 x i8] } [ %134, %129 ], [ %117, %104 ], [ %86, %81 ], [ %75, %71 ]
  %87 = extractvalue { ptr, ptr, i64 } %10, 1
  %88 = load i64, ptr %87, align 8
  %89 = icmp eq i64 %88, 0
  %90 = sub i64 %88, 1
  %91 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %90, ptr %91, align 8
  br i1 %89, label %92, label %81

92:                                               ; preds = %81
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %83, 1
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %84, 2
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, ptr %85, 3
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %86, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %97

98:                                               ; preds = %71
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %51, 0
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %52, 1
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %53, 2
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, ptr %54, 3
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, { i64, [24 x i8] } %75, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %103

104:                                              ; preds = %33
  %105 = phi i64 [ %32, %33 ]
  %106 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %107 = call ptr %106()
  %108 = getelementptr inbounds i64, ptr %107, i32 1
  %109 = load i64, ptr %108, align 8
  %110 = load i64, ptr %107, align 8
  %111 = mul i64 %110, 28690
  %112 = add i64 %109, %111
  %113 = call i64 @llvm.uadd.sat.i64(i64 %105, i64 %112)
  %114 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %35, 0
  %115 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } undef, { { ptr, i32, i32, i32 } } %114, 0
  %116 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, {}, {} } undef }, { { { ptr, i32, i32, i32 } }, {}, {} } %115, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %116, ptr %13, align 8
  %117 = load { i64, [24 x i8] }, ptr %13, align 8
  %118 = extractvalue { ptr, ptr, i64 } %10, 1
  %119 = load i64, ptr %118, align 8
  %120 = icmp eq i64 %119, 0
  %121 = sub i64 %119, 1
  %122 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %121, ptr %122, align 8
  br i1 %120, label %123, label %81

123:                                              ; preds = %104
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, i64 %113, 1
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %125, i64 %19, 2
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, ptr %20, 3
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, { i64, [24 x i8] } %117, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %128

129:                                              ; preds = %16
  %130 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  call void @"drop$378"({ { ptr, i32, i32, i32 } } %130)
  %131 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %132 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %131, 0
  %133 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %132, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %133, ptr %12, align 8
  %134 = load { i64, [24 x i8] }, ptr %12, align 8
  %135 = extractvalue { ptr, ptr, i64 } %10, 1
  %136 = load i64, ptr %135, align 8
  %137 = icmp eq i64 %136, 0
  %138 = sub i64 %136, 1
  %139 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %138, ptr %139, align 8
  br i1 %137, label %140, label %81

140:                                              ; preds = %129
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, i64 %18, 1
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, i64 %19, 2
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, ptr %20, 3
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, { i64, [24 x i8] } %134, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %145

146:                                              ; preds = %57
  call void @puts(ptr @assert_msg_85)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f39(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f39"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f39(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f39(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %59, %6
  %17 = phi i64 [ %51, %59 ], [ %0, %6 ]
  %18 = phi i64 [ %64, %59 ], [ %1, %6 ]
  %19 = phi i64 [ %53, %59 ], [ %2, %6 ]
  %20 = phi ptr [ %54, %59 ], [ %3, %6 ]
  %21 = phi { { ptr, i32, i32, i32 } } [ %66, %59 ], [ %4, %6 ]
  %22 = phi {} [ %65, %59 ], [ %5, %6 ]
  %23 = add i64 %17, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = getelementptr inbounds i64, ptr %25, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %25, align 8
  %29 = mul i64 %28, 28490
  %30 = add i64 %27, %29
  %31 = icmp uge i64 %18, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %30)
  br i1 %31, label %33, label %129

33:                                               ; preds = %16
  %34 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  %35 = extractvalue { { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %104

40:                                               ; preds = %33
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f37"(i64 %23, i64 %32, i64 %19, ptr %20, {} %22, i252 %49)
  %51 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 0
  %52 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 1
  %53 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 2
  %54 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 3
  %55 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %50, 4
  store { i64, [24 x i8] } %55, ptr %14, align 8
  %56 = load i1, ptr %14, align 1
  switch i1 %56, label %57 [
    i1 false, label %59
    i1 true, label %71
  ]

57:                                               ; preds = %40
  br i1 false, label %58, label %146

58:                                               ; preds = %57
  unreachable

59:                                               ; preds = %40
  %60 = load { i1, { {}, {} } }, ptr %14, align 1
  %61 = extractvalue { i1, { {}, {} } } %60, 1
  %62 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %63 = call ptr %62()
  %64 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 0)
  %65 = extractvalue { {}, {} } %61, 0
  %66 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %47, 0
  %67 = extractvalue { ptr, ptr, i64 } %10, 1
  %68 = load i64, ptr %67, align 8
  %69 = add i64 %68, 1
  %70 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %69, ptr %70, align 8
  br label %16

71:                                               ; preds = %40
  %72 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %73 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %72, 1
  call void @"drop$377"({ ptr, i32, i32, i32 } %47)
  %74 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %73, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %74, ptr %15, align 8
  %75 = load { i64, [24 x i8] }, ptr %15, align 8
  %76 = extractvalue { ptr, ptr, i64 } %10, 1
  %77 = load i64, ptr %76, align 8
  %78 = icmp eq i64 %77, 0
  %79 = sub i64 %77, 1
  %80 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %79, ptr %80, align 8
  br i1 %78, label %98, label %81

81:                                               ; preds = %81, %71, %104, %129
  %82 = phi i64 [ %23, %129 ], [ %23, %104 ], [ %82, %81 ], [ %51, %71 ]
  %83 = phi i64 [ %18, %129 ], [ %113, %104 ], [ %83, %81 ], [ %52, %71 ]
  %84 = phi i64 [ %19, %129 ], [ %19, %104 ], [ %84, %81 ], [ %53, %71 ]
  %85 = phi ptr [ %20, %129 ], [ %20, %104 ], [ %85, %81 ], [ %54, %71 ]
  %86 = phi { i64, [24 x i8] } [ %134, %129 ], [ %117, %104 ], [ %86, %81 ], [ %75, %71 ]
  %87 = extractvalue { ptr, ptr, i64 } %10, 1
  %88 = load i64, ptr %87, align 8
  %89 = icmp eq i64 %88, 0
  %90 = sub i64 %88, 1
  %91 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %90, ptr %91, align 8
  br i1 %89, label %92, label %81

92:                                               ; preds = %81
  %93 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %93, i64 %83, 1
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %84, 2
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, ptr %85, 3
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %86, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %97

98:                                               ; preds = %71
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %51, 0
  %100 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %52, 1
  %101 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %53, 2
  %102 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %101, ptr %54, 3
  %103 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %102, { i64, [24 x i8] } %75, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %103

104:                                              ; preds = %33
  %105 = phi i64 [ %32, %33 ]
  %106 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %107 = call ptr %106()
  %108 = getelementptr inbounds i64, ptr %107, i32 1
  %109 = load i64, ptr %108, align 8
  %110 = load i64, ptr %107, align 8
  %111 = mul i64 %110, 28690
  %112 = add i64 %109, %111
  %113 = call i64 @llvm.uadd.sat.i64(i64 %105, i64 %112)
  %114 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %35, 0
  %115 = insertvalue { { { ptr, i32, i32, i32 } }, {}, {} } undef, { { ptr, i32, i32, i32 } } %114, 0
  %116 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, {}, {} } undef }, { { { ptr, i32, i32, i32 } }, {}, {} } %115, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {}, {} } } %116, ptr %13, align 8
  %117 = load { i64, [24 x i8] }, ptr %13, align 8
  %118 = extractvalue { ptr, ptr, i64 } %10, 1
  %119 = load i64, ptr %118, align 8
  %120 = icmp eq i64 %119, 0
  %121 = sub i64 %119, 1
  %122 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %121, ptr %122, align 8
  br i1 %120, label %123, label %81

123:                                              ; preds = %104
  %124 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %125 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %124, i64 %113, 1
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %125, i64 %19, 2
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %126, ptr %20, 3
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %127, { i64, [24 x i8] } %117, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %128

129:                                              ; preds = %16
  %130 = phi { { ptr, i32, i32, i32 } } [ %21, %16 ]
  call void @"drop$378"({ { ptr, i32, i32, i32 } } %130)
  %131 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %132 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %131, 0
  %133 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %132, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %133, ptr %12, align 8
  %134 = load { i64, [24 x i8] }, ptr %12, align 8
  %135 = extractvalue { ptr, ptr, i64 } %10, 1
  %136 = load i64, ptr %135, align 8
  %137 = icmp eq i64 %136, 0
  %138 = sub i64 %136, 1
  %139 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %138, ptr %139, align 8
  br i1 %137, label %140, label %81

140:                                              ; preds = %129
  %141 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %23, 0
  %142 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %141, i64 %18, 1
  %143 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %142, i64 %19, 2
  %144 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %143, ptr %20, 3
  %145 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %144, { i64, [24 x i8] } %134, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %145

146:                                              ; preds = %57
  call void @puts(ptr @assert_msg_86)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f40(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f40"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, {} %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f40(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f40(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, {} %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 0
  call void @"drop$378"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } @"dup$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$378"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %6, { {} } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %7, { {} } %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %9, {} %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %10, {} %11, 2
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } undef, { { { ptr, i32, i32, i32 } }, { {} }, {} } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %14, { { { ptr, i32, i32, i32 } }, { {} }, {} } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %15
}

define private void @"drop$380"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, 1
  call void @"drop$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$380"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } @"dup$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { {} }, {} }, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, { { { ptr, i32, i32, i32 } }, { {} }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %5, { { { ptr, i32, i32, i32 } }, { {} }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f41"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, i252 %6, { ptr, i32, i32, i32 } %7) {
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i1, [31 x i8] }, i64 1, align 8
  %14 = alloca i64, i64 1, align 8
  %15 = alloca i252, i64 1, align 16
  %16 = alloca i252, i64 1, align 16
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f36"(i64 %0, i64 %1, i64 %2, ptr %3, {} undef, i252 %5)
  %24 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 0
  %25 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 1
  %26 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 2
  %27 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 3
  %28 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %23, 4
  store { i64, [24 x i8] } %28, ptr %9, align 8
  %29 = load i1, ptr %9, align 1
  switch i1 %29, label %30 [
    i1 false, label %32
    i1 true, label %41
  ]

30:                                               ; preds = %8
  br i1 false, label %31, label %133

31:                                               ; preds = %30
  unreachable

32:                                               ; preds = %8
  %33 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %7, 0
  %34 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f67"(i64 %24, i64 %25, i64 %26, ptr %27, { { ptr, i32, i32, i32 } } %33, { {} } %4)
  %35 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 0
  %36 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 1
  %37 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 2
  %38 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 3
  %39 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %34, 4
  store { i64, [24 x i8] } %39, ptr %11, align 8
  %40 = load i1, ptr %11, align 1
  switch i1 %40, label %51 [
    i1 false, label %53
    i1 true, label %64
  ]

41:                                               ; preds = %8
  %42 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %43 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %42, 1
  call void @"drop$377"({ ptr, i32, i32, i32 } %7)
  %44 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %43, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %44, ptr %10, align 8
  %45 = load { i64, [24 x i8] }, ptr %10, align 8
  %46 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %24, 0
  %47 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %46, i64 %25, 1
  %48 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %47, i64 %26, 2
  %49 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %48, ptr %27, 3
  %50 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %49, { i64, [24 x i8] } %45, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %50

51:                                               ; preds = %32
  br i1 false, label %52, label %134

52:                                               ; preds = %51
  unreachable

53:                                               ; preds = %32
  %54 = load { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } }, ptr %11, align 8
  %55 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %54, 1
  %56 = load ptr, ptr %38, align 8
  store i64 %36, ptr %14, align 8
  store i252 814182874304483309791743286124228493744277863724345952005546811777229850325, ptr %15, align 16
  store i252 %6, ptr %16, align 16
  %57 = getelementptr inbounds ptr, ptr %38, i32 9
  %58 = load ptr, ptr %57, align 8
  call void %58(ptr %13, ptr %56, ptr %14, i32 0, ptr %15, ptr %16)
  %59 = load { i1, [31 x i8] }, ptr %13, align 1
  %60 = extractvalue { i1, [31 x i8] } %59, 0
  %61 = getelementptr inbounds i8, ptr %13, i32 8
  %62 = load { ptr, i32, i32, i32 }, ptr %61, align 8
  %63 = load i64, ptr %14, align 8
  br i1 %60, label %123, label %74

64:                                               ; preds = %32
  %65 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %66 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %65, 1
  %67 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %66, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %67, ptr %12, align 8
  %68 = load { i64, [24 x i8] }, ptr %12, align 8
  %69 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %35, 0
  %70 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %69, i64 %36, 1
  %71 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %70, i64 %37, 2
  %72 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %71, ptr %38, 3
  %73 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %72, { i64, [24 x i8] } %68, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %73

74:                                               ; preds = %53
  %75 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f68"(i64 %35, i64 %63, ptr %38, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 563027124402777014625093953982261603, i32 15 }, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 309102034584004589806963, i32 10 })
  %76 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 0
  %77 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 1
  %78 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 2
  %79 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %75, 3
  store { i64, [24 x i8] } %79, ptr %18, align 8
  %80 = load i1, ptr %18, align 1
  switch i1 %80, label %81 [
    i1 false, label %83
    i1 true, label %90
  ]

81:                                               ; preds = %74
  br i1 false, label %82, label %135

82:                                               ; preds = %81
  unreachable

83:                                               ; preds = %74
  %84 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f69"(i64 %76, i64 %77, ptr %78, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 563027124402777014625093953982261603, i32 15 }, { { ptr, i32, i32, i32 }, i252, i32 } { { ptr, i32, i32, i32 } zeroinitializer, i252 79130119626846975927743603, i32 11 })
  %85 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 0
  %86 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 1
  %87 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 2
  %88 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %84, 3
  store { i64, [24 x i8] } %88, ptr %20, align 8
  %89 = load i1, ptr %20, align 1
  switch i1 %89, label %100 [
    i1 false, label %102
    i1 true, label %113
  ]

90:                                               ; preds = %74
  %91 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %92 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %91, 1
  call void @"drop$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %55)
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %19, align 8
  %94 = load { i64, [24 x i8] }, ptr %19, align 8
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %76, 0
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %77, 1
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, i64 %37, 2
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, ptr %78, 3
  %99 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %98, { i64, [24 x i8] } %94, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %99

100:                                              ; preds = %83
  br i1 false, label %101, label %136

101:                                              ; preds = %100
  unreachable

102:                                              ; preds = %83
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %86, i64 0)
  %106 = extractvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } %55, 0
  call void @"drop$378"({ { ptr, i32, i32, i32 } } %106)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %22, align 1
  %107 = load { i64, [24 x i8] }, ptr %22, align 8
  %108 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %85, 0
  %109 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %108, i64 %105, 1
  %110 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %109, i64 %37, 2
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %110, ptr %87, 3
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %107, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %112

113:                                              ; preds = %83
  %114 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %20, align 8
  %115 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %114, 1
  call void @"drop$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %55)
  %116 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %115, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %116, ptr %21, align 8
  %117 = load { i64, [24 x i8] }, ptr %21, align 8
  %118 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %85, 0
  %119 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %118, i64 %86, 1
  %120 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %119, i64 %37, 2
  %121 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %120, ptr %87, 3
  %122 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %121, { i64, [24 x i8] } %117, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %122

123:                                              ; preds = %53
  %124 = phi { { { ptr, i32, i32, i32 } }, { {} }, {} } [ %55, %53 ]
  call void @"drop$379"({ { { ptr, i32, i32, i32 } }, { {} }, {} } %124)
  %125 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 1
  %126 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %125, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %126, ptr %17, align 8
  %127 = load { i64, [24 x i8] }, ptr %17, align 8
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %35, 0
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %63, 1
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %37, 2
  %131 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %130, ptr %38, 3
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %131, { i64, [24 x i8] } %127, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %132

133:                                              ; preds = %30
  call void @puts(ptr @assert_msg_87)
  call void @abort()
  unreachable

134:                                              ; preds = %51
  call void @puts(ptr @assert_msg_88)
  call void @abort()
  unreachable

135:                                              ; preds = %81
  call void @puts(ptr @assert_msg_89)
  call void @abort()
  unreachable

136:                                              ; preds = %100
  call void @puts(ptr @assert_msg_90)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f41(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, i252 %6, { ptr, i32, i32, i32 } %7) {
  %9 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f41"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, i252 %5, i252 %6, { ptr, i32, i32, i32 } %7)
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %9, 4
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %10, 0
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %11, 1
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %12, 2
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, ptr %13, 3
  %19 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %18, { i64, [24 x i8] } %14, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %19
}

define void @_mlir_ciface_f41(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, i252 %7, { ptr, i32, i32, i32 } %8) {
  %10 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f41(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, i252 %6, i252 %7, { ptr, i32, i32, i32 } %8)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %10, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 %0) {
  %2 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %2, align 4
  %3 = getelementptr inbounds i8, ptr %2, i32 4
  store i32 0, ptr %3, align 4
  %4 = getelementptr inbounds i8, ptr %2, i32 16
  %5 = call ptr @realloc(ptr null, i64 8)
  store ptr %4, ptr %5, align 8
  %6 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %5, 0
  %7 = insertvalue { ptr, i32, i32, i32 } %6, i32 8, 3
  %8 = load ptr, ptr %5, align 8
  store i252 %0, ptr %8, align 16
  %9 = insertvalue { ptr, i32, i32, i32 } %7, i32 1, 2
  %10 = getelementptr inbounds i8, ptr %8, i32 -12
  store i32 1, ptr %10, align 4
  %11 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %9, 1
  %12 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %11, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %12
}

define private { {}, { ptr, i32, i32, i32 } } @f42(i252 %0) {
  %2 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 %0)
  %3 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %2, 0
  ret { {}, { ptr, i32, i32, i32 } } %3
}

define void @_mlir_ciface_f42(ptr %0, i252 %1) {
  %3 = call { {}, { ptr, i32, i32, i32 } } @f42(i252 %1)
  store { {}, { ptr, i32, i32, i32 } } %3, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f43"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 117999861104695822858408463129383551244204096177556094315754355)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f43() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f43"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f43(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f43()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f44"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [24 x i8] }, i64 1, align 4
  %4 = alloca { i32, [24 x i8] }, i64 1, align 4
  %5 = alloca { i32, [20 x i8] }, i64 1, align 4
  %6 = alloca { i32, [24 x i8] }, i64 1, align 4
  %7 = alloca { i32, [20 x i8] }, i64 1, align 4
  %8 = alloca { i32, [24 x i8] }, i64 1, align 4
  %9 = alloca { i32, [20 x i8] }, i64 1, align 4
  %10 = alloca { i32, [24 x i8] }, i64 1, align 4
  %11 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %12 = extractvalue { ptr, i32, i32, i32 } %11, 1
  %13 = extractvalue { ptr, i32, i32, i32 } %11, 2
  %14 = sub i32 %13, %12
  %15 = icmp uge i32 %14, 1
  br i1 %15, label %16, label %103

16:                                               ; preds = %2
  %17 = extractvalue { ptr, i32, i32, i32 } %11, 0
  %18 = load ptr, ptr %17, align 8
  %19 = zext i32 %12 to i64
  %20 = mul i64 %19, 32
  %21 = getelementptr inbounds i8, ptr %18, i64 %20
  %22 = add i32 %12, 1
  %23 = insertvalue { ptr, i32, i32, i32 } %11, i32 %22, 1
  %24 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %24, ptr %21, i64 32, i1 false)
  %25 = load i252, ptr %24, align 16
  call void @free(ptr %24)
  %26 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %23)
  %27 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %26, 1
  %29 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %28, 0
  %30 = icmp eq i252 %25, 0
  br i1 %30, label %31, label %55

31:                                               ; preds = %16
  %32 = phi { ptr, i32, i32, i32 } [ %27, %16 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %32)
  %33 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @"impl$f70"(i64 %0, { { ptr, i32, i32, i32 } } %29)
  %34 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %33, 0
  %35 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %33, 1
  %36 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %33, 2
  store { i32, [20 x i8] } %36, ptr %7, align 4
  %37 = load i1, ptr %7, align 1
  switch i1 %37, label %38 [
    i1 false, label %40
    i1 true, label %50
  ]

38:                                               ; preds = %31
  br i1 false, label %39, label %111

39:                                               ; preds = %38
  unreachable

40:                                               ; preds = %31
  %41 = load { i1, { i32, i32, i32, i32, i32 } }, ptr %7, align 4
  %42 = extractvalue { i1, { i32, i32, i32, i32, i32 } } %41, 1
  %43 = insertvalue { i1, { i32, i32, i32, i32, i32 } } { i1 false, { i32, i32, i32, i32, i32 } undef }, { i32, i32, i32, i32, i32 } %42, 1
  store { i1, { i32, i32, i32, i32, i32 } } %43, ptr %9, align 4
  %44 = load { i32, [20 x i8] }, ptr %9, align 4
  %45 = insertvalue { i1, { i32, [20 x i8] } } { i1 false, { i32, [20 x i8] } undef }, { i32, [20 x i8] } %44, 1
  store { i1, { i32, [20 x i8] } } %45, ptr %10, align 4
  %46 = load { i32, [24 x i8] }, ptr %10, align 4
  %47 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %34, 0
  %48 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %47, { { ptr, i32, i32, i32 } } %35, 1
  %49 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %48, { i32, [24 x i8] } %46, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %49

50:                                               ; preds = %31
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %8, align 1
  %51 = load { i32, [24 x i8] }, ptr %8, align 4
  %52 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %34, 0
  %53 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %52, { { ptr, i32, i32, i32 } } %35, 1
  %54 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %53, { i32, [24 x i8] } %51, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %54

55:                                               ; preds = %16
  %56 = phi i252 [ %25, %16 ]
  %57 = phi i252 [ 1, %16 ]
  %58 = zext i252 %56 to i256
  %59 = zext i252 %57 to i256
  %60 = sub i256 %58, %59
  %61 = add i256 %60, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %62 = icmp ult i256 %58, %59
  %63 = select i1 %62, i256 %61, i256 %60
  %64 = trunc i256 %63 to i252
  %65 = icmp eq i252 %64, 0
  br i1 %65, label %66, label %97

66:                                               ; preds = %55
  %67 = phi { { ptr, i32, i32, i32 } } [ %29, %55 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %67)
  %68 = extractvalue { ptr, i32, i32, i32 } %27, 1
  %69 = extractvalue { ptr, i32, i32, i32 } %27, 2
  %70 = sub i32 %69, %68
  %71 = icmp uge i32 %70, 1
  br i1 %71, label %72, label %103

72:                                               ; preds = %66
  %73 = extractvalue { ptr, i32, i32, i32 } %27, 0
  %74 = load ptr, ptr %73, align 8
  %75 = zext i32 %68 to i64
  %76 = mul i64 %75, 32
  %77 = getelementptr inbounds i8, ptr %74, i64 %76
  %78 = add i32 %68, 1
  %79 = insertvalue { ptr, i32, i32, i32 } %27, i32 %78, 1
  %80 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %80, ptr %77, i64 32, i1 false)
  %81 = load i252, ptr %80, align 16
  call void @free(ptr %80)
  %82 = icmp ult i252 %81, 4294967296
  %83 = add i64 %0, 2
  %84 = add i64 %0, 3
  %85 = select i1 %82, i64 %83, i64 %84
  %86 = trunc i252 %81 to i32
  br i1 %82, label %87, label %103

87:                                               ; preds = %72
  %88 = phi { ptr, i32, i32, i32 } [ %79, %72 ]
  %89 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %88, 0
  %90 = insertvalue { i1, i32 } { i1 true, i32 undef }, i32 %86, 1
  store { i1, i32 } %90, ptr %5, align 4
  %91 = load { i32, [20 x i8] }, ptr %5, align 4
  %92 = insertvalue { i1, { i32, [20 x i8] } } { i1 false, { i32, [20 x i8] } undef }, { i32, [20 x i8] } %91, 1
  store { i1, { i32, [20 x i8] } } %92, ptr %6, align 4
  %93 = load { i32, [24 x i8] }, ptr %6, align 4
  %94 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %85, 0
  %95 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %94, { { ptr, i32, i32, i32 } } %89, 1
  %96 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %95, { i32, [24 x i8] } %93, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %96

97:                                               ; preds = %55
  %98 = phi { ptr, i32, i32, i32 } [ %27, %55 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %98)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %99 = load { i32, [24 x i8] }, ptr %4, align 4
  %100 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %0, 0
  %101 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %100, { { ptr, i32, i32, i32 } } %29, 1
  %102 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %101, { i32, [24 x i8] } %99, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %102

103:                                              ; preds = %72, %66, %2
  %104 = phi i64 [ %85, %72 ], [ %0, %66 ], [ %0, %2 ]
  %105 = phi { ptr, i32, i32, i32 } [ %79, %72 ], [ %27, %66 ], [ %11, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %106 = load { i32, [24 x i8] }, ptr %3, align 4
  %107 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %105, 0
  %108 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %104, 0
  %109 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %108, { { ptr, i32, i32, i32 } } %107, 1
  %110 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %109, { i32, [24 x i8] } %106, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %110

111:                                              ; preds = %38
  call void @puts(ptr @assert_msg_91)
  call void @abort()
  unreachable
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @f44(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @"impl$f44"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %8, { i32, [24 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %9
}

define void @_mlir_ciface_f44(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } @f44(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$367"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$367"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 8)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 8, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f45"(i64 %0, i64 %1, { { { { ptr, i32, i32, i32 } } }, {} } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [48 x i8] }, i64 1, align 8
  %11 = alloca { i64, [48 x i8] }, i64 1, align 8
  %12 = alloca { i32, [4 x i8] }, i64 1, align 4
  br label %13

13:                                               ; preds = %172, %4
  %14 = phi i64 [ %129, %172 ], [ %0, %4 ]
  %15 = phi i64 [ %131, %172 ], [ %1, %4 ]
  %16 = phi { { { { ptr, i32, i32, i32 } } }, {} } [ %185, %172 ], [ %2, %4 ]
  %17 = phi { ptr, i32, i32, i32 } [ %181, %172 ], [ %3, %4 ]
  %18 = add i64 %14, 1
  %19 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %20 = call ptr %19()
  %21 = load i64, ptr %20, align 8
  %22 = mul i64 %21, 2270
  %23 = icmp uge i64 %15, %22
  %24 = call i64 @llvm.usub.sat.i64(i64 %15, i64 %22)
  br i1 %23, label %25, label %226

25:                                               ; preds = %13
  %26 = phi { { { { ptr, i32, i32, i32 } } }, {} } [ %16, %13 ]
  %27 = extractvalue { { { { ptr, i32, i32, i32 } } }, {} } %26, 0
  %28 = extractvalue { { { ptr, i32, i32, i32 } } } %27, 0
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %203

34:                                               ; preds = %25
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 8
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 8)
  call void @llvm.memcpy.p0.p0.i64(ptr %42, ptr %39, i64 8, i1 false)
  %43 = load { i32, [4 x i8] }, ptr %42, align 4
  call void @free(ptr %42)
  store { i32, [4 x i8] } %43, ptr %12, align 4
  %44 = load i3, ptr %12, align 1
  switch i3 %44, label %45 [
    i3 0, label %47
    i3 1, label %53
    i3 2, label %65
    i3 3, label %77
    i3 -4, label %89
    i3 -3, label %101
    i3 -2, label %113
  ]

45:                                               ; preds = %34
  br i1 false, label %46, label %241

46:                                               ; preds = %45
  unreachable

47:                                               ; preds = %34
  %48 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %49 = call ptr %48()
  %50 = load i64, ptr %49, align 8
  %51 = mul i64 %50, 90
  %52 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 %51)
  br label %127

53:                                               ; preds = %34
  %54 = load { i3, i32 }, ptr %12, align 4
  %55 = extractvalue { i3, i32 } %54, 1
  %56 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %57 = call ptr %56()
  %58 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 0)
  %59 = zext i32 %55 to i256
  %60 = add i256 %59, 4294967296
  %61 = add i256 %59, -3618502788666131213697322783095070105623107215331596699973092056131577053185
  %62 = icmp uge i256 %60, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %63 = select i1 %62, i256 %61, i256 %60
  %64 = trunc i256 %63 to i252
  br label %127

65:                                               ; preds = %34
  %66 = load { i3, i32 }, ptr %12, align 4
  %67 = extractvalue { i3, i32 } %66, 1
  %68 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %69 = call ptr %68()
  %70 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 0)
  %71 = zext i32 %67 to i256
  %72 = add i256 %71, 8589934592
  %73 = add i256 %71, -3618502788666131213697322783095070105623107215331596699973092056127282085889
  %74 = icmp uge i256 %72, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %75 = select i1 %74, i256 %73, i256 %72
  %76 = trunc i256 %75 to i252
  br label %127

77:                                               ; preds = %34
  %78 = load { i3, i32 }, ptr %12, align 4
  %79 = extractvalue { i3, i32 } %78, 1
  %80 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %81 = call ptr %80()
  %82 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 0)
  %83 = zext i32 %79 to i256
  %84 = add i256 %83, 12884901888
  %85 = add i256 %83, -3618502788666131213697322783095070105623107215331596699973092056122987118593
  %86 = icmp uge i256 %84, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %87 = select i1 %86, i256 %85, i256 %84
  %88 = trunc i256 %87 to i252
  br label %127

89:                                               ; preds = %34
  %90 = load { i3, i32 }, ptr %12, align 4
  %91 = extractvalue { i3, i32 } %90, 1
  %92 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %93 = call ptr %92()
  %94 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 0)
  %95 = zext i32 %91 to i256
  %96 = add i256 %95, 17179869184
  %97 = add i256 %95, -3618502788666131213697322783095070105623107215331596699973092056118692151297
  %98 = icmp uge i256 %96, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %99 = select i1 %98, i256 %97, i256 %96
  %100 = trunc i256 %99 to i252
  br label %127

101:                                              ; preds = %34
  %102 = load { i3, i32 }, ptr %12, align 4
  %103 = extractvalue { i3, i32 } %102, 1
  %104 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %105 = call ptr %104()
  %106 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 0)
  %107 = zext i32 %103 to i256
  %108 = add i256 %107, 21474836480
  %109 = add i256 %107, -3618502788666131213697322783095070105623107215331596699973092056114397184001
  %110 = icmp uge i256 %108, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %111 = select i1 %110, i256 %109, i256 %108
  %112 = trunc i256 %111 to i252
  br label %127

113:                                              ; preds = %34
  %114 = load { i3, i32 }, ptr %12, align 4
  %115 = extractvalue { i3, i32 } %114, 1
  %116 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %117 = call ptr %116()
  %118 = load i64, ptr %117, align 8
  %119 = mul i64 %118, 100
  %120 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 %119)
  %121 = zext i32 %115 to i256
  %122 = add i256 %121, 25769803776
  %123 = add i256 %121, -3618502788666131213697322783095070105623107215331596699973092056110102216705
  %124 = icmp uge i256 %122, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %125 = select i1 %124, i256 %123, i256 %122
  %126 = trunc i256 %125 to i252
  br label %127

127:                                              ; preds = %47, %53, %65, %77, %89, %101, %113
  %128 = phi { ptr, i32, i32, i32 } [ %17, %113 ], [ %17, %101 ], [ %17, %89 ], [ %17, %77 ], [ %17, %65 ], [ %17, %53 ], [ %17, %47 ]
  %129 = phi i64 [ %18, %113 ], [ %18, %101 ], [ %18, %89 ], [ %18, %77 ], [ %18, %65 ], [ %18, %53 ], [ %18, %47 ]
  %130 = phi { ptr, i32, i32, i32 } [ %41, %113 ], [ %41, %101 ], [ %41, %89 ], [ %41, %77 ], [ %41, %65 ], [ %41, %53 ], [ %41, %47 ]
  %131 = phi i64 [ %120, %113 ], [ %106, %101 ], [ %94, %89 ], [ %82, %77 ], [ %70, %65 ], [ %58, %53 ], [ %52, %47 ]
  %132 = phi i252 [ %126, %113 ], [ %112, %101 ], [ %100, %89 ], [ %88, %77 ], [ %76, %65 ], [ %64, %53 ], [ 0, %47 ]
  %133 = extractvalue { ptr, i32, i32, i32 } %128, 3
  %134 = icmp eq i32 %133, 0
  br i1 %134, label %135, label %149

135:                                              ; preds = %127
  %136 = shl i32 %133, 1
  %137 = call i32 @llvm.umin.i32(i32 %136, i32 1024)
  %138 = add i32 %137, %133
  %139 = call i32 @llvm.umax.i32(i32 %138, i32 8)
  %140 = zext i32 %139 to i64
  %141 = mul i64 %140, 32
  %142 = add i64 %141, 16
  %143 = call ptr @realloc(ptr null, i64 %142)
  store i32 1, ptr %143, align 4
  %144 = getelementptr inbounds i8, ptr %143, i32 4
  store i32 0, ptr %144, align 4
  %145 = getelementptr inbounds i8, ptr %143, i32 16
  %146 = call ptr @realloc(ptr null, i64 8)
  store ptr %145, ptr %146, align 8
  %147 = insertvalue { ptr, i32, i32, i32 } %128, ptr %146, 0
  %148 = insertvalue { ptr, i32, i32, i32 } %147, i32 %139, 3
  br label %170

149:                                              ; preds = %127
  %150 = extractvalue { ptr, i32, i32, i32 } %128, 2
  %151 = icmp ult i32 %150, %133
  br i1 %151, label %152, label %153

152:                                              ; preds = %149
  br label %167

153:                                              ; preds = %149
  %154 = shl i32 %133, 1
  %155 = call i32 @llvm.umin.i32(i32 %154, i32 1024)
  %156 = add i32 %155, %133
  %157 = call i32 @llvm.umax.i32(i32 %156, i32 8)
  %158 = zext i32 %157 to i64
  %159 = mul i64 %158, 32
  %160 = add i64 %159, 16
  %161 = extractvalue { ptr, i32, i32, i32 } %128, 0
  %162 = load ptr, ptr %161, align 8
  %163 = getelementptr inbounds i8, ptr %162, i32 -16
  %164 = call ptr @realloc(ptr %163, i64 %160)
  %165 = getelementptr inbounds i8, ptr %164, i32 16
  store ptr %165, ptr %161, align 8
  %166 = insertvalue { ptr, i32, i32, i32 } %128, i32 %157, 3
  br label %167

167:                                              ; preds = %152, %153
  %168 = phi { ptr, i32, i32, i32 } [ %166, %153 ], [ %128, %152 ]
  br label %169

169:                                              ; preds = %167
  br label %170

170:                                              ; preds = %135, %169
  %171 = phi { ptr, i32, i32, i32 } [ %168, %169 ], [ %148, %135 ]
  br label %172

172:                                              ; preds = %170
  %173 = extractvalue { ptr, i32, i32, i32 } %171, 0
  %174 = load ptr, ptr %173, align 8
  %175 = extractvalue { ptr, i32, i32, i32 } %171, 2
  %176 = zext i32 %175 to i64
  %177 = mul i64 %176, 32
  %178 = getelementptr inbounds i8, ptr %174, i64 %177
  store i252 %132, ptr %178, align 16
  %179 = extractvalue { ptr, i32, i32, i32 } %171, 2
  %180 = add i32 %179, 1
  %181 = insertvalue { ptr, i32, i32, i32 } %171, i32 %180, 2
  %182 = getelementptr inbounds i8, ptr %174, i32 -12
  store i32 %180, ptr %182, align 4
  %183 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %130, 0
  %184 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %183, 0
  %185 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %184, 0
  %186 = extractvalue { ptr, ptr, i64 } %8, 1
  %187 = load i64, ptr %186, align 8
  %188 = add i64 %187, 1
  %189 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %188, ptr %189, align 8
  br label %13

190:                                              ; preds = %190, %203, %226
  %191 = phi i64 [ %18, %226 ], [ %18, %203 ], [ %191, %190 ]
  %192 = phi i64 [ %15, %226 ], [ %209, %203 ], [ %192, %190 ]
  %193 = phi { i64, [48 x i8] } [ %231, %226 ], [ %216, %203 ], [ %193, %190 ]
  %194 = extractvalue { ptr, ptr, i64 } %8, 1
  %195 = load i64, ptr %194, align 8
  %196 = icmp eq i64 %195, 0
  %197 = sub i64 %195, 1
  %198 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %197, ptr %198, align 8
  br i1 %196, label %199, label %190

199:                                              ; preds = %190
  %200 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %191, 0
  %201 = insertvalue { i64, i64, { i64, [48 x i8] } } %200, i64 %192, 1
  %202 = insertvalue { i64, i64, { i64, [48 x i8] } } %201, { i64, [48 x i8] } %193, 2
  ret { i64, i64, { i64, [48 x i8] } } %202

203:                                              ; preds = %25
  %204 = phi i64 [ %24, %25 ]
  %205 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %206 = call ptr %205()
  %207 = load i64, ptr %206, align 8
  %208 = mul i64 %207, 2970
  %209 = call i64 @llvm.uadd.sat.i64(i64 %204, i64 %208)
  %210 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %29, 0
  %211 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %210, 0
  %212 = insertvalue { { { { ptr, i32, i32, i32 } } }, {} } undef, { { { ptr, i32, i32, i32 } } } %211, 0
  %213 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } undef, { { { { ptr, i32, i32, i32 } } }, {} } %212, 0
  %214 = insertvalue { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %213, { ptr, i32, i32, i32 } %17, 1
  %215 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } undef }, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } %214, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, {} }, { ptr, i32, i32, i32 }, {} } } %215, ptr %11, align 8
  %216 = load { i64, [48 x i8] }, ptr %11, align 8
  %217 = extractvalue { ptr, ptr, i64 } %8, 1
  %218 = load i64, ptr %217, align 8
  %219 = icmp eq i64 %218, 0
  %220 = sub i64 %218, 1
  %221 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %220, ptr %221, align 8
  br i1 %219, label %222, label %190

222:                                              ; preds = %203
  %223 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %18, 0
  %224 = insertvalue { i64, i64, { i64, [48 x i8] } } %223, i64 %209, 1
  %225 = insertvalue { i64, i64, { i64, [48 x i8] } } %224, { i64, [48 x i8] } %216, 2
  ret { i64, i64, { i64, [48 x i8] } } %225

226:                                              ; preds = %13
  %227 = phi { ptr, i32, i32, i32 } [ %17, %13 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %227)
  call void @"drop$467"({ { { { ptr, i32, i32, i32 } } }, {} } %16)
  %228 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %229 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %228, 0
  %230 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %229, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %230, ptr %10, align 8
  %231 = load { i64, [48 x i8] }, ptr %10, align 8
  %232 = extractvalue { ptr, ptr, i64 } %8, 1
  %233 = load i64, ptr %232, align 8
  %234 = icmp eq i64 %233, 0
  %235 = sub i64 %233, 1
  %236 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %235, ptr %236, align 8
  br i1 %234, label %237, label %190

237:                                              ; preds = %226
  %238 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %18, 0
  %239 = insertvalue { i64, i64, { i64, [48 x i8] } } %238, i64 %15, 1
  %240 = insertvalue { i64, i64, { i64, [48 x i8] } } %239, { i64, [48 x i8] } %231, 2
  ret { i64, i64, { i64, [48 x i8] } } %240

241:                                              ; preds = %45
  call void @puts(ptr @assert_msg_92)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [48 x i8] } } @f45(i64 %0, i64 %1, { { { { ptr, i32, i32, i32 } } }, {} } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f45"(i64 %0, i64 %1, { { { { ptr, i32, i32, i32 } } }, {} } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [48 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [48 x i8] } } %10, { i64, [48 x i8] } %8, 2
  ret { i64, i64, { i64, [48 x i8] } } %11
}

define void @_mlir_ciface_f45(ptr %0, i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [48 x i8] } } @f45(i64 %1, i64 %2, { { { { ptr, i32, i32, i32 } } }, {} } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [48 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$360"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$360"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$243"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$243"({ { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } undef, { { { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %8, { { { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, 0
  call void @"drop$243"({ { { ptr, i32, i32, i32 } } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } @"dup$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } @"dup$243"({ { { ptr, i32, i32, i32 } } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { { ptr, i32, i32, i32 } } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, { { { ptr, i32, i32, i32 } } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6, { { {} } } %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %7, { { {} } } %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %11, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %10, 1
  ret { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %12
}

define private void @"drop$365"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  %3 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$360"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } @"dup$365"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } @"dup$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$360"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } undef, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %17, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$366"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$365"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$366"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } @"dup$365"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$361"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$360"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$361"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$360"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$362"({ { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0, 0
  call void @"drop$361"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } @"dup$362"({ { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$361"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %6, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %7, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %8, 1
  %11 = extractvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %0, 2
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %9, {} %11, 2
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %10, {} %11, 2
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } undef, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %14, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %15
}

define private void @"drop$363"({ i64, [64 x i8] } %0) {
  %2 = alloca { i64, [64 x i8] }, i64 1, align 8
  store { i64, [64 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$362"({ { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [64 x i8] }, { i64, [64 x i8] } } @"dup$363"({ i64, [64 x i8] } %0) {
  %2 = alloca { i64, [64 x i8] }, i64 1, align 8
  store { i64, [64 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } @"dup$362"({ { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [64 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [64 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [64 x i8] }, { i64, [64 x i8] } } undef, { i64, [64 x i8] } %11, 0
  %15 = insertvalue { { i64, [64 x i8] }, { i64, [64 x i8] } } %14, { i64, [64 x i8] } %13, 1
  ret { { i64, [64 x i8] }, { i64, [64 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [64 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [64 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [64 x i8] }, { i64, [64 x i8] } } undef, { i64, [64 x i8] } %23, 0
  %27 = insertvalue { { i64, [64 x i8] }, { i64, [64 x i8] } } %26, { i64, [64 x i8] } %25, 1
  ret { { i64, [64 x i8] }, { i64, [64 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f46"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = alloca { i64, [48 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [64 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %14, 0
  %16 = call fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f71"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %15, { ptr, i32, i32, i32 } zeroinitializer)
  %17 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, 0
  %18 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, 1
  %19 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, 2
  %20 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, 3
  %21 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, 4
  %22 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, 5
  store { i64, [48 x i8] } %22, ptr %8, align 8
  %23 = load i1, ptr %8, align 1
  switch i1 %23, label %24 [
    i1 false, label %26
    i1 true, label %36
  ]

24:                                               ; preds = %7
  br i1 false, label %25, label %135

25:                                               ; preds = %24
  unreachable

26:                                               ; preds = %7
  %27 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } }, ptr %8, align 8
  %28 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %27, 1
  %29 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f72"(i64 %17, i64 %18, i64 %19, ptr %21, { i252 } { i252 1254074017074475171384430419983034313718811929311188110826608799162214963686 })
  %30 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %29, 0
  %31 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %29, 1
  %32 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %29, 2
  %33 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %29, 3
  %34 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %29, 4
  store { i64, [24 x i8] } %34, ptr %10, align 8
  %35 = load i1, ptr %10, align 1
  switch i1 %35, label %47 [
    i1 false, label %49
    i1 true, label %94
  ]

36:                                               ; preds = %7
  %37 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %38 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %37, 1
  %39 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %38, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %39, ptr %9, align 8
  %40 = load { i64, [24 x i8] }, ptr %9, align 8
  %41 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %17, 0
  %42 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %41, i64 %18, 1
  %43 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %42, i64 %19, 2
  %44 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %43, i64 %20, 3
  %45 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %44, ptr %21, 4
  %46 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %45, { i64, [24 x i8] } %40, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %46

47:                                               ; preds = %26
  br i1 false, label %48, label %136

48:                                               ; preds = %47
  unreachable

49:                                               ; preds = %26
  %50 = load { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } }, ptr %10, align 2
  %51 = extractvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %50, 1
  %52 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %51, 0
  %53 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 0
  %54 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 1
  %55 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 2
  %56 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 3
  %57 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 4
  %58 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 5
  %59 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 6
  %60 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 7
  %61 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 8
  %62 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 9
  %63 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %52, 10
  %64 = zext i8 %53 to i32
  %65 = zext i8 %54 to i32
  %66 = zext i8 %55 to i32
  %67 = zext i8 %56 to i32
  %68 = zext i8 %57 to i16
  %69 = zext i8 %58 to i16
  %70 = zext i8 %59 to i16
  %71 = zext i8 %60 to i16
  %72 = zext i16 %61 to i32
  %73 = zext i16 %62 to i32
  %74 = zext i16 %63 to i32
  %75 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %28, 0
  %76 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %28, 1
  call void @"drop$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %75)
  %77 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %76, 0
  %78 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } undef, i32 %64, 0
  %79 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %78, i32 %65, 1
  %80 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %79, i32 %66, 2
  %81 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %80, i32 %67, 3
  %82 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %81, i16 %68, 4
  %83 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %82, i16 %69, 5
  %84 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %83, i16 %70, 6
  %85 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %84, i16 %71, 7
  %86 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %85, i32 %72, 8
  %87 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %86, i32 %73, 9
  %88 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %87, i32 %74, 10
  %89 = call fastcc { i64, i64, { i64, [64 x i8] } } @"impl$f73"(i64 %30, i64 %31, { { ptr, i32, i32, i32 } } %77, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %88)
  %90 = extractvalue { i64, i64, { i64, [64 x i8] } } %89, 0
  %91 = extractvalue { i64, i64, { i64, [64 x i8] } } %89, 1
  %92 = extractvalue { i64, i64, { i64, [64 x i8] } } %89, 2
  store { i64, [64 x i8] } %92, ptr %12, align 8
  %93 = load i1, ptr %12, align 1
  switch i1 %93, label %105 [
    i1 false, label %107
    i1 true, label %124
  ]

94:                                               ; preds = %26
  %95 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %96 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %95, 1
  call void @"drop$365"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %28)
  %97 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %96, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %97, ptr %11, align 8
  %98 = load { i64, [24 x i8] }, ptr %11, align 8
  %99 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %30, 0
  %100 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %99, i64 %31, 1
  %101 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %100, i64 %32, 2
  %102 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %101, i64 %20, 3
  %103 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %102, ptr %33, 4
  %104 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %103, { i64, [24 x i8] } %98, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %104

105:                                              ; preds = %49
  br i1 false, label %106, label %137

106:                                              ; preds = %105
  unreachable

107:                                              ; preds = %49
  %108 = load { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } }, ptr %12, align 8
  %109 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %108, 1
  %110 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %111 = call ptr %110()
  %112 = call i64 @llvm.uadd.sat.i64(i64 %91, i64 0)
  %113 = extractvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %109, 0
  %114 = extractvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %109, 1
  call void @"drop$361"({ { ptr, i32, i32, i32 } } %113)
  %115 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f74"(i64 %90, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %114)
  %116 = extractvalue { i64, { i64, [24 x i8] } } %115, 0
  %117 = extractvalue { i64, { i64, [24 x i8] } } %115, 1
  %118 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %116, 0
  %119 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %118, i64 %112, 1
  %120 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %119, i64 %32, 2
  %121 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %120, i64 %20, 3
  %122 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %121, ptr %33, 4
  %123 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %122, { i64, [24 x i8] } %117, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %123

124:                                              ; preds = %49
  %125 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %126 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %125, 1
  %127 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %126, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %127, ptr %13, align 8
  %128 = load { i64, [24 x i8] }, ptr %13, align 8
  %129 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %90, 0
  %130 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %129, i64 %91, 1
  %131 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %130, i64 %32, 2
  %132 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %131, i64 %20, 3
  %133 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %132, ptr %33, 4
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %133, { i64, [24 x i8] } %128, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %134

135:                                              ; preds = %24
  call void @puts(ptr @assert_msg_93)
  call void @abort()
  unreachable

136:                                              ; preds = %47
  call void @puts(ptr @assert_msg_94)
  call void @abort()
  unreachable

137:                                              ; preds = %105
  call void @puts(ptr @assert_msg_95)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f46(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f46"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { { ptr, i32, i32, i32 } } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %19, { i64, [24 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %20
}

define void @_mlir_ciface_f46(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, { { ptr, i32, i32, i32 } } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } @f46(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { {} } %6, { { ptr, i32, i32, i32 } } %7)
  store { i64, i64, i64, i64, ptr, { i64, [24 x i8] } } %9, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 7891998437966260601762371672023996916393715052535837300)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f47() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f47"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f47(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f47()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f48"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %113, %5
  %17 = phi i64 [ %22, %113 ], [ %0, %5 ]
  %18 = phi i64 [ %72, %113 ], [ %1, %5 ]
  %19 = phi { { ptr, i32, i32, i32 } } [ %130, %113 ], [ %2, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %122, %113 ], [ %3, %5 ]
  %21 = phi i252 [ %129, %113 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 1770
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %170

29:                                               ; preds = %16
  %30 = phi i252 [ %21, %16 ]
  %31 = icmp eq i252 %30, 0
  br i1 %31, label %32, label %54

32:                                               ; preds = %29
  %33 = phi i64 [ %28, %29 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = load i64, ptr %35, align 8
  %37 = mul i64 %36, 2670
  %38 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %37)
  %39 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %20, 1
  store { i1, { ptr, i32, i32, i32 } } %39, ptr %14, align 8
  %40 = load { i64, [24 x i8] }, ptr %14, align 8
  %41 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %19, 0
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %41, { i64, [24 x i8] } %40, 1
  %43 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %43, ptr %15, align 8
  %44 = load { i64, [56 x i8] }, ptr %15, align 8
  %45 = extractvalue { ptr, ptr, i64 } %9, 1
  %46 = load i64, ptr %45, align 8
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %46, 1
  %49 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %48, ptr %49, align 8
  br i1 %47, label %50, label %135

50:                                               ; preds = %32
  %51 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } %51, i64 %38, 1
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, { i64, [56 x i8] } %44, 2
  ret { i64, i64, { i64, [56 x i8] } } %53

54:                                               ; preds = %29
  %55 = phi { { ptr, i32, i32, i32 } } [ %19, %29 ]
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %148

61:                                               ; preds = %54
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %71 = call ptr %70()
  %72 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 0)
  %73 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %74 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %76, label %90

76:                                               ; preds = %61
  %77 = shl i32 %74, 1
  %78 = call i32 @llvm.umin.i32(i32 %77, i32 1024)
  %79 = add i32 %78, %74
  %80 = call i32 @llvm.umax.i32(i32 %79, i32 8)
  %81 = zext i32 %80 to i64
  %82 = mul i64 %81, 32
  %83 = add i64 %82, 16
  %84 = call ptr @realloc(ptr null, i64 %83)
  store i32 1, ptr %84, align 4
  %85 = getelementptr inbounds i8, ptr %84, i32 4
  store i32 0, ptr %85, align 4
  %86 = getelementptr inbounds i8, ptr %84, i32 16
  %87 = call ptr @realloc(ptr null, i64 8)
  store ptr %86, ptr %87, align 8
  %88 = insertvalue { ptr, i32, i32, i32 } %20, ptr %87, 0
  %89 = insertvalue { ptr, i32, i32, i32 } %88, i32 %80, 3
  br label %111

90:                                               ; preds = %61
  %91 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %92 = icmp ult i32 %91, %74
  br i1 %92, label %93, label %94

93:                                               ; preds = %90
  br label %108

94:                                               ; preds = %90
  %95 = shl i32 %74, 1
  %96 = call i32 @llvm.umin.i32(i32 %95, i32 1024)
  %97 = add i32 %96, %74
  %98 = call i32 @llvm.umax.i32(i32 %97, i32 8)
  %99 = zext i32 %98 to i64
  %100 = mul i64 %99, 32
  %101 = add i64 %100, 16
  %102 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %103 = load ptr, ptr %102, align 8
  %104 = getelementptr inbounds i8, ptr %103, i32 -16
  %105 = call ptr @realloc(ptr %104, i64 %101)
  %106 = getelementptr inbounds i8, ptr %105, i32 16
  store ptr %106, ptr %102, align 8
  %107 = insertvalue { ptr, i32, i32, i32 } %20, i32 %98, 3
  br label %108

108:                                              ; preds = %93, %94
  %109 = phi { ptr, i32, i32, i32 } [ %107, %94 ], [ %20, %93 ]
  br label %110

110:                                              ; preds = %108
  br label %111

111:                                              ; preds = %76, %110
  %112 = phi { ptr, i32, i32, i32 } [ %109, %110 ], [ %89, %76 ]
  br label %113

113:                                              ; preds = %111
  %114 = extractvalue { ptr, i32, i32, i32 } %112, 0
  %115 = load ptr, ptr %114, align 8
  %116 = extractvalue { ptr, i32, i32, i32 } %112, 2
  %117 = zext i32 %116 to i64
  %118 = mul i64 %117, 32
  %119 = getelementptr inbounds i8, ptr %115, i64 %118
  store i252 %73, ptr %119, align 16
  %120 = extractvalue { ptr, i32, i32, i32 } %112, 2
  %121 = add i32 %120, 1
  %122 = insertvalue { ptr, i32, i32, i32 } %112, i32 %121, 2
  %123 = getelementptr inbounds i8, ptr %115, i32 -12
  store i32 %121, ptr %123, align 4
  %124 = zext i252 %30 to i256
  %125 = sub i256 %124, 1
  %126 = add i256 %124, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %127 = icmp ult i256 %124, 1
  %128 = select i1 %127, i256 %126, i256 %125
  %129 = trunc i256 %128 to i252
  %130 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %131 = extractvalue { ptr, ptr, i64 } %9, 1
  %132 = load i64, ptr %131, align 8
  %133 = add i64 %132, 1
  %134 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %133, ptr %134, align 8
  br label %16

135:                                              ; preds = %135, %32, %148, %170
  %136 = phi i64 [ %22, %170 ], [ %22, %148 ], [ %136, %135 ], [ %22, %32 ]
  %137 = phi i64 [ %18, %170 ], [ %154, %148 ], [ %137, %135 ], [ %38, %32 ]
  %138 = phi { i64, [56 x i8] } [ %175, %170 ], [ %160, %148 ], [ %138, %135 ], [ %44, %32 ]
  %139 = extractvalue { ptr, ptr, i64 } %9, 1
  %140 = load i64, ptr %139, align 8
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %140, 1
  %143 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %142, ptr %143, align 8
  br i1 %141, label %144, label %135

144:                                              ; preds = %135
  %145 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %136, 0
  %146 = insertvalue { i64, i64, { i64, [56 x i8] } } %145, i64 %137, 1
  %147 = insertvalue { i64, i64, { i64, [56 x i8] } } %146, { i64, [56 x i8] } %138, 2
  ret { i64, i64, { i64, [56 x i8] } } %147

148:                                              ; preds = %54
  %149 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %149)
  %150 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %151 = call ptr %150()
  %152 = load i64, ptr %151, align 8
  %153 = mul i64 %152, 2370
  %154 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %153)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %155 = load { i64, [24 x i8] }, ptr %12, align 8
  %156 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %56, 0
  %157 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %156, 0
  %158 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %157, { i64, [24 x i8] } %155, 1
  %159 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %158, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %159, ptr %13, align 8
  %160 = load { i64, [56 x i8] }, ptr %13, align 8
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %166, label %135

166:                                              ; preds = %148
  %167 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %168 = insertvalue { i64, i64, { i64, [56 x i8] } } %167, i64 %154, 1
  %169 = insertvalue { i64, i64, { i64, [56 x i8] } } %168, { i64, [56 x i8] } %160, 2
  ret { i64, i64, { i64, [56 x i8] } } %169

170:                                              ; preds = %16
  %171 = phi { ptr, i32, i32, i32 } [ %20, %16 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %171)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %19)
  %172 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %173 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %172, 0
  %174 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %173, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %174, ptr %11, align 8
  %175 = load { i64, [56 x i8] }, ptr %11, align 8
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %135

181:                                              ; preds = %170
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %18, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184
}

define private { i64, i64, { i64, [56 x i8] } } @f48(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f48"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f48(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f48(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$358"(ptr %0) {
  %2 = load { ptr, i32, i32, i32 }, ptr %0, align 8
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$358"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 24)
  %3 = load { ptr, i32, i32, i32 }, ptr %0, align 8
  %4 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %3)
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 0
  %6 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 1
  store { ptr, i32, i32, i32 } %5, ptr %0, align 8
  store { ptr, i32, i32, i32 } %6, ptr %2, align 8
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$357"({ i128, [32 x i8] } %0) {
  %2 = alloca { i128, [32 x i8] }, i64 1, align 16
  store { i128, [32 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [32 x i8] }, { i128, [32 x i8] } } @"dup$357"({ i128, [32 x i8] } %0) {
  %2 = alloca { i128, [32 x i8] }, i64 1, align 16
  store { i128, [32 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i252 } }, ptr %2, align 16
  %6 = extractvalue { i1, { i252 } } %5, 1
  %7 = insertvalue { i1, { i252 } } %5, { i252 } %6, 1
  store { i1, { i252 } } %7, ptr %2, align 16
  %8 = load { i128, [32 x i8] }, ptr %2, align 16
  %9 = insertvalue { i1, { i252 } } %5, { i252 } %6, 1
  store { i1, { i252 } } %9, ptr %2, align 16
  %10 = load { i128, [32 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } undef, { i128, [32 x i8] } %8, 0
  %12 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } %11, { i128, [32 x i8] } %10, 1
  ret { { i128, [32 x i8] }, { i128, [32 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i128, [32 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i128, [32 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } undef, { i128, [32 x i8] } %20, 0
  %24 = insertvalue { { i128, [32 x i8] }, { i128, [32 x i8] } } %23, { i128, [32 x i8] } %22, 1
  ret { { i128, [32 x i8] }, { i128, [32 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f49"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %4, { ptr, i32, i32, i32 } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [72 x i8] }, i64 1, align 8
  %13 = alloca { i64, [72 x i8] }, i64 1, align 8
  %14 = alloca { i128, [32 x i8] }, i64 1, align 16
  %15 = alloca { i64, [72 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %115, %6
  %17 = phi i64 [ %61, %115 ], [ %0, %6 ]
  %18 = phi i64 [ %74, %115 ], [ %1, %6 ]
  %19 = phi i64 [ %63, %115 ], [ %2, %6 ]
  %20 = phi ptr [ %64, %115 ], [ %3, %6 ]
  %21 = phi { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } [ %128, %115 ], [ %4, %6 ]
  %22 = phi { ptr, i32, i32, i32 } [ %124, %115 ], [ %5, %6 ]
  %23 = add i64 %17, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = getelementptr inbounds i64, ptr %25, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %25, align 8
  %29 = mul i64 %28, 22380
  %30 = add i64 %27, %29
  %31 = icmp uge i64 %18, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %30)
  br i1 %31, label %33, label %194

33:                                               ; preds = %16
  %34 = phi { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } [ %21, %16 ]
  %35 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %34, 0
  %36 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %34, 1
  %37 = extractvalue { { ptr, i32, i32, i32 } } %35, 0
  %38 = extractvalue { ptr, i32, i32, i32 } %37, 1
  %39 = extractvalue { ptr, i32, i32, i32 } %37, 2
  %40 = sub i32 %39, %38
  %41 = icmp uge i32 %40, 1
  br i1 %41, label %42, label %166

42:                                               ; preds = %33
  %43 = extractvalue { ptr, i32, i32, i32 } %37, 0
  %44 = load ptr, ptr %43, align 8
  %45 = zext i32 %38 to i64
  %46 = mul i64 %45, 24
  %47 = getelementptr inbounds i8, ptr %44, i64 %46
  %48 = add i32 %38, 1
  %49 = insertvalue { ptr, i32, i32, i32 } %37, i32 %48, 1
  %50 = call ptr @realloc(ptr null, i64 24)
  %51 = load { ptr, i32, i32, i32 }, ptr %47, align 8
  %52 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %51)
  %53 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %52, 0
  %54 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %52, 1
  store { ptr, i32, i32, i32 } %53, ptr %47, align 8
  store { ptr, i32, i32, i32 } %54, ptr %50, align 8
  %55 = call { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } @"dup$450"({ { {} }, { { ptr, i32, i32, i32 } } } %36)
  %56 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %55, 0
  %57 = extractvalue { { { {} }, { { ptr, i32, i32, i32 } } }, { { {} }, { { ptr, i32, i32, i32 } } } } %55, 1
  %58 = load { ptr, i32, i32, i32 }, ptr %50, align 8
  call void @free(ptr %50)
  %59 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %58, 0
  %60 = call fastcc { i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f75"(i64 %23, i64 %32, i64 %19, ptr %20, { { {} }, { { ptr, i32, i32, i32 } } } %57, { { ptr, i32, i32, i32 } } %59)
  %61 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %60, 0
  %62 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %60, 1
  %63 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %60, 2
  %64 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %60, 3
  %65 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %60, 4
  store { i128, [32 x i8] } %65, ptr %14, align 16
  %66 = load i1, ptr %14, align 1
  switch i1 %66, label %67 [
    i1 false, label %69
    i1 true, label %133
  ]

67:                                               ; preds = %42
  br i1 false, label %68, label %211

68:                                               ; preds = %67
  unreachable

69:                                               ; preds = %42
  %70 = load { i1, { i252 } }, ptr %14, align 16
  %71 = extractvalue { i1, { i252 } } %70, 1
  %72 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %73 = call ptr %72()
  %74 = call i64 @llvm.uadd.sat.i64(i64 %62, i64 0)
  %75 = extractvalue { i252 } %71, 0
  %76 = extractvalue { ptr, i32, i32, i32 } %22, 3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %78, label %92

78:                                               ; preds = %69
  %79 = shl i32 %76, 1
  %80 = call i32 @llvm.umin.i32(i32 %79, i32 1024)
  %81 = add i32 %80, %76
  %82 = call i32 @llvm.umax.i32(i32 %81, i32 8)
  %83 = zext i32 %82 to i64
  %84 = mul i64 %83, 32
  %85 = add i64 %84, 16
  %86 = call ptr @realloc(ptr null, i64 %85)
  store i32 1, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %86, i32 4
  store i32 0, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %86, i32 16
  %89 = call ptr @realloc(ptr null, i64 8)
  store ptr %88, ptr %89, align 8
  %90 = insertvalue { ptr, i32, i32, i32 } %22, ptr %89, 0
  %91 = insertvalue { ptr, i32, i32, i32 } %90, i32 %82, 3
  br label %113

92:                                               ; preds = %69
  %93 = extractvalue { ptr, i32, i32, i32 } %22, 2
  %94 = icmp ult i32 %93, %76
  br i1 %94, label %95, label %96

95:                                               ; preds = %92
  br label %110

96:                                               ; preds = %92
  %97 = shl i32 %76, 1
  %98 = call i32 @llvm.umin.i32(i32 %97, i32 1024)
  %99 = add i32 %98, %76
  %100 = call i32 @llvm.umax.i32(i32 %99, i32 8)
  %101 = zext i32 %100 to i64
  %102 = mul i64 %101, 32
  %103 = add i64 %102, 16
  %104 = extractvalue { ptr, i32, i32, i32 } %22, 0
  %105 = load ptr, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %105, i32 -16
  %107 = call ptr @realloc(ptr %106, i64 %103)
  %108 = getelementptr inbounds i8, ptr %107, i32 16
  store ptr %108, ptr %104, align 8
  %109 = insertvalue { ptr, i32, i32, i32 } %22, i32 %100, 3
  br label %110

110:                                              ; preds = %95, %96
  %111 = phi { ptr, i32, i32, i32 } [ %109, %96 ], [ %22, %95 ]
  br label %112

112:                                              ; preds = %110
  br label %113

113:                                              ; preds = %78, %112
  %114 = phi { ptr, i32, i32, i32 } [ %111, %112 ], [ %91, %78 ]
  br label %115

115:                                              ; preds = %113
  %116 = extractvalue { ptr, i32, i32, i32 } %114, 0
  %117 = load ptr, ptr %116, align 8
  %118 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %119 = zext i32 %118 to i64
  %120 = mul i64 %119, 32
  %121 = getelementptr inbounds i8, ptr %117, i64 %120
  store i252 %75, ptr %121, align 16
  %122 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %123 = add i32 %122, 1
  %124 = insertvalue { ptr, i32, i32, i32 } %114, i32 %123, 2
  %125 = getelementptr inbounds i8, ptr %117, i32 -12
  store i32 %123, ptr %125, align 4
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %49, 0
  %127 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %126, 0
  %128 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %127, { { {} }, { { ptr, i32, i32, i32 } } } %56, 1
  %129 = extractvalue { ptr, ptr, i64 } %10, 1
  %130 = load i64, ptr %129, align 8
  %131 = add i64 %130, 1
  %132 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %131, ptr %132, align 8
  br label %16

133:                                              ; preds = %42
  %134 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %135 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %134, 1
  call void @"drop$284"({ ptr, i32, i32, i32 } %49)
  call void @"drop$450"({ { {} }, { { ptr, i32, i32, i32 } } } %56)
  call void @"drop$2"({ ptr, i32, i32, i32 } %22)
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %15, align 8
  %137 = load { i64, [72 x i8] }, ptr %15, align 8
  %138 = extractvalue { ptr, ptr, i64 } %10, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %160, label %143

143:                                              ; preds = %143, %133, %166, %194
  %144 = phi i64 [ %23, %194 ], [ %23, %166 ], [ %144, %143 ], [ %61, %133 ]
  %145 = phi i64 [ %18, %194 ], [ %175, %166 ], [ %145, %143 ], [ %62, %133 ]
  %146 = phi i64 [ %19, %194 ], [ %19, %166 ], [ %146, %143 ], [ %63, %133 ]
  %147 = phi ptr [ %20, %194 ], [ %20, %166 ], [ %147, %143 ], [ %64, %133 ]
  %148 = phi { i64, [72 x i8] } [ %199, %194 ], [ %182, %166 ], [ %148, %143 ], [ %137, %133 ]
  %149 = extractvalue { ptr, ptr, i64 } %10, 1
  %150 = load i64, ptr %149, align 8
  %151 = icmp eq i64 %150, 0
  %152 = sub i64 %150, 1
  %153 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %152, ptr %153, align 8
  br i1 %151, label %154, label %143

154:                                              ; preds = %143
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %144, 0
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %155, i64 %145, 1
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %156, i64 %146, 2
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %157, ptr %147, 3
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %158, { i64, [72 x i8] } %148, 4
  ret { i64, i64, i64, ptr, { i64, [72 x i8] } } %159

160:                                              ; preds = %133
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %61, 0
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %161, i64 %62, 1
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %162, i64 %63, 2
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %163, ptr %64, 3
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %164, { i64, [72 x i8] } %137, 4
  ret { i64, i64, i64, ptr, { i64, [72 x i8] } } %165

166:                                              ; preds = %33
  %167 = phi i64 [ %32, %33 ]
  %168 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %169 = call ptr %168()
  %170 = getelementptr inbounds i64, ptr %169, i32 1
  %171 = load i64, ptr %170, align 8
  %172 = load i64, ptr %169, align 8
  %173 = mul i64 %172, 22580
  %174 = add i64 %171, %173
  %175 = call i64 @llvm.uadd.sat.i64(i64 %167, i64 %174)
  %176 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %37, 0
  %177 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } undef, { { ptr, i32, i32, i32 } } %176, 0
  %178 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %177, { { {} }, { { ptr, i32, i32, i32 } } } %36, 1
  %179 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %178, 0
  %180 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %179, { ptr, i32, i32, i32 } %22, 1
  %181 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } %180, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } }, { ptr, i32, i32, i32 }, {} } } %181, ptr %13, align 8
  %182 = load { i64, [72 x i8] }, ptr %13, align 8
  %183 = extractvalue { ptr, ptr, i64 } %10, 1
  %184 = load i64, ptr %183, align 8
  %185 = icmp eq i64 %184, 0
  %186 = sub i64 %184, 1
  %187 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %186, ptr %187, align 8
  br i1 %185, label %188, label %143

188:                                              ; preds = %166
  %189 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %23, 0
  %190 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %189, i64 %175, 1
  %191 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %190, i64 %19, 2
  %192 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %191, ptr %20, 3
  %193 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %192, { i64, [72 x i8] } %182, 4
  ret { i64, i64, i64, ptr, { i64, [72 x i8] } } %193

194:                                              ; preds = %16
  %195 = phi { ptr, i32, i32, i32 } [ %22, %16 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %195)
  call void @"drop$451"({ { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %21)
  %196 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %197 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %196, 0
  %198 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %197, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %198, ptr %12, align 8
  %199 = load { i64, [72 x i8] }, ptr %12, align 8
  %200 = extractvalue { ptr, ptr, i64 } %10, 1
  %201 = load i64, ptr %200, align 8
  %202 = icmp eq i64 %201, 0
  %203 = sub i64 %201, 1
  %204 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %203, ptr %204, align 8
  br i1 %202, label %205, label %143

205:                                              ; preds = %194
  %206 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %23, 0
  %207 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %206, i64 %18, 1
  %208 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %207, i64 %19, 2
  %209 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %208, ptr %20, 3
  %210 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %209, { i64, [72 x i8] } %199, 4
  ret { i64, i64, i64, ptr, { i64, [72 x i8] } } %210

211:                                              ; preds = %67
  call void @puts(ptr @assert_msg_96)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [72 x i8] } } @f49(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [72 x i8] } } @"impl$f49"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %4, { ptr, i32, i32, i32 } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [72 x i8] } } %16, { i64, [72 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [72 x i8] } } %17
}

define void @_mlir_ciface_f49(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [72 x i8] } } @f49(i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, { { ptr, i32, i32, i32 } } } } %5, { ptr, i32, i32, i32 } %6)
  store { i64, i64, i64, ptr, { i64, [72 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$354"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %0, 0
  call void @"drop$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } @"dup$354"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } @"dup$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %0, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %6, { i128, [32 x i8] } %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %7, { i128, [32 x i8] } %8, 1
  %11 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } undef, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %9, 0
  %12 = insertvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %11, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %10, 1
  ret { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %12
}

define private void @"drop$355"({ i128, [112 x i8] } %0) {
  %2 = alloca { i128, [112 x i8] }, i64 1, align 16
  store { i128, [112 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %5, 1
  call void @"drop$354"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [112 x i8] }, { i128, [112 x i8] } } @"dup$355"({ i128, [112 x i8] } %0) {
  %2 = alloca { i128, [112 x i8] }, i64 1, align 16
  store { i128, [112 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } @"dup$354"({ { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [112 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %5, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [112 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } undef, { i128, [112 x i8] } %11, 0
  %15 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } %14, { i128, [112 x i8] } %13, 1
  ret { { i128, [112 x i8] }, { i128, [112 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [112 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [112 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } undef, { i128, [112 x i8] } %23, 0
  %27 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } %26, { i128, [112 x i8] } %25, 1
  ret { { i128, [112 x i8] }, { i128, [112 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i128, [96 x i8] } } @"impl$f50"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, { ptr, i32, i32, i32 } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i128, [96 x i8] }, i64 1, align 16
  %13 = alloca { i128, [112 x i8] }, i64 1, align 16
  %14 = alloca { i128, [96 x i8] }, i64 1, align 16
  %15 = alloca { i128, [32 x i8] }, i64 1, align 16
  %16 = alloca { i128, [96 x i8] }, i64 1, align 16
  br label %17

17:                                               ; preds = %108, %6
  %18 = phi i64 [ %37, %108 ], [ %0, %6 ]
  %19 = phi i64 [ %68, %108 ], [ %1, %6 ]
  %20 = phi i64 [ %39, %108 ], [ %2, %6 ]
  %21 = phi ptr [ %40, %108 ], [ %3, %6 ]
  %22 = phi { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } [ %48, %108 ], [ %4, %6 ]
  %23 = phi { ptr, i32, i32, i32 } [ %117, %108 ], [ %5, %6 ]
  %24 = add i64 %18, 1
  %25 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %26 = call ptr %25()
  %27 = getelementptr inbounds i64, ptr %26, i32 1
  %28 = load i64, ptr %27, align 8
  %29 = load i64, ptr %26, align 8
  %30 = mul i64 %29, 18190
  %31 = add i64 %28, %30
  %32 = icmp uge i64 %19, %31
  %33 = call i64 @llvm.usub.sat.i64(i64 %19, i64 %31)
  br i1 %32, label %34, label %167

34:                                               ; preds = %17
  %35 = phi i64 [ %24, %17 ]
  %36 = call fastcc { i64, i64, i64, ptr, { i128, [112 x i8] } } @"impl$f76"(i64 %35, i64 %33, i64 %20, ptr %21, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %22)
  %37 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %36, 0
  %38 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %36, 1
  %39 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %36, 2
  %40 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %36, 3
  %41 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %36, 4
  store { i128, [112 x i8] } %41, ptr %13, align 16
  %42 = load i1, ptr %13, align 1
  switch i1 %42, label %43 [
    i1 false, label %45
    i1 true, label %51
  ]

43:                                               ; preds = %34
  br i1 false, label %44, label %184

44:                                               ; preds = %43
  unreachable

45:                                               ; preds = %34
  %46 = load { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } }, ptr %13, align 16
  %47 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %46, 1
  %48 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %47, 0
  %49 = extractvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %47, 1
  store { i128, [32 x i8] } %49, ptr %15, align 16
  %50 = load i1, ptr %15, align 1
  switch i1 %50, label %61 [
    i1 false, label %63
    i1 true, label %123
  ]

51:                                               ; preds = %34
  %52 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %53 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %52, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %23)
  %54 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %53, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %54, ptr %14, align 8
  %55 = load { i128, [96 x i8] }, ptr %14, align 16
  %56 = extractvalue { ptr, ptr, i64 } %10, 1
  %57 = load i64, ptr %56, align 8
  %58 = icmp eq i64 %57, 0
  %59 = sub i64 %57, 1
  %60 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %59, ptr %60, align 8
  br i1 %58, label %161, label %138

61:                                               ; preds = %45
  br i1 false, label %62, label %185

62:                                               ; preds = %61
  unreachable

63:                                               ; preds = %45
  %64 = load { i1, i252 }, ptr %15, align 16
  %65 = extractvalue { i1, i252 } %64, 1
  %66 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %67 = call ptr %66()
  %68 = call i64 @llvm.uadd.sat.i64(i64 %38, i64 0)
  %69 = extractvalue { ptr, i32, i32, i32 } %23, 3
  %70 = icmp eq i32 %69, 0
  br i1 %70, label %71, label %85

71:                                               ; preds = %63
  %72 = shl i32 %69, 1
  %73 = call i32 @llvm.umin.i32(i32 %72, i32 1024)
  %74 = add i32 %73, %69
  %75 = call i32 @llvm.umax.i32(i32 %74, i32 8)
  %76 = zext i32 %75 to i64
  %77 = mul i64 %76, 32
  %78 = add i64 %77, 16
  %79 = call ptr @realloc(ptr null, i64 %78)
  store i32 1, ptr %79, align 4
  %80 = getelementptr inbounds i8, ptr %79, i32 4
  store i32 0, ptr %80, align 4
  %81 = getelementptr inbounds i8, ptr %79, i32 16
  %82 = call ptr @realloc(ptr null, i64 8)
  store ptr %81, ptr %82, align 8
  %83 = insertvalue { ptr, i32, i32, i32 } %23, ptr %82, 0
  %84 = insertvalue { ptr, i32, i32, i32 } %83, i32 %75, 3
  br label %106

85:                                               ; preds = %63
  %86 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %87 = icmp ult i32 %86, %69
  br i1 %87, label %88, label %89

88:                                               ; preds = %85
  br label %103

89:                                               ; preds = %85
  %90 = shl i32 %69, 1
  %91 = call i32 @llvm.umin.i32(i32 %90, i32 1024)
  %92 = add i32 %91, %69
  %93 = call i32 @llvm.umax.i32(i32 %92, i32 8)
  %94 = zext i32 %93 to i64
  %95 = mul i64 %94, 32
  %96 = add i64 %95, 16
  %97 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr inbounds i8, ptr %98, i32 -16
  %100 = call ptr @realloc(ptr %99, i64 %96)
  %101 = getelementptr inbounds i8, ptr %100, i32 16
  store ptr %101, ptr %97, align 8
  %102 = insertvalue { ptr, i32, i32, i32 } %23, i32 %93, 3
  br label %103

103:                                              ; preds = %88, %89
  %104 = phi { ptr, i32, i32, i32 } [ %102, %89 ], [ %23, %88 ]
  br label %105

105:                                              ; preds = %103
  br label %106

106:                                              ; preds = %71, %105
  %107 = phi { ptr, i32, i32, i32 } [ %104, %105 ], [ %84, %71 ]
  br label %108

108:                                              ; preds = %106
  %109 = extractvalue { ptr, i32, i32, i32 } %107, 0
  %110 = load ptr, ptr %109, align 8
  %111 = extractvalue { ptr, i32, i32, i32 } %107, 2
  %112 = zext i32 %111 to i64
  %113 = mul i64 %112, 32
  %114 = getelementptr inbounds i8, ptr %110, i64 %113
  store i252 %65, ptr %114, align 16
  %115 = extractvalue { ptr, i32, i32, i32 } %107, 2
  %116 = add i32 %115, 1
  %117 = insertvalue { ptr, i32, i32, i32 } %107, i32 %116, 2
  %118 = getelementptr inbounds i8, ptr %110, i32 -12
  store i32 %116, ptr %118, align 4
  %119 = extractvalue { ptr, ptr, i64 } %10, 1
  %120 = load i64, ptr %119, align 8
  %121 = add i64 %120, 1
  %122 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %121, ptr %122, align 8
  br label %17

123:                                              ; preds = %45
  %124 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %125 = call ptr %124()
  %126 = load i64, ptr %125, align 8
  %127 = mul i64 %126, 3270
  %128 = call i64 @llvm.uadd.sat.i64(i64 %38, i64 %127)
  %129 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %48, 0
  %130 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %129, { ptr, i32, i32, i32 } %23, 1
  %131 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } %130, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { ptr, i32, i32, i32 }, {} } } %131, ptr %16, align 16
  %132 = load { i128, [96 x i8] }, ptr %16, align 16
  %133 = extractvalue { ptr, ptr, i64 } %10, 1
  %134 = load i64, ptr %133, align 8
  %135 = icmp eq i64 %134, 0
  %136 = sub i64 %134, 1
  %137 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %136, ptr %137, align 8
  br i1 %135, label %155, label %138

138:                                              ; preds = %138, %123, %51, %167
  %139 = phi i64 [ %24, %167 ], [ %139, %138 ], [ %37, %123 ], [ %37, %51 ]
  %140 = phi i64 [ %19, %167 ], [ %140, %138 ], [ %128, %123 ], [ %38, %51 ]
  %141 = phi i64 [ %20, %167 ], [ %141, %138 ], [ %39, %123 ], [ %39, %51 ]
  %142 = phi ptr [ %21, %167 ], [ %142, %138 ], [ %40, %123 ], [ %40, %51 ]
  %143 = phi { i128, [96 x i8] } [ %172, %167 ], [ %143, %138 ], [ %132, %123 ], [ %55, %51 ]
  %144 = extractvalue { ptr, ptr, i64 } %10, 1
  %145 = load i64, ptr %144, align 8
  %146 = icmp eq i64 %145, 0
  %147 = sub i64 %145, 1
  %148 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %147, ptr %148, align 8
  br i1 %146, label %149, label %138

149:                                              ; preds = %138
  %150 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } undef, i64 %139, 0
  %151 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %150, i64 %140, 1
  %152 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %151, i64 %141, 2
  %153 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %152, ptr %142, 3
  %154 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %153, { i128, [96 x i8] } %143, 4
  ret { i64, i64, i64, ptr, { i128, [96 x i8] } } %154

155:                                              ; preds = %123
  %156 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } undef, i64 %37, 0
  %157 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %156, i64 %128, 1
  %158 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %157, i64 %39, 2
  %159 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %158, ptr %40, 3
  %160 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %159, { i128, [96 x i8] } %132, 4
  ret { i64, i64, i64, ptr, { i128, [96 x i8] } } %160

161:                                              ; preds = %51
  %162 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } undef, i64 %37, 0
  %163 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %162, i64 %38, 1
  %164 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %163, i64 %39, 2
  %165 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %164, ptr %40, 3
  %166 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %165, { i128, [96 x i8] } %55, 4
  ret { i64, i64, i64, ptr, { i128, [96 x i8] } } %166

167:                                              ; preds = %17
  %168 = phi { ptr, i32, i32, i32 } [ %23, %17 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %168)
  call void @"drop$353"({ { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %22)
  %169 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %170 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %169, 0
  %171 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %170, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %171, ptr %12, align 8
  %172 = load { i128, [96 x i8] }, ptr %12, align 16
  %173 = extractvalue { ptr, ptr, i64 } %10, 1
  %174 = load i64, ptr %173, align 8
  %175 = icmp eq i64 %174, 0
  %176 = sub i64 %174, 1
  %177 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %176, ptr %177, align 8
  br i1 %175, label %178, label %138

178:                                              ; preds = %167
  %179 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } undef, i64 %24, 0
  %180 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %179, i64 %19, 1
  %181 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %180, i64 %20, 2
  %182 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %181, ptr %21, 3
  %183 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %182, { i128, [96 x i8] } %172, 4
  ret { i64, i64, i64, ptr, { i128, [96 x i8] } } %183

184:                                              ; preds = %43
  call void @puts(ptr @assert_msg_97)
  call void @abort()
  unreachable

185:                                              ; preds = %61
  call void @puts(ptr @assert_msg_98)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i128, [96 x i8] } } @f50(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i128, [96 x i8] } } @"impl$f50"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, { ptr, i32, i32, i32 } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i128, [96 x i8] } } %16, { i128, [96 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i128, [96 x i8] } } %17
}

define void @_mlir_ciface_f50(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call { i64, i64, i64, ptr, { i128, [96 x i8] } } @f50(i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %5, { ptr, i32, i32, i32 } %6)
  store { i64, i64, i64, ptr, { i128, [96 x i8] } } %8, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, { i128, [96 x i8] } } @"impl$f51"(i64 %0, i64 %1, i252 %2, { { { ptr, i32, i32, i32 }, i252, i32 } } %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = alloca { i128, [96 x i8] }, i64 1, align 16
  %7 = alloca { i128, [96 x i8] }, i64 1, align 16
  %8 = alloca { i128, [96 x i8] }, i64 1, align 16
  %9 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %10 = trunc i252 %2 to i128
  %11 = lshr i252 %2, 128
  %12 = trunc i252 %11 to i128
  %13 = icmp ne i128 %12, 0
  %14 = add i64 %0, 3
  %15 = add i64 %0, 1
  %16 = select i1 %13, i64 %14, i64 %15
  br i1 %13, label %24, label %17

17:                                               ; preds = %4
  %18 = phi i64 [ %1, %4 ]
  %19 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %20 = call ptr %19()
  %21 = load i64, ptr %20, align 8
  %22 = mul i64 %21, 940
  %23 = call i64 @llvm.uadd.sat.i64(i64 %18, i64 %22)
  br label %29

24:                                               ; preds = %4
  %25 = phi i64 [ %1, %4 ]
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 0)
  br label %29

29:                                               ; preds = %24, %17
  %30 = phi i252 [ 10, %24 ], [ 10, %17 ]
  %31 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %9, %24 ], [ %9, %17 ]
  %32 = phi i64 [ %16, %24 ], [ %16, %17 ]
  %33 = phi i64 [ %28, %24 ], [ %23, %17 ]
  %34 = phi i128 [ %10, %24 ], [ %10, %17 ]
  %35 = phi i128 [ %12, %24 ], [ 0, %17 ]
  %36 = insertvalue { i128, i128 } undef, i128 %34, 0
  %37 = insertvalue { i128, i128 } %36, i128 %35, 1
  %38 = trunc i252 %30 to i128
  %39 = lshr i252 %30, 128
  %40 = trunc i252 %39 to i128
  %41 = icmp ne i128 %40, 0
  %42 = add i64 %32, 3
  %43 = add i64 %32, 1
  %44 = select i1 %41, i64 %42, i64 %43
  br i1 %41, label %52, label %45

45:                                               ; preds = %29
  %46 = phi i64 [ %33, %29 ]
  %47 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %48 = call ptr %47()
  %49 = load i64, ptr %48, align 8
  %50 = mul i64 %49, 790
  %51 = call i64 @llvm.uadd.sat.i64(i64 %46, i64 %50)
  br label %57

52:                                               ; preds = %29
  %53 = phi i64 [ %33, %29 ]
  %54 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %55 = call ptr %54()
  %56 = call i64 @llvm.uadd.sat.i64(i64 %53, i64 0)
  br label %57

57:                                               ; preds = %52, %45
  %58 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %31, %52 ], [ %31, %45 ]
  %59 = phi { i128, i128 } [ %37, %52 ], [ %37, %45 ]
  %60 = phi i64 [ %44, %52 ], [ %44, %45 ]
  %61 = phi i64 [ %56, %52 ], [ %51, %45 ]
  %62 = phi i128 [ %38, %52 ], [ %38, %45 ]
  %63 = phi i128 [ %40, %52 ], [ 0, %45 ]
  %64 = insertvalue { i128, i128 } undef, i128 %62, 0
  %65 = insertvalue { i128, i128 } %64, i128 %63, 1
  %66 = icmp eq i128 %62, 0
  %67 = icmp eq i128 %63, 0
  %68 = and i1 %66, %67
  br i1 %68, label %69, label %78

69:                                               ; preds = %57
  %70 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %58, %57 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %70)
  %71 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %72 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %71, 0
  %73 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %72, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %73, ptr %8, align 8
  %74 = load { i128, [96 x i8] }, ptr %8, align 16
  %75 = insertvalue { i64, i64, { i128, [96 x i8] } } undef, i64 %60, 0
  %76 = insertvalue { i64, i64, { i128, [96 x i8] } } %75, i64 %61, 1
  %77 = insertvalue { i64, i64, { i128, [96 x i8] } } %76, { i128, [96 x i8] } %74, 2
  ret { i64, i64, { i128, [96 x i8] } } %77

78:                                               ; preds = %57
  %79 = phi { i128, i128 } [ %59, %57 ]
  %80 = call fastcc { i64, i64, { i128, [80 x i8] } } @"impl$f78"(i64 %60, i64 %61, { i128, i128 } %79, { { ptr, i32, i32, i32 }, i252, i32 } %58, { i128, i128 } %65)
  %81 = extractvalue { i64, i64, { i128, [80 x i8] } } %80, 0
  %82 = extractvalue { i64, i64, { i128, [80 x i8] } } %80, 1
  %83 = extractvalue { i64, i64, { i128, [80 x i8] } } %80, 2
  store { i128, [80 x i8] } %83, ptr %5, align 16
  %84 = load i1, ptr %5, align 1
  switch i1 %84, label %85 [
    i1 false, label %87
    i1 true, label %102
  ]

85:                                               ; preds = %78
  br i1 false, label %86, label %110

86:                                               ; preds = %85
  unreachable

87:                                               ; preds = %78
  %88 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %5, align 16
  %89 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %88, 1
  %90 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %91 = call ptr %90()
  %92 = call i64 @llvm.uadd.sat.i64(i64 %82, i64 0)
  %93 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %89, 0
  %94 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %93, 0
  %95 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } undef, { { { ptr, i32, i32, i32 }, i252, i32 } } %94, 0
  %96 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %95, { i1, [0 x i8] } { i1 false, [0 x i8] undef }, 1
  %97 = insertvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } { i1 false, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } undef }, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } %96, 1
  store { i1, { { { { ptr, i32, i32, i32 }, i252, i32 } }, { i1, [0 x i8] } } } %97, ptr %7, align 16
  %98 = load { i128, [96 x i8] }, ptr %7, align 16
  %99 = insertvalue { i64, i64, { i128, [96 x i8] } } undef, i64 %81, 0
  %100 = insertvalue { i64, i64, { i128, [96 x i8] } } %99, i64 %92, 1
  %101 = insertvalue { i64, i64, { i128, [96 x i8] } } %100, { i128, [96 x i8] } %98, 2
  ret { i64, i64, { i128, [96 x i8] } } %101

102:                                              ; preds = %78
  %103 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %104 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %103, 1
  %105 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %104, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %105, ptr %6, align 8
  %106 = load { i128, [96 x i8] }, ptr %6, align 16
  %107 = insertvalue { i64, i64, { i128, [96 x i8] } } undef, i64 %81, 0
  %108 = insertvalue { i64, i64, { i128, [96 x i8] } } %107, i64 %82, 1
  %109 = insertvalue { i64, i64, { i128, [96 x i8] } } %108, { i128, [96 x i8] } %106, 2
  ret { i64, i64, { i128, [96 x i8] } } %109

110:                                              ; preds = %85
  call void @puts(ptr @assert_msg_99)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [96 x i8] } } @f51(i64 %0, i64 %1, i252 %2, { { { ptr, i32, i32, i32 }, i252, i32 } } %3) {
  %5 = call fastcc { i64, i64, { i128, [96 x i8] } } @"impl$f51"(i64 %0, i64 %1, i252 %2, { { { ptr, i32, i32, i32 }, i252, i32 } } %3)
  %6 = extractvalue { i64, i64, { i128, [96 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i128, [96 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i128, [96 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i128, [96 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i128, [96 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i128, [96 x i8] } } %10, { i128, [96 x i8] } %8, 2
  ret { i64, i64, { i128, [96 x i8] } } %11
}

define void @_mlir_ciface_f51(ptr %0, i64 %1, i64 %2, i252 %3, { { { ptr, i32, i32, i32 }, i252, i32 } } %4) {
  %6 = call { i64, i64, { i128, [96 x i8] } } @f51(i64 %1, i64 %2, i252 %3, { { { ptr, i32, i32, i32 }, i252, i32 } } %4)
  store { i64, i64, { i128, [96 x i8] } } %6, ptr %0, align 16
  ret void
}

define private void @"drop$344"({ i128, [16 x i8] } %0) {
  %2 = alloca { i128, [16 x i8] }, i64 1, align 16
  store { i128, [16 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [16 x i8] }, { i128, [16 x i8] } } @"dup$344"({ i128, [16 x i8] } %0) {
  %2 = alloca { i128, [16 x i8] }, i64 1, align 16
  store { i128, [16 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i128 } }, ptr %2, align 16
  %6 = extractvalue { i1, { i128 } } %5, 1
  %7 = insertvalue { i1, { i128 } } %5, { i128 } %6, 1
  store { i1, { i128 } } %7, ptr %2, align 16
  %8 = load { i128, [16 x i8] }, ptr %2, align 16
  %9 = insertvalue { i1, { i128 } } %5, { i128 } %6, 1
  store { i1, { i128 } } %9, ptr %2, align 16
  %10 = load { i128, [16 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } undef, { i128, [16 x i8] } %8, 0
  %12 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } %11, { i128, [16 x i8] } %10, 1
  ret { { i128, [16 x i8] }, { i128, [16 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i128, [16 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i128, [16 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } undef, { i128, [16 x i8] } %20, 0
  %24 = insertvalue { { i128, [16 x i8] }, { i128, [16 x i8] } } %23, { i128, [16 x i8] } %22, 1
  ret { { i128, [16 x i8] }, { i128, [16 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, { i128, [80 x i8] } } @"impl$f52"(i64 %0, { { ptr, i32, i32, i32 }, i252, i32 } %1, i252 %2, i32 %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = alloca { i128, [16 x i8] }, i64 1, align 16
  %7 = alloca { i128, [80 x i8] }, i64 1, align 16
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [16 x i8] }, i64 1, align 16
  %10 = alloca { i128, [80 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [16 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i128, [48 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = alloca { i128, [80 x i8] }, i64 1, align 16
  %17 = alloca { i128, [80 x i8] }, i64 1, align 16
  %18 = alloca { i128, [16 x i8] }, i64 1, align 16
  %19 = alloca { i128, [80 x i8] }, i64 1, align 16
  %20 = alloca { i128, [80 x i8] }, i64 1, align 16
  %21 = icmp eq i32 %3, 0
  br i1 %21, label %22, label %29

22:                                               ; preds = %4
  %23 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %1, %4 ]
  %24 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %23, 0
  %25 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %24, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %25, ptr %20, align 16
  %26 = load { i128, [80 x i8] }, ptr %20, align 16
  %27 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %0, 0
  %28 = insertvalue { i64, { i128, [80 x i8] } } %27, { i128, [80 x i8] } %26, 1
  ret { i64, { i128, [80 x i8] } } %28

29:                                               ; preds = %4
  %30 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %1, %4 ]
  %31 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %30, 0
  %32 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %30, 1
  %33 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %30, 2
  %34 = add i64 %0, 1
  %35 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %33, i32 %3)
  %36 = extractvalue { i32, i1 } %35, 0
  %37 = extractvalue { i32, i1 } %35, 1
  br i1 %37, label %443, label %38

38:                                               ; preds = %29
  %39 = phi i32 [ %36, %29 ]
  %40 = add i64 %0, 2
  %41 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %39, i32 31)
  %42 = extractvalue { i32, i1 } %41, 0
  %43 = extractvalue { i32, i1 } %41, 1
  br i1 %43, label %363, label %44

44:                                               ; preds = %38
  %45 = phi i64 [ %40, %38 ]
  %46 = phi i32 [ 31, %38 ]
  %47 = phi i32 [ %33, %38 ]
  %48 = add i64 %45, 1
  %49 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %46, i32 %47)
  %50 = extractvalue { i32, i1 } %49, 0
  %51 = extractvalue { i32, i1 } %49, 1
  br i1 %51, label %355, label %52

52:                                               ; preds = %44
  %53 = phi i32 [ %50, %44 ]
  %54 = add i64 %45, 2
  %55 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %53, i32 16)
  %56 = extractvalue { i32, i1 } %55, 0
  %57 = extractvalue { i32, i1 } %55, 1
  br i1 %57, label %83, label %58

58:                                               ; preds = %52
  %59 = phi i64 [ %54, %52 ]
  %60 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f79"(i64 %59, i32 %56)
  %61 = extractvalue { i64, { i128, [16 x i8] } } %60, 0
  %62 = extractvalue { i64, { i128, [16 x i8] } } %60, 1
  store { i128, [16 x i8] } %62, ptr %18, align 16
  %63 = load i1, ptr %18, align 1
  switch i1 %63, label %64 [
    i1 false, label %66
    i1 true, label %76
  ]

64:                                               ; preds = %58
  br i1 false, label %65, label %455

65:                                               ; preds = %64
  unreachable

66:                                               ; preds = %58
  %67 = load { i1, { i128 } }, ptr %18, align 16
  %68 = extractvalue { i1, { i128 } } %67, 1
  %69 = extractvalue { i128 } %68, 0
  %70 = zext i128 %69 to i512
  %71 = mul i512 %70, 340282366920938463463374607431768211456
  %72 = urem i512 %71, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %73 = icmp uge i512 %71, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %74 = select i1 %73, i512 %72, i512 %71
  %75 = trunc i512 %74 to i252
  br label %103

76:                                               ; preds = %58
  %77 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %78 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %77, 1
  call void @"drop$42"({ ptr, i32, i32, i32 } %31)
  %79 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %78, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %79, ptr %19, align 8
  %80 = load { i128, [80 x i8] }, ptr %19, align 16
  %81 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %61, 0
  %82 = insertvalue { i64, { i128, [80 x i8] } } %81, { i128, [80 x i8] } %80, 1
  ret { i64, { i128, [80 x i8] } } %82

83:                                               ; preds = %52
  %84 = phi i64 [ %54, %52 ]
  %85 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f79"(i64 %84, i32 %53)
  %86 = extractvalue { i64, { i128, [16 x i8] } } %85, 0
  %87 = extractvalue { i64, { i128, [16 x i8] } } %85, 1
  store { i128, [16 x i8] } %87, ptr %12, align 16
  %88 = load i1, ptr %12, align 1
  switch i1 %88, label %89 [
    i1 false, label %91
    i1 true, label %96
  ]

89:                                               ; preds = %83
  br i1 false, label %90, label %453

90:                                               ; preds = %89
  unreachable

91:                                               ; preds = %83
  %92 = load { i1, { i128 } }, ptr %12, align 16
  %93 = extractvalue { i1, { i128 } } %92, 1
  %94 = extractvalue { i128 } %93, 0
  %95 = zext i128 %94 to i252
  br label %103

96:                                               ; preds = %83
  %97 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %98 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %97, 1
  call void @"drop$42"({ ptr, i32, i32, i32 } %31)
  %99 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %98, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %99, ptr %13, align 8
  %100 = load { i128, [80 x i8] }, ptr %13, align 16
  %101 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %86, 0
  %102 = insertvalue { i64, { i128, [80 x i8] } } %101, { i128, [80 x i8] } %100, 1
  ret { i64, { i128, [80 x i8] } } %102

103:                                              ; preds = %91, %66
  %104 = phi i252 [ %2, %91 ], [ %2, %66 ]
  %105 = phi { ptr, i32, i32, i32 } [ %31, %91 ], [ %31, %66 ]
  %106 = phi i252 [ %32, %91 ], [ %32, %66 ]
  %107 = phi i32 [ %42, %91 ], [ %42, %66 ]
  %108 = phi i64 [ %86, %91 ], [ %61, %66 ]
  %109 = phi i252 [ %95, %91 ], [ %75, %66 ]
  %110 = icmp eq i32 %107, 0
  br i1 %110, label %111, label %195

111:                                              ; preds = %103
  %112 = phi i252 [ %106, %103 ]
  %113 = phi i252 [ %109, %103 ]
  %114 = zext i252 %112 to i512
  %115 = zext i252 %113 to i512
  %116 = mul i512 %114, %115
  %117 = urem i512 %116, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %118 = icmp uge i512 %116, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %119 = select i1 %118, i512 %117, i512 %116
  %120 = trunc i512 %119 to i252
  %121 = zext i252 %104 to i256
  %122 = zext i252 %120 to i256
  %123 = add i256 %121, %122
  %124 = sub i256 %123, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %125 = icmp uge i256 %123, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %126 = select i1 %125, i256 %124, i256 %123
  %127 = trunc i256 %126 to i252
  %128 = add i64 %108, 3
  %129 = icmp ule i252 %127, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %129, label %130, label %132

130:                                              ; preds = %111
  %131 = trunc i256 %126 to i248
  br label %132

132:                                              ; preds = %130, %111
  %133 = phi { ptr, i32, i32, i32 } [ %105, %130 ], [ %105, %111 ]
  %134 = phi i252 [ 0, %130 ], [ 0, %111 ]
  %135 = phi i64 [ %128, %130 ], [ %128, %111 ]
  %136 = phi i248 [ %131, %130 ], [ 88068479653790488123916992367510505285, %111 ]
  %137 = extractvalue { ptr, i32, i32, i32 } %133, 3
  %138 = icmp eq i32 %137, 0
  br i1 %138, label %139, label %153

139:                                              ; preds = %132
  %140 = shl i32 %137, 1
  %141 = call i32 @llvm.umin.i32(i32 %140, i32 1024)
  %142 = add i32 %141, %137
  %143 = call i32 @llvm.umax.i32(i32 %142, i32 8)
  %144 = zext i32 %143 to i64
  %145 = mul i64 %144, 32
  %146 = add i64 %145, 16
  %147 = call ptr @realloc(ptr null, i64 %146)
  store i32 1, ptr %147, align 4
  %148 = getelementptr inbounds i8, ptr %147, i32 4
  store i32 0, ptr %148, align 4
  %149 = getelementptr inbounds i8, ptr %147, i32 16
  %150 = call ptr @realloc(ptr null, i64 8)
  store ptr %149, ptr %150, align 8
  %151 = insertvalue { ptr, i32, i32, i32 } %133, ptr %150, 0
  %152 = insertvalue { ptr, i32, i32, i32 } %151, i32 %143, 3
  br label %174

153:                                              ; preds = %132
  %154 = extractvalue { ptr, i32, i32, i32 } %133, 2
  %155 = icmp ult i32 %154, %137
  br i1 %155, label %156, label %157

156:                                              ; preds = %153
  br label %171

157:                                              ; preds = %153
  %158 = shl i32 %137, 1
  %159 = call i32 @llvm.umin.i32(i32 %158, i32 1024)
  %160 = add i32 %159, %137
  %161 = call i32 @llvm.umax.i32(i32 %160, i32 8)
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 32
  %164 = add i64 %163, 16
  %165 = extractvalue { ptr, i32, i32, i32 } %133, 0
  %166 = load ptr, ptr %165, align 8
  %167 = getelementptr inbounds i8, ptr %166, i32 -16
  %168 = call ptr @realloc(ptr %167, i64 %164)
  %169 = getelementptr inbounds i8, ptr %168, i32 16
  store ptr %169, ptr %165, align 8
  %170 = insertvalue { ptr, i32, i32, i32 } %133, i32 %161, 3
  br label %171

171:                                              ; preds = %156, %157
  %172 = phi { ptr, i32, i32, i32 } [ %170, %157 ], [ %133, %156 ]
  br label %173

173:                                              ; preds = %171
  br label %174

174:                                              ; preds = %139, %173
  %175 = phi { ptr, i32, i32, i32 } [ %172, %173 ], [ %152, %139 ]
  br label %176

176:                                              ; preds = %174
  %177 = extractvalue { ptr, i32, i32, i32 } %175, 0
  %178 = load ptr, ptr %177, align 8
  %179 = extractvalue { ptr, i32, i32, i32 } %175, 2
  %180 = zext i32 %179 to i64
  %181 = mul i64 %180, 32
  %182 = getelementptr inbounds i8, ptr %178, i64 %181
  store i248 %136, ptr %182, align 16
  %183 = extractvalue { ptr, i32, i32, i32 } %175, 2
  %184 = add i32 %183, 1
  %185 = insertvalue { ptr, i32, i32, i32 } %175, i32 %184, 2
  %186 = getelementptr inbounds i8, ptr %178, i32 -12
  store i32 %184, ptr %186, align 4
  %187 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %185, 0
  %188 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %187, i252 %134, 1
  %189 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %188, i32 0, 2
  %190 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %189, 0
  %191 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %190, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %191, ptr %17, align 16
  %192 = load { i128, [80 x i8] }, ptr %17, align 16
  %193 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %135, 0
  %194 = insertvalue { i64, { i128, [80 x i8] } } %193, { i128, [80 x i8] } %192, 1
  ret { i64, { i128, [80 x i8] } } %194

195:                                              ; preds = %103
  %196 = phi i64 [ %108, %103 ]
  %197 = phi i252 [ %104, %103 ]
  %198 = trunc i252 %197 to i128
  %199 = lshr i252 %197, 128
  %200 = trunc i252 %199 to i128
  %201 = icmp ne i128 %200, 0
  %202 = add i64 %196, 3
  %203 = add i64 %196, 1
  %204 = select i1 %201, i64 %202, i64 %203
  %205 = call fastcc { i64, { i128, [48 x i8] } } @"impl$f80"(i64 %204, i32 %107)
  %206 = extractvalue { i64, { i128, [48 x i8] } } %205, 0
  %207 = extractvalue { i64, { i128, [48 x i8] } } %205, 1
  store { i128, [48 x i8] } %207, ptr %14, align 16
  %208 = load i2, ptr %14, align 1
  switch i2 %208, label %209 [
    i2 0, label %211
    i2 1, label %214
    i2 -2, label %237
    i2 -1, label %258
  ]

209:                                              ; preds = %195
  br i1 false, label %210, label %454

210:                                              ; preds = %209
  unreachable

211:                                              ; preds = %195
  %212 = zext i128 %200 to i252
  %213 = zext i128 %198 to i252
  br label %265

214:                                              ; preds = %195
  %215 = load { i2, { i128, i252 } }, ptr %14, align 16
  %216 = extractvalue { i2, { i128, i252 } } %215, 1
  %217 = extractvalue { i128, i252 } %216, 0
  %218 = extractvalue { i128, i252 } %216, 1
  %219 = add i64 %206, 4
  %220 = udiv i128 %198, %217
  %221 = urem i128 %198, %217
  %222 = zext i128 %221 to i252
  %223 = zext i128 %200 to i512
  %224 = zext i252 %218 to i512
  %225 = mul i512 %223, %224
  %226 = urem i512 %225, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %227 = icmp uge i512 %225, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %228 = select i1 %227, i512 %226, i512 %225
  %229 = trunc i512 %228 to i252
  %230 = zext i252 %229 to i256
  %231 = zext i128 %220 to i256
  %232 = add i256 %230, %231
  %233 = sub i256 %232, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %234 = icmp uge i256 %232, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %235 = select i1 %234, i256 %233, i256 %232
  %236 = trunc i256 %235 to i252
  br label %265

237:                                              ; preds = %195
  %238 = load { i2, { i128 } }, ptr %14, align 16
  %239 = extractvalue { i2, { i128 } } %238, 1
  %240 = extractvalue { i128 } %239, 0
  %241 = add i64 %206, 4
  %242 = udiv i128 %200, %240
  %243 = urem i128 %200, %240
  %244 = zext i128 %242 to i252
  %245 = zext i128 %243 to i512
  %246 = mul i512 %245, 340282366920938463463374607431768211456
  %247 = urem i512 %246, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %248 = icmp uge i512 %246, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %249 = select i1 %248, i512 %247, i512 %246
  %250 = trunc i512 %249 to i252
  %251 = zext i252 %250 to i256
  %252 = zext i128 %198 to i256
  %253 = add i256 %251, %252
  %254 = sub i256 %253, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %255 = icmp uge i256 %253, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %256 = select i1 %255, i256 %254, i256 %253
  %257 = trunc i256 %256 to i252
  br label %265

258:                                              ; preds = %195
  call void @"drop$42"({ ptr, i32, i32, i32 } %105)
  %259 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f81"()
  %260 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %259, 0
  %261 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %260, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %261, ptr %15, align 8
  %262 = load { i128, [80 x i8] }, ptr %15, align 16
  %263 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %206, 0
  %264 = insertvalue { i64, { i128, [80 x i8] } } %263, { i128, [80 x i8] } %262, 1
  ret { i64, { i128, [80 x i8] } } %264

265:                                              ; preds = %211, %214, %237
  %266 = phi { ptr, i32, i32, i32 } [ %105, %237 ], [ %105, %214 ], [ %105, %211 ]
  %267 = phi i252 [ %106, %237 ], [ %106, %214 ], [ %106, %211 ]
  %268 = phi i32 [ %107, %237 ], [ %107, %214 ], [ %107, %211 ]
  %269 = phi i252 [ %109, %237 ], [ %109, %214 ], [ %109, %211 ]
  %270 = phi i64 [ %241, %237 ], [ %219, %214 ], [ %206, %211 ]
  %271 = phi i252 [ %244, %237 ], [ %236, %214 ], [ %212, %211 ]
  %272 = phi i252 [ %257, %237 ], [ %222, %214 ], [ %213, %211 ]
  %273 = zext i252 %267 to i512
  %274 = zext i252 %269 to i512
  %275 = mul i512 %273, %274
  %276 = urem i512 %275, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %277 = icmp uge i512 %275, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %278 = select i1 %277, i512 %276, i512 %275
  %279 = trunc i512 %278 to i252
  %280 = zext i252 %271 to i256
  %281 = zext i252 %279 to i256
  %282 = add i256 %280, %281
  %283 = sub i256 %282, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %284 = icmp uge i256 %282, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %285 = select i1 %284, i256 %283, i256 %282
  %286 = trunc i256 %285 to i252
  %287 = add i64 %270, 3
  %288 = icmp ule i252 %286, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %288, label %289, label %291

289:                                              ; preds = %265
  %290 = trunc i256 %285 to i248
  br label %291

291:                                              ; preds = %289, %265
  %292 = phi { ptr, i32, i32, i32 } [ %266, %289 ], [ %266, %265 ]
  %293 = phi i32 [ %268, %289 ], [ %268, %265 ]
  %294 = phi i252 [ %272, %289 ], [ %272, %265 ]
  %295 = phi i64 [ %287, %289 ], [ %287, %265 ]
  %296 = phi i248 [ %290, %289 ], [ 88068479653790488123916992367510505285, %265 ]
  %297 = extractvalue { ptr, i32, i32, i32 } %292, 3
  %298 = icmp eq i32 %297, 0
  br i1 %298, label %299, label %313

299:                                              ; preds = %291
  %300 = shl i32 %297, 1
  %301 = call i32 @llvm.umin.i32(i32 %300, i32 1024)
  %302 = add i32 %301, %297
  %303 = call i32 @llvm.umax.i32(i32 %302, i32 8)
  %304 = zext i32 %303 to i64
  %305 = mul i64 %304, 32
  %306 = add i64 %305, 16
  %307 = call ptr @realloc(ptr null, i64 %306)
  store i32 1, ptr %307, align 4
  %308 = getelementptr inbounds i8, ptr %307, i32 4
  store i32 0, ptr %308, align 4
  %309 = getelementptr inbounds i8, ptr %307, i32 16
  %310 = call ptr @realloc(ptr null, i64 8)
  store ptr %309, ptr %310, align 8
  %311 = insertvalue { ptr, i32, i32, i32 } %292, ptr %310, 0
  %312 = insertvalue { ptr, i32, i32, i32 } %311, i32 %303, 3
  br label %334

313:                                              ; preds = %291
  %314 = extractvalue { ptr, i32, i32, i32 } %292, 2
  %315 = icmp ult i32 %314, %297
  br i1 %315, label %316, label %317

316:                                              ; preds = %313
  br label %331

317:                                              ; preds = %313
  %318 = shl i32 %297, 1
  %319 = call i32 @llvm.umin.i32(i32 %318, i32 1024)
  %320 = add i32 %319, %297
  %321 = call i32 @llvm.umax.i32(i32 %320, i32 8)
  %322 = zext i32 %321 to i64
  %323 = mul i64 %322, 32
  %324 = add i64 %323, 16
  %325 = extractvalue { ptr, i32, i32, i32 } %292, 0
  %326 = load ptr, ptr %325, align 8
  %327 = getelementptr inbounds i8, ptr %326, i32 -16
  %328 = call ptr @realloc(ptr %327, i64 %324)
  %329 = getelementptr inbounds i8, ptr %328, i32 16
  store ptr %329, ptr %325, align 8
  %330 = insertvalue { ptr, i32, i32, i32 } %292, i32 %321, 3
  br label %331

331:                                              ; preds = %316, %317
  %332 = phi { ptr, i32, i32, i32 } [ %330, %317 ], [ %292, %316 ]
  br label %333

333:                                              ; preds = %331
  br label %334

334:                                              ; preds = %299, %333
  %335 = phi { ptr, i32, i32, i32 } [ %332, %333 ], [ %312, %299 ]
  br label %336

336:                                              ; preds = %334
  %337 = extractvalue { ptr, i32, i32, i32 } %335, 0
  %338 = load ptr, ptr %337, align 8
  %339 = extractvalue { ptr, i32, i32, i32 } %335, 2
  %340 = zext i32 %339 to i64
  %341 = mul i64 %340, 32
  %342 = getelementptr inbounds i8, ptr %338, i64 %341
  store i248 %296, ptr %342, align 16
  %343 = extractvalue { ptr, i32, i32, i32 } %335, 2
  %344 = add i32 %343, 1
  %345 = insertvalue { ptr, i32, i32, i32 } %335, i32 %344, 2
  %346 = getelementptr inbounds i8, ptr %338, i32 -12
  store i32 %344, ptr %346, align 4
  %347 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %345, 0
  %348 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %347, i252 %294, 1
  %349 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %348, i32 %293, 2
  %350 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %349, 0
  %351 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %350, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %351, ptr %16, align 16
  %352 = load { i128, [80 x i8] }, ptr %16, align 16
  %353 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %295, 0
  %354 = insertvalue { i64, { i128, [80 x i8] } } %353, { i128, [80 x i8] } %352, 1
  ret { i64, { i128, [80 x i8] } } %354

355:                                              ; preds = %44
  %356 = phi { ptr, i32, i32, i32 } [ %31, %44 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %356)
  %357 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f82"()
  %358 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %357, 0
  %359 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %358, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %359, ptr %11, align 8
  %360 = load { i128, [80 x i8] }, ptr %11, align 16
  %361 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %48, 0
  %362 = insertvalue { i64, { i128, [80 x i8] } } %361, { i128, [80 x i8] } %360, 1
  ret { i64, { i128, [80 x i8] } } %362

363:                                              ; preds = %38
  %364 = phi i32 [ %3, %38 ]
  %365 = add i64 %0, 3
  %366 = call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %364, i32 16)
  %367 = extractvalue { i32, i1 } %366, 0
  %368 = extractvalue { i32, i1 } %366, 1
  br i1 %368, label %394, label %369

369:                                              ; preds = %363
  %370 = phi i64 [ %365, %363 ]
  %371 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f79"(i64 %370, i32 %367)
  %372 = extractvalue { i64, { i128, [16 x i8] } } %371, 0
  %373 = extractvalue { i64, { i128, [16 x i8] } } %371, 1
  store { i128, [16 x i8] } %373, ptr %9, align 16
  %374 = load i1, ptr %9, align 1
  switch i1 %374, label %375 [
    i1 false, label %377
    i1 true, label %387
  ]

375:                                              ; preds = %369
  br i1 false, label %376, label %452

376:                                              ; preds = %375
  unreachable

377:                                              ; preds = %369
  %378 = load { i1, { i128 } }, ptr %9, align 16
  %379 = extractvalue { i1, { i128 } } %378, 1
  %380 = extractvalue { i128 } %379, 0
  %381 = zext i128 %380 to i512
  %382 = mul i512 %381, 340282366920938463463374607431768211456
  %383 = urem i512 %382, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %384 = icmp uge i512 %382, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %385 = select i1 %384, i512 %383, i512 %382
  %386 = trunc i512 %385 to i252
  br label %414

387:                                              ; preds = %369
  %388 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %389 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %388, 1
  call void @"drop$42"({ ptr, i32, i32, i32 } %31)
  %390 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %389, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %390, ptr %10, align 8
  %391 = load { i128, [80 x i8] }, ptr %10, align 16
  %392 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %372, 0
  %393 = insertvalue { i64, { i128, [80 x i8] } } %392, { i128, [80 x i8] } %391, 1
  ret { i64, { i128, [80 x i8] } } %393

394:                                              ; preds = %363
  %395 = phi i64 [ %365, %363 ]
  %396 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f79"(i64 %395, i32 %364)
  %397 = extractvalue { i64, { i128, [16 x i8] } } %396, 0
  %398 = extractvalue { i64, { i128, [16 x i8] } } %396, 1
  store { i128, [16 x i8] } %398, ptr %6, align 16
  %399 = load i1, ptr %6, align 1
  switch i1 %399, label %400 [
    i1 false, label %402
    i1 true, label %407
  ]

400:                                              ; preds = %394
  br i1 false, label %401, label %451

401:                                              ; preds = %400
  unreachable

402:                                              ; preds = %394
  %403 = load { i1, { i128 } }, ptr %6, align 16
  %404 = extractvalue { i1, { i128 } } %403, 1
  %405 = extractvalue { i128 } %404, 0
  %406 = zext i128 %405 to i252
  br label %414

407:                                              ; preds = %394
  %408 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %409 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %408, 1
  call void @"drop$42"({ ptr, i32, i32, i32 } %31)
  %410 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %409, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %410, ptr %7, align 8
  %411 = load { i128, [80 x i8] }, ptr %7, align 16
  %412 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %397, 0
  %413 = insertvalue { i64, { i128, [80 x i8] } } %412, { i128, [80 x i8] } %411, 1
  ret { i64, { i128, [80 x i8] } } %413

414:                                              ; preds = %402, %377
  %415 = phi i252 [ %2, %402 ], [ %2, %377 ]
  %416 = phi { ptr, i32, i32, i32 } [ %31, %402 ], [ %31, %377 ]
  %417 = phi i252 [ %32, %402 ], [ %32, %377 ]
  %418 = phi i32 [ %39, %402 ], [ %39, %377 ]
  %419 = phi i64 [ %397, %402 ], [ %372, %377 ]
  %420 = phi i252 [ %406, %402 ], [ %386, %377 ]
  %421 = zext i252 %417 to i512
  %422 = zext i252 %420 to i512
  %423 = mul i512 %421, %422
  %424 = urem i512 %423, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %425 = icmp uge i512 %423, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %426 = select i1 %425, i512 %424, i512 %423
  %427 = trunc i512 %426 to i252
  %428 = zext i252 %415 to i256
  %429 = zext i252 %427 to i256
  %430 = add i256 %428, %429
  %431 = sub i256 %430, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %432 = icmp uge i256 %430, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %433 = select i1 %432, i256 %431, i256 %430
  %434 = trunc i256 %433 to i252
  %435 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %416, 0
  %436 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %435, i252 %434, 1
  %437 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %436, i32 %418, 2
  %438 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %437, 0
  %439 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %438, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %439, ptr %8, align 16
  %440 = load { i128, [80 x i8] }, ptr %8, align 16
  %441 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %419, 0
  %442 = insertvalue { i64, { i128, [80 x i8] } } %441, { i128, [80 x i8] } %440, 1
  ret { i64, { i128, [80 x i8] } } %442

443:                                              ; preds = %29
  %444 = phi { ptr, i32, i32, i32 } [ %31, %29 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %444)
  %445 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f83"()
  %446 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %445, 0
  %447 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %446, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %447, ptr %5, align 8
  %448 = load { i128, [80 x i8] }, ptr %5, align 16
  %449 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %34, 0
  %450 = insertvalue { i64, { i128, [80 x i8] } } %449, { i128, [80 x i8] } %448, 1
  ret { i64, { i128, [80 x i8] } } %450

451:                                              ; preds = %400
  call void @puts(ptr @assert_msg_100)
  call void @abort()
  unreachable

452:                                              ; preds = %375
  call void @puts(ptr @assert_msg_101)
  call void @abort()
  unreachable

453:                                              ; preds = %89
  call void @puts(ptr @assert_msg_102)
  call void @abort()
  unreachable

454:                                              ; preds = %209
  call void @puts(ptr @assert_msg_103)
  call void @abort()
  unreachable

455:                                              ; preds = %64
  call void @puts(ptr @assert_msg_104)
  call void @abort()
  unreachable
}

define private { i64, { i128, [80 x i8] } } @f52(i64 %0, { { ptr, i32, i32, i32 }, i252, i32 } %1, i252 %2, i32 %3) {
  %5 = call fastcc { i64, { i128, [80 x i8] } } @"impl$f52"(i64 %0, { { ptr, i32, i32, i32 }, i252, i32 } %1, i252 %2, i32 %3)
  %6 = extractvalue { i64, { i128, [80 x i8] } } %5, 0
  %7 = extractvalue { i64, { i128, [80 x i8] } } %5, 1
  %8 = insertvalue { i64, { i128, [80 x i8] } } undef, i64 %6, 0
  %9 = insertvalue { i64, { i128, [80 x i8] } } %8, { i128, [80 x i8] } %7, 1
  ret { i64, { i128, [80 x i8] } } %9
}

define void @_mlir_ciface_f52(ptr %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2, i252 %3, i32 %4) {
  %6 = call { i64, { i128, [80 x i8] } } @f52(i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2, i252 %3, i32 %4)
  store { i64, { i128, [80 x i8] } } %6, ptr %0, align 16
  ret void
}

define private void @"drop$43"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$42"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$42"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$44"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$43"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$44"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f53"(i64 %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %6 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 0
  %7 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %5, 1
  %8 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %7, 0
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = extractvalue { ptr, i32, i32, i32 } %11, 1
  %13 = extractvalue { ptr, i32, i32, i32 } %11, 2
  %14 = sub i32 %13, %12
  call void @"drop$43"({ ptr, i32, i32, i32 } %11)
  %15 = zext i32 %14 to i252
  %16 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %16, align 4
  %17 = getelementptr inbounds i8, ptr %16, i32 4
  store i32 0, ptr %17, align 4
  %18 = getelementptr inbounds i8, ptr %16, i32 16
  %19 = call ptr @realloc(ptr null, i64 8)
  store ptr %18, ptr %19, align 8
  %20 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %19, 0
  %21 = insertvalue { ptr, i32, i32, i32 } %20, i32 8, 3
  %22 = load ptr, ptr %19, align 8
  store i252 1997209042069643135709344952807065910992472029923670688473712229447419591075, ptr %22, align 16
  %23 = insertvalue { ptr, i32, i32, i32 } %21, i32 1, 2
  %24 = getelementptr inbounds i8, ptr %22, i32 -12
  store i32 1, ptr %24, align 4
  %25 = load ptr, ptr %19, align 8
  %26 = getelementptr inbounds i8, ptr %25, i32 32
  store i252 %15, ptr %26, align 16
  %27 = insertvalue { ptr, i32, i32, i32 } %23, i32 2, 2
  %28 = getelementptr inbounds i8, ptr %25, i32 -12
  store i32 2, ptr %28, align 4
  %29 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %10, 0
  %30 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %29, { ptr, i32, i32, i32 } %27)
  %31 = extractvalue { i64, i64, { i64, [24 x i8] } } %30, 0
  %32 = extractvalue { i64, i64, { i64, [24 x i8] } } %30, 1
  %33 = extractvalue { i64, i64, { i64, [24 x i8] } } %30, 2
  store { i64, [24 x i8] } %33, ptr %4, align 8
  %34 = load i1, ptr %4, align 1
  switch i1 %34, label %35 [
    i1 false, label %37
    i1 true, label %152
  ]

35:                                               ; preds = %3
  br i1 false, label %36, label %158

36:                                               ; preds = %35
  unreachable

37:                                               ; preds = %3
  %38 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %4, align 8
  %39 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %38, 1
  %40 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  %41 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %40, 0
  %42 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %40, 1
  %43 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %42, 0
  %44 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %42, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %43)
  %45 = zext i32 %44 to i252
  %46 = extractvalue { { ptr, i32, i32, i32 }, {} } %39, 0
  %47 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %41, 0
  %48 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %41, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %47)
  %49 = extractvalue { ptr, i32, i32, i32 } %46, 3
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %51, label %65

51:                                               ; preds = %37
  %52 = shl i32 %49, 1
  %53 = call i32 @llvm.umin.i32(i32 %52, i32 1024)
  %54 = add i32 %53, %49
  %55 = call i32 @llvm.umax.i32(i32 %54, i32 8)
  %56 = zext i32 %55 to i64
  %57 = mul i64 %56, 32
  %58 = add i64 %57, 16
  %59 = call ptr @realloc(ptr null, i64 %58)
  store i32 1, ptr %59, align 4
  %60 = getelementptr inbounds i8, ptr %59, i32 4
  store i32 0, ptr %60, align 4
  %61 = getelementptr inbounds i8, ptr %59, i32 16
  %62 = call ptr @realloc(ptr null, i64 8)
  store ptr %61, ptr %62, align 8
  %63 = insertvalue { ptr, i32, i32, i32 } %46, ptr %62, 0
  %64 = insertvalue { ptr, i32, i32, i32 } %63, i32 %55, 3
  br label %86

65:                                               ; preds = %37
  %66 = extractvalue { ptr, i32, i32, i32 } %46, 2
  %67 = icmp ult i32 %66, %49
  br i1 %67, label %68, label %69

68:                                               ; preds = %65
  br label %83

69:                                               ; preds = %65
  %70 = shl i32 %49, 1
  %71 = call i32 @llvm.umin.i32(i32 %70, i32 1024)
  %72 = add i32 %71, %49
  %73 = call i32 @llvm.umax.i32(i32 %72, i32 8)
  %74 = zext i32 %73 to i64
  %75 = mul i64 %74, 32
  %76 = add i64 %75, 16
  %77 = extractvalue { ptr, i32, i32, i32 } %46, 0
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr inbounds i8, ptr %78, i32 -16
  %80 = call ptr @realloc(ptr %79, i64 %76)
  %81 = getelementptr inbounds i8, ptr %80, i32 16
  store ptr %81, ptr %77, align 8
  %82 = insertvalue { ptr, i32, i32, i32 } %46, i32 %73, 3
  br label %83

83:                                               ; preds = %68, %69
  %84 = phi { ptr, i32, i32, i32 } [ %82, %69 ], [ %46, %68 ]
  br label %85

85:                                               ; preds = %83
  br label %86

86:                                               ; preds = %51, %85
  %87 = phi { ptr, i32, i32, i32 } [ %84, %85 ], [ %64, %51 ]
  br label %88

88:                                               ; preds = %86
  %89 = extractvalue { ptr, i32, i32, i32 } %87, 0
  %90 = load ptr, ptr %89, align 8
  %91 = extractvalue { ptr, i32, i32, i32 } %87, 2
  %92 = zext i32 %91 to i64
  %93 = mul i64 %92, 32
  %94 = getelementptr inbounds i8, ptr %90, i64 %93
  store i252 %48, ptr %94, align 16
  %95 = extractvalue { ptr, i32, i32, i32 } %87, 2
  %96 = add i32 %95, 1
  %97 = insertvalue { ptr, i32, i32, i32 } %87, i32 %96, 2
  %98 = getelementptr inbounds i8, ptr %90, i32 -12
  store i32 %96, ptr %98, align 4
  %99 = extractvalue { ptr, i32, i32, i32 } %87, 3
  %100 = icmp eq i32 %99, 0
  br i1 %100, label %101, label %115

101:                                              ; preds = %88
  %102 = shl i32 %99, 1
  %103 = call i32 @llvm.umin.i32(i32 %102, i32 1024)
  %104 = add i32 %103, %99
  %105 = call i32 @llvm.umax.i32(i32 %104, i32 8)
  %106 = zext i32 %105 to i64
  %107 = mul i64 %106, 32
  %108 = add i64 %107, 16
  %109 = call ptr @realloc(ptr null, i64 %108)
  store i32 1, ptr %109, align 4
  %110 = getelementptr inbounds i8, ptr %109, i32 4
  store i32 0, ptr %110, align 4
  %111 = getelementptr inbounds i8, ptr %109, i32 16
  %112 = call ptr @realloc(ptr null, i64 8)
  store ptr %111, ptr %112, align 8
  %113 = insertvalue { ptr, i32, i32, i32 } %97, ptr %112, 0
  %114 = insertvalue { ptr, i32, i32, i32 } %113, i32 %105, 3
  br label %135

115:                                              ; preds = %88
  %116 = icmp ult i32 %96, %99
  br i1 %116, label %117, label %118

117:                                              ; preds = %115
  br label %132

118:                                              ; preds = %115
  %119 = shl i32 %99, 1
  %120 = call i32 @llvm.umin.i32(i32 %119, i32 1024)
  %121 = add i32 %120, %99
  %122 = call i32 @llvm.umax.i32(i32 %121, i32 8)
  %123 = zext i32 %122 to i64
  %124 = mul i64 %123, 32
  %125 = add i64 %124, 16
  %126 = extractvalue { ptr, i32, i32, i32 } %87, 0
  %127 = load ptr, ptr %126, align 8
  %128 = getelementptr inbounds i8, ptr %127, i32 -16
  %129 = call ptr @realloc(ptr %128, i64 %125)
  %130 = getelementptr inbounds i8, ptr %129, i32 16
  store ptr %130, ptr %126, align 8
  %131 = insertvalue { ptr, i32, i32, i32 } %97, i32 %122, 3
  br label %132

132:                                              ; preds = %117, %118
  %133 = phi { ptr, i32, i32, i32 } [ %131, %118 ], [ %97, %117 ]
  br label %134

134:                                              ; preds = %132
  br label %135

135:                                              ; preds = %101, %134
  %136 = phi { ptr, i32, i32, i32 } [ %133, %134 ], [ %114, %101 ]
  br label %137

137:                                              ; preds = %135
  %138 = extractvalue { ptr, i32, i32, i32 } %136, 0
  %139 = load ptr, ptr %138, align 8
  %140 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %141 = zext i32 %140 to i64
  %142 = mul i64 %141, 32
  %143 = getelementptr inbounds i8, ptr %139, i64 %142
  store i252 %45, ptr %143, align 16
  %144 = extractvalue { ptr, i32, i32, i32 } %136, 2
  %145 = add i32 %144, 1
  %146 = insertvalue { ptr, i32, i32, i32 } %136, i32 %145, 2
  %147 = getelementptr inbounds i8, ptr %139, i32 -12
  store i32 %145, ptr %147, align 4
  %148 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %146, 1
  %149 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } undef, i64 %31, 0
  %150 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %149, i64 %32, 1
  %151 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %150, { {}, { ptr, i32, i32, i32 } } %148, 2
  ret { i64, i64, { {}, { ptr, i32, i32, i32 } } } %151

152:                                              ; preds = %3
  %153 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %154 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %153, 1
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %6)
  %155 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } undef, i64 %31, 0
  %156 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %155, i64 %32, 1
  %157 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %156, { {}, { ptr, i32, i32, i32 } } %154, 2
  ret { i64, i64, { {}, { ptr, i32, i32, i32 } } } %157

158:                                              ; preds = %35
  call void @puts(ptr @assert_msg_105)
  call void @abort()
  unreachable
}

define private { i64, i64, { {}, { ptr, i32, i32, i32 } } } @f53(i64 %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2) {
  %4 = call fastcc { i64, i64, { {}, { ptr, i32, i32, i32 } } } @"impl$f53"(i64 %0, i64 %1, { { ptr, i32, i32, i32 }, i252, i32 } %2)
  %5 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %4, 0
  %6 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %4, 1
  %7 = extractvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %4, 2
  %8 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { {}, { ptr, i32, i32, i32 } } } %9, { {}, { ptr, i32, i32, i32 } } %7, 2
  ret { i64, i64, { {}, { ptr, i32, i32, i32 } } } %10
}

define void @_mlir_ciface_f53(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 }, i252, i32 } %3) {
  %5 = call { i64, i64, { {}, { ptr, i32, i32, i32 } } } @f53(i64 %1, i64 %2, { { ptr, i32, i32, i32 }, i252, i32 } %3)
  store { i64, i64, { {}, { ptr, i32, i32, i32 } } } %5, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f54"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 30828113188794245257250221355944970489240709081949230)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f54() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f54"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f54(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f54()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 39878429859757942499084499860145094553463)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f55() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f55(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f55()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 39878429859761676908720221312622923640695)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f56() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f56(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f56()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f57"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %117, %5
  %17 = phi i64 [ %71, %117 ], [ %0, %5 ]
  %18 = phi i64 [ %77, %117 ], [ %1, %5 ]
  %19 = phi { { ptr, i32, i32, i32 } } [ %134, %117 ], [ %2, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %126, %117 ], [ %3, %5 ]
  %21 = phi i252 [ %133, %117 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 2680
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %185

29:                                               ; preds = %16
  %30 = phi i252 [ %21, %16 ]
  %31 = icmp eq i252 %30, 0
  br i1 %31, label %32, label %54

32:                                               ; preds = %29
  %33 = phi i64 [ %28, %29 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = load i64, ptr %35, align 8
  %37 = mul i64 %36, 3580
  %38 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 %37)
  %39 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %20, 1
  store { i1, { ptr, i32, i32, i32 } } %39, ptr %14, align 8
  %40 = load { i64, [24 x i8] }, ptr %14, align 8
  %41 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %19, 0
  %42 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %41, { i64, [24 x i8] } %40, 1
  %43 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %42, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %43, ptr %15, align 8
  %44 = load { i64, [56 x i8] }, ptr %15, align 8
  %45 = extractvalue { ptr, ptr, i64 } %9, 1
  %46 = load i64, ptr %45, align 8
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %46, 1
  %49 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %48, ptr %49, align 8
  br i1 %47, label %50, label %139

50:                                               ; preds = %32
  %51 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %52 = insertvalue { i64, i64, { i64, [56 x i8] } } %51, i64 %38, 1
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } %52, { i64, [56 x i8] } %44, 2
  ret { i64, i64, { i64, [56 x i8] } } %53

54:                                               ; preds = %29
  %55 = phi { { ptr, i32, i32, i32 } } [ %19, %29 ]
  %56 = extractvalue { { ptr, i32, i32, i32 } } %55, 0
  %57 = extractvalue { ptr, i32, i32, i32 } %56, 1
  %58 = extractvalue { ptr, i32, i32, i32 } %56, 2
  %59 = sub i32 %58, %57
  %60 = icmp uge i32 %59, 1
  br i1 %60, label %61, label %159

61:                                               ; preds = %54
  %62 = extractvalue { ptr, i32, i32, i32 } %56, 0
  %63 = load ptr, ptr %62, align 8
  %64 = zext i32 %57 to i64
  %65 = mul i64 %64, 32
  %66 = getelementptr inbounds i8, ptr %63, i64 %65
  %67 = add i32 %57, 1
  %68 = insertvalue { ptr, i32, i32, i32 } %56, i32 %67, 1
  %69 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %69, ptr %66, i64 32, i1 false)
  %70 = load i252, ptr %69, align 16
  call void @free(ptr %69)
  %71 = add i64 %17, 4
  %72 = icmp ule i252 %70, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %72, label %73, label %152

73:                                               ; preds = %61
  %74 = trunc i252 %70 to i248
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 0)
  %78 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %94

80:                                               ; preds = %73
  %81 = shl i32 %78, 1
  %82 = call i32 @llvm.umin.i32(i32 %81, i32 1024)
  %83 = add i32 %82, %78
  %84 = call i32 @llvm.umax.i32(i32 %83, i32 8)
  %85 = zext i32 %84 to i64
  %86 = mul i64 %85, 32
  %87 = add i64 %86, 16
  %88 = call ptr @realloc(ptr null, i64 %87)
  store i32 1, ptr %88, align 4
  %89 = getelementptr inbounds i8, ptr %88, i32 4
  store i32 0, ptr %89, align 4
  %90 = getelementptr inbounds i8, ptr %88, i32 16
  %91 = call ptr @realloc(ptr null, i64 8)
  store ptr %90, ptr %91, align 8
  %92 = insertvalue { ptr, i32, i32, i32 } %20, ptr %91, 0
  %93 = insertvalue { ptr, i32, i32, i32 } %92, i32 %84, 3
  br label %115

94:                                               ; preds = %73
  %95 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %96 = icmp ult i32 %95, %78
  br i1 %96, label %97, label %98

97:                                               ; preds = %94
  br label %112

98:                                               ; preds = %94
  %99 = shl i32 %78, 1
  %100 = call i32 @llvm.umin.i32(i32 %99, i32 1024)
  %101 = add i32 %100, %78
  %102 = call i32 @llvm.umax.i32(i32 %101, i32 8)
  %103 = zext i32 %102 to i64
  %104 = mul i64 %103, 32
  %105 = add i64 %104, 16
  %106 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr inbounds i8, ptr %107, i32 -16
  %109 = call ptr @realloc(ptr %108, i64 %105)
  %110 = getelementptr inbounds i8, ptr %109, i32 16
  store ptr %110, ptr %106, align 8
  %111 = insertvalue { ptr, i32, i32, i32 } %20, i32 %102, 3
  br label %112

112:                                              ; preds = %97, %98
  %113 = phi { ptr, i32, i32, i32 } [ %111, %98 ], [ %20, %97 ]
  br label %114

114:                                              ; preds = %112
  br label %115

115:                                              ; preds = %80, %114
  %116 = phi { ptr, i32, i32, i32 } [ %113, %114 ], [ %93, %80 ]
  br label %117

117:                                              ; preds = %115
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %119 = load ptr, ptr %118, align 8
  %120 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %121 = zext i32 %120 to i64
  %122 = mul i64 %121, 32
  %123 = getelementptr inbounds i8, ptr %119, i64 %122
  store i248 %74, ptr %123, align 16
  %124 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %125 = add i32 %124, 1
  %126 = insertvalue { ptr, i32, i32, i32 } %116, i32 %125, 2
  %127 = getelementptr inbounds i8, ptr %119, i32 -12
  store i32 %125, ptr %127, align 4
  %128 = zext i252 %30 to i256
  %129 = sub i256 %128, 1
  %130 = add i256 %128, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %131 = icmp ult i256 %128, 1
  %132 = select i1 %131, i256 %130, i256 %129
  %133 = trunc i256 %132 to i252
  %134 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %68, 0
  %135 = extractvalue { ptr, ptr, i64 } %9, 1
  %136 = load i64, ptr %135, align 8
  %137 = add i64 %136, 1
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %137, ptr %138, align 8
  br label %16

139:                                              ; preds = %139, %32, %166, %185
  %140 = phi i64 [ %22, %185 ], [ %167, %166 ], [ %140, %139 ], [ %22, %32 ]
  %141 = phi i64 [ %18, %185 ], [ %168, %166 ], [ %141, %139 ], [ %38, %32 ]
  %142 = phi { i64, [56 x i8] } [ %190, %185 ], [ %175, %166 ], [ %142, %139 ], [ %44, %32 ]
  %143 = extractvalue { ptr, ptr, i64 } %9, 1
  %144 = load i64, ptr %143, align 8
  %145 = icmp eq i64 %144, 0
  %146 = sub i64 %144, 1
  %147 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %146, ptr %147, align 8
  br i1 %145, label %148, label %139

148:                                              ; preds = %139
  %149 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %140, 0
  %150 = insertvalue { i64, i64, { i64, [56 x i8] } } %149, i64 %141, 1
  %151 = insertvalue { i64, i64, { i64, [56 x i8] } } %150, { i64, [56 x i8] } %142, 2
  ret { i64, i64, { i64, [56 x i8] } } %151

152:                                              ; preds = %61
  %153 = phi { ptr, i32, i32, i32 } [ %20, %61 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %153)
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = load i64, ptr %155, align 8
  %157 = mul i64 %156, 1670
  %158 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %157)
  br label %166

159:                                              ; preds = %54
  %160 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %160)
  %161 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %162 = call ptr %161()
  %163 = load i64, ptr %162, align 8
  %164 = mul i64 %163, 2880
  %165 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %164)
  br label %166

166:                                              ; preds = %152, %159
  %167 = phi i64 [ %22, %159 ], [ %71, %152 ]
  %168 = phi i64 [ %165, %159 ], [ %158, %152 ]
  %169 = phi { ptr, i32, i32, i32 } [ %56, %159 ], [ %68, %152 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %170 = load { i64, [24 x i8] }, ptr %12, align 8
  %171 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %169, 0
  %172 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %171, 0
  %173 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %172, { i64, [24 x i8] } %170, 1
  %174 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %173, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %174, ptr %13, align 8
  %175 = load { i64, [56 x i8] }, ptr %13, align 8
  %176 = extractvalue { ptr, ptr, i64 } %9, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %139

181:                                              ; preds = %166
  %182 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %167, 0
  %183 = insertvalue { i64, i64, { i64, [56 x i8] } } %182, i64 %168, 1
  %184 = insertvalue { i64, i64, { i64, [56 x i8] } } %183, { i64, [56 x i8] } %175, 2
  ret { i64, i64, { i64, [56 x i8] } } %184

185:                                              ; preds = %16
  %186 = phi { ptr, i32, i32, i32 } [ %20, %16 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %186)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %19)
  %187 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %188 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %187, 0
  %189 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %188, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %189, ptr %11, align 8
  %190 = load { i64, [56 x i8] }, ptr %11, align 8
  %191 = extractvalue { ptr, ptr, i64 } %9, 1
  %192 = load i64, ptr %191, align 8
  %193 = icmp eq i64 %192, 0
  %194 = sub i64 %192, 1
  %195 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %194, ptr %195, align 8
  br i1 %193, label %196, label %139

196:                                              ; preds = %185
  %197 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %22, 0
  %198 = insertvalue { i64, i64, { i64, [56 x i8] } } %197, i64 %18, 1
  %199 = insertvalue { i64, i64, { i64, [56 x i8] } } %198, { i64, [56 x i8] } %190, 2
  ret { i64, i64, { i64, [56 x i8] } } %199
}

define private { i64, i64, { i64, [56 x i8] } } @f57(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f57"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f57(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f57(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$329"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, 1
  call void @"drop$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$329"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %10, ptr %2, align 16
  %11 = load { i128, [144 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %12, ptr %2, align 16
  %13 = load { i128, [144 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %11, 0
  %15 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %14, { i128, [144 x i8] } %13, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i128, [144 x i8] }, ptr %2, align 16
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i128, [144 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %20, 0
  %24 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %23, { i128, [144 x i8] } %22, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$330"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  call void @"drop$329"({ i128, [144 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$330"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %0, 1
  %9 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$329"({ i128, [144 x i8] } %8)
  %10 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 0
  %11 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6, { i128, [144 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %7, { i128, [144 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %15
}

define private void @"drop$331"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  call void @"drop$330"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [192 x i8] }, { i128, [192 x i8] } } @"dup$331"({ i128, [192 x i8] } %0) {
  %2 = alloca { i128, [192 x i8] }, i64 1, align 16
  store { i128, [192 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } @"dup$330"({ { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [192 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [192 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %11, 0
  %15 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %14, { i128, [192 x i8] } %13, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [192 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [192 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } undef, { i128, [192 x i8] } %23, 0
  %27 = insertvalue { { i128, [192 x i8] }, { i128, [192 x i8] } } %26, { i128, [192 x i8] } %25, 1
  ret { { i128, [192 x i8] }, { i128, [192 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [208 x i8] } } @"impl$f58"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [160 x i8] }, i64 1, align 16
  %5 = alloca { i128, [208 x i8] }, i64 1, align 16
  %6 = alloca { i128, [160 x i8] }, i64 1, align 16
  %7 = alloca { i128, [208 x i8] }, i64 1, align 16
  %8 = alloca { i128, [192 x i8] }, i64 1, align 16
  %9 = alloca { i128, [208 x i8] }, i64 1, align 16
  %10 = alloca { i128, [144 x i8] }, i64 1, align 16
  %11 = alloca { i128, [160 x i8] }, i64 1, align 16
  %12 = alloca { i128, [208 x i8] }, i64 1, align 16
  %13 = alloca { i128, [144 x i8] }, i64 1, align 16
  %14 = alloca { i128, [160 x i8] }, i64 1, align 16
  %15 = alloca { i128, [208 x i8] }, i64 1, align 16
  %16 = alloca { i128, [128 x i8] }, i64 1, align 16
  %17 = alloca { i128, [208 x i8] }, i64 1, align 16
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i128, [144 x i8] }, i64 1, align 16
  %20 = alloca { i128, [160 x i8] }, i64 1, align 16
  %21 = alloca { i128, [208 x i8] }, i64 1, align 16
  %22 = alloca { i128, [144 x i8] }, i64 1, align 16
  %23 = alloca { i128, [160 x i8] }, i64 1, align 16
  %24 = alloca { i128, [208 x i8] }, i64 1, align 16
  %25 = extractvalue { { ptr, i32, i32, i32 } } %2, 0
  %26 = extractvalue { ptr, i32, i32, i32 } %25, 1
  %27 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %28 = sub i32 %27, %26
  %29 = icmp uge i32 %28, 1
  br i1 %29, label %30, label %227

30:                                               ; preds = %3
  %31 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %32 = load ptr, ptr %31, align 8
  %33 = zext i32 %26 to i64
  %34 = mul i64 %33, 32
  %35 = getelementptr inbounds i8, ptr %32, i64 %34
  %36 = add i32 %26, 1
  %37 = insertvalue { ptr, i32, i32, i32 } %25, i32 %36, 1
  %38 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %38, ptr %35, i64 32, i1 false)
  %39 = load i252, ptr %38, align 16
  call void @free(ptr %38)
  %40 = icmp eq i252 %39, 0
  br i1 %40, label %41, label %81

41:                                               ; preds = %30
  %42 = phi { ptr, i32, i32, i32 } [ %37, %30 ]
  %43 = extractvalue { ptr, i32, i32, i32 } %42, 1
  %44 = extractvalue { ptr, i32, i32, i32 } %42, 2
  %45 = sub i32 %44, %43
  %46 = icmp uge i32 %45, 1
  br i1 %46, label %47, label %74

47:                                               ; preds = %41
  %48 = extractvalue { ptr, i32, i32, i32 } %42, 0
  %49 = load ptr, ptr %48, align 8
  %50 = zext i32 %43 to i64
  %51 = mul i64 %50, 32
  %52 = getelementptr inbounds i8, ptr %49, i64 %51
  %53 = add i32 %43, 1
  %54 = insertvalue { ptr, i32, i32, i32 } %42, i32 %53, 1
  %55 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %55, ptr %52, i64 32, i1 false)
  %56 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %57 = call ptr %56()
  %58 = load i64, ptr %57, align 8
  %59 = mul i64 %58, 22140
  %60 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %59)
  %61 = load i252, ptr %55, align 16
  call void @free(ptr %55)
  %62 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %54, 0
  %63 = insertvalue { i2, i252 } { i2 0, i252 undef }, i252 %61, 1
  store { i2, i252 } %63, ptr %22, align 16
  %64 = load { i128, [144 x i8] }, ptr %22, align 16
  %65 = insertvalue { i1, { i128, [144 x i8] } } { i1 false, { i128, [144 x i8] } undef }, { i128, [144 x i8] } %64, 1
  store { i1, { i128, [144 x i8] } } %65, ptr %23, align 16
  %66 = load { i128, [160 x i8] }, ptr %23, align 16
  %67 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %62, 0
  %68 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %67, { i128, [160 x i8] } %66, 1
  %69 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %68, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %69, ptr %24, align 16
  %70 = load { i128, [208 x i8] }, ptr %24, align 16
  %71 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %0, 0
  %72 = insertvalue { i64, i64, { i128, [208 x i8] } } %71, i64 %60, 1
  %73 = insertvalue { i64, i64, { i128, [208 x i8] } } %72, { i128, [208 x i8] } %70, 2
  ret { i64, i64, { i128, [208 x i8] } } %73

74:                                               ; preds = %41
  %75 = phi i64 [ %1, %41 ]
  %76 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %77 = call ptr %76()
  %78 = load i64, ptr %77, align 8
  %79 = mul i64 %78, 21640
  %80 = call i64 @llvm.uadd.sat.i64(i64 %75, i64 %79)
  br label %234

81:                                               ; preds = %30
  %82 = phi { ptr, i32, i32, i32 } [ %37, %30 ]
  %83 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %82, 0
  %84 = zext i252 %39 to i256
  %85 = sub i256 %84, 1
  %86 = add i256 %84, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %87 = icmp ult i256 %84, 1
  %88 = select i1 %87, i256 %86, i256 %85
  %89 = trunc i256 %88 to i252
  %90 = icmp eq i252 %89, 0
  br i1 %90, label %91, label %141

91:                                               ; preds = %81
  %92 = phi i64 [ %0, %81 ]
  %93 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f26"(i64 %92, i64 %1, { { ptr, i32, i32, i32 } } %83)
  %94 = extractvalue { i64, i64, { i128, [128 x i8] } } %93, 0
  %95 = extractvalue { i64, i64, { i128, [128 x i8] } } %93, 1
  %96 = extractvalue { i64, i64, { i128, [128 x i8] } } %93, 2
  store { i128, [128 x i8] } %96, ptr %16, align 16
  %97 = load i1, ptr %16, align 1
  switch i1 %97, label %98 [
    i1 false, label %100
    i1 true, label %106
  ]

98:                                               ; preds = %91
  br i1 false, label %99, label %247

99:                                               ; preds = %98
  unreachable

100:                                              ; preds = %91
  %101 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %16, align 16
  %102 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %101, 1
  %103 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %102, 0
  %104 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %102, 1
  store { i128, [80 x i8] } %104, ptr %18, align 16
  %105 = load i1, ptr %18, align 1
  switch i1 %105, label %114 [
    i1 false, label %116
    i1 true, label %135
  ]

106:                                              ; preds = %91
  %107 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %108 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %107, 1
  %109 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %108, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %109, ptr %17, align 8
  %110 = load { i128, [208 x i8] }, ptr %17, align 16
  %111 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %94, 0
  %112 = insertvalue { i64, i64, { i128, [208 x i8] } } %111, i64 %95, 1
  %113 = insertvalue { i64, i64, { i128, [208 x i8] } } %112, { i128, [208 x i8] } %110, 2
  ret { i64, i64, { i128, [208 x i8] } } %113

114:                                              ; preds = %100
  br i1 false, label %115, label %248

115:                                              ; preds = %114
  unreachable

116:                                              ; preds = %100
  %117 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %18, align 16
  %118 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %117, 1
  %119 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %120 = call ptr %119()
  %121 = load i64, ptr %120, align 8
  %122 = mul i64 %121, 14560
  %123 = call i64 @llvm.uadd.sat.i64(i64 %95, i64 %122)
  %124 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } { i2 1, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %118, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %124, ptr %19, align 16
  %125 = load { i128, [144 x i8] }, ptr %19, align 16
  %126 = insertvalue { i1, { i128, [144 x i8] } } { i1 false, { i128, [144 x i8] } undef }, { i128, [144 x i8] } %125, 1
  store { i1, { i128, [144 x i8] } } %126, ptr %20, align 16
  %127 = load { i128, [160 x i8] }, ptr %20, align 16
  %128 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %103, 0
  %129 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %128, { i128, [160 x i8] } %127, 1
  %130 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %129, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %130, ptr %21, align 16
  %131 = load { i128, [208 x i8] }, ptr %21, align 16
  %132 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %94, 0
  %133 = insertvalue { i64, i64, { i128, [208 x i8] } } %132, i64 %123, 1
  %134 = insertvalue { i64, i64, { i128, [208 x i8] } } %133, { i128, [208 x i8] } %131, 2
  ret { i64, i64, { i128, [208 x i8] } } %134

135:                                              ; preds = %100
  %136 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %137 = call ptr %136()
  %138 = load i64, ptr %137, align 8
  %139 = mul i64 %138, 14060
  %140 = call i64 @llvm.uadd.sat.i64(i64 %95, i64 %139)
  br label %200

141:                                              ; preds = %81
  %142 = phi i252 [ %39, %81 ]
  %143 = phi i252 [ 2, %81 ]
  %144 = zext i252 %142 to i256
  %145 = zext i252 %143 to i256
  %146 = sub i256 %144, %145
  %147 = add i256 %146, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %148 = icmp ult i256 %144, %145
  %149 = select i1 %148, i256 %147, i256 %146
  %150 = trunc i256 %149 to i252
  %151 = icmp eq i252 %150, 0
  br i1 %151, label %152, label %212

152:                                              ; preds = %141
  %153 = phi i64 [ %0, %141 ]
  %154 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f85"(i64 %153, i64 %1, { { ptr, i32, i32, i32 } } %83)
  %155 = extractvalue { i64, i64, { i128, [192 x i8] } } %154, 0
  %156 = extractvalue { i64, i64, { i128, [192 x i8] } } %154, 1
  %157 = extractvalue { i64, i64, { i128, [192 x i8] } } %154, 2
  store { i128, [192 x i8] } %157, ptr %8, align 16
  %158 = load i1, ptr %8, align 1
  switch i1 %158, label %159 [
    i1 false, label %161
    i1 true, label %167
  ]

159:                                              ; preds = %152
  br i1 false, label %160, label %249

160:                                              ; preds = %159
  unreachable

161:                                              ; preds = %152
  %162 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } }, ptr %8, align 16
  %163 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %162, 1
  %164 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %163, 0
  %165 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %163, 1
  store { i128, [144 x i8] } %165, ptr %10, align 16
  %166 = load i1, ptr %10, align 1
  switch i1 %166, label %175 [
    i1 false, label %177
    i1 true, label %196
  ]

167:                                              ; preds = %152
  %168 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %169 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %168, 1
  %170 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %169, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %170, ptr %9, align 8
  %171 = load { i128, [208 x i8] }, ptr %9, align 16
  %172 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %155, 0
  %173 = insertvalue { i64, i64, { i128, [208 x i8] } } %172, i64 %156, 1
  %174 = insertvalue { i64, i64, { i128, [208 x i8] } } %173, { i128, [208 x i8] } %171, 2
  ret { i64, i64, { i128, [208 x i8] } } %174

175:                                              ; preds = %161
  br i1 false, label %176, label %250

176:                                              ; preds = %175
  unreachable

177:                                              ; preds = %161
  %178 = load { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %10, align 16
  %179 = extractvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %178, 1
  %180 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %181 = call ptr %180()
  %182 = load i64, ptr %181, align 8
  %183 = mul i64 %182, 400
  %184 = call i64 @llvm.uadd.sat.i64(i64 %156, i64 %183)
  %185 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } { i2 -2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %179, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %185, ptr %13, align 16
  %186 = load { i128, [144 x i8] }, ptr %13, align 16
  %187 = insertvalue { i1, { i128, [144 x i8] } } { i1 false, { i128, [144 x i8] } undef }, { i128, [144 x i8] } %186, 1
  store { i1, { i128, [144 x i8] } } %187, ptr %14, align 16
  %188 = load { i128, [160 x i8] }, ptr %14, align 16
  %189 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %164, 0
  %190 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %189, { i128, [160 x i8] } %188, 1
  %191 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %190, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %191, ptr %15, align 16
  %192 = load { i128, [208 x i8] }, ptr %15, align 16
  %193 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %155, 0
  %194 = insertvalue { i64, i64, { i128, [208 x i8] } } %193, i64 %184, 1
  %195 = insertvalue { i64, i64, { i128, [208 x i8] } } %194, { i128, [208 x i8] } %192, 2
  ret { i64, i64, { i128, [208 x i8] } } %195

196:                                              ; preds = %161
  %197 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %198 = call ptr %197()
  %199 = call i64 @llvm.uadd.sat.i64(i64 %156, i64 0)
  br label %200

200:                                              ; preds = %135, %196
  %201 = phi i64 [ %155, %196 ], [ %94, %135 ]
  %202 = phi i64 [ %199, %196 ], [ %140, %135 ]
  %203 = phi { { ptr, i32, i32, i32 } } [ %164, %196 ], [ %103, %135 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %11, align 1
  %204 = load { i128, [160 x i8] }, ptr %11, align 16
  %205 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %203, 0
  %206 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %205, { i128, [160 x i8] } %204, 1
  %207 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %206, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %207, ptr %12, align 16
  %208 = load { i128, [208 x i8] }, ptr %12, align 16
  %209 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %201, 0
  %210 = insertvalue { i64, i64, { i128, [208 x i8] } } %209, i64 %202, 1
  %211 = insertvalue { i64, i64, { i128, [208 x i8] } } %210, { i128, [208 x i8] } %208, 2
  ret { i64, i64, { i128, [208 x i8] } } %211

212:                                              ; preds = %141
  %213 = phi i64 [ %1, %141 ]
  %214 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %215 = call ptr %214()
  %216 = load i64, ptr %215, align 8
  %217 = mul i64 %216, 22140
  %218 = call i64 @llvm.uadd.sat.i64(i64 %213, i64 %217)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %6, align 1
  %219 = load { i128, [160 x i8] }, ptr %6, align 16
  %220 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %83, 0
  %221 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %220, { i128, [160 x i8] } %219, 1
  %222 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %221, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %222, ptr %7, align 16
  %223 = load { i128, [208 x i8] }, ptr %7, align 16
  %224 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %0, 0
  %225 = insertvalue { i64, i64, { i128, [208 x i8] } } %224, i64 %218, 1
  %226 = insertvalue { i64, i64, { i128, [208 x i8] } } %225, { i128, [208 x i8] } %223, 2
  ret { i64, i64, { i128, [208 x i8] } } %226

227:                                              ; preds = %3
  %228 = phi i64 [ %1, %3 ]
  %229 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %230 = call ptr %229()
  %231 = load i64, ptr %230, align 8
  %232 = mul i64 %231, 22340
  %233 = call i64 @llvm.uadd.sat.i64(i64 %228, i64 %232)
  br label %234

234:                                              ; preds = %74, %227
  %235 = phi i64 [ %0, %227 ], [ %0, %74 ]
  %236 = phi i64 [ %233, %227 ], [ %80, %74 ]
  %237 = phi { ptr, i32, i32, i32 } [ %25, %227 ], [ %42, %74 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %238 = load { i128, [160 x i8] }, ptr %4, align 16
  %239 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %237, 0
  %240 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef, { { ptr, i32, i32, i32 } } %239, 0
  %241 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %240, { i128, [160 x i8] } %238, 1
  %242 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } %241, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [160 x i8] } } } %242, ptr %5, align 16
  %243 = load { i128, [208 x i8] }, ptr %5, align 16
  %244 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %235, 0
  %245 = insertvalue { i64, i64, { i128, [208 x i8] } } %244, i64 %236, 1
  %246 = insertvalue { i64, i64, { i128, [208 x i8] } } %245, { i128, [208 x i8] } %243, 2
  ret { i64, i64, { i128, [208 x i8] } } %246

247:                                              ; preds = %98
  call void @puts(ptr @assert_msg_106)
  call void @abort()
  unreachable

248:                                              ; preds = %114
  call void @puts(ptr @assert_msg_107)
  call void @abort()
  unreachable

249:                                              ; preds = %159
  call void @puts(ptr @assert_msg_108)
  call void @abort()
  unreachable

250:                                              ; preds = %175
  call void @puts(ptr @assert_msg_109)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [208 x i8] } } @f58(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [208 x i8] } } @"impl$f58"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [208 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [208 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [208 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [208 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [208 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [208 x i8] } } %9, { i128, [208 x i8] } %7, 2
  ret { i64, i64, { i128, [208 x i8] } } %10
}

define void @_mlir_ciface_f58(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [208 x i8] } } @f58(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [208 x i8] } } %5, ptr %0, align 16
  ret void
}

define private void @"drop$328"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$328"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i8 } }, ptr %2, align 1
  %6 = extractvalue { i1, { i8 } } %5, 1
  %7 = insertvalue { i1, { i8 } } %5, { i8 } %6, 1
  store { i1, { i8 } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { i8 } } %5, { i8 } %6, 1
  store { i1, { i8 } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$326"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$326"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i16 } }, ptr %2, align 2
  %6 = extractvalue { i1, { i16 } } %5, 1
  %7 = insertvalue { i1, { i16 } } %5, { i16 } %6, 1
  store { i1, { i16 } } %7, ptr %2, align 2
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { i16 } } %5, { i16 } %6, 1
  store { i1, { i16 } } %9, ptr %2, align 2
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, { i128, [16 x i8] } } @"impl$f59"(i64 %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i128, [16 x i8] }, i64 1, align 16
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i128, [16 x i8] }, i64 1, align 16
  %7 = alloca { i128, [16 x i8] }, i64 1, align 16
  %8 = alloca { i128, [16 x i8] }, i64 1, align 16
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i128, [16 x i8] }, i64 1, align 16
  %11 = alloca { i128, [16 x i8] }, i64 1, align 16
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i128, [16 x i8] }, i64 1, align 16
  %14 = alloca { i128, [16 x i8] }, i64 1, align 16
  %15 = alloca { i128, [16 x i8] }, i64 1, align 16
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i128, [16 x i8] }, i64 1, align 16
  %18 = alloca { i128, [16 x i8] }, i64 1, align 16
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i128, [16 x i8] }, i64 1, align 16
  %21 = alloca { i128, [16 x i8] }, i64 1, align 16
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i128, [16 x i8] }, i64 1, align 16
  %24 = alloca { i128, [16 x i8] }, i64 1, align 16
  %25 = alloca { i128, [16 x i8] }, i64 1, align 16
  %26 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 0
  %27 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 1
  %28 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 2
  %29 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 3
  %30 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 4
  %31 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 5
  %32 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 6
  %33 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 7
  %34 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 8
  %35 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 9
  %36 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1, 10
  %37 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f86"(i64 %0, i8 %26)
  %38 = extractvalue { i64, { i64, [24 x i8] } } %37, 0
  %39 = extractvalue { i64, { i64, [24 x i8] } } %37, 1
  store { i64, [24 x i8] } %39, ptr %3, align 8
  %40 = load i1, ptr %3, align 1
  switch i1 %40, label %41 [
    i1 false, label %43
    i1 true, label %52
  ]

41:                                               ; preds = %2
  br i1 false, label %42, label %410

42:                                               ; preds = %41
  unreachable

43:                                               ; preds = %2
  %44 = load { i1, { i8 } }, ptr %3, align 1
  %45 = extractvalue { i1, { i8 } } %44, 1
  %46 = extractvalue { i8 } %45, 0
  %47 = zext i8 %46 to i128
  %48 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f86"(i64 %38, i8 %27)
  %49 = extractvalue { i64, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { i64, { i64, [24 x i8] } } %48, 1
  store { i64, [24 x i8] } %50, ptr %5, align 8
  %51 = load i1, ptr %5, align 1
  switch i1 %51, label %59 [
    i1 false, label %61
    i1 true, label %74
  ]

52:                                               ; preds = %2
  %53 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %3, align 8
  %54 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %53, 1
  %55 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %54, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %55, ptr %4, align 8
  %56 = load { i128, [16 x i8] }, ptr %4, align 16
  %57 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %38, 0
  %58 = insertvalue { i64, { i128, [16 x i8] } } %57, { i128, [16 x i8] } %56, 1
  ret { i64, { i128, [16 x i8] } } %58

59:                                               ; preds = %43
  br i1 false, label %60, label %411

60:                                               ; preds = %59
  unreachable

61:                                               ; preds = %43
  %62 = load { i1, { i8 } }, ptr %5, align 1
  %63 = extractvalue { i1, { i8 } } %62, 1
  %64 = extractvalue { i8 } %63, 0
  %65 = zext i8 %64 to i128
  %66 = zext i128 %65 to i256
  %67 = mul i256 %66, 256
  %68 = trunc i256 %67 to i128
  %69 = lshr i256 %67, 128
  %70 = trunc i256 %69 to i128
  %71 = add i64 %49, 9
  %72 = zext i128 %70 to i252
  %73 = icmp eq i252 %72, 0
  br i1 %73, label %81, label %403

74:                                               ; preds = %43
  %75 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %76 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %75, 1
  %77 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %76, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %77, ptr %6, align 8
  %78 = load { i128, [16 x i8] }, ptr %6, align 16
  %79 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %49, 0
  %80 = insertvalue { i64, { i128, [16 x i8] } } %79, { i128, [16 x i8] } %78, 1
  ret { i64, { i128, [16 x i8] } } %80

81:                                               ; preds = %61
  %82 = phi i64 [ %71, %61 ]
  %83 = phi i128 [ %47, %61 ]
  %84 = phi i128 [ %68, %61 ]
  %85 = add i64 %82, 1
  %86 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %83, i128 %84)
  %87 = extractvalue { i128, i1 } %86, 0
  %88 = extractvalue { i128, i1 } %86, 1
  br i1 %88, label %395, label %89

89:                                               ; preds = %81
  %90 = phi i64 [ %85, %81 ]
  %91 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f86"(i64 %90, i8 %28)
  %92 = extractvalue { i64, { i64, [24 x i8] } } %91, 0
  %93 = extractvalue { i64, { i64, [24 x i8] } } %91, 1
  store { i64, [24 x i8] } %93, ptr %9, align 8
  %94 = load i1, ptr %9, align 1
  switch i1 %94, label %95 [
    i1 false, label %97
    i1 true, label %110
  ]

95:                                               ; preds = %89
  br i1 false, label %96, label %412

96:                                               ; preds = %95
  unreachable

97:                                               ; preds = %89
  %98 = load { i1, { i8 } }, ptr %9, align 1
  %99 = extractvalue { i1, { i8 } } %98, 1
  %100 = extractvalue { i8 } %99, 0
  %101 = zext i8 %100 to i128
  %102 = zext i128 %101 to i256
  %103 = mul i256 %102, 65536
  %104 = trunc i256 %103 to i128
  %105 = lshr i256 %103, 128
  %106 = trunc i256 %105 to i128
  %107 = add i64 %92, 9
  %108 = zext i128 %106 to i252
  %109 = icmp eq i252 %108, 0
  br i1 %109, label %117, label %388

110:                                              ; preds = %89
  %111 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %112 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %111, 1
  %113 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %112, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %113, ptr %10, align 8
  %114 = load { i128, [16 x i8] }, ptr %10, align 16
  %115 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %92, 0
  %116 = insertvalue { i64, { i128, [16 x i8] } } %115, { i128, [16 x i8] } %114, 1
  ret { i64, { i128, [16 x i8] } } %116

117:                                              ; preds = %97
  %118 = phi i64 [ %107, %97 ]
  %119 = phi i128 [ %87, %97 ]
  %120 = phi i128 [ %104, %97 ]
  %121 = add i64 %118, 1
  %122 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %119, i128 %120)
  %123 = extractvalue { i128, i1 } %122, 0
  %124 = extractvalue { i128, i1 } %122, 1
  br i1 %124, label %395, label %125

125:                                              ; preds = %117
  %126 = phi i64 [ %121, %117 ]
  %127 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f86"(i64 %126, i8 %29)
  %128 = extractvalue { i64, { i64, [24 x i8] } } %127, 0
  %129 = extractvalue { i64, { i64, [24 x i8] } } %127, 1
  store { i64, [24 x i8] } %129, ptr %12, align 8
  %130 = load i1, ptr %12, align 1
  switch i1 %130, label %131 [
    i1 false, label %133
    i1 true, label %146
  ]

131:                                              ; preds = %125
  br i1 false, label %132, label %413

132:                                              ; preds = %131
  unreachable

133:                                              ; preds = %125
  %134 = load { i1, { i8 } }, ptr %12, align 1
  %135 = extractvalue { i1, { i8 } } %134, 1
  %136 = extractvalue { i8 } %135, 0
  %137 = zext i8 %136 to i128
  %138 = zext i128 %137 to i256
  %139 = mul i256 %138, 16777216
  %140 = trunc i256 %139 to i128
  %141 = lshr i256 %139, 128
  %142 = trunc i256 %141 to i128
  %143 = add i64 %128, 9
  %144 = zext i128 %142 to i252
  %145 = icmp eq i252 %144, 0
  br i1 %145, label %153, label %381

146:                                              ; preds = %125
  %147 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %148 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %147, 1
  %149 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %148, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %149, ptr %13, align 8
  %150 = load { i128, [16 x i8] }, ptr %13, align 16
  %151 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %128, 0
  %152 = insertvalue { i64, { i128, [16 x i8] } } %151, { i128, [16 x i8] } %150, 1
  ret { i64, { i128, [16 x i8] } } %152

153:                                              ; preds = %133
  %154 = phi i64 [ %143, %133 ]
  %155 = phi i128 [ %123, %133 ]
  %156 = phi i128 [ %140, %133 ]
  %157 = add i64 %154, 1
  %158 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %155, i128 %156)
  %159 = extractvalue { i128, i1 } %158, 0
  %160 = extractvalue { i128, i1 } %158, 1
  br i1 %160, label %395, label %161

161:                                              ; preds = %153
  %162 = phi i8 [ %30, %153 ]
  %163 = zext i8 %162 to i128
  %164 = zext i128 %163 to i256
  %165 = mul i256 %164, 4294967296
  %166 = trunc i256 %165 to i128
  %167 = lshr i256 %165, 128
  %168 = trunc i256 %167 to i128
  %169 = add i64 %154, 10
  %170 = zext i128 %168 to i252
  %171 = icmp eq i252 %170, 0
  br i1 %171, label %172, label %373

172:                                              ; preds = %161
  %173 = phi i64 [ %169, %161 ]
  %174 = phi i128 [ %159, %161 ]
  %175 = phi i128 [ %166, %161 ]
  %176 = add i64 %173, 1
  %177 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %174, i128 %175)
  %178 = extractvalue { i128, i1 } %177, 0
  %179 = extractvalue { i128, i1 } %177, 1
  br i1 %179, label %395, label %180

180:                                              ; preds = %172
  %181 = phi i8 [ %31, %172 ]
  %182 = zext i8 %181 to i128
  %183 = zext i128 %182 to i256
  %184 = mul i256 %183, 1099511627776
  %185 = trunc i256 %184 to i128
  %186 = lshr i256 %184, 128
  %187 = trunc i256 %186 to i128
  %188 = add i64 %173, 10
  %189 = zext i128 %187 to i252
  %190 = icmp eq i252 %189, 0
  br i1 %190, label %191, label %373

191:                                              ; preds = %180
  %192 = phi i64 [ %188, %180 ]
  %193 = phi i128 [ %178, %180 ]
  %194 = phi i128 [ %185, %180 ]
  %195 = add i64 %192, 1
  %196 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %193, i128 %194)
  %197 = extractvalue { i128, i1 } %196, 0
  %198 = extractvalue { i128, i1 } %196, 1
  br i1 %198, label %395, label %199

199:                                              ; preds = %191
  %200 = phi i8 [ %32, %191 ]
  %201 = zext i8 %200 to i128
  %202 = zext i128 %201 to i256
  %203 = mul i256 %202, 281474976710656
  %204 = trunc i256 %203 to i128
  %205 = lshr i256 %203, 128
  %206 = trunc i256 %205 to i128
  %207 = add i64 %192, 10
  %208 = zext i128 %206 to i252
  %209 = icmp eq i252 %208, 0
  br i1 %209, label %210, label %373

210:                                              ; preds = %199
  %211 = phi i64 [ %207, %199 ]
  %212 = phi i128 [ %197, %199 ]
  %213 = phi i128 [ %204, %199 ]
  %214 = add i64 %211, 1
  %215 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %212, i128 %213)
  %216 = extractvalue { i128, i1 } %215, 0
  %217 = extractvalue { i128, i1 } %215, 1
  br i1 %217, label %395, label %218

218:                                              ; preds = %210
  %219 = phi i8 [ %33, %210 ]
  %220 = zext i8 %219 to i128
  %221 = zext i128 %220 to i256
  %222 = mul i256 %221, 72057594037927936
  %223 = trunc i256 %222 to i128
  %224 = lshr i256 %222, 128
  %225 = trunc i256 %224 to i128
  %226 = add i64 %211, 10
  %227 = zext i128 %225 to i252
  %228 = icmp eq i252 %227, 0
  br i1 %228, label %229, label %373

229:                                              ; preds = %218
  %230 = phi i64 [ %226, %218 ]
  %231 = phi i128 [ %216, %218 ]
  %232 = phi i128 [ %223, %218 ]
  %233 = add i64 %230, 1
  %234 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %231, i128 %232)
  %235 = extractvalue { i128, i1 } %234, 0
  %236 = extractvalue { i128, i1 } %234, 1
  br i1 %236, label %395, label %237

237:                                              ; preds = %229
  %238 = phi i64 [ %233, %229 ]
  %239 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f87"(i64 %238, i16 %34)
  %240 = extractvalue { i64, { i64, [24 x i8] } } %239, 0
  %241 = extractvalue { i64, { i64, [24 x i8] } } %239, 1
  store { i64, [24 x i8] } %241, ptr %16, align 8
  %242 = load i1, ptr %16, align 1
  switch i1 %242, label %243 [
    i1 false, label %245
    i1 true, label %258
  ]

243:                                              ; preds = %237
  br i1 false, label %244, label %414

244:                                              ; preds = %243
  unreachable

245:                                              ; preds = %237
  %246 = load { i1, { i16 } }, ptr %16, align 2
  %247 = extractvalue { i1, { i16 } } %246, 1
  %248 = extractvalue { i16 } %247, 0
  %249 = zext i16 %248 to i128
  %250 = zext i128 %249 to i256
  %251 = mul i256 %250, 18446744073709551616
  %252 = trunc i256 %251 to i128
  %253 = lshr i256 %251, 128
  %254 = trunc i256 %253 to i128
  %255 = add i64 %240, 9
  %256 = zext i128 %254 to i252
  %257 = icmp eq i252 %256, 0
  br i1 %257, label %265, label %366

258:                                              ; preds = %237
  %259 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %260 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %259, 1
  %261 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %260, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %261, ptr %17, align 8
  %262 = load { i128, [16 x i8] }, ptr %17, align 16
  %263 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %240, 0
  %264 = insertvalue { i64, { i128, [16 x i8] } } %263, { i128, [16 x i8] } %262, 1
  ret { i64, { i128, [16 x i8] } } %264

265:                                              ; preds = %245
  %266 = phi i64 [ %255, %245 ]
  %267 = phi i128 [ %235, %245 ]
  %268 = phi i128 [ %252, %245 ]
  %269 = add i64 %266, 1
  %270 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %267, i128 %268)
  %271 = extractvalue { i128, i1 } %270, 0
  %272 = extractvalue { i128, i1 } %270, 1
  br i1 %272, label %395, label %273

273:                                              ; preds = %265
  %274 = phi i64 [ %269, %265 ]
  %275 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f87"(i64 %274, i16 %35)
  %276 = extractvalue { i64, { i64, [24 x i8] } } %275, 0
  %277 = extractvalue { i64, { i64, [24 x i8] } } %275, 1
  store { i64, [24 x i8] } %277, ptr %19, align 8
  %278 = load i1, ptr %19, align 1
  switch i1 %278, label %279 [
    i1 false, label %281
    i1 true, label %294
  ]

279:                                              ; preds = %273
  br i1 false, label %280, label %415

280:                                              ; preds = %279
  unreachable

281:                                              ; preds = %273
  %282 = load { i1, { i16 } }, ptr %19, align 2
  %283 = extractvalue { i1, { i16 } } %282, 1
  %284 = extractvalue { i16 } %283, 0
  %285 = zext i16 %284 to i128
  %286 = zext i128 %285 to i256
  %287 = mul i256 %286, 1208925819614629174706176
  %288 = trunc i256 %287 to i128
  %289 = lshr i256 %287, 128
  %290 = trunc i256 %289 to i128
  %291 = add i64 %276, 9
  %292 = zext i128 %290 to i252
  %293 = icmp eq i252 %292, 0
  br i1 %293, label %301, label %359

294:                                              ; preds = %273
  %295 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %296 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %295, 1
  %297 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %296, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %297, ptr %20, align 8
  %298 = load { i128, [16 x i8] }, ptr %20, align 16
  %299 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %276, 0
  %300 = insertvalue { i64, { i128, [16 x i8] } } %299, { i128, [16 x i8] } %298, 1
  ret { i64, { i128, [16 x i8] } } %300

301:                                              ; preds = %281
  %302 = phi i64 [ %291, %281 ]
  %303 = phi i128 [ %271, %281 ]
  %304 = phi i128 [ %288, %281 ]
  %305 = add i64 %302, 1
  %306 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %303, i128 %304)
  %307 = extractvalue { i128, i1 } %306, 0
  %308 = extractvalue { i128, i1 } %306, 1
  br i1 %308, label %395, label %309

309:                                              ; preds = %301
  %310 = phi i64 [ %305, %301 ]
  %311 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f87"(i64 %310, i16 %36)
  %312 = extractvalue { i64, { i64, [24 x i8] } } %311, 0
  %313 = extractvalue { i64, { i64, [24 x i8] } } %311, 1
  store { i64, [24 x i8] } %313, ptr %22, align 8
  %314 = load i1, ptr %22, align 1
  switch i1 %314, label %315 [
    i1 false, label %317
    i1 true, label %330
  ]

315:                                              ; preds = %309
  br i1 false, label %316, label %416

316:                                              ; preds = %315
  unreachable

317:                                              ; preds = %309
  %318 = load { i1, { i16 } }, ptr %22, align 2
  %319 = extractvalue { i1, { i16 } } %318, 1
  %320 = extractvalue { i16 } %319, 0
  %321 = zext i16 %320 to i128
  %322 = zext i128 %321 to i256
  %323 = mul i256 %322, 79228162514264337593543950336
  %324 = trunc i256 %323 to i128
  %325 = lshr i256 %323, 128
  %326 = trunc i256 %325 to i128
  %327 = add i64 %312, 9
  %328 = zext i128 %326 to i252
  %329 = icmp eq i252 %328, 0
  br i1 %329, label %337, label %352

330:                                              ; preds = %309
  %331 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %22, align 8
  %332 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %331, 1
  %333 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %332, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %333, ptr %23, align 8
  %334 = load { i128, [16 x i8] }, ptr %23, align 16
  %335 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %312, 0
  %336 = insertvalue { i64, { i128, [16 x i8] } } %335, { i128, [16 x i8] } %334, 1
  ret { i64, { i128, [16 x i8] } } %336

337:                                              ; preds = %317
  %338 = phi i64 [ %327, %317 ]
  %339 = phi i128 [ %307, %317 ]
  %340 = phi i128 [ %324, %317 ]
  %341 = add i64 %338, 1
  %342 = call { i128, i1 } @llvm.uadd.with.overflow.i128(i128 %339, i128 %340)
  %343 = extractvalue { i128, i1 } %342, 0
  %344 = extractvalue { i128, i1 } %342, 1
  br i1 %344, label %395, label %345

345:                                              ; preds = %337
  %346 = phi i128 [ %343, %337 ]
  %347 = insertvalue { i128 } undef, i128 %346, 0
  %348 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %347, 1
  store { i1, { i128 } } %348, ptr %25, align 16
  %349 = load { i128, [16 x i8] }, ptr %25, align 16
  %350 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %341, 0
  %351 = insertvalue { i64, { i128, [16 x i8] } } %350, { i128, [16 x i8] } %349, 1
  ret { i64, { i128, [16 x i8] } } %351

352:                                              ; preds = %317
  %353 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %354 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %353, 0
  %355 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %354, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %355, ptr %24, align 8
  %356 = load { i128, [16 x i8] }, ptr %24, align 16
  %357 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %327, 0
  %358 = insertvalue { i64, { i128, [16 x i8] } } %357, { i128, [16 x i8] } %356, 1
  ret { i64, { i128, [16 x i8] } } %358

359:                                              ; preds = %281
  %360 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %361 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %360, 0
  %362 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %361, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %362, ptr %21, align 8
  %363 = load { i128, [16 x i8] }, ptr %21, align 16
  %364 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %291, 0
  %365 = insertvalue { i64, { i128, [16 x i8] } } %364, { i128, [16 x i8] } %363, 1
  ret { i64, { i128, [16 x i8] } } %365

366:                                              ; preds = %245
  %367 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %368 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %367, 0
  %369 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %368, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %369, ptr %18, align 8
  %370 = load { i128, [16 x i8] }, ptr %18, align 16
  %371 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %255, 0
  %372 = insertvalue { i64, { i128, [16 x i8] } } %371, { i128, [16 x i8] } %370, 1
  ret { i64, { i128, [16 x i8] } } %372

373:                                              ; preds = %218, %199, %180, %161
  %374 = phi i64 [ %226, %218 ], [ %207, %199 ], [ %188, %180 ], [ %169, %161 ]
  %375 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %376 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %375, 0
  %377 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %376, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %377, ptr %15, align 8
  %378 = load { i128, [16 x i8] }, ptr %15, align 16
  %379 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %374, 0
  %380 = insertvalue { i64, { i128, [16 x i8] } } %379, { i128, [16 x i8] } %378, 1
  ret { i64, { i128, [16 x i8] } } %380

381:                                              ; preds = %133
  %382 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %383 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %382, 0
  %384 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %383, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %384, ptr %14, align 8
  %385 = load { i128, [16 x i8] }, ptr %14, align 16
  %386 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %143, 0
  %387 = insertvalue { i64, { i128, [16 x i8] } } %386, { i128, [16 x i8] } %385, 1
  ret { i64, { i128, [16 x i8] } } %387

388:                                              ; preds = %97
  %389 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %390 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %389, 0
  %391 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %390, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %391, ptr %11, align 8
  %392 = load { i128, [16 x i8] }, ptr %11, align 16
  %393 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %107, 0
  %394 = insertvalue { i64, { i128, [16 x i8] } } %393, { i128, [16 x i8] } %392, 1
  ret { i64, { i128, [16 x i8] } } %394

395:                                              ; preds = %337, %301, %265, %229, %210, %191, %172, %153, %117, %81
  %396 = phi i64 [ %341, %337 ], [ %305, %301 ], [ %269, %265 ], [ %233, %229 ], [ %214, %210 ], [ %195, %191 ], [ %176, %172 ], [ %157, %153 ], [ %121, %117 ], [ %85, %81 ]
  %397 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f55"()
  %398 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %397, 0
  %399 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %398, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %399, ptr %8, align 8
  %400 = load { i128, [16 x i8] }, ptr %8, align 16
  %401 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %396, 0
  %402 = insertvalue { i64, { i128, [16 x i8] } } %401, { i128, [16 x i8] } %400, 1
  ret { i64, { i128, [16 x i8] } } %402

403:                                              ; preds = %61
  %404 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f56"()
  %405 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %404, 0
  %406 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %405, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %406, ptr %7, align 8
  %407 = load { i128, [16 x i8] }, ptr %7, align 16
  %408 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %71, 0
  %409 = insertvalue { i64, { i128, [16 x i8] } } %408, { i128, [16 x i8] } %407, 1
  ret { i64, { i128, [16 x i8] } } %409

410:                                              ; preds = %41
  call void @puts(ptr @assert_msg_110)
  call void @abort()
  unreachable

411:                                              ; preds = %59
  call void @puts(ptr @assert_msg_111)
  call void @abort()
  unreachable

412:                                              ; preds = %95
  call void @puts(ptr @assert_msg_112)
  call void @abort()
  unreachable

413:                                              ; preds = %131
  call void @puts(ptr @assert_msg_113)
  call void @abort()
  unreachable

414:                                              ; preds = %243
  call void @puts(ptr @assert_msg_114)
  call void @abort()
  unreachable

415:                                              ; preds = %279
  call void @puts(ptr @assert_msg_115)
  call void @abort()
  unreachable

416:                                              ; preds = %315
  call void @puts(ptr @assert_msg_116)
  call void @abort()
  unreachable
}

define private { i64, { i128, [16 x i8] } } @f59(i64 %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1) {
  %3 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f59"(i64 %0, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %1)
  %4 = extractvalue { i64, { i128, [16 x i8] } } %3, 0
  %5 = extractvalue { i64, { i128, [16 x i8] } } %3, 1
  %6 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i128, [16 x i8] } } %6, { i128, [16 x i8] } %5, 1
  ret { i64, { i128, [16 x i8] } } %7
}

define void @_mlir_ciface_f59(ptr %0, i64 %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2) {
  %4 = call { i64, { i128, [16 x i8] } } @f59(i64 %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2)
  store { i64, { i128, [16 x i8] } } %4, ptr %0, align 16
  ret void
}

define private void @"drop$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  call void @"drop$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0)
  ret void
}

define private { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0) {
  %2 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %0)
  %3 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %2, 0
  %4 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %2, 1
  %5 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %6 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %5, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 1
  ret { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6
}

define private void @"drop$318"({ i128, [144 x i8] } %0) {
  call void @"drop$140"({ i128, [144 x i8] } %0)
  ret void
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$318"({ i128, [144 x i8] } %0) {
  %2 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$140"({ i128, [144 x i8] } %0)
  %3 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %2, 0
  %4 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %2, 1
  %5 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %3, 0
  %6 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %5, { i128, [144 x i8] } %4, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %6
}

define private void @"drop$319"(ptr %0) {
  %2 = load { i128, [144 x i8] }, ptr %0, align 16
  call void @"drop$318"({ i128, [144 x i8] } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$319"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 160)
  %3 = load { i128, [144 x i8] }, ptr %0, align 16
  %4 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$318"({ i128, [144 x i8] } %3)
  %5 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %4, 0
  %6 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %4, 1
  store { i128, [144 x i8] } %5, ptr %0, align 16
  store { i128, [144 x i8] } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$38"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$37"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$38"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$37"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$39"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$38"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$39"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$38"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f60"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i128, [144 x i8] }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %21

21:                                               ; preds = %1004, %4
  %22 = phi i64 [ %1006, %1004 ], [ %0, %4 ]
  %23 = phi i64 [ %1007, %1004 ], [ %1, %4 ]
  %24 = phi { { ptr, i32, i32, i32 } } [ %1005, %1004 ], [ %2, %4 ]
  %25 = phi { ptr, i32, i32, i32 } [ %1008, %1004 ], [ %3, %4 ]
  %26 = add i64 %22, 1
  %27 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %28 = call ptr %27()
  %29 = load i64, ptr %28, align 8
  %30 = mul i64 %29, 14420
  %31 = icmp uge i64 %23, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %23, i64 %30)
  br i1 %31, label %33, label %1057

33:                                               ; preds = %21
  %34 = phi { { ptr, i32, i32, i32 } } [ %24, %21 ]
  %35 = extractvalue { { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %1038

40:                                               ; preds = %33
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 160
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 160)
  %49 = load { i128, [144 x i8] }, ptr %45, align 16
  %50 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$140"({ i128, [144 x i8] } %49)
  %51 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %50, 0
  %52 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %50, 1
  store { i128, [144 x i8] } %51, ptr %45, align 16
  store { i128, [144 x i8] } %52, ptr %48, align 16
  %53 = load { i128, [144 x i8] }, ptr %48, align 16
  call void @free(ptr %48)
  %54 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %47, 0
  store { i128, [144 x i8] } %53, ptr %12, align 16
  %55 = load i2, ptr %12, align 1
  switch i2 %55, label %56 [
    i2 0, label %58
    i2 1, label %165
    i2 -2, label %284
  ]

56:                                               ; preds = %40
  br i1 false, label %57, label %1072

57:                                               ; preds = %56
  unreachable

58:                                               ; preds = %40
  %59 = load { i2, i252 }, ptr %12, align 16
  %60 = extractvalue { i2, i252 } %59, 1
  %61 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %62 = call ptr %61()
  %63 = load i64, ptr %62, align 8
  %64 = mul i64 %63, 10500
  %65 = call i64 @llvm.uadd.sat.i64(i64 %32, i64 %64)
  %66 = extractvalue { ptr, i32, i32, i32 } %25, 3
  %67 = icmp eq i32 %66, 0
  br i1 %67, label %68, label %82

68:                                               ; preds = %58
  %69 = shl i32 %66, 1
  %70 = call i32 @llvm.umin.i32(i32 %69, i32 1024)
  %71 = add i32 %70, %66
  %72 = call i32 @llvm.umax.i32(i32 %71, i32 8)
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 32
  %75 = add i64 %74, 16
  %76 = call ptr @realloc(ptr null, i64 %75)
  store i32 1, ptr %76, align 4
  %77 = getelementptr inbounds i8, ptr %76, i32 4
  store i32 0, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %76, i32 16
  %79 = call ptr @realloc(ptr null, i64 8)
  store ptr %78, ptr %79, align 8
  %80 = insertvalue { ptr, i32, i32, i32 } %25, ptr %79, 0
  %81 = insertvalue { ptr, i32, i32, i32 } %80, i32 %72, 3
  br label %103

82:                                               ; preds = %58
  %83 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %84 = icmp ult i32 %83, %66
  br i1 %84, label %85, label %86

85:                                               ; preds = %82
  br label %100

86:                                               ; preds = %82
  %87 = shl i32 %66, 1
  %88 = call i32 @llvm.umin.i32(i32 %87, i32 1024)
  %89 = add i32 %88, %66
  %90 = call i32 @llvm.umax.i32(i32 %89, i32 8)
  %91 = zext i32 %90 to i64
  %92 = mul i64 %91, 32
  %93 = add i64 %92, 16
  %94 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %95 = load ptr, ptr %94, align 8
  %96 = getelementptr inbounds i8, ptr %95, i32 -16
  %97 = call ptr @realloc(ptr %96, i64 %93)
  %98 = getelementptr inbounds i8, ptr %97, i32 16
  store ptr %98, ptr %94, align 8
  %99 = insertvalue { ptr, i32, i32, i32 } %25, i32 %90, 3
  br label %100

100:                                              ; preds = %85, %86
  %101 = phi { ptr, i32, i32, i32 } [ %99, %86 ], [ %25, %85 ]
  br label %102

102:                                              ; preds = %100
  br label %103

103:                                              ; preds = %68, %102
  %104 = phi { ptr, i32, i32, i32 } [ %101, %102 ], [ %81, %68 ]
  br label %105

105:                                              ; preds = %103
  %106 = extractvalue { ptr, i32, i32, i32 } %104, 0
  %107 = load ptr, ptr %106, align 8
  %108 = extractvalue { ptr, i32, i32, i32 } %104, 2
  %109 = zext i32 %108 to i64
  %110 = mul i64 %109, 32
  %111 = getelementptr inbounds i8, ptr %107, i64 %110
  store i252 0, ptr %111, align 16
  %112 = extractvalue { ptr, i32, i32, i32 } %104, 2
  %113 = add i32 %112, 1
  %114 = insertvalue { ptr, i32, i32, i32 } %104, i32 %113, 2
  %115 = getelementptr inbounds i8, ptr %107, i32 -12
  store i32 %113, ptr %115, align 4
  %116 = extractvalue { ptr, i32, i32, i32 } %104, 3
  %117 = icmp eq i32 %116, 0
  br i1 %117, label %118, label %132

118:                                              ; preds = %105
  %119 = shl i32 %116, 1
  %120 = call i32 @llvm.umin.i32(i32 %119, i32 1024)
  %121 = add i32 %120, %116
  %122 = call i32 @llvm.umax.i32(i32 %121, i32 8)
  %123 = zext i32 %122 to i64
  %124 = mul i64 %123, 32
  %125 = add i64 %124, 16
  %126 = call ptr @realloc(ptr null, i64 %125)
  store i32 1, ptr %126, align 4
  %127 = getelementptr inbounds i8, ptr %126, i32 4
  store i32 0, ptr %127, align 4
  %128 = getelementptr inbounds i8, ptr %126, i32 16
  %129 = call ptr @realloc(ptr null, i64 8)
  store ptr %128, ptr %129, align 8
  %130 = insertvalue { ptr, i32, i32, i32 } %114, ptr %129, 0
  %131 = insertvalue { ptr, i32, i32, i32 } %130, i32 %122, 3
  br label %152

132:                                              ; preds = %105
  %133 = icmp ult i32 %113, %116
  br i1 %133, label %134, label %135

134:                                              ; preds = %132
  br label %149

135:                                              ; preds = %132
  %136 = shl i32 %116, 1
  %137 = call i32 @llvm.umin.i32(i32 %136, i32 1024)
  %138 = add i32 %137, %116
  %139 = call i32 @llvm.umax.i32(i32 %138, i32 8)
  %140 = zext i32 %139 to i64
  %141 = mul i64 %140, 32
  %142 = add i64 %141, 16
  %143 = extractvalue { ptr, i32, i32, i32 } %104, 0
  %144 = load ptr, ptr %143, align 8
  %145 = getelementptr inbounds i8, ptr %144, i32 -16
  %146 = call ptr @realloc(ptr %145, i64 %142)
  %147 = getelementptr inbounds i8, ptr %146, i32 16
  store ptr %147, ptr %143, align 8
  %148 = insertvalue { ptr, i32, i32, i32 } %114, i32 %139, 3
  br label %149

149:                                              ; preds = %134, %135
  %150 = phi { ptr, i32, i32, i32 } [ %148, %135 ], [ %114, %134 ]
  br label %151

151:                                              ; preds = %149
  br label %152

152:                                              ; preds = %118, %151
  %153 = phi { ptr, i32, i32, i32 } [ %150, %151 ], [ %131, %118 ]
  br label %154

154:                                              ; preds = %152
  %155 = extractvalue { ptr, i32, i32, i32 } %153, 0
  %156 = load ptr, ptr %155, align 8
  %157 = extractvalue { ptr, i32, i32, i32 } %153, 2
  %158 = zext i32 %157 to i64
  %159 = mul i64 %158, 32
  %160 = getelementptr inbounds i8, ptr %156, i64 %159
  store i252 %60, ptr %160, align 16
  %161 = extractvalue { ptr, i32, i32, i32 } %153, 2
  %162 = add i32 %161, 1
  %163 = insertvalue { ptr, i32, i32, i32 } %153, i32 %162, 2
  %164 = getelementptr inbounds i8, ptr %156, i32 -12
  store i32 %162, ptr %164, align 4
  br label %1004

165:                                              ; preds = %40
  %166 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %12, align 16
  %167 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %166, 1
  %168 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %167)
  %169 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %168, 0
  %170 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %168, 1
  %171 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %170, 0
  %172 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %171)
  %173 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %172, 0
  %174 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %172, 1
  %175 = extractvalue { ptr, i32, i32, i32 } %174, 1
  %176 = extractvalue { ptr, i32, i32, i32 } %174, 2
  %177 = sub i32 %176, %175
  call void @"drop$43"({ ptr, i32, i32, i32 } %174)
  %178 = zext i32 %177 to i252
  %179 = extractvalue { ptr, i32, i32, i32 } %25, 3
  %180 = icmp eq i32 %179, 0
  br i1 %180, label %181, label %195

181:                                              ; preds = %165
  %182 = shl i32 %179, 1
  %183 = call i32 @llvm.umin.i32(i32 %182, i32 1024)
  %184 = add i32 %183, %179
  %185 = call i32 @llvm.umax.i32(i32 %184, i32 8)
  %186 = zext i32 %185 to i64
  %187 = mul i64 %186, 32
  %188 = add i64 %187, 16
  %189 = call ptr @realloc(ptr null, i64 %188)
  store i32 1, ptr %189, align 4
  %190 = getelementptr inbounds i8, ptr %189, i32 4
  store i32 0, ptr %190, align 4
  %191 = getelementptr inbounds i8, ptr %189, i32 16
  %192 = call ptr @realloc(ptr null, i64 8)
  store ptr %191, ptr %192, align 8
  %193 = insertvalue { ptr, i32, i32, i32 } %25, ptr %192, 0
  %194 = insertvalue { ptr, i32, i32, i32 } %193, i32 %185, 3
  br label %216

195:                                              ; preds = %165
  %196 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %197 = icmp ult i32 %196, %179
  br i1 %197, label %198, label %199

198:                                              ; preds = %195
  br label %213

199:                                              ; preds = %195
  %200 = shl i32 %179, 1
  %201 = call i32 @llvm.umin.i32(i32 %200, i32 1024)
  %202 = add i32 %201, %179
  %203 = call i32 @llvm.umax.i32(i32 %202, i32 8)
  %204 = zext i32 %203 to i64
  %205 = mul i64 %204, 32
  %206 = add i64 %205, 16
  %207 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %208 = load ptr, ptr %207, align 8
  %209 = getelementptr inbounds i8, ptr %208, i32 -16
  %210 = call ptr @realloc(ptr %209, i64 %206)
  %211 = getelementptr inbounds i8, ptr %210, i32 16
  store ptr %211, ptr %207, align 8
  %212 = insertvalue { ptr, i32, i32, i32 } %25, i32 %203, 3
  br label %213

213:                                              ; preds = %198, %199
  %214 = phi { ptr, i32, i32, i32 } [ %212, %199 ], [ %25, %198 ]
  br label %215

215:                                              ; preds = %213
  br label %216

216:                                              ; preds = %181, %215
  %217 = phi { ptr, i32, i32, i32 } [ %214, %215 ], [ %194, %181 ]
  br label %218

218:                                              ; preds = %216
  %219 = extractvalue { ptr, i32, i32, i32 } %217, 0
  %220 = load ptr, ptr %219, align 8
  %221 = extractvalue { ptr, i32, i32, i32 } %217, 2
  %222 = zext i32 %221 to i64
  %223 = mul i64 %222, 32
  %224 = getelementptr inbounds i8, ptr %220, i64 %223
  store i252 1, ptr %224, align 16
  %225 = extractvalue { ptr, i32, i32, i32 } %217, 2
  %226 = add i32 %225, 1
  %227 = insertvalue { ptr, i32, i32, i32 } %217, i32 %226, 2
  %228 = getelementptr inbounds i8, ptr %220, i32 -12
  store i32 %226, ptr %228, align 4
  %229 = extractvalue { ptr, i32, i32, i32 } %217, 3
  %230 = icmp eq i32 %229, 0
  br i1 %230, label %231, label %245

231:                                              ; preds = %218
  %232 = shl i32 %229, 1
  %233 = call i32 @llvm.umin.i32(i32 %232, i32 1024)
  %234 = add i32 %233, %229
  %235 = call i32 @llvm.umax.i32(i32 %234, i32 8)
  %236 = zext i32 %235 to i64
  %237 = mul i64 %236, 32
  %238 = add i64 %237, 16
  %239 = call ptr @realloc(ptr null, i64 %238)
  store i32 1, ptr %239, align 4
  %240 = getelementptr inbounds i8, ptr %239, i32 4
  store i32 0, ptr %240, align 4
  %241 = getelementptr inbounds i8, ptr %239, i32 16
  %242 = call ptr @realloc(ptr null, i64 8)
  store ptr %241, ptr %242, align 8
  %243 = insertvalue { ptr, i32, i32, i32 } %227, ptr %242, 0
  %244 = insertvalue { ptr, i32, i32, i32 } %243, i32 %235, 3
  br label %265

245:                                              ; preds = %218
  %246 = icmp ult i32 %226, %229
  br i1 %246, label %247, label %248

247:                                              ; preds = %245
  br label %262

248:                                              ; preds = %245
  %249 = shl i32 %229, 1
  %250 = call i32 @llvm.umin.i32(i32 %249, i32 1024)
  %251 = add i32 %250, %229
  %252 = call i32 @llvm.umax.i32(i32 %251, i32 8)
  %253 = zext i32 %252 to i64
  %254 = mul i64 %253, 32
  %255 = add i64 %254, 16
  %256 = extractvalue { ptr, i32, i32, i32 } %217, 0
  %257 = load ptr, ptr %256, align 8
  %258 = getelementptr inbounds i8, ptr %257, i32 -16
  %259 = call ptr @realloc(ptr %258, i64 %255)
  %260 = getelementptr inbounds i8, ptr %259, i32 16
  store ptr %260, ptr %256, align 8
  %261 = insertvalue { ptr, i32, i32, i32 } %227, i32 %252, 3
  br label %262

262:                                              ; preds = %247, %248
  %263 = phi { ptr, i32, i32, i32 } [ %261, %248 ], [ %227, %247 ]
  br label %264

264:                                              ; preds = %262
  br label %265

265:                                              ; preds = %231, %264
  %266 = phi { ptr, i32, i32, i32 } [ %263, %264 ], [ %244, %231 ]
  br label %267

267:                                              ; preds = %265
  %268 = extractvalue { ptr, i32, i32, i32 } %266, 0
  %269 = load ptr, ptr %268, align 8
  %270 = extractvalue { ptr, i32, i32, i32 } %266, 2
  %271 = zext i32 %270 to i64
  %272 = mul i64 %271, 32
  %273 = getelementptr inbounds i8, ptr %269, i64 %272
  store i252 %178, ptr %273, align 16
  %274 = extractvalue { ptr, i32, i32, i32 } %266, 2
  %275 = add i32 %274, 1
  %276 = insertvalue { ptr, i32, i32, i32 } %266, i32 %275, 2
  %277 = getelementptr inbounds i8, ptr %269, i32 -12
  store i32 %275, ptr %277, align 4
  %278 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %173, 0
  %279 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %26, i64 %32, { { ptr, i32, i32, i32 } } %278, { ptr, i32, i32, i32 } %276)
  %280 = extractvalue { i64, i64, { i64, [24 x i8] } } %279, 0
  %281 = extractvalue { i64, i64, { i64, [24 x i8] } } %279, 1
  %282 = extractvalue { i64, i64, { i64, [24 x i8] } } %279, 2
  store { i64, [24 x i8] } %282, ptr %19, align 8
  %283 = load i1, ptr %19, align 1
  switch i1 %283, label %409 [
    i1 false, label %411
    i1 true, label %527
  ]

284:                                              ; preds = %40
  %285 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %12, align 16
  %286 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %285, 1
  %287 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %286)
  %288 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %287, 0
  %289 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %287, 1
  %290 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %289, 0
  %291 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %289, 4
  %292 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %289, 5
  call void @"drop$38"({ ptr, i32, i32, i32 } %291)
  call void @"drop$38"({ ptr, i32, i32, i32 } %292)
  %293 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %290)
  %294 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %293, 0
  %295 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %293, 1
  %296 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %295, 0
  %297 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %296)
  %298 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %297, 0
  %299 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %297, 1
  %300 = extractvalue { ptr, i32, i32, i32 } %299, 1
  %301 = extractvalue { ptr, i32, i32, i32 } %299, 2
  %302 = sub i32 %301, %300
  call void @"drop$43"({ ptr, i32, i32, i32 } %299)
  %303 = zext i32 %302 to i252
  %304 = extractvalue { ptr, i32, i32, i32 } %25, 3
  %305 = icmp eq i32 %304, 0
  br i1 %305, label %306, label %320

306:                                              ; preds = %284
  %307 = shl i32 %304, 1
  %308 = call i32 @llvm.umin.i32(i32 %307, i32 1024)
  %309 = add i32 %308, %304
  %310 = call i32 @llvm.umax.i32(i32 %309, i32 8)
  %311 = zext i32 %310 to i64
  %312 = mul i64 %311, 32
  %313 = add i64 %312, 16
  %314 = call ptr @realloc(ptr null, i64 %313)
  store i32 1, ptr %314, align 4
  %315 = getelementptr inbounds i8, ptr %314, i32 4
  store i32 0, ptr %315, align 4
  %316 = getelementptr inbounds i8, ptr %314, i32 16
  %317 = call ptr @realloc(ptr null, i64 8)
  store ptr %316, ptr %317, align 8
  %318 = insertvalue { ptr, i32, i32, i32 } %25, ptr %317, 0
  %319 = insertvalue { ptr, i32, i32, i32 } %318, i32 %310, 3
  br label %341

320:                                              ; preds = %284
  %321 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %322 = icmp ult i32 %321, %304
  br i1 %322, label %323, label %324

323:                                              ; preds = %320
  br label %338

324:                                              ; preds = %320
  %325 = shl i32 %304, 1
  %326 = call i32 @llvm.umin.i32(i32 %325, i32 1024)
  %327 = add i32 %326, %304
  %328 = call i32 @llvm.umax.i32(i32 %327, i32 8)
  %329 = zext i32 %328 to i64
  %330 = mul i64 %329, 32
  %331 = add i64 %330, 16
  %332 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %333 = load ptr, ptr %332, align 8
  %334 = getelementptr inbounds i8, ptr %333, i32 -16
  %335 = call ptr @realloc(ptr %334, i64 %331)
  %336 = getelementptr inbounds i8, ptr %335, i32 16
  store ptr %336, ptr %332, align 8
  %337 = insertvalue { ptr, i32, i32, i32 } %25, i32 %328, 3
  br label %338

338:                                              ; preds = %323, %324
  %339 = phi { ptr, i32, i32, i32 } [ %337, %324 ], [ %25, %323 ]
  br label %340

340:                                              ; preds = %338
  br label %341

341:                                              ; preds = %306, %340
  %342 = phi { ptr, i32, i32, i32 } [ %339, %340 ], [ %319, %306 ]
  br label %343

343:                                              ; preds = %341
  %344 = extractvalue { ptr, i32, i32, i32 } %342, 0
  %345 = load ptr, ptr %344, align 8
  %346 = extractvalue { ptr, i32, i32, i32 } %342, 2
  %347 = zext i32 %346 to i64
  %348 = mul i64 %347, 32
  %349 = getelementptr inbounds i8, ptr %345, i64 %348
  store i252 2, ptr %349, align 16
  %350 = extractvalue { ptr, i32, i32, i32 } %342, 2
  %351 = add i32 %350, 1
  %352 = insertvalue { ptr, i32, i32, i32 } %342, i32 %351, 2
  %353 = getelementptr inbounds i8, ptr %345, i32 -12
  store i32 %351, ptr %353, align 4
  %354 = extractvalue { ptr, i32, i32, i32 } %342, 3
  %355 = icmp eq i32 %354, 0
  br i1 %355, label %356, label %370

356:                                              ; preds = %343
  %357 = shl i32 %354, 1
  %358 = call i32 @llvm.umin.i32(i32 %357, i32 1024)
  %359 = add i32 %358, %354
  %360 = call i32 @llvm.umax.i32(i32 %359, i32 8)
  %361 = zext i32 %360 to i64
  %362 = mul i64 %361, 32
  %363 = add i64 %362, 16
  %364 = call ptr @realloc(ptr null, i64 %363)
  store i32 1, ptr %364, align 4
  %365 = getelementptr inbounds i8, ptr %364, i32 4
  store i32 0, ptr %365, align 4
  %366 = getelementptr inbounds i8, ptr %364, i32 16
  %367 = call ptr @realloc(ptr null, i64 8)
  store ptr %366, ptr %367, align 8
  %368 = insertvalue { ptr, i32, i32, i32 } %352, ptr %367, 0
  %369 = insertvalue { ptr, i32, i32, i32 } %368, i32 %360, 3
  br label %390

370:                                              ; preds = %343
  %371 = icmp ult i32 %351, %354
  br i1 %371, label %372, label %373

372:                                              ; preds = %370
  br label %387

373:                                              ; preds = %370
  %374 = shl i32 %354, 1
  %375 = call i32 @llvm.umin.i32(i32 %374, i32 1024)
  %376 = add i32 %375, %354
  %377 = call i32 @llvm.umax.i32(i32 %376, i32 8)
  %378 = zext i32 %377 to i64
  %379 = mul i64 %378, 32
  %380 = add i64 %379, 16
  %381 = extractvalue { ptr, i32, i32, i32 } %342, 0
  %382 = load ptr, ptr %381, align 8
  %383 = getelementptr inbounds i8, ptr %382, i32 -16
  %384 = call ptr @realloc(ptr %383, i64 %380)
  %385 = getelementptr inbounds i8, ptr %384, i32 16
  store ptr %385, ptr %381, align 8
  %386 = insertvalue { ptr, i32, i32, i32 } %352, i32 %377, 3
  br label %387

387:                                              ; preds = %372, %373
  %388 = phi { ptr, i32, i32, i32 } [ %386, %373 ], [ %352, %372 ]
  br label %389

389:                                              ; preds = %387
  br label %390

390:                                              ; preds = %356, %389
  %391 = phi { ptr, i32, i32, i32 } [ %388, %389 ], [ %369, %356 ]
  br label %392

392:                                              ; preds = %390
  %393 = extractvalue { ptr, i32, i32, i32 } %391, 0
  %394 = load ptr, ptr %393, align 8
  %395 = extractvalue { ptr, i32, i32, i32 } %391, 2
  %396 = zext i32 %395 to i64
  %397 = mul i64 %396, 32
  %398 = getelementptr inbounds i8, ptr %394, i64 %397
  store i252 %303, ptr %398, align 16
  %399 = extractvalue { ptr, i32, i32, i32 } %391, 2
  %400 = add i32 %399, 1
  %401 = insertvalue { ptr, i32, i32, i32 } %391, i32 %400, 2
  %402 = getelementptr inbounds i8, ptr %394, i32 -12
  store i32 %400, ptr %402, align 4
  %403 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %298, 0
  %404 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %26, i64 %32, { { ptr, i32, i32, i32 } } %403, { ptr, i32, i32, i32 } %401)
  %405 = extractvalue { i64, i64, { i64, [24 x i8] } } %404, 0
  %406 = extractvalue { i64, i64, { i64, [24 x i8] } } %404, 1
  %407 = extractvalue { i64, i64, { i64, [24 x i8] } } %404, 2
  store { i64, [24 x i8] } %407, ptr %13, align 8
  %408 = load i1, ptr %13, align 1
  switch i1 %408, label %541 [
    i1 false, label %543
    i1 true, label %893
  ]

409:                                              ; preds = %267
  br i1 false, label %410, label %1073

410:                                              ; preds = %409
  unreachable

411:                                              ; preds = %267
  %412 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %19, align 8
  %413 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %412, 1
  %414 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %415 = call ptr %414()
  %416 = load i64, ptr %415, align 8
  %417 = mul i64 %416, 6970
  %418 = call i64 @llvm.uadd.sat.i64(i64 %281, i64 %417)
  %419 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %169)
  %420 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %419, 0
  %421 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %419, 1
  %422 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %421, 0
  %423 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %421, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %422)
  %424 = zext i32 %423 to i252
  %425 = extractvalue { { ptr, i32, i32, i32 }, {} } %413, 0
  %426 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %420, 0
  %427 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %420, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %426)
  %428 = extractvalue { ptr, i32, i32, i32 } %425, 3
  %429 = icmp eq i32 %428, 0
  br i1 %429, label %430, label %444

430:                                              ; preds = %411
  %431 = shl i32 %428, 1
  %432 = call i32 @llvm.umin.i32(i32 %431, i32 1024)
  %433 = add i32 %432, %428
  %434 = call i32 @llvm.umax.i32(i32 %433, i32 8)
  %435 = zext i32 %434 to i64
  %436 = mul i64 %435, 32
  %437 = add i64 %436, 16
  %438 = call ptr @realloc(ptr null, i64 %437)
  store i32 1, ptr %438, align 4
  %439 = getelementptr inbounds i8, ptr %438, i32 4
  store i32 0, ptr %439, align 4
  %440 = getelementptr inbounds i8, ptr %438, i32 16
  %441 = call ptr @realloc(ptr null, i64 8)
  store ptr %440, ptr %441, align 8
  %442 = insertvalue { ptr, i32, i32, i32 } %425, ptr %441, 0
  %443 = insertvalue { ptr, i32, i32, i32 } %442, i32 %434, 3
  br label %465

444:                                              ; preds = %411
  %445 = extractvalue { ptr, i32, i32, i32 } %425, 2
  %446 = icmp ult i32 %445, %428
  br i1 %446, label %447, label %448

447:                                              ; preds = %444
  br label %462

448:                                              ; preds = %444
  %449 = shl i32 %428, 1
  %450 = call i32 @llvm.umin.i32(i32 %449, i32 1024)
  %451 = add i32 %450, %428
  %452 = call i32 @llvm.umax.i32(i32 %451, i32 8)
  %453 = zext i32 %452 to i64
  %454 = mul i64 %453, 32
  %455 = add i64 %454, 16
  %456 = extractvalue { ptr, i32, i32, i32 } %425, 0
  %457 = load ptr, ptr %456, align 8
  %458 = getelementptr inbounds i8, ptr %457, i32 -16
  %459 = call ptr @realloc(ptr %458, i64 %455)
  %460 = getelementptr inbounds i8, ptr %459, i32 16
  store ptr %460, ptr %456, align 8
  %461 = insertvalue { ptr, i32, i32, i32 } %425, i32 %452, 3
  br label %462

462:                                              ; preds = %447, %448
  %463 = phi { ptr, i32, i32, i32 } [ %461, %448 ], [ %425, %447 ]
  br label %464

464:                                              ; preds = %462
  br label %465

465:                                              ; preds = %430, %464
  %466 = phi { ptr, i32, i32, i32 } [ %463, %464 ], [ %443, %430 ]
  br label %467

467:                                              ; preds = %465
  %468 = extractvalue { ptr, i32, i32, i32 } %466, 0
  %469 = load ptr, ptr %468, align 8
  %470 = extractvalue { ptr, i32, i32, i32 } %466, 2
  %471 = zext i32 %470 to i64
  %472 = mul i64 %471, 32
  %473 = getelementptr inbounds i8, ptr %469, i64 %472
  store i252 %427, ptr %473, align 16
  %474 = extractvalue { ptr, i32, i32, i32 } %466, 2
  %475 = add i32 %474, 1
  %476 = insertvalue { ptr, i32, i32, i32 } %466, i32 %475, 2
  %477 = getelementptr inbounds i8, ptr %469, i32 -12
  store i32 %475, ptr %477, align 4
  %478 = extractvalue { ptr, i32, i32, i32 } %466, 3
  %479 = icmp eq i32 %478, 0
  br i1 %479, label %480, label %494

480:                                              ; preds = %467
  %481 = shl i32 %478, 1
  %482 = call i32 @llvm.umin.i32(i32 %481, i32 1024)
  %483 = add i32 %482, %478
  %484 = call i32 @llvm.umax.i32(i32 %483, i32 8)
  %485 = zext i32 %484 to i64
  %486 = mul i64 %485, 32
  %487 = add i64 %486, 16
  %488 = call ptr @realloc(ptr null, i64 %487)
  store i32 1, ptr %488, align 4
  %489 = getelementptr inbounds i8, ptr %488, i32 4
  store i32 0, ptr %489, align 4
  %490 = getelementptr inbounds i8, ptr %488, i32 16
  %491 = call ptr @realloc(ptr null, i64 8)
  store ptr %490, ptr %491, align 8
  %492 = insertvalue { ptr, i32, i32, i32 } %476, ptr %491, 0
  %493 = insertvalue { ptr, i32, i32, i32 } %492, i32 %484, 3
  br label %514

494:                                              ; preds = %467
  %495 = icmp ult i32 %475, %478
  br i1 %495, label %496, label %497

496:                                              ; preds = %494
  br label %511

497:                                              ; preds = %494
  %498 = shl i32 %478, 1
  %499 = call i32 @llvm.umin.i32(i32 %498, i32 1024)
  %500 = add i32 %499, %478
  %501 = call i32 @llvm.umax.i32(i32 %500, i32 8)
  %502 = zext i32 %501 to i64
  %503 = mul i64 %502, 32
  %504 = add i64 %503, 16
  %505 = extractvalue { ptr, i32, i32, i32 } %466, 0
  %506 = load ptr, ptr %505, align 8
  %507 = getelementptr inbounds i8, ptr %506, i32 -16
  %508 = call ptr @realloc(ptr %507, i64 %504)
  %509 = getelementptr inbounds i8, ptr %508, i32 16
  store ptr %509, ptr %505, align 8
  %510 = insertvalue { ptr, i32, i32, i32 } %476, i32 %501, 3
  br label %511

511:                                              ; preds = %496, %497
  %512 = phi { ptr, i32, i32, i32 } [ %510, %497 ], [ %476, %496 ]
  br label %513

513:                                              ; preds = %511
  br label %514

514:                                              ; preds = %480, %513
  %515 = phi { ptr, i32, i32, i32 } [ %512, %513 ], [ %493, %480 ]
  br label %516

516:                                              ; preds = %514
  %517 = extractvalue { ptr, i32, i32, i32 } %515, 0
  %518 = load ptr, ptr %517, align 8
  %519 = extractvalue { ptr, i32, i32, i32 } %515, 2
  %520 = zext i32 %519 to i64
  %521 = mul i64 %520, 32
  %522 = getelementptr inbounds i8, ptr %518, i64 %521
  store i252 %424, ptr %522, align 16
  %523 = extractvalue { ptr, i32, i32, i32 } %515, 2
  %524 = add i32 %523, 1
  %525 = insertvalue { ptr, i32, i32, i32 } %515, i32 %524, 2
  %526 = getelementptr inbounds i8, ptr %518, i32 -12
  store i32 %524, ptr %526, align 4
  br label %1004

527:                                              ; preds = %267
  %528 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %19, align 8
  %529 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %528, 1
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %169)
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %54)
  %530 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %529, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %530, ptr %20, align 8
  %531 = load { i64, [24 x i8] }, ptr %20, align 8
  %532 = extractvalue { ptr, ptr, i64 } %8, 1
  %533 = load i64, ptr %532, align 8
  %534 = icmp eq i64 %533, 0
  %535 = sub i64 %533, 1
  %536 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %535, ptr %536, align 8
  br i1 %534, label %537, label %1013

537:                                              ; preds = %527
  %538 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %280, 0
  %539 = insertvalue { i64, i64, { i64, [24 x i8] } } %538, i64 %281, 1
  %540 = insertvalue { i64, i64, { i64, [24 x i8] } } %539, { i64, [24 x i8] } %531, 2
  ret { i64, i64, { i64, [24 x i8] } } %540

541:                                              ; preds = %392
  br i1 false, label %542, label %1074

542:                                              ; preds = %541
  unreachable

543:                                              ; preds = %392
  %544 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %545 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %544, 1
  %546 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %294)
  %547 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %546, 0
  %548 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %546, 1
  %549 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %548, 0
  %550 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %548, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %549)
  %551 = zext i32 %550 to i252
  %552 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %288)
  %553 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %552, 0
  %554 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %552, 1
  %555 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %554, 0
  %556 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %554, 1
  %557 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %554, 4
  %558 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %554, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %555)
  call void @"drop$38"({ ptr, i32, i32, i32 } %557)
  call void @"drop$38"({ ptr, i32, i32, i32 } %558)
  %559 = zext i16 %556 to i252
  %560 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %553)
  %561 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %560, 0
  %562 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %560, 1
  %563 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %562, 0
  %564 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %562, 2
  %565 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %562, 4
  %566 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %562, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %563)
  call void @"drop$38"({ ptr, i32, i32, i32 } %565)
  call void @"drop$38"({ ptr, i32, i32, i32 } %566)
  %567 = zext i8 %564 to i252
  %568 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %561)
  %569 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %568, 0
  %570 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %568, 1
  %571 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %570, 0
  %572 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %570, 3
  %573 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %570, 4
  %574 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %570, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %571)
  call void @"drop$38"({ ptr, i32, i32, i32 } %573)
  call void @"drop$38"({ ptr, i32, i32, i32 } %574)
  %575 = zext i32 %572 to i252
  %576 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %569)
  %577 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %576, 0
  %578 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %576, 1
  %579 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %578, 0
  %580 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %578, 4
  %581 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %578, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %579)
  call void @"drop$38"({ ptr, i32, i32, i32 } %581)
  %582 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$38"({ ptr, i32, i32, i32 } %580)
  %583 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %582, 0
  %584 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %582, 1
  %585 = extractvalue { ptr, i32, i32, i32 } %584, 1
  %586 = extractvalue { ptr, i32, i32, i32 } %584, 2
  %587 = sub i32 %586, %585
  call void @"drop$38"({ ptr, i32, i32, i32 } %584)
  %588 = zext i32 %587 to i252
  %589 = extractvalue { { ptr, i32, i32, i32 }, {} } %545, 0
  %590 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %547, 0
  %591 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %547, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %590)
  %592 = extractvalue { ptr, i32, i32, i32 } %589, 3
  %593 = icmp eq i32 %592, 0
  br i1 %593, label %594, label %608

594:                                              ; preds = %543
  %595 = shl i32 %592, 1
  %596 = call i32 @llvm.umin.i32(i32 %595, i32 1024)
  %597 = add i32 %596, %592
  %598 = call i32 @llvm.umax.i32(i32 %597, i32 8)
  %599 = zext i32 %598 to i64
  %600 = mul i64 %599, 32
  %601 = add i64 %600, 16
  %602 = call ptr @realloc(ptr null, i64 %601)
  store i32 1, ptr %602, align 4
  %603 = getelementptr inbounds i8, ptr %602, i32 4
  store i32 0, ptr %603, align 4
  %604 = getelementptr inbounds i8, ptr %602, i32 16
  %605 = call ptr @realloc(ptr null, i64 8)
  store ptr %604, ptr %605, align 8
  %606 = insertvalue { ptr, i32, i32, i32 } %589, ptr %605, 0
  %607 = insertvalue { ptr, i32, i32, i32 } %606, i32 %598, 3
  br label %629

608:                                              ; preds = %543
  %609 = extractvalue { ptr, i32, i32, i32 } %589, 2
  %610 = icmp ult i32 %609, %592
  br i1 %610, label %611, label %612

611:                                              ; preds = %608
  br label %626

612:                                              ; preds = %608
  %613 = shl i32 %592, 1
  %614 = call i32 @llvm.umin.i32(i32 %613, i32 1024)
  %615 = add i32 %614, %592
  %616 = call i32 @llvm.umax.i32(i32 %615, i32 8)
  %617 = zext i32 %616 to i64
  %618 = mul i64 %617, 32
  %619 = add i64 %618, 16
  %620 = extractvalue { ptr, i32, i32, i32 } %589, 0
  %621 = load ptr, ptr %620, align 8
  %622 = getelementptr inbounds i8, ptr %621, i32 -16
  %623 = call ptr @realloc(ptr %622, i64 %619)
  %624 = getelementptr inbounds i8, ptr %623, i32 16
  store ptr %624, ptr %620, align 8
  %625 = insertvalue { ptr, i32, i32, i32 } %589, i32 %616, 3
  br label %626

626:                                              ; preds = %611, %612
  %627 = phi { ptr, i32, i32, i32 } [ %625, %612 ], [ %589, %611 ]
  br label %628

628:                                              ; preds = %626
  br label %629

629:                                              ; preds = %594, %628
  %630 = phi { ptr, i32, i32, i32 } [ %627, %628 ], [ %607, %594 ]
  br label %631

631:                                              ; preds = %629
  %632 = extractvalue { ptr, i32, i32, i32 } %630, 0
  %633 = load ptr, ptr %632, align 8
  %634 = extractvalue { ptr, i32, i32, i32 } %630, 2
  %635 = zext i32 %634 to i64
  %636 = mul i64 %635, 32
  %637 = getelementptr inbounds i8, ptr %633, i64 %636
  store i252 %591, ptr %637, align 16
  %638 = extractvalue { ptr, i32, i32, i32 } %630, 2
  %639 = add i32 %638, 1
  %640 = insertvalue { ptr, i32, i32, i32 } %630, i32 %639, 2
  %641 = getelementptr inbounds i8, ptr %633, i32 -12
  store i32 %639, ptr %641, align 4
  %642 = extractvalue { ptr, i32, i32, i32 } %630, 3
  %643 = icmp eq i32 %642, 0
  br i1 %643, label %644, label %658

644:                                              ; preds = %631
  %645 = shl i32 %642, 1
  %646 = call i32 @llvm.umin.i32(i32 %645, i32 1024)
  %647 = add i32 %646, %642
  %648 = call i32 @llvm.umax.i32(i32 %647, i32 8)
  %649 = zext i32 %648 to i64
  %650 = mul i64 %649, 32
  %651 = add i64 %650, 16
  %652 = call ptr @realloc(ptr null, i64 %651)
  store i32 1, ptr %652, align 4
  %653 = getelementptr inbounds i8, ptr %652, i32 4
  store i32 0, ptr %653, align 4
  %654 = getelementptr inbounds i8, ptr %652, i32 16
  %655 = call ptr @realloc(ptr null, i64 8)
  store ptr %654, ptr %655, align 8
  %656 = insertvalue { ptr, i32, i32, i32 } %640, ptr %655, 0
  %657 = insertvalue { ptr, i32, i32, i32 } %656, i32 %648, 3
  br label %678

658:                                              ; preds = %631
  %659 = icmp ult i32 %639, %642
  br i1 %659, label %660, label %661

660:                                              ; preds = %658
  br label %675

661:                                              ; preds = %658
  %662 = shl i32 %642, 1
  %663 = call i32 @llvm.umin.i32(i32 %662, i32 1024)
  %664 = add i32 %663, %642
  %665 = call i32 @llvm.umax.i32(i32 %664, i32 8)
  %666 = zext i32 %665 to i64
  %667 = mul i64 %666, 32
  %668 = add i64 %667, 16
  %669 = extractvalue { ptr, i32, i32, i32 } %630, 0
  %670 = load ptr, ptr %669, align 8
  %671 = getelementptr inbounds i8, ptr %670, i32 -16
  %672 = call ptr @realloc(ptr %671, i64 %668)
  %673 = getelementptr inbounds i8, ptr %672, i32 16
  store ptr %673, ptr %669, align 8
  %674 = insertvalue { ptr, i32, i32, i32 } %640, i32 %665, 3
  br label %675

675:                                              ; preds = %660, %661
  %676 = phi { ptr, i32, i32, i32 } [ %674, %661 ], [ %640, %660 ]
  br label %677

677:                                              ; preds = %675
  br label %678

678:                                              ; preds = %644, %677
  %679 = phi { ptr, i32, i32, i32 } [ %676, %677 ], [ %657, %644 ]
  br label %680

680:                                              ; preds = %678
  %681 = extractvalue { ptr, i32, i32, i32 } %679, 0
  %682 = load ptr, ptr %681, align 8
  %683 = extractvalue { ptr, i32, i32, i32 } %679, 2
  %684 = zext i32 %683 to i64
  %685 = mul i64 %684, 32
  %686 = getelementptr inbounds i8, ptr %682, i64 %685
  store i252 %551, ptr %686, align 16
  %687 = extractvalue { ptr, i32, i32, i32 } %679, 2
  %688 = add i32 %687, 1
  %689 = insertvalue { ptr, i32, i32, i32 } %679, i32 %688, 2
  %690 = getelementptr inbounds i8, ptr %682, i32 -12
  store i32 %688, ptr %690, align 4
  %691 = extractvalue { ptr, i32, i32, i32 } %679, 3
  %692 = icmp eq i32 %691, 0
  br i1 %692, label %693, label %707

693:                                              ; preds = %680
  %694 = shl i32 %691, 1
  %695 = call i32 @llvm.umin.i32(i32 %694, i32 1024)
  %696 = add i32 %695, %691
  %697 = call i32 @llvm.umax.i32(i32 %696, i32 8)
  %698 = zext i32 %697 to i64
  %699 = mul i64 %698, 32
  %700 = add i64 %699, 16
  %701 = call ptr @realloc(ptr null, i64 %700)
  store i32 1, ptr %701, align 4
  %702 = getelementptr inbounds i8, ptr %701, i32 4
  store i32 0, ptr %702, align 4
  %703 = getelementptr inbounds i8, ptr %701, i32 16
  %704 = call ptr @realloc(ptr null, i64 8)
  store ptr %703, ptr %704, align 8
  %705 = insertvalue { ptr, i32, i32, i32 } %689, ptr %704, 0
  %706 = insertvalue { ptr, i32, i32, i32 } %705, i32 %697, 3
  br label %727

707:                                              ; preds = %680
  %708 = icmp ult i32 %688, %691
  br i1 %708, label %709, label %710

709:                                              ; preds = %707
  br label %724

710:                                              ; preds = %707
  %711 = shl i32 %691, 1
  %712 = call i32 @llvm.umin.i32(i32 %711, i32 1024)
  %713 = add i32 %712, %691
  %714 = call i32 @llvm.umax.i32(i32 %713, i32 8)
  %715 = zext i32 %714 to i64
  %716 = mul i64 %715, 32
  %717 = add i64 %716, 16
  %718 = extractvalue { ptr, i32, i32, i32 } %679, 0
  %719 = load ptr, ptr %718, align 8
  %720 = getelementptr inbounds i8, ptr %719, i32 -16
  %721 = call ptr @realloc(ptr %720, i64 %717)
  %722 = getelementptr inbounds i8, ptr %721, i32 16
  store ptr %722, ptr %718, align 8
  %723 = insertvalue { ptr, i32, i32, i32 } %689, i32 %714, 3
  br label %724

724:                                              ; preds = %709, %710
  %725 = phi { ptr, i32, i32, i32 } [ %723, %710 ], [ %689, %709 ]
  br label %726

726:                                              ; preds = %724
  br label %727

727:                                              ; preds = %693, %726
  %728 = phi { ptr, i32, i32, i32 } [ %725, %726 ], [ %706, %693 ]
  br label %729

729:                                              ; preds = %727
  %730 = extractvalue { ptr, i32, i32, i32 } %728, 0
  %731 = load ptr, ptr %730, align 8
  %732 = extractvalue { ptr, i32, i32, i32 } %728, 2
  %733 = zext i32 %732 to i64
  %734 = mul i64 %733, 32
  %735 = getelementptr inbounds i8, ptr %731, i64 %734
  store i252 %559, ptr %735, align 16
  %736 = extractvalue { ptr, i32, i32, i32 } %728, 2
  %737 = add i32 %736, 1
  %738 = insertvalue { ptr, i32, i32, i32 } %728, i32 %737, 2
  %739 = getelementptr inbounds i8, ptr %731, i32 -12
  store i32 %737, ptr %739, align 4
  %740 = extractvalue { ptr, i32, i32, i32 } %728, 3
  %741 = icmp eq i32 %740, 0
  br i1 %741, label %742, label %756

742:                                              ; preds = %729
  %743 = shl i32 %740, 1
  %744 = call i32 @llvm.umin.i32(i32 %743, i32 1024)
  %745 = add i32 %744, %740
  %746 = call i32 @llvm.umax.i32(i32 %745, i32 8)
  %747 = zext i32 %746 to i64
  %748 = mul i64 %747, 32
  %749 = add i64 %748, 16
  %750 = call ptr @realloc(ptr null, i64 %749)
  store i32 1, ptr %750, align 4
  %751 = getelementptr inbounds i8, ptr %750, i32 4
  store i32 0, ptr %751, align 4
  %752 = getelementptr inbounds i8, ptr %750, i32 16
  %753 = call ptr @realloc(ptr null, i64 8)
  store ptr %752, ptr %753, align 8
  %754 = insertvalue { ptr, i32, i32, i32 } %738, ptr %753, 0
  %755 = insertvalue { ptr, i32, i32, i32 } %754, i32 %746, 3
  br label %776

756:                                              ; preds = %729
  %757 = icmp ult i32 %737, %740
  br i1 %757, label %758, label %759

758:                                              ; preds = %756
  br label %773

759:                                              ; preds = %756
  %760 = shl i32 %740, 1
  %761 = call i32 @llvm.umin.i32(i32 %760, i32 1024)
  %762 = add i32 %761, %740
  %763 = call i32 @llvm.umax.i32(i32 %762, i32 8)
  %764 = zext i32 %763 to i64
  %765 = mul i64 %764, 32
  %766 = add i64 %765, 16
  %767 = extractvalue { ptr, i32, i32, i32 } %728, 0
  %768 = load ptr, ptr %767, align 8
  %769 = getelementptr inbounds i8, ptr %768, i32 -16
  %770 = call ptr @realloc(ptr %769, i64 %766)
  %771 = getelementptr inbounds i8, ptr %770, i32 16
  store ptr %771, ptr %767, align 8
  %772 = insertvalue { ptr, i32, i32, i32 } %738, i32 %763, 3
  br label %773

773:                                              ; preds = %758, %759
  %774 = phi { ptr, i32, i32, i32 } [ %772, %759 ], [ %738, %758 ]
  br label %775

775:                                              ; preds = %773
  br label %776

776:                                              ; preds = %742, %775
  %777 = phi { ptr, i32, i32, i32 } [ %774, %775 ], [ %755, %742 ]
  br label %778

778:                                              ; preds = %776
  %779 = extractvalue { ptr, i32, i32, i32 } %777, 0
  %780 = load ptr, ptr %779, align 8
  %781 = extractvalue { ptr, i32, i32, i32 } %777, 2
  %782 = zext i32 %781 to i64
  %783 = mul i64 %782, 32
  %784 = getelementptr inbounds i8, ptr %780, i64 %783
  store i252 %567, ptr %784, align 16
  %785 = extractvalue { ptr, i32, i32, i32 } %777, 2
  %786 = add i32 %785, 1
  %787 = insertvalue { ptr, i32, i32, i32 } %777, i32 %786, 2
  %788 = getelementptr inbounds i8, ptr %780, i32 -12
  store i32 %786, ptr %788, align 4
  %789 = extractvalue { ptr, i32, i32, i32 } %777, 3
  %790 = icmp eq i32 %789, 0
  br i1 %790, label %791, label %805

791:                                              ; preds = %778
  %792 = shl i32 %789, 1
  %793 = call i32 @llvm.umin.i32(i32 %792, i32 1024)
  %794 = add i32 %793, %789
  %795 = call i32 @llvm.umax.i32(i32 %794, i32 8)
  %796 = zext i32 %795 to i64
  %797 = mul i64 %796, 32
  %798 = add i64 %797, 16
  %799 = call ptr @realloc(ptr null, i64 %798)
  store i32 1, ptr %799, align 4
  %800 = getelementptr inbounds i8, ptr %799, i32 4
  store i32 0, ptr %800, align 4
  %801 = getelementptr inbounds i8, ptr %799, i32 16
  %802 = call ptr @realloc(ptr null, i64 8)
  store ptr %801, ptr %802, align 8
  %803 = insertvalue { ptr, i32, i32, i32 } %787, ptr %802, 0
  %804 = insertvalue { ptr, i32, i32, i32 } %803, i32 %795, 3
  br label %825

805:                                              ; preds = %778
  %806 = icmp ult i32 %786, %789
  br i1 %806, label %807, label %808

807:                                              ; preds = %805
  br label %822

808:                                              ; preds = %805
  %809 = shl i32 %789, 1
  %810 = call i32 @llvm.umin.i32(i32 %809, i32 1024)
  %811 = add i32 %810, %789
  %812 = call i32 @llvm.umax.i32(i32 %811, i32 8)
  %813 = zext i32 %812 to i64
  %814 = mul i64 %813, 32
  %815 = add i64 %814, 16
  %816 = extractvalue { ptr, i32, i32, i32 } %777, 0
  %817 = load ptr, ptr %816, align 8
  %818 = getelementptr inbounds i8, ptr %817, i32 -16
  %819 = call ptr @realloc(ptr %818, i64 %815)
  %820 = getelementptr inbounds i8, ptr %819, i32 16
  store ptr %820, ptr %816, align 8
  %821 = insertvalue { ptr, i32, i32, i32 } %787, i32 %812, 3
  br label %822

822:                                              ; preds = %807, %808
  %823 = phi { ptr, i32, i32, i32 } [ %821, %808 ], [ %787, %807 ]
  br label %824

824:                                              ; preds = %822
  br label %825

825:                                              ; preds = %791, %824
  %826 = phi { ptr, i32, i32, i32 } [ %823, %824 ], [ %804, %791 ]
  br label %827

827:                                              ; preds = %825
  %828 = extractvalue { ptr, i32, i32, i32 } %826, 0
  %829 = load ptr, ptr %828, align 8
  %830 = extractvalue { ptr, i32, i32, i32 } %826, 2
  %831 = zext i32 %830 to i64
  %832 = mul i64 %831, 32
  %833 = getelementptr inbounds i8, ptr %829, i64 %832
  store i252 %575, ptr %833, align 16
  %834 = extractvalue { ptr, i32, i32, i32 } %826, 2
  %835 = add i32 %834, 1
  %836 = insertvalue { ptr, i32, i32, i32 } %826, i32 %835, 2
  %837 = getelementptr inbounds i8, ptr %829, i32 -12
  store i32 %835, ptr %837, align 4
  %838 = extractvalue { ptr, i32, i32, i32 } %826, 3
  %839 = icmp eq i32 %838, 0
  br i1 %839, label %840, label %854

840:                                              ; preds = %827
  %841 = shl i32 %838, 1
  %842 = call i32 @llvm.umin.i32(i32 %841, i32 1024)
  %843 = add i32 %842, %838
  %844 = call i32 @llvm.umax.i32(i32 %843, i32 8)
  %845 = zext i32 %844 to i64
  %846 = mul i64 %845, 32
  %847 = add i64 %846, 16
  %848 = call ptr @realloc(ptr null, i64 %847)
  store i32 1, ptr %848, align 4
  %849 = getelementptr inbounds i8, ptr %848, i32 4
  store i32 0, ptr %849, align 4
  %850 = getelementptr inbounds i8, ptr %848, i32 16
  %851 = call ptr @realloc(ptr null, i64 8)
  store ptr %850, ptr %851, align 8
  %852 = insertvalue { ptr, i32, i32, i32 } %836, ptr %851, 0
  %853 = insertvalue { ptr, i32, i32, i32 } %852, i32 %844, 3
  br label %874

854:                                              ; preds = %827
  %855 = icmp ult i32 %835, %838
  br i1 %855, label %856, label %857

856:                                              ; preds = %854
  br label %871

857:                                              ; preds = %854
  %858 = shl i32 %838, 1
  %859 = call i32 @llvm.umin.i32(i32 %858, i32 1024)
  %860 = add i32 %859, %838
  %861 = call i32 @llvm.umax.i32(i32 %860, i32 8)
  %862 = zext i32 %861 to i64
  %863 = mul i64 %862, 32
  %864 = add i64 %863, 16
  %865 = extractvalue { ptr, i32, i32, i32 } %826, 0
  %866 = load ptr, ptr %865, align 8
  %867 = getelementptr inbounds i8, ptr %866, i32 -16
  %868 = call ptr @realloc(ptr %867, i64 %864)
  %869 = getelementptr inbounds i8, ptr %868, i32 16
  store ptr %869, ptr %865, align 8
  %870 = insertvalue { ptr, i32, i32, i32 } %836, i32 %861, 3
  br label %871

871:                                              ; preds = %856, %857
  %872 = phi { ptr, i32, i32, i32 } [ %870, %857 ], [ %836, %856 ]
  br label %873

873:                                              ; preds = %871
  br label %874

874:                                              ; preds = %840, %873
  %875 = phi { ptr, i32, i32, i32 } [ %872, %873 ], [ %853, %840 ]
  br label %876

876:                                              ; preds = %874
  %877 = extractvalue { ptr, i32, i32, i32 } %875, 0
  %878 = load ptr, ptr %877, align 8
  %879 = extractvalue { ptr, i32, i32, i32 } %875, 2
  %880 = zext i32 %879 to i64
  %881 = mul i64 %880, 32
  %882 = getelementptr inbounds i8, ptr %878, i64 %881
  store i252 %588, ptr %882, align 16
  %883 = extractvalue { ptr, i32, i32, i32 } %875, 2
  %884 = add i32 %883, 1
  %885 = insertvalue { ptr, i32, i32, i32 } %875, i32 %884, 2
  %886 = getelementptr inbounds i8, ptr %878, i32 -12
  store i32 %884, ptr %886, align 4
  %887 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %583, 0
  %888 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f88"(i64 %405, i64 %406, { { ptr, i32, i32, i32 } } %887, { ptr, i32, i32, i32 } %885)
  %889 = extractvalue { i64, i64, { i64, [24 x i8] } } %888, 0
  %890 = extractvalue { i64, i64, { i64, [24 x i8] } } %888, 1
  %891 = extractvalue { i64, i64, { i64, [24 x i8] } } %888, 2
  store { i64, [24 x i8] } %891, ptr %15, align 8
  %892 = load i1, ptr %15, align 1
  switch i1 %892, label %903 [
    i1 false, label %905
    i1 true, label %975
  ]

893:                                              ; preds = %392
  %894 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %895 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %894, 1
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %54)
  call void @"drop$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %288)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %294)
  %896 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %895, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %896, ptr %14, align 8
  %897 = load { i64, [24 x i8] }, ptr %14, align 8
  %898 = extractvalue { ptr, ptr, i64 } %8, 1
  %899 = load i64, ptr %898, align 8
  %900 = icmp eq i64 %899, 0
  %901 = sub i64 %899, 1
  %902 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %901, ptr %902, align 8
  br i1 %900, label %1034, label %1013

903:                                              ; preds = %876
  br i1 false, label %904, label %1075

904:                                              ; preds = %903
  unreachable

905:                                              ; preds = %876
  %906 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %15, align 8
  %907 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %906, 1
  %908 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %577, 0
  %909 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %577, 4
  %910 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %577, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %908)
  call void @"drop$38"({ ptr, i32, i32, i32 } %909)
  %911 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$38"({ ptr, i32, i32, i32 } %910)
  %912 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %911, 0
  %913 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %911, 1
  %914 = extractvalue { ptr, i32, i32, i32 } %913, 1
  %915 = extractvalue { ptr, i32, i32, i32 } %913, 2
  %916 = sub i32 %915, %914
  call void @"drop$38"({ ptr, i32, i32, i32 } %913)
  %917 = zext i32 %916 to i252
  %918 = extractvalue { { ptr, i32, i32, i32 }, {} } %907, 0
  %919 = extractvalue { ptr, i32, i32, i32 } %918, 3
  %920 = icmp eq i32 %919, 0
  br i1 %920, label %921, label %935

921:                                              ; preds = %905
  %922 = shl i32 %919, 1
  %923 = call i32 @llvm.umin.i32(i32 %922, i32 1024)
  %924 = add i32 %923, %919
  %925 = call i32 @llvm.umax.i32(i32 %924, i32 8)
  %926 = zext i32 %925 to i64
  %927 = mul i64 %926, 32
  %928 = add i64 %927, 16
  %929 = call ptr @realloc(ptr null, i64 %928)
  store i32 1, ptr %929, align 4
  %930 = getelementptr inbounds i8, ptr %929, i32 4
  store i32 0, ptr %930, align 4
  %931 = getelementptr inbounds i8, ptr %929, i32 16
  %932 = call ptr @realloc(ptr null, i64 8)
  store ptr %931, ptr %932, align 8
  %933 = insertvalue { ptr, i32, i32, i32 } %918, ptr %932, 0
  %934 = insertvalue { ptr, i32, i32, i32 } %933, i32 %925, 3
  br label %956

935:                                              ; preds = %905
  %936 = extractvalue { ptr, i32, i32, i32 } %918, 2
  %937 = icmp ult i32 %936, %919
  br i1 %937, label %938, label %939

938:                                              ; preds = %935
  br label %953

939:                                              ; preds = %935
  %940 = shl i32 %919, 1
  %941 = call i32 @llvm.umin.i32(i32 %940, i32 1024)
  %942 = add i32 %941, %919
  %943 = call i32 @llvm.umax.i32(i32 %942, i32 8)
  %944 = zext i32 %943 to i64
  %945 = mul i64 %944, 32
  %946 = add i64 %945, 16
  %947 = extractvalue { ptr, i32, i32, i32 } %918, 0
  %948 = load ptr, ptr %947, align 8
  %949 = getelementptr inbounds i8, ptr %948, i32 -16
  %950 = call ptr @realloc(ptr %949, i64 %946)
  %951 = getelementptr inbounds i8, ptr %950, i32 16
  store ptr %951, ptr %947, align 8
  %952 = insertvalue { ptr, i32, i32, i32 } %918, i32 %943, 3
  br label %953

953:                                              ; preds = %938, %939
  %954 = phi { ptr, i32, i32, i32 } [ %952, %939 ], [ %918, %938 ]
  br label %955

955:                                              ; preds = %953
  br label %956

956:                                              ; preds = %921, %955
  %957 = phi { ptr, i32, i32, i32 } [ %954, %955 ], [ %934, %921 ]
  br label %958

958:                                              ; preds = %956
  %959 = extractvalue { ptr, i32, i32, i32 } %957, 0
  %960 = load ptr, ptr %959, align 8
  %961 = extractvalue { ptr, i32, i32, i32 } %957, 2
  %962 = zext i32 %961 to i64
  %963 = mul i64 %962, 32
  %964 = getelementptr inbounds i8, ptr %960, i64 %963
  store i252 %917, ptr %964, align 16
  %965 = extractvalue { ptr, i32, i32, i32 } %957, 2
  %966 = add i32 %965, 1
  %967 = insertvalue { ptr, i32, i32, i32 } %957, i32 %966, 2
  %968 = getelementptr inbounds i8, ptr %960, i32 -12
  store i32 %966, ptr %968, align 4
  %969 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %912, 0
  %970 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f88"(i64 %889, i64 %890, { { ptr, i32, i32, i32 } } %969, { ptr, i32, i32, i32 } %967)
  %971 = extractvalue { i64, i64, { i64, [24 x i8] } } %970, 0
  %972 = extractvalue { i64, i64, { i64, [24 x i8] } } %970, 1
  %973 = extractvalue { i64, i64, { i64, [24 x i8] } } %970, 2
  store { i64, [24 x i8] } %973, ptr %17, align 8
  %974 = load i1, ptr %17, align 1
  switch i1 %974, label %985 [
    i1 false, label %987
    i1 true, label %994
  ]

975:                                              ; preds = %876
  %976 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %15, align 8
  %977 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %976, 1
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %54)
  call void @"drop$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %577)
  %978 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %977, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %978, ptr %16, align 8
  %979 = load { i64, [24 x i8] }, ptr %16, align 8
  %980 = extractvalue { ptr, ptr, i64 } %8, 1
  %981 = load i64, ptr %980, align 8
  %982 = icmp eq i64 %981, 0
  %983 = sub i64 %981, 1
  %984 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %983, ptr %984, align 8
  br i1 %982, label %1030, label %1013

985:                                              ; preds = %958
  br i1 false, label %986, label %1076

986:                                              ; preds = %985
  unreachable

987:                                              ; preds = %958
  %988 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %17, align 8
  %989 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %988, 1
  %990 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %991 = call ptr %990()
  %992 = call i64 @llvm.uadd.sat.i64(i64 %972, i64 0)
  %993 = extractvalue { { ptr, i32, i32, i32 }, {} } %989, 0
  br label %1004

994:                                              ; preds = %958
  %995 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %996 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %995, 1
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %54)
  %997 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %996, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %997, ptr %18, align 8
  %998 = load { i64, [24 x i8] }, ptr %18, align 8
  %999 = extractvalue { ptr, ptr, i64 } %8, 1
  %1000 = load i64, ptr %999, align 8
  %1001 = icmp eq i64 %1000, 0
  %1002 = sub i64 %1000, 1
  %1003 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %1002, ptr %1003, align 8
  br i1 %1001, label %1026, label %1013

1004:                                             ; preds = %154, %516, %987
  %1005 = phi { { ptr, i32, i32, i32 } } [ %54, %987 ], [ %54, %516 ], [ %54, %154 ]
  %1006 = phi i64 [ %971, %987 ], [ %280, %516 ], [ %26, %154 ]
  %1007 = phi i64 [ %992, %987 ], [ %418, %516 ], [ %65, %154 ]
  %1008 = phi { ptr, i32, i32, i32 } [ %993, %987 ], [ %525, %516 ], [ %163, %154 ]
  %1009 = extractvalue { ptr, ptr, i64 } %8, 1
  %1010 = load i64, ptr %1009, align 8
  %1011 = add i64 %1010, 1
  %1012 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %1011, ptr %1012, align 8
  br label %21

1013:                                             ; preds = %1013, %527, %994, %975, %893, %1038, %1057
  %1014 = phi i64 [ %26, %1057 ], [ %26, %1038 ], [ %1014, %1013 ], [ %971, %994 ], [ %889, %975 ], [ %405, %893 ], [ %280, %527 ]
  %1015 = phi i64 [ %23, %1057 ], [ %1044, %1038 ], [ %1015, %1013 ], [ %972, %994 ], [ %890, %975 ], [ %406, %893 ], [ %281, %527 ]
  %1016 = phi { i64, [24 x i8] } [ %1062, %1057 ], [ %1047, %1038 ], [ %1016, %1013 ], [ %998, %994 ], [ %979, %975 ], [ %897, %893 ], [ %531, %527 ]
  %1017 = extractvalue { ptr, ptr, i64 } %8, 1
  %1018 = load i64, ptr %1017, align 8
  %1019 = icmp eq i64 %1018, 0
  %1020 = sub i64 %1018, 1
  %1021 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %1020, ptr %1021, align 8
  br i1 %1019, label %1022, label %1013

1022:                                             ; preds = %1013
  %1023 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %1014, 0
  %1024 = insertvalue { i64, i64, { i64, [24 x i8] } } %1023, i64 %1015, 1
  %1025 = insertvalue { i64, i64, { i64, [24 x i8] } } %1024, { i64, [24 x i8] } %1016, 2
  ret { i64, i64, { i64, [24 x i8] } } %1025

1026:                                             ; preds = %994
  %1027 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %971, 0
  %1028 = insertvalue { i64, i64, { i64, [24 x i8] } } %1027, i64 %972, 1
  %1029 = insertvalue { i64, i64, { i64, [24 x i8] } } %1028, { i64, [24 x i8] } %998, 2
  ret { i64, i64, { i64, [24 x i8] } } %1029

1030:                                             ; preds = %975
  %1031 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %889, 0
  %1032 = insertvalue { i64, i64, { i64, [24 x i8] } } %1031, i64 %890, 1
  %1033 = insertvalue { i64, i64, { i64, [24 x i8] } } %1032, { i64, [24 x i8] } %979, 2
  ret { i64, i64, { i64, [24 x i8] } } %1033

1034:                                             ; preds = %893
  %1035 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %405, 0
  %1036 = insertvalue { i64, i64, { i64, [24 x i8] } } %1035, i64 %406, 1
  %1037 = insertvalue { i64, i64, { i64, [24 x i8] } } %1036, { i64, [24 x i8] } %897, 2
  ret { i64, i64, { i64, [24 x i8] } } %1037

1038:                                             ; preds = %33
  %1039 = phi { ptr, i32, i32, i32 } [ %35, %33 ]
  call void @"drop$293"({ ptr, i32, i32, i32 } %1039)
  %1040 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %1041 = call ptr %1040()
  %1042 = load i64, ptr %1041, align 8
  %1043 = mul i64 %1042, 15120
  %1044 = call i64 @llvm.uadd.sat.i64(i64 %32, i64 %1043)
  %1045 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %25, 0
  %1046 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %1045, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %1046, ptr %11, align 8
  %1047 = load { i64, [24 x i8] }, ptr %11, align 8
  %1048 = extractvalue { ptr, ptr, i64 } %8, 1
  %1049 = load i64, ptr %1048, align 8
  %1050 = icmp eq i64 %1049, 0
  %1051 = sub i64 %1049, 1
  %1052 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %1051, ptr %1052, align 8
  br i1 %1050, label %1053, label %1013

1053:                                             ; preds = %1038
  %1054 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %26, 0
  %1055 = insertvalue { i64, i64, { i64, [24 x i8] } } %1054, i64 %1044, 1
  %1056 = insertvalue { i64, i64, { i64, [24 x i8] } } %1055, { i64, [24 x i8] } %1047, 2
  ret { i64, i64, { i64, [24 x i8] } } %1056

1057:                                             ; preds = %21
  %1058 = phi { ptr, i32, i32, i32 } [ %25, %21 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %1058)
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %24)
  %1059 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %1060 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1059, 0
  %1061 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %1060, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %1061, ptr %10, align 8
  %1062 = load { i64, [24 x i8] }, ptr %10, align 8
  %1063 = extractvalue { ptr, ptr, i64 } %8, 1
  %1064 = load i64, ptr %1063, align 8
  %1065 = icmp eq i64 %1064, 0
  %1066 = sub i64 %1064, 1
  %1067 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %1066, ptr %1067, align 8
  br i1 %1065, label %1068, label %1013

1068:                                             ; preds = %1057
  %1069 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %26, 0
  %1070 = insertvalue { i64, i64, { i64, [24 x i8] } } %1069, i64 %23, 1
  %1071 = insertvalue { i64, i64, { i64, [24 x i8] } } %1070, { i64, [24 x i8] } %1062, 2
  ret { i64, i64, { i64, [24 x i8] } } %1071

1072:                                             ; preds = %56
  call void @puts(ptr @assert_msg_117)
  call void @abort()
  unreachable

1073:                                             ; preds = %409
  call void @puts(ptr @assert_msg_118)
  call void @abort()
  unreachable

1074:                                             ; preds = %541
  call void @puts(ptr @assert_msg_119)
  call void @abort()
  unreachable

1075:                                             ; preds = %903
  call void @puts(ptr @assert_msg_120)
  call void @abort()
  unreachable

1076:                                             ; preds = %985
  call void @puts(ptr @assert_msg_121)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f60(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f60"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f60(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f60(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$315"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0, 2
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  ret void
}

define private { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } @"dup$315"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0) {
  %2 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0, 0
  %3 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0, { i3, [0 x i8] } %2, 0
  %4 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i3, [0 x i8] } %2, 0
  %5 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0, 1
  %6 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %3, i32 %5, 1
  %7 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %4, i32 %5, 1
  %8 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0, 2
  %9 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 1
  %12 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6, { { ptr, i32, i32, i32 }, i252, i32 } %10, 2
  %13 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %7, { { ptr, i32, i32, i32 }, i252, i32 } %11, 2
  %14 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0, 3
  %15 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %12, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %14, 3
  %16 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %13, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %14, 3
  %17 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } undef, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %15, 0
  %18 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %17, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %16, 1
  ret { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %18
}

define private void @"drop$316"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0) {
  call void @"drop$315"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0)
  ret void
}

define private { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } @"dup$316"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0) {
  %2 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } @"dup$315"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %0)
  %3 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %2, 0
  %4 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %2, 1
  %5 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } undef, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %3, 0
  %6 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %4, 1
  ret { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %6
}

define private void @"drop$310"({ { ptr, i32, i32, i32 }, i252, {} } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, i252, {} } %0, 0
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } @"dup$310"({ { ptr, i32, i32, i32 }, i252, {} } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 }, i252, {} } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, i252, {} } %0, 1
  %9 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } %6, i252 %8, 1
  %10 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } %7, i252 %8, 1
  %11 = extractvalue { { ptr, i32, i32, i32 }, i252, {} } %0, 2
  %12 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } %9, {} %11, 2
  %13 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } %10, {} %11, 2
  %14 = insertvalue { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } undef, { { ptr, i32, i32, i32 }, i252, {} } %12, 0
  %15 = insertvalue { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } %14, { { ptr, i32, i32, i32 }, i252, {} } %13, 1
  ret { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } %15
}

define private void @"drop$311"({ i128, [64 x i8] } %0) {
  %2 = alloca { i128, [64 x i8] }, i64 1, align 16
  store { i128, [64 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, i252, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, {} } } %5, 1
  call void @"drop$310"({ { ptr, i32, i32, i32 }, i252, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [64 x i8] }, { i128, [64 x i8] } } @"dup$311"({ i128, [64 x i8] } %0) {
  %2 = alloca { i128, [64 x i8] }, i64 1, align 16
  store { i128, [64 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { ptr, i32, i32, i32 }, i252, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, {} } } %5, 1
  %7 = call { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } @"dup$310"({ { ptr, i32, i32, i32 }, i252, {} } %6)
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } %7, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 }, i252, {} }, { { ptr, i32, i32, i32 }, i252, {} } } %7, 1
  %10 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, {} } } %5, { { ptr, i32, i32, i32 }, i252, {} } %8, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, {} } } %10, ptr %2, align 16
  %11 = load { i128, [64 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, {} } } %5, { { ptr, i32, i32, i32 }, i252, {} } %9, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, {} } } %12, ptr %2, align 16
  %13 = load { i128, [64 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } undef, { i128, [64 x i8] } %11, 0
  %15 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } %14, { i128, [64 x i8] } %13, 1
  ret { { i128, [64 x i8] }, { i128, [64 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [64 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [64 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } undef, { i128, [64 x i8] } %23, 0
  %27 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } %26, { i128, [64 x i8] } %25, 1
  ret { { i128, [64 x i8] }, { i128, [64 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$303"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$2"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$303"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$307"({ { { ptr, i32, i32, i32 } }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, {} } %0, 0
  call void @"drop$303"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } @"dup$307"({ { { ptr, i32, i32, i32 } }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$303"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, {} } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, {} } %6, {} %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, {} } %7, {} %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } undef, { { { ptr, i32, i32, i32 } }, {} } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } %11, { { { ptr, i32, i32, i32 } }, {} } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } %12
}

define private void @"drop$308"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {} } } %5, 1
  call void @"drop$307"({ { { ptr, i32, i32, i32 } }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$308"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } @"dup$307"({ { { ptr, i32, i32, i32 } }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, {} }, { { { ptr, i32, i32, i32 } }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {} } } %5, { { { ptr, i32, i32, i32 } }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {} } } %5, { { { ptr, i32, i32, i32 } }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [24 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [24 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %23, 0
  %27 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %26, { i64, [24 x i8] } %25, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$304"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  call void @"drop$303"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$304"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$303"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %6, i32 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %7, i32 %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } undef, { { { ptr, i32, i32, i32 } }, i32 } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %11, { { { ptr, i32, i32, i32 } }, i32 } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %12
}

define private void @"drop$305"({ { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0, 0
  call void @"drop$304"({ { { ptr, i32, i32, i32 } }, i32 } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } @"dup$305"({ { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$304"({ { { ptr, i32, i32, i32 } }, i32 } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0, { { { ptr, i32, i32, i32 } }, i32 } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } undef, { { { ptr, i32, i32, i32 } }, i32 } %5, 0
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0, 1
  %9 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %6, { {} } %8, 1
  %10 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %7, { {} } %8, 1
  %11 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %0, 2
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %9, {} %11, 2
  %13 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %10, {} %11, 2
  %14 = insertvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } undef, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %12, 0
  %15 = insertvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %14, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %13, 1
  ret { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %15
}

define private void @"drop$306"({ i64, [32 x i8] } %0) {
  %2 = alloca { i64, [32 x i8] }, i64 1, align 8
  store { i64, [32 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %5, 1
  call void @"drop$305"({ { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [32 x i8] }, { i64, [32 x i8] } } @"dup$306"({ i64, [32 x i8] } %0) {
  %2 = alloca { i64, [32 x i8] }, i64 1, align 8
  store { i64, [32 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } @"dup$305"({ { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %5, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [32 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %5, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [32 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } undef, { i64, [32 x i8] } %11, 0
  %15 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } %14, { i64, [32 x i8] } %13, 1
  ret { { i64, [32 x i8] }, { i64, [32 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [32 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [32 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } undef, { i64, [32 x i8] } %23, 0
  %27 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } %26, { i64, [32 x i8] } %25, 1
  ret { { i64, [32 x i8] }, { i64, [32 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { i3, [0 x i8] } %5, i32 %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca { i128, [16 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i1, [31 x i8] }, i64 1, align 8
  %17 = alloca i64, i64 1, align 8
  %18 = alloca i252, i64 1, align 16
  %19 = alloca i252, i64 1, align 16
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i128, [64 x i8] }, i64 1, align 16
  %24 = alloca { i64, [24 x i8] }, i64 1, align 8
  %25 = alloca { i64, [24 x i8] }, i64 1, align 8
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = alloca { i64, [32 x i8] }, i64 1, align 8
  %28 = alloca { i64, [24 x i8] }, i64 1, align 8
  %29 = alloca { i64, [24 x i8] }, i64 1, align 8
  %30 = extractvalue { i3, [0 x i8] } %5, 0
  switch i3 %30, label %31 [
    i3 0, label %33
    i3 1, label %40
    i3 2, label %51
    i3 3, label %62
    i3 -4, label %73
    i3 -3, label %84
    i3 -2, label %95
  ]

31:                                               ; preds = %10
  br i1 false, label %32, label %291

32:                                               ; preds = %31
  unreachable

33:                                               ; preds = %10
  %34 = phi i64 [ %1, %10 ]
  %35 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %36 = call ptr %35()
  %37 = load i64, ptr %36, align 8
  %38 = mul i64 %37, 200
  %39 = call i64 @llvm.uadd.sat.i64(i64 %34, i64 %38)
  br label %108

40:                                               ; preds = %10
  %41 = phi i64 [ %1, %10 ]
  %42 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %43 = call ptr %42()
  %44 = call i64 @llvm.uadd.sat.i64(i64 %41, i64 0)
  %45 = zext i32 %6 to i256
  %46 = add i256 %45, 4294967296
  %47 = add i256 %45, -3618502788666131213697322783095070105623107215331596699973092056131577053185
  %48 = icmp uge i256 %46, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %49 = select i1 %48, i256 %47, i256 %46
  %50 = trunc i256 %49 to i252
  br label %108

51:                                               ; preds = %10
  %52 = phi i64 [ %1, %10 ]
  %53 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %54 = call ptr %53()
  %55 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 0)
  %56 = zext i32 %6 to i256
  %57 = add i256 %56, 8589934592
  %58 = add i256 %56, -3618502788666131213697322783095070105623107215331596699973092056127282085889
  %59 = icmp uge i256 %57, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %60 = select i1 %59, i256 %58, i256 %57
  %61 = trunc i256 %60 to i252
  br label %108

62:                                               ; preds = %10
  %63 = phi i64 [ %1, %10 ]
  %64 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %65 = call ptr %64()
  %66 = call i64 @llvm.uadd.sat.i64(i64 %63, i64 0)
  %67 = zext i32 %6 to i256
  %68 = add i256 %67, 12884901888
  %69 = add i256 %67, -3618502788666131213697322783095070105623107215331596699973092056122987118593
  %70 = icmp uge i256 %68, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %71 = select i1 %70, i256 %69, i256 %68
  %72 = trunc i256 %71 to i252
  br label %108

73:                                               ; preds = %10
  %74 = phi i64 [ %1, %10 ]
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = call i64 @llvm.uadd.sat.i64(i64 %74, i64 0)
  %78 = zext i32 %6 to i256
  %79 = add i256 %78, 17179869184
  %80 = add i256 %78, -3618502788666131213697322783095070105623107215331596699973092056118692151297
  %81 = icmp uge i256 %79, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %82 = select i1 %81, i256 %80, i256 %79
  %83 = trunc i256 %82 to i252
  br label %108

84:                                               ; preds = %10
  %85 = phi i64 [ %1, %10 ]
  %86 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %87 = call ptr %86()
  %88 = call i64 @llvm.uadd.sat.i64(i64 %85, i64 0)
  %89 = zext i32 %6 to i256
  %90 = add i256 %89, 21474836480
  %91 = add i256 %89, -3618502788666131213697322783095070105623107215331596699973092056114397184001
  %92 = icmp uge i256 %90, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %93 = select i1 %92, i256 %91, i256 %90
  %94 = trunc i256 %93 to i252
  br label %108

95:                                               ; preds = %10
  %96 = phi i64 [ %1, %10 ]
  %97 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %98 = call ptr %97()
  %99 = load i64, ptr %98, align 8
  %100 = mul i64 %99, 100
  %101 = call i64 @llvm.uadd.sat.i64(i64 %96, i64 %100)
  %102 = zext i32 %6 to i256
  %103 = add i256 %102, 25769803776
  %104 = add i256 %102, -3618502788666131213697322783095070105623107215331596699973092056110102216705
  %105 = icmp uge i256 %103, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %106 = select i1 %105, i256 %104, i256 %103
  %107 = trunc i256 %106 to i252
  br label %108

108:                                              ; preds = %33, %40, %51, %62, %73, %84, %95
  %109 = phi i64 [ %0, %95 ], [ %0, %84 ], [ %0, %73 ], [ %0, %62 ], [ %0, %51 ], [ %0, %40 ], [ %0, %33 ]
  %110 = phi i64 [ %2, %95 ], [ %2, %84 ], [ %2, %73 ], [ %2, %62 ], [ %2, %51 ], [ %2, %40 ], [ %2, %33 ]
  %111 = phi ptr [ %3, %95 ], [ %3, %84 ], [ %3, %73 ], [ %3, %62 ], [ %3, %51 ], [ %3, %40 ], [ %3, %33 ]
  %112 = phi { {} } [ %4, %95 ], [ %4, %84 ], [ %4, %73 ], [ %4, %62 ], [ %4, %51 ], [ %4, %40 ], [ %4, %33 ]
  %113 = phi { i3, [0 x i8] } [ %5, %95 ], [ %5, %84 ], [ %5, %73 ], [ %5, %62 ], [ %5, %51 ], [ %5, %40 ], [ %5, %33 ]
  %114 = phi i32 [ %6, %95 ], [ %6, %84 ], [ %6, %73 ], [ %6, %62 ], [ %6, %51 ], [ %6, %40 ], [ %6, %33 ]
  %115 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %7, %95 ], [ %7, %84 ], [ %7, %73 ], [ %7, %62 ], [ %7, %51 ], [ %7, %40 ], [ %7, %33 ]
  %116 = phi { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } [ %8, %95 ], [ %8, %84 ], [ %8, %73 ], [ %8, %62 ], [ %8, %51 ], [ %8, %40 ], [ %8, %33 ]
  %117 = phi { ptr, i32, i32, i32 } [ %9, %95 ], [ %9, %84 ], [ %9, %73 ], [ %9, %62 ], [ %9, %51 ], [ %9, %40 ], [ %9, %33 ]
  %118 = phi i252 [ %107, %95 ], [ %94, %84 ], [ %83, %73 ], [ %72, %62 ], [ %61, %51 ], [ %50, %40 ], [ 0, %33 ]
  %119 = phi i64 [ %101, %95 ], [ %88, %84 ], [ %77, %73 ], [ %66, %62 ], [ %55, %51 ], [ %44, %40 ], [ %39, %33 ]
  %120 = add i64 %110, 3
  %121 = zext i252 %118 to i256
  store i256 1555170125836447351353653902862745931305207776976209346350698701924491819, ptr %11, align 16
  store i256 %121, ptr %12, align 16
  %122 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %122(ptr %13, ptr %11, ptr %12)
  %123 = load i256, ptr %13, align 16
  %124 = trunc i256 %123 to i252
  %125 = add i64 %109, 3
  %126 = sub i252 %124, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %127 = icmp ult i252 %124, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %128 = select i1 %127, i252 %124, i252 %126
  %129 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f59"(i64 %125, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %116)
  %130 = extractvalue { i64, { i128, [16 x i8] } } %129, 0
  %131 = extractvalue { i64, { i128, [16 x i8] } } %129, 1
  store { i128, [16 x i8] } %131, ptr %14, align 16
  %132 = load i1, ptr %14, align 1
  switch i1 %132, label %133 [
    i1 false, label %135
    i1 true, label %148
  ]

133:                                              ; preds = %108
  br i1 false, label %134, label %292

134:                                              ; preds = %133
  unreachable

135:                                              ; preds = %108
  %136 = load { i1, { i128 } }, ptr %14, align 16
  %137 = extractvalue { i1, { i128 } } %136, 1
  %138 = extractvalue { i128 } %137, 0
  %139 = zext i128 %138 to i252
  %140 = load ptr, ptr %111, align 8
  store i64 %119, ptr %17, align 8
  store i252 %128, ptr %18, align 16
  store i252 %139, ptr %19, align 16
  %141 = getelementptr inbounds ptr, ptr %111, i32 9
  %142 = load ptr, ptr %141, align 8
  call void %142(ptr %16, ptr %140, ptr %17, i32 0, ptr %18, ptr %19)
  %143 = load { i1, [31 x i8] }, ptr %16, align 1
  %144 = extractvalue { i1, [31 x i8] } %143, 0
  %145 = getelementptr inbounds i8, ptr %16, i32 8
  %146 = load { ptr, i32, i32, i32 }, ptr %145, align 8
  %147 = load i64, ptr %17, align 8
  br i1 %144, label %281, label %160

148:                                              ; preds = %108
  %149 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %150 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %149, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %117)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %115)
  %151 = extractvalue { {}, { ptr, i32, i32, i32 } } %150, 1
  %152 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %151, 1
  %153 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %152, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %153, ptr %15, align 8
  %154 = load { i64, [24 x i8] }, ptr %15, align 8
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %130, 0
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, i64 %119, 1
  %157 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %156, i64 %120, 2
  %158 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %157, ptr %111, 3
  %159 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %158, { i64, [24 x i8] } %154, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %159

160:                                              ; preds = %135
  %161 = phi { i3, [0 x i8] } [ %113, %135 ]
  %162 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i3, [0 x i8] } %161, 0
  %163 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %162, i32 %114, 1
  %164 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %163, { { ptr, i32, i32, i32 }, i252, i32 } %115, 2
  %165 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %164, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %116, 3
  %166 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } @"dup$315"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %165)
  %167 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %166, 0
  %168 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %166, 1
  call void @"drop$315"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %167)
  %169 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f89"(i64 %130, i64 %147, ptr %111, i252 1305529206446757794626433385883827655608344407302279304195976632702005615498, i252 %118, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %168)
  %170 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 0
  %171 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 1
  %172 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 2
  %173 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 3
  store { i64, [24 x i8] } %173, ptr %21, align 8
  %174 = load i1, ptr %21, align 1
  switch i1 %174, label %175 [
    i1 false, label %177
    i1 true, label %198
  ]

175:                                              ; preds = %160
  br i1 false, label %176, label %293

176:                                              ; preds = %175
  unreachable

177:                                              ; preds = %160
  %178 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %117)
  %179 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %178, 0
  %180 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %178, 1
  %181 = extractvalue { ptr, i32, i32, i32 } %180, 1
  %182 = extractvalue { ptr, i32, i32, i32 } %180, 2
  %183 = sub i32 %182, %181
  call void @"drop$3"({ ptr, i32, i32, i32 } %180)
  %184 = zext i32 %183 to i252
  %185 = zext i252 %118 to i512
  %186 = mul i512 %185, 4294967296
  %187 = urem i512 %186, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %188 = icmp uge i512 %186, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %189 = select i1 %188, i512 %187, i512 %186
  %190 = trunc i512 %189 to i252
  %191 = call fastcc { i64, i64, i64, ptr, { i128, [64 x i8] } } @"impl$f90"(i64 %170, i64 %171, i64 %120, ptr %172, i252 %190, i252 %184, { i252 } { i252 1436209994116032968217460821259974301319484759399248048177294919499399378304 }, { ptr, i32, i32, i32 } zeroinitializer)
  %192 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %191, 0
  %193 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %191, 1
  %194 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %191, 2
  %195 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %191, 3
  %196 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %191, 4
  store { i128, [64 x i8] } %196, ptr %23, align 16
  %197 = load i1, ptr %23, align 1
  switch i1 %197, label %208 [
    i1 false, label %210
    i1 true, label %221
  ]

198:                                              ; preds = %160
  %199 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %21, align 8
  %200 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %199, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %117)
  %201 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %200, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %201, ptr %22, align 8
  %202 = load { i64, [24 x i8] }, ptr %22, align 8
  %203 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %170, 0
  %204 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %203, i64 %171, 1
  %205 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %204, i64 %120, 2
  %206 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %205, ptr %172, 3
  %207 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %206, { i64, [24 x i8] } %202, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %207

208:                                              ; preds = %177
  br i1 false, label %209, label %294

209:                                              ; preds = %208
  unreachable

210:                                              ; preds = %177
  %211 = load { i1, { { ptr, i32, i32, i32 }, i252, {} } }, ptr %23, align 16
  %212 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, {} } } %211, 1
  %213 = extractvalue { { ptr, i32, i32, i32 }, i252, {} } %212, 0
  %214 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %213, 0
  %215 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f91"(i64 %192, i64 %193, ptr %195, { { ptr, i32, i32, i32 } } %214, i252 3055551908028526501914924269284987698957048785899022598052704863388955138917)
  %216 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %215, 0
  %217 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %215, 1
  %218 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %215, 2
  %219 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %215, 3
  store { i64, [24 x i8] } %219, ptr %25, align 8
  %220 = load i1, ptr %25, align 1
  switch i1 %220, label %231 [
    i1 false, label %233
    i1 true, label %246
  ]

221:                                              ; preds = %177
  %222 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %23, align 8
  %223 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %222, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %179)
  %224 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %223, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %224, ptr %24, align 8
  %225 = load { i64, [24 x i8] }, ptr %24, align 8
  %226 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %192, 0
  %227 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %226, i64 %193, 1
  %228 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %227, i64 %194, 2
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %228, ptr %195, 3
  %230 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %229, { i64, [24 x i8] } %225, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %230

231:                                              ; preds = %210
  br i1 false, label %232, label %295

232:                                              ; preds = %231
  unreachable

233:                                              ; preds = %210
  %234 = load { i1, { { { ptr, i32, i32, i32 } }, {} } }, ptr %25, align 8
  %235 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, {} } } %234, 1
  call void @"drop$307"({ { { ptr, i32, i32, i32 } }, {} } %235)
  %236 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %179, 0
  %237 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %236, 0
  %238 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %237, i32 0, 1
  %239 = call fastcc { i64, i64, i64, ptr, { i64, [32 x i8] } } @"impl$f92"(i64 %216, i64 %217, i64 %194, ptr %218, { { { ptr, i32, i32, i32 } }, i32 } %238, i252 %190, i32 %114, { {} } %112, { i3, [0 x i8] } %161)
  %240 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %239, 0
  %241 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %239, 1
  %242 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %239, 2
  %243 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %239, 3
  %244 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %239, 4
  store { i64, [32 x i8] } %244, ptr %27, align 8
  %245 = load i1, ptr %27, align 1
  switch i1 %245, label %256 [
    i1 false, label %258
    i1 true, label %271
  ]

246:                                              ; preds = %210
  %247 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %25, align 8
  %248 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %247, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %179)
  %249 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %248, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %249, ptr %26, align 8
  %250 = load { i64, [24 x i8] }, ptr %26, align 8
  %251 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %216, 0
  %252 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %251, i64 %217, 1
  %253 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %252, i64 %194, 2
  %254 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %253, ptr %218, 3
  %255 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %254, { i64, [24 x i8] } %250, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %255

256:                                              ; preds = %233
  br i1 false, label %257, label %296

257:                                              ; preds = %256
  unreachable

258:                                              ; preds = %233
  %259 = load { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } }, ptr %27, align 8
  %260 = extractvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %259, 1
  %261 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %262 = call ptr %261()
  %263 = call i64 @llvm.uadd.sat.i64(i64 %241, i64 0)
  %264 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %260, 0
  call void @"drop$304"({ { { ptr, i32, i32, i32 } }, i32 } %264)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %29, align 1
  %265 = load { i64, [24 x i8] }, ptr %29, align 8
  %266 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %240, 0
  %267 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %266, i64 %263, 1
  %268 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %267, i64 %242, 2
  %269 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %268, ptr %243, 3
  %270 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %269, { i64, [24 x i8] } %265, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %270

271:                                              ; preds = %233
  %272 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %27, align 8
  %273 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %272, 1
  %274 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %273, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %274, ptr %28, align 8
  %275 = load { i64, [24 x i8] }, ptr %28, align 8
  %276 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %240, 0
  %277 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %276, i64 %241, 1
  %278 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %277, i64 %242, 2
  %279 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %278, ptr %243, 3
  %280 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %279, { i64, [24 x i8] } %275, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %280

281:                                              ; preds = %135
  %282 = phi { ptr, i32, i32, i32 } [ %117, %135 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %282)
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %115)
  %283 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %146, 1
  %284 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %283, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %284, ptr %20, align 8
  %285 = load { i64, [24 x i8] }, ptr %20, align 8
  %286 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %130, 0
  %287 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %286, i64 %147, 1
  %288 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %287, i64 %120, 2
  %289 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %288, ptr %111, 3
  %290 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %289, { i64, [24 x i8] } %285, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %290

291:                                              ; preds = %31
  call void @puts(ptr @assert_msg_122)
  call void @abort()
  unreachable

292:                                              ; preds = %133
  call void @puts(ptr @assert_msg_123)
  call void @abort()
  unreachable

293:                                              ; preds = %175
  call void @puts(ptr @assert_msg_124)
  call void @abort()
  unreachable

294:                                              ; preds = %208
  call void @puts(ptr @assert_msg_125)
  call void @abort()
  unreachable

295:                                              ; preds = %231
  call void @puts(ptr @assert_msg_126)
  call void @abort()
  unreachable

296:                                              ; preds = %256
  call void @puts(ptr @assert_msg_127)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f61(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { i3, [0 x i8] } %5, i32 %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %8, { ptr, i32, i32, i32 } %9) {
  %11 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %0, i64 %1, i64 %2, ptr %3, { {} } %4, { i3, [0 x i8] } %5, i32 %6, { { ptr, i32, i32, i32 }, i252, i32 } %7, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %8, { ptr, i32, i32, i32 } %9)
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 0
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 1
  %14 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 2
  %15 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 3
  %16 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %11, 4
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %12, 0
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %17, i64 %13, 1
  %19 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %18, i64 %14, 2
  %20 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %19, ptr %15, 3
  %21 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %20, { i64, [24 x i8] } %16, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %21
}

define void @_mlir_ciface_f61(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { i3, [0 x i8] } %6, i32 %7, { { ptr, i32, i32, i32 }, i252, i32 } %8, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %9, { ptr, i32, i32, i32 } %10) {
  %12 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f61(i64 %1, i64 %2, i64 %3, ptr %4, { {} } %5, { i3, [0 x i8] } %6, i32 %7, { { ptr, i32, i32, i32 }, i252, i32 } %8, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %9, { ptr, i32, i32, i32 } %10)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f62"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 1749165063169615148890104124711417950509560691)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f62() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f62"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f62(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f62()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f63"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [144 x i8] }, i64 1, align 16
  %5 = alloca { i128, [192 x i8] }, i64 1, align 16
  %6 = alloca { i128, [128 x i8] }, i64 1, align 16
  %7 = alloca { i128, [192 x i8] }, i64 1, align 16
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [144 x i8] }, i64 1, align 16
  %10 = alloca { i128, [192 x i8] }, i64 1, align 16
  %11 = alloca { i16, [14 x i8] }, i64 1, align 2
  %12 = alloca { i64, [56 x i8] }, i64 1, align 8
  %13 = alloca { i128, [192 x i8] }, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i128, [144 x i8] }, i64 1, align 16
  %16 = alloca { i128, [192 x i8] }, i64 1, align 16
  %17 = extractvalue { { ptr, i32, i32, i32 } } %2, 0
  %18 = extractvalue { ptr, i32, i32, i32 } %17, 1
  %19 = extractvalue { ptr, i32, i32, i32 } %17, 2
  %20 = sub i32 %19, %18
  %21 = icmp uge i32 %20, 1
  br i1 %21, label %22, label %317

22:                                               ; preds = %3
  %23 = extractvalue { ptr, i32, i32, i32 } %17, 0
  %24 = load ptr, ptr %23, align 8
  %25 = zext i32 %18 to i64
  %26 = mul i64 %25, 32
  %27 = getelementptr inbounds i8, ptr %24, i64 %26
  %28 = add i32 %18, 1
  %29 = insertvalue { ptr, i32, i32, i32 } %17, i32 %28, 1
  %30 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %30, ptr %27, i64 32, i1 false)
  %31 = load i252, ptr %30, align 16
  call void @free(ptr %30)
  %32 = icmp eq i252 %31, 0
  br i1 %32, label %33, label %40

33:                                               ; preds = %22
  %34 = phi i64 [ %1, %22 ]
  %35 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %36 = call ptr %35()
  %37 = load i64, ptr %36, align 8
  %38 = mul i64 %37, 950
  %39 = call i64 @llvm.uadd.sat.i64(i64 %34, i64 %38)
  br label %136

40:                                               ; preds = %22
  %41 = phi i252 [ %31, %22 ]
  %42 = zext i252 %41 to i256
  %43 = sub i256 %42, 1
  %44 = add i256 %42, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %45 = icmp ult i256 %42, 1
  %46 = select i1 %45, i256 %44, i256 %43
  %47 = trunc i256 %46 to i252
  %48 = icmp eq i252 %47, 0
  br i1 %48, label %49, label %56

49:                                               ; preds = %40
  %50 = phi i64 [ %1, %40 ]
  %51 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %52 = call ptr %51()
  %53 = load i64, ptr %52, align 8
  %54 = mul i64 %53, 760
  %55 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 %54)
  br label %136

56:                                               ; preds = %40
  %57 = phi i252 [ %41, %40 ]
  %58 = zext i252 %57 to i256
  %59 = sub i256 %58, 2
  %60 = add i256 %58, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %61 = icmp ult i256 %58, 2
  %62 = select i1 %61, i256 %60, i256 %59
  %63 = trunc i256 %62 to i252
  %64 = icmp eq i252 %63, 0
  br i1 %64, label %65, label %72

65:                                               ; preds = %56
  %66 = phi i64 [ %1, %56 ]
  %67 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %68 = call ptr %67()
  %69 = load i64, ptr %68, align 8
  %70 = mul i64 %69, 570
  %71 = call i64 @llvm.uadd.sat.i64(i64 %66, i64 %70)
  br label %136

72:                                               ; preds = %56
  %73 = phi i252 [ %57, %56 ]
  %74 = zext i252 %73 to i256
  %75 = sub i256 %74, 3
  %76 = add i256 %74, 3618502788666131213697322783095070105623107215331596699973092056135872020478
  %77 = icmp ult i256 %74, 3
  %78 = select i1 %77, i256 %76, i256 %75
  %79 = trunc i256 %78 to i252
  %80 = icmp eq i252 %79, 0
  br i1 %80, label %81, label %88

81:                                               ; preds = %72
  %82 = phi i64 [ %1, %72 ]
  %83 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %84 = call ptr %83()
  %85 = load i64, ptr %84, align 8
  %86 = mul i64 %85, 380
  %87 = call i64 @llvm.uadd.sat.i64(i64 %82, i64 %86)
  br label %136

88:                                               ; preds = %72
  %89 = phi i252 [ %73, %72 ]
  %90 = zext i252 %89 to i256
  %91 = sub i256 %90, 4
  %92 = add i256 %90, 3618502788666131213697322783095070105623107215331596699973092056135872020477
  %93 = icmp ult i256 %90, 4
  %94 = select i1 %93, i256 %92, i256 %91
  %95 = trunc i256 %94 to i252
  %96 = icmp eq i252 %95, 0
  br i1 %96, label %97, label %104

97:                                               ; preds = %88
  %98 = phi i64 [ %1, %88 ]
  %99 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %100 = call ptr %99()
  %101 = load i64, ptr %100, align 8
  %102 = mul i64 %101, 190
  %103 = call i64 @llvm.uadd.sat.i64(i64 %98, i64 %102)
  br label %136

104:                                              ; preds = %88
  %105 = phi i252 [ %89, %88 ]
  %106 = zext i252 %105 to i256
  %107 = sub i256 %106, 5
  %108 = add i256 %106, 3618502788666131213697322783095070105623107215331596699973092056135872020476
  %109 = icmp ult i256 %106, 5
  %110 = select i1 %109, i256 %108, i256 %107
  %111 = trunc i256 %110 to i252
  %112 = icmp eq i252 %111, 0
  br i1 %112, label %113, label %118

113:                                              ; preds = %104
  %114 = phi i64 [ %1, %104 ]
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = call i64 @llvm.uadd.sat.i64(i64 %114, i64 0)
  br label %136

118:                                              ; preds = %104
  %119 = phi i252 [ %105, %104 ]
  %120 = phi i252 [ 6, %104 ]
  %121 = zext i252 %119 to i256
  %122 = zext i252 %120 to i256
  %123 = sub i256 %121, %122
  %124 = add i256 %123, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %125 = icmp ult i256 %121, %122
  %126 = select i1 %125, i256 %124, i256 %123
  %127 = trunc i256 %126 to i252
  %128 = icmp eq i252 %127, 0
  br i1 %128, label %129, label %310

129:                                              ; preds = %118
  %130 = phi i64 [ %1, %118 ]
  %131 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %132 = call ptr %131()
  %133 = load i64, ptr %132, align 8
  %134 = mul i64 %133, 10
  %135 = call i64 @llvm.uadd.sat.i64(i64 %130, i64 %134)
  br label %136

136:                                              ; preds = %33, %49, %65, %81, %97, %113, %129
  %137 = phi i64 [ %0, %129 ], [ %0, %113 ], [ %0, %97 ], [ %0, %81 ], [ %0, %65 ], [ %0, %49 ], [ %0, %33 ]
  %138 = phi { i3, [0 x i8] } [ { i3 -2, [0 x i8] undef }, %129 ], [ { i3 -3, [0 x i8] undef }, %113 ], [ { i3 -4, [0 x i8] undef }, %97 ], [ { i3 3, [0 x i8] undef }, %81 ], [ { i3 2, [0 x i8] undef }, %65 ], [ { i3 1, [0 x i8] undef }, %49 ], [ { i3 0, [0 x i8] undef }, %33 ]
  %139 = phi { ptr, i32, i32, i32 } [ %29, %129 ], [ %29, %113 ], [ %29, %97 ], [ %29, %81 ], [ %29, %65 ], [ %29, %49 ], [ %29, %33 ]
  %140 = phi i64 [ %135, %129 ], [ %117, %113 ], [ %103, %97 ], [ %87, %81 ], [ %71, %65 ], [ %55, %49 ], [ %39, %33 ]
  %141 = extractvalue { ptr, i32, i32, i32 } %139, 1
  %142 = extractvalue { ptr, i32, i32, i32 } %139, 2
  %143 = sub i32 %142, %141
  %144 = icmp uge i32 %143, 1
  br i1 %144, label %145, label %303

145:                                              ; preds = %136
  %146 = extractvalue { ptr, i32, i32, i32 } %139, 0
  %147 = load ptr, ptr %146, align 8
  %148 = zext i32 %141 to i64
  %149 = mul i64 %148, 32
  %150 = getelementptr inbounds i8, ptr %147, i64 %149
  %151 = add i32 %141, 1
  %152 = insertvalue { ptr, i32, i32, i32 } %139, i32 %151, 1
  %153 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %153, ptr %150, i64 32, i1 false)
  %154 = load i252, ptr %153, align 16
  call void @free(ptr %153)
  %155 = icmp ult i252 %154, 4294967296
  %156 = add i64 %137, 2
  %157 = add i64 %137, 3
  %158 = select i1 %155, i64 %156, i64 %157
  %159 = trunc i252 %154 to i32
  br i1 %155, label %160, label %296

160:                                              ; preds = %145
  %161 = phi { ptr, i32, i32, i32 } [ %152, %145 ]
  %162 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %161, 0
  %163 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f26"(i64 %158, i64 %140, { { ptr, i32, i32, i32 } } %162)
  %164 = extractvalue { i64, i64, { i128, [128 x i8] } } %163, 0
  %165 = extractvalue { i64, i64, { i128, [128 x i8] } } %163, 1
  %166 = extractvalue { i64, i64, { i128, [128 x i8] } } %163, 2
  store { i128, [128 x i8] } %166, ptr %6, align 16
  %167 = load i1, ptr %6, align 1
  switch i1 %167, label %168 [
    i1 false, label %170
    i1 true, label %176
  ]

168:                                              ; preds = %160
  br i1 false, label %169, label %337

169:                                              ; preds = %168
  unreachable

170:                                              ; preds = %160
  %171 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %6, align 16
  %172 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %171, 1
  %173 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %172, 0
  %174 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %172, 1
  store { i128, [80 x i8] } %174, ptr %8, align 16
  %175 = load i1, ptr %8, align 1
  switch i1 %175, label %184 [
    i1 false, label %186
    i1 true, label %194
  ]

176:                                              ; preds = %160
  %177 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %178 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %177, 1
  %179 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %178, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %179, ptr %7, align 8
  %180 = load { i128, [192 x i8] }, ptr %7, align 16
  %181 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %164, 0
  %182 = insertvalue { i64, i64, { i128, [192 x i8] } } %181, i64 %165, 1
  %183 = insertvalue { i64, i64, { i128, [192 x i8] } } %182, { i128, [192 x i8] } %180, 2
  ret { i64, i64, { i128, [192 x i8] } } %183

184:                                              ; preds = %170
  br i1 false, label %185, label %338

185:                                              ; preds = %184
  unreachable

186:                                              ; preds = %170
  %187 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %8, align 16
  %188 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %187, 1
  %189 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } @"impl$f27"(i64 %164, { { ptr, i32, i32, i32 } } %173)
  %190 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %189, 0
  %191 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %189, 1
  %192 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [14 x i8] } } %189, 2
  store { i16, [14 x i8] } %192, ptr %11, align 2
  %193 = load i1, ptr %11, align 1
  switch i1 %193, label %200 [
    i1 false, label %202
    i1 true, label %210
  ]

194:                                              ; preds = %170
  %195 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %196 = call ptr %195()
  %197 = load i64, ptr %196, align 8
  %198 = mul i64 %197, 19730
  %199 = call i64 @llvm.uadd.sat.i64(i64 %165, i64 %198)
  br label %284

200:                                              ; preds = %186
  br i1 false, label %201, label %339

201:                                              ; preds = %200
  unreachable

202:                                              ; preds = %186
  %203 = load { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, ptr %11, align 2
  %204 = extractvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %203, 1
  %205 = extractvalue { { ptr, i32, i32, i32 } } %191, 0
  %206 = extractvalue { ptr, i32, i32, i32 } %205, 1
  %207 = extractvalue { ptr, i32, i32, i32 } %205, 2
  %208 = sub i32 %207, %206
  %209 = icmp uge i32 %208, 1
  br i1 %209, label %216, label %276

210:                                              ; preds = %186
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %188)
  %211 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %212 = call ptr %211()
  %213 = load i64, ptr %212, align 8
  %214 = mul i64 %213, 4560
  %215 = call i64 @llvm.uadd.sat.i64(i64 %165, i64 %214)
  br label %284

216:                                              ; preds = %202
  %217 = extractvalue { ptr, i32, i32, i32 } %205, 0
  %218 = load ptr, ptr %217, align 8
  %219 = zext i32 %206 to i64
  %220 = mul i64 %219, 32
  %221 = getelementptr inbounds i8, ptr %218, i64 %220
  %222 = add i32 %206, 1
  %223 = insertvalue { ptr, i32, i32, i32 } %205, i32 %222, 1
  %224 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %224, ptr %221, i64 32, i1 false)
  %225 = load i252, ptr %224, align 16
  call void @free(ptr %224)
  %226 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %223, 0
  %227 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f28"(i64 %190, i64 %165, { { ptr, i32, i32, i32 } } %226, { ptr, i32, i32, i32 } zeroinitializer, i252 %225)
  %228 = extractvalue { i64, i64, { i64, [56 x i8] } } %227, 0
  %229 = extractvalue { i64, i64, { i64, [56 x i8] } } %227, 1
  %230 = extractvalue { i64, i64, { i64, [56 x i8] } } %227, 2
  store { i64, [56 x i8] } %230, ptr %12, align 8
  %231 = load i1, ptr %12, align 1
  switch i1 %231, label %232 [
    i1 false, label %234
    i1 true, label %240
  ]

232:                                              ; preds = %216
  br i1 false, label %233, label %340

233:                                              ; preds = %232
  unreachable

234:                                              ; preds = %216
  %235 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %12, align 8
  %236 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %235, 1
  %237 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %236, 0
  %238 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %236, 1
  store { i64, [24 x i8] } %238, ptr %14, align 8
  %239 = load i1, ptr %14, align 1
  switch i1 %239, label %248 [
    i1 false, label %250
    i1 true, label %272
  ]

240:                                              ; preds = %216
  %241 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %242 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %241, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %188)
  %243 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %242, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %243, ptr %13, align 8
  %244 = load { i128, [192 x i8] }, ptr %13, align 16
  %245 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %228, 0
  %246 = insertvalue { i64, i64, { i128, [192 x i8] } } %245, i64 %229, 1
  %247 = insertvalue { i64, i64, { i128, [192 x i8] } } %246, { i128, [192 x i8] } %244, 2
  ret { i64, i64, { i128, [192 x i8] } } %247

248:                                              ; preds = %234
  br i1 false, label %249, label %341

249:                                              ; preds = %248
  unreachable

250:                                              ; preds = %234
  %251 = load { i1, { ptr, i32, i32, i32 } }, ptr %14, align 8
  %252 = extractvalue { i1, { ptr, i32, i32, i32 } } %251, 1
  %253 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %254 = call ptr %253()
  %255 = load i64, ptr %254, align 8
  %256 = mul i64 %255, 500
  %257 = call i64 @llvm.uadd.sat.i64(i64 %229, i64 %256)
  %258 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } undef, { i3, [0 x i8] } %138, 0
  %259 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %258, i32 %159, 1
  %260 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %259, { { ptr, i32, i32, i32 }, i252, i32 } %188, 2
  %261 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %260, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %204, 3
  %262 = insertvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %261, { ptr, i32, i32, i32 } %252, 4
  %263 = insertvalue { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } { i1 false, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } undef }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %262, 1
  store { i1, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %263, ptr %15, align 16
  %264 = load { i128, [144 x i8] }, ptr %15, align 16
  %265 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %237, 0
  %266 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %265, { i128, [144 x i8] } %264, 1
  %267 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %266, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %267, ptr %16, align 16
  %268 = load { i128, [192 x i8] }, ptr %16, align 16
  %269 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %228, 0
  %270 = insertvalue { i64, i64, { i128, [192 x i8] } } %269, i64 %257, 1
  %271 = insertvalue { i64, i64, { i128, [192 x i8] } } %270, { i128, [192 x i8] } %268, 2
  ret { i64, i64, { i128, [192 x i8] } } %271

272:                                              ; preds = %234
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %188)
  %273 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %274 = call ptr %273()
  %275 = call i64 @llvm.uadd.sat.i64(i64 %229, i64 0)
  br label %284

276:                                              ; preds = %202
  %277 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %188, %202 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %277)
  %278 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %279 = call ptr %278()
  %280 = load i64, ptr %279, align 8
  %281 = mul i64 %280, 3270
  %282 = call i64 @llvm.uadd.sat.i64(i64 %165, i64 %281)
  %283 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %205, 0
  br label %284

284:                                              ; preds = %272, %276, %210, %194
  %285 = phi i64 [ %190, %276 ], [ %228, %272 ], [ %190, %210 ], [ %164, %194 ]
  %286 = phi i64 [ %282, %276 ], [ %275, %272 ], [ %215, %210 ], [ %199, %194 ]
  %287 = phi { { ptr, i32, i32, i32 } } [ %283, %276 ], [ %237, %272 ], [ %191, %210 ], [ %173, %194 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %288 = load { i128, [144 x i8] }, ptr %9, align 16
  %289 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %287, 0
  %290 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %289, { i128, [144 x i8] } %288, 1
  %291 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %290, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %291, ptr %10, align 16
  %292 = load { i128, [192 x i8] }, ptr %10, align 16
  %293 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %285, 0
  %294 = insertvalue { i64, i64, { i128, [192 x i8] } } %293, i64 %286, 1
  %295 = insertvalue { i64, i64, { i128, [192 x i8] } } %294, { i128, [192 x i8] } %292, 2
  ret { i64, i64, { i128, [192 x i8] } } %295

296:                                              ; preds = %145
  %297 = phi i64 [ %140, %145 ]
  %298 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %299 = call ptr %298()
  %300 = load i64, ptr %299, align 8
  %301 = mul i64 %300, 26740
  %302 = call i64 @llvm.uadd.sat.i64(i64 %297, i64 %301)
  br label %324

303:                                              ; preds = %136
  %304 = phi i64 [ %140, %136 ]
  %305 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %306 = call ptr %305()
  %307 = load i64, ptr %306, align 8
  %308 = mul i64 %307, 27940
  %309 = call i64 @llvm.uadd.sat.i64(i64 %304, i64 %308)
  br label %324

310:                                              ; preds = %118
  %311 = phi i64 [ %1, %118 ]
  %312 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %313 = call ptr %312()
  %314 = load i64, ptr %313, align 8
  %315 = mul i64 %314, 28740
  %316 = call i64 @llvm.uadd.sat.i64(i64 %311, i64 %315)
  br label %324

317:                                              ; preds = %3
  %318 = phi i64 [ %1, %3 ]
  %319 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %320 = call ptr %319()
  %321 = load i64, ptr %320, align 8
  %322 = mul i64 %321, 30140
  %323 = call i64 @llvm.uadd.sat.i64(i64 %318, i64 %322)
  br label %324

324:                                              ; preds = %296, %303, %310, %317
  %325 = phi i64 [ %0, %317 ], [ %0, %310 ], [ %137, %303 ], [ %158, %296 ]
  %326 = phi i64 [ %323, %317 ], [ %316, %310 ], [ %309, %303 ], [ %302, %296 ]
  %327 = phi { ptr, i32, i32, i32 } [ %17, %317 ], [ %29, %310 ], [ %139, %303 ], [ %152, %296 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %328 = load { i128, [144 x i8] }, ptr %4, align 16
  %329 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %327, 0
  %330 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %329, 0
  %331 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %330, { i128, [144 x i8] } %328, 1
  %332 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %331, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %332, ptr %5, align 16
  %333 = load { i128, [192 x i8] }, ptr %5, align 16
  %334 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %325, 0
  %335 = insertvalue { i64, i64, { i128, [192 x i8] } } %334, i64 %326, 1
  %336 = insertvalue { i64, i64, { i128, [192 x i8] } } %335, { i128, [192 x i8] } %333, 2
  ret { i64, i64, { i128, [192 x i8] } } %336

337:                                              ; preds = %168
  call void @puts(ptr @assert_msg_128)
  call void @abort()
  unreachable

338:                                              ; preds = %184
  call void @puts(ptr @assert_msg_129)
  call void @abort()
  unreachable

339:                                              ; preds = %200
  call void @puts(ptr @assert_msg_130)
  call void @abort()
  unreachable

340:                                              ; preds = %232
  call void @puts(ptr @assert_msg_131)
  call void @abort()
  unreachable

341:                                              ; preds = %248
  call void @puts(ptr @assert_msg_132)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [192 x i8] } } @f63(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f63"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [192 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [192 x i8] } } %9, { i128, [192 x i8] } %7, 2
  ret { i64, i64, { i128, [192 x i8] } } %10
}

define void @_mlir_ciface_f63(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [192 x i8] } } @f63(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [192 x i8] } } %5, ptr %0, align 16
  ret void
}

define private void @"drop$298"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  call void @"drop$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0)
  ret void
}

define private { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$298"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0) {
  %2 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %0)
  %3 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %2, 0
  %4 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %2, 1
  %5 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } undef, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %3, 0
  %6 = insertvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %4, 1
  ret { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %6
}

define private void @"drop$299"(ptr %0) {
  %2 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %0, align 16
  call void @"drop$298"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$299"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 144)
  %3 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %0, align 16
  %4 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$298"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %3)
  %5 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %4, 0
  %6 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %4, 1
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %5, ptr %0, align 16
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private void @"drop$295"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$292"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$295"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$294"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } undef, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %17, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$296"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$295"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$296"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$295"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f64"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [48 x i8] }, i64 1, align 8
  %11 = alloca { i64, [48 x i8] }, i64 1, align 8
  %12 = alloca { i64, [48 x i8] }, i64 1, align 8
  %13 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %14

14:                                               ; preds = %107, %4
  %15 = phi i64 [ %52, %107 ], [ %0, %4 ]
  %16 = phi i64 [ %63, %107 ], [ %1, %4 ]
  %17 = phi { { { ptr, i32, i32, i32 } } } [ %65, %107 ], [ %2, %4 ]
  %18 = phi { ptr, i32, i32, i32 } [ %116, %107 ], [ %3, %4 ]
  %19 = add i64 %15, 1
  %20 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %21 = call ptr %20()
  %22 = load i64, ptr %21, align 8
  %23 = mul i64 %22, 6960
  %24 = icmp uge i64 %16, %23
  %25 = call i64 @llvm.usub.sat.i64(i64 %16, i64 %23)
  br i1 %24, label %26, label %171

26:                                               ; preds = %14
  %27 = phi { { { ptr, i32, i32, i32 } } } [ %17, %14 ]
  %28 = extractvalue { { { ptr, i32, i32, i32 } } } %27, 0
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %149

34:                                               ; preds = %26
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 144
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 144)
  %43 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %39, align 16
  %44 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %43)
  %45 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %44, 0
  %46 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %44, 1
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %45, ptr %39, align 16
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %46, ptr %42, align 16
  %47 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %42, align 16
  call void @free(ptr %42)
  %48 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %47, 2
  %49 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %47, 4
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %48)
  %50 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %49, 0
  %51 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f93"(i64 %19, i64 %25, { { ptr, i32, i32, i32 } } %50, { ptr, i32, i32, i32 } zeroinitializer)
  %52 = extractvalue { i64, i64, { i64, [48 x i8] } } %51, 0
  %53 = extractvalue { i64, i64, { i64, [48 x i8] } } %51, 1
  %54 = extractvalue { i64, i64, { i64, [48 x i8] } } %51, 2
  store { i64, [48 x i8] } %54, ptr %12, align 8
  %55 = load i1, ptr %12, align 1
  switch i1 %55, label %56 [
    i1 false, label %58
    i1 true, label %122
  ]

56:                                               ; preds = %34
  br i1 false, label %57, label %186

57:                                               ; preds = %56
  unreachable

58:                                               ; preds = %34
  %59 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %12, align 8
  %60 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %59, 1
  %61 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %62 = call ptr %61()
  %63 = call i64 @llvm.uadd.sat.i64(i64 %53, i64 0)
  %64 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %65 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %64, 0
  %66 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %60, 0
  %67 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %60, 1
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %66)
  %68 = extractvalue { ptr, i32, i32, i32 } %18, 3
  %69 = icmp eq i32 %68, 0
  br i1 %69, label %70, label %84

70:                                               ; preds = %58
  %71 = shl i32 %68, 1
  %72 = call i32 @llvm.umin.i32(i32 %71, i32 1024)
  %73 = add i32 %72, %68
  %74 = call i32 @llvm.umax.i32(i32 %73, i32 8)
  %75 = zext i32 %74 to i64
  %76 = mul i64 %75, 24
  %77 = add i64 %76, 8
  %78 = call ptr @realloc(ptr null, i64 %77)
  store i32 1, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %78, i32 4
  store i32 0, ptr %79, align 4
  %80 = getelementptr inbounds i8, ptr %78, i32 8
  %81 = call ptr @realloc(ptr null, i64 8)
  store ptr %80, ptr %81, align 8
  %82 = insertvalue { ptr, i32, i32, i32 } %18, ptr %81, 0
  %83 = insertvalue { ptr, i32, i32, i32 } %82, i32 %74, 3
  br label %105

84:                                               ; preds = %58
  %85 = extractvalue { ptr, i32, i32, i32 } %18, 2
  %86 = icmp ult i32 %85, %68
  br i1 %86, label %87, label %88

87:                                               ; preds = %84
  br label %102

88:                                               ; preds = %84
  %89 = shl i32 %68, 1
  %90 = call i32 @llvm.umin.i32(i32 %89, i32 1024)
  %91 = add i32 %90, %68
  %92 = call i32 @llvm.umax.i32(i32 %91, i32 8)
  %93 = zext i32 %92 to i64
  %94 = mul i64 %93, 24
  %95 = add i64 %94, 8
  %96 = extractvalue { ptr, i32, i32, i32 } %18, 0
  %97 = load ptr, ptr %96, align 8
  %98 = getelementptr inbounds i8, ptr %97, i32 -8
  %99 = call ptr @realloc(ptr %98, i64 %95)
  %100 = getelementptr inbounds i8, ptr %99, i32 8
  store ptr %100, ptr %96, align 8
  %101 = insertvalue { ptr, i32, i32, i32 } %18, i32 %92, 3
  br label %102

102:                                              ; preds = %87, %88
  %103 = phi { ptr, i32, i32, i32 } [ %101, %88 ], [ %18, %87 ]
  br label %104

104:                                              ; preds = %102
  br label %105

105:                                              ; preds = %70, %104
  %106 = phi { ptr, i32, i32, i32 } [ %103, %104 ], [ %83, %70 ]
  br label %107

107:                                              ; preds = %105
  %108 = extractvalue { ptr, i32, i32, i32 } %106, 0
  %109 = load ptr, ptr %108, align 8
  %110 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %111 = zext i32 %110 to i64
  %112 = mul i64 %111, 24
  %113 = getelementptr inbounds i8, ptr %109, i64 %112
  store { ptr, i32, i32, i32 } %67, ptr %113, align 8
  %114 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %115 = add i32 %114, 1
  %116 = insertvalue { ptr, i32, i32, i32 } %106, i32 %115, 2
  %117 = getelementptr inbounds i8, ptr %109, i32 -4
  store i32 %115, ptr %117, align 4
  %118 = extractvalue { ptr, ptr, i64 } %8, 1
  %119 = load i64, ptr %118, align 8
  %120 = add i64 %119, 1
  %121 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %120, ptr %121, align 8
  br label %14

122:                                              ; preds = %34
  %123 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %124 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %123, 1
  call void @"drop$300"({ ptr, i32, i32, i32 } %41)
  call void @"drop$289"({ ptr, i32, i32, i32 } %18)
  %125 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %124, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %125, ptr %13, align 8
  %126 = load { i64, [48 x i8] }, ptr %13, align 8
  %127 = extractvalue { ptr, ptr, i64 } %8, 1
  %128 = load i64, ptr %127, align 8
  %129 = icmp eq i64 %128, 0
  %130 = sub i64 %128, 1
  %131 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %130, ptr %131, align 8
  br i1 %129, label %145, label %132

132:                                              ; preds = %132, %122, %149, %171
  %133 = phi i64 [ %19, %171 ], [ %19, %149 ], [ %133, %132 ], [ %52, %122 ]
  %134 = phi i64 [ %16, %171 ], [ %155, %149 ], [ %134, %132 ], [ %53, %122 ]
  %135 = phi { i64, [48 x i8] } [ %176, %171 ], [ %161, %149 ], [ %135, %132 ], [ %126, %122 ]
  %136 = extractvalue { ptr, ptr, i64 } %8, 1
  %137 = load i64, ptr %136, align 8
  %138 = icmp eq i64 %137, 0
  %139 = sub i64 %137, 1
  %140 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %139, ptr %140, align 8
  br i1 %138, label %141, label %132

141:                                              ; preds = %132
  %142 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %133, 0
  %143 = insertvalue { i64, i64, { i64, [48 x i8] } } %142, i64 %134, 1
  %144 = insertvalue { i64, i64, { i64, [48 x i8] } } %143, { i64, [48 x i8] } %135, 2
  ret { i64, i64, { i64, [48 x i8] } } %144

145:                                              ; preds = %122
  %146 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %52, 0
  %147 = insertvalue { i64, i64, { i64, [48 x i8] } } %146, i64 %53, 1
  %148 = insertvalue { i64, i64, { i64, [48 x i8] } } %147, { i64, [48 x i8] } %126, 2
  ret { i64, i64, { i64, [48 x i8] } } %148

149:                                              ; preds = %26
  %150 = phi i64 [ %25, %26 ]
  %151 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %152 = call ptr %151()
  %153 = load i64, ptr %152, align 8
  %154 = mul i64 %153, 7660
  %155 = call i64 @llvm.uadd.sat.i64(i64 %150, i64 %154)
  %156 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %29, 0
  %157 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %156, 0
  %158 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } undef, { { { ptr, i32, i32, i32 } } } %157, 0
  %159 = insertvalue { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %158, { ptr, i32, i32, i32 } %18, 1
  %160 = insertvalue { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } undef }, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } %159, 1
  store { i1, { { { { ptr, i32, i32, i32 } } }, { ptr, i32, i32, i32 }, {} } } %160, ptr %11, align 8
  %161 = load { i64, [48 x i8] }, ptr %11, align 8
  %162 = extractvalue { ptr, ptr, i64 } %8, 1
  %163 = load i64, ptr %162, align 8
  %164 = icmp eq i64 %163, 0
  %165 = sub i64 %163, 1
  %166 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %165, ptr %166, align 8
  br i1 %164, label %167, label %132

167:                                              ; preds = %149
  %168 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %19, 0
  %169 = insertvalue { i64, i64, { i64, [48 x i8] } } %168, i64 %155, 1
  %170 = insertvalue { i64, i64, { i64, [48 x i8] } } %169, { i64, [48 x i8] } %161, 2
  ret { i64, i64, { i64, [48 x i8] } } %170

171:                                              ; preds = %14
  %172 = phi { { { ptr, i32, i32, i32 } } } [ %17, %14 ]
  call void @"drop$401"({ { { ptr, i32, i32, i32 } } } %172)
  call void @"drop$289"({ ptr, i32, i32, i32 } %18)
  %173 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %174 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %173, 0
  %175 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %174, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %175, ptr %10, align 8
  %176 = load { i64, [48 x i8] }, ptr %10, align 8
  %177 = extractvalue { ptr, ptr, i64 } %8, 1
  %178 = load i64, ptr %177, align 8
  %179 = icmp eq i64 %178, 0
  %180 = sub i64 %178, 1
  %181 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %180, ptr %181, align 8
  br i1 %179, label %182, label %132

182:                                              ; preds = %171
  %183 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %19, 0
  %184 = insertvalue { i64, i64, { i64, [48 x i8] } } %183, i64 %16, 1
  %185 = insertvalue { i64, i64, { i64, [48 x i8] } } %184, { i64, [48 x i8] } %176, 2
  ret { i64, i64, { i64, [48 x i8] } } %185

186:                                              ; preds = %56
  call void @puts(ptr @assert_msg_133)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [48 x i8] } } @f64(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f64"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [48 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [48 x i8] } } %10, { i64, [48 x i8] } %8, 2
  ret { i64, i64, { i64, [48 x i8] } } %11
}

define void @_mlir_ciface_f64(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 } } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [48 x i8] } } @f64(i64 %1, i64 %2, { { { ptr, i32, i32, i32 } } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [48 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$288"(ptr %0) {
  %2 = load { ptr, i32, i32, i32 }, ptr %0, align 8
  call void @"drop$293"({ ptr, i32, i32, i32 } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$288"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 24)
  %3 = load { ptr, i32, i32, i32 }, ptr %0, align 8
  %4 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$293"({ ptr, i32, i32, i32 } %3)
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 0
  %6 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 1
  store { ptr, i32, i32, i32 } %5, ptr %0, align 8
  store { ptr, i32, i32, i32 } %6, ptr %2, align 8
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f65"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %14

14:                                               ; preds = %112, %4
  %15 = phi i64 [ %106, %112 ], [ %0, %4 ]
  %16 = phi i64 [ %117, %112 ], [ %1, %4 ]
  %17 = phi { { ptr, i32, i32, i32 } } [ %118, %112 ], [ %2, %4 ]
  %18 = phi { ptr, i32, i32, i32 } [ %119, %112 ], [ %3, %4 ]
  %19 = add i64 %15, 1
  %20 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %21 = call ptr %20()
  %22 = load i64, ptr %21, align 8
  %23 = mul i64 %22, 5210
  %24 = icmp uge i64 %16, %23
  %25 = call i64 @llvm.usub.sat.i64(i64 %16, i64 %23)
  br i1 %24, label %26, label %170

26:                                               ; preds = %14
  %27 = phi { { ptr, i32, i32, i32 } } [ %17, %14 ]
  %28 = extractvalue { { ptr, i32, i32, i32 } } %27, 0
  %29 = extractvalue { ptr, i32, i32, i32 } %28, 1
  %30 = extractvalue { ptr, i32, i32, i32 } %28, 2
  %31 = sub i32 %30, %29
  %32 = icmp uge i32 %31, 1
  br i1 %32, label %33, label %151

33:                                               ; preds = %26
  %34 = extractvalue { ptr, i32, i32, i32 } %28, 0
  %35 = load ptr, ptr %34, align 8
  %36 = zext i32 %29 to i64
  %37 = mul i64 %36, 24
  %38 = getelementptr inbounds i8, ptr %35, i64 %37
  %39 = add i32 %29, 1
  %40 = insertvalue { ptr, i32, i32, i32 } %28, i32 %39, 1
  %41 = call ptr @realloc(ptr null, i64 24)
  %42 = load { ptr, i32, i32, i32 }, ptr %38, align 8
  %43 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$292"({ ptr, i32, i32, i32 } %42)
  %44 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %43, 0
  %45 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %43, 1
  store { ptr, i32, i32, i32 } %44, ptr %38, align 8
  store { ptr, i32, i32, i32 } %45, ptr %41, align 8
  %46 = load { ptr, i32, i32, i32 }, ptr %41, align 8
  call void @free(ptr %41)
  %47 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$293"({ ptr, i32, i32, i32 } %46)
  %48 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %47, 0
  %49 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %47, 1
  %50 = extractvalue { ptr, i32, i32, i32 } %49, 1
  %51 = extractvalue { ptr, i32, i32, i32 } %49, 2
  %52 = sub i32 %51, %50
  call void @"drop$293"({ ptr, i32, i32, i32 } %49)
  %53 = zext i32 %52 to i252
  %54 = extractvalue { ptr, i32, i32, i32 } %18, 3
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %70

56:                                               ; preds = %33
  %57 = shl i32 %54, 1
  %58 = call i32 @llvm.umin.i32(i32 %57, i32 1024)
  %59 = add i32 %58, %54
  %60 = call i32 @llvm.umax.i32(i32 %59, i32 8)
  %61 = zext i32 %60 to i64
  %62 = mul i64 %61, 32
  %63 = add i64 %62, 16
  %64 = call ptr @realloc(ptr null, i64 %63)
  store i32 1, ptr %64, align 4
  %65 = getelementptr inbounds i8, ptr %64, i32 4
  store i32 0, ptr %65, align 4
  %66 = getelementptr inbounds i8, ptr %64, i32 16
  %67 = call ptr @realloc(ptr null, i64 8)
  store ptr %66, ptr %67, align 8
  %68 = insertvalue { ptr, i32, i32, i32 } %18, ptr %67, 0
  %69 = insertvalue { ptr, i32, i32, i32 } %68, i32 %60, 3
  br label %91

70:                                               ; preds = %33
  %71 = extractvalue { ptr, i32, i32, i32 } %18, 2
  %72 = icmp ult i32 %71, %54
  br i1 %72, label %73, label %74

73:                                               ; preds = %70
  br label %88

74:                                               ; preds = %70
  %75 = shl i32 %54, 1
  %76 = call i32 @llvm.umin.i32(i32 %75, i32 1024)
  %77 = add i32 %76, %54
  %78 = call i32 @llvm.umax.i32(i32 %77, i32 8)
  %79 = zext i32 %78 to i64
  %80 = mul i64 %79, 32
  %81 = add i64 %80, 16
  %82 = extractvalue { ptr, i32, i32, i32 } %18, 0
  %83 = load ptr, ptr %82, align 8
  %84 = getelementptr inbounds i8, ptr %83, i32 -16
  %85 = call ptr @realloc(ptr %84, i64 %81)
  %86 = getelementptr inbounds i8, ptr %85, i32 16
  store ptr %86, ptr %82, align 8
  %87 = insertvalue { ptr, i32, i32, i32 } %18, i32 %78, 3
  br label %88

88:                                               ; preds = %73, %74
  %89 = phi { ptr, i32, i32, i32 } [ %87, %74 ], [ %18, %73 ]
  br label %90

90:                                               ; preds = %88
  br label %91

91:                                               ; preds = %56, %90
  %92 = phi { ptr, i32, i32, i32 } [ %89, %90 ], [ %69, %56 ]
  br label %93

93:                                               ; preds = %91
  %94 = extractvalue { ptr, i32, i32, i32 } %92, 0
  %95 = load ptr, ptr %94, align 8
  %96 = extractvalue { ptr, i32, i32, i32 } %92, 2
  %97 = zext i32 %96 to i64
  %98 = mul i64 %97, 32
  %99 = getelementptr inbounds i8, ptr %95, i64 %98
  store i252 %53, ptr %99, align 16
  %100 = extractvalue { ptr, i32, i32, i32 } %92, 2
  %101 = add i32 %100, 1
  %102 = insertvalue { ptr, i32, i32, i32 } %92, i32 %101, 2
  %103 = getelementptr inbounds i8, ptr %95, i32 -12
  store i32 %101, ptr %103, align 4
  %104 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %48, 0
  %105 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f60"(i64 %19, i64 %25, { { ptr, i32, i32, i32 } } %104, { ptr, i32, i32, i32 } %102)
  %106 = extractvalue { i64, i64, { i64, [24 x i8] } } %105, 0
  %107 = extractvalue { i64, i64, { i64, [24 x i8] } } %105, 1
  %108 = extractvalue { i64, i64, { i64, [24 x i8] } } %105, 2
  store { i64, [24 x i8] } %108, ptr %12, align 8
  %109 = load i1, ptr %12, align 1
  switch i1 %109, label %110 [
    i1 false, label %112
    i1 true, label %124
  ]

110:                                              ; preds = %93
  br i1 false, label %111, label %185

111:                                              ; preds = %110
  unreachable

112:                                              ; preds = %93
  %113 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %12, align 8
  %114 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %113, 1
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = call i64 @llvm.uadd.sat.i64(i64 %107, i64 0)
  %118 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %40, 0
  %119 = extractvalue { { ptr, i32, i32, i32 }, {} } %114, 0
  %120 = extractvalue { ptr, ptr, i64 } %8, 1
  %121 = load i64, ptr %120, align 8
  %122 = add i64 %121, 1
  %123 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %122, ptr %123, align 8
  br label %14

124:                                              ; preds = %93
  %125 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %126 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %125, 1
  call void @"drop$290"({ ptr, i32, i32, i32 } %40)
  %127 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %126, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %127, ptr %13, align 8
  %128 = load { i64, [24 x i8] }, ptr %13, align 8
  %129 = extractvalue { ptr, ptr, i64 } %8, 1
  %130 = load i64, ptr %129, align 8
  %131 = icmp eq i64 %130, 0
  %132 = sub i64 %130, 1
  %133 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %132, ptr %133, align 8
  br i1 %131, label %147, label %134

134:                                              ; preds = %134, %124, %151, %170
  %135 = phi i64 [ %19, %170 ], [ %19, %151 ], [ %135, %134 ], [ %106, %124 ]
  %136 = phi i64 [ %16, %170 ], [ %157, %151 ], [ %136, %134 ], [ %107, %124 ]
  %137 = phi { i64, [24 x i8] } [ %175, %170 ], [ %160, %151 ], [ %137, %134 ], [ %128, %124 ]
  %138 = extractvalue { ptr, ptr, i64 } %8, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %143, label %134

143:                                              ; preds = %134
  %144 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %135, 0
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } %144, i64 %136, 1
  %146 = insertvalue { i64, i64, { i64, [24 x i8] } } %145, { i64, [24 x i8] } %137, 2
  ret { i64, i64, { i64, [24 x i8] } } %146

147:                                              ; preds = %124
  %148 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %106, 0
  %149 = insertvalue { i64, i64, { i64, [24 x i8] } } %148, i64 %107, 1
  %150 = insertvalue { i64, i64, { i64, [24 x i8] } } %149, { i64, [24 x i8] } %128, 2
  ret { i64, i64, { i64, [24 x i8] } } %150

151:                                              ; preds = %26
  %152 = phi { ptr, i32, i32, i32 } [ %28, %26 ]
  call void @"drop$290"({ ptr, i32, i32, i32 } %152)
  %153 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %154 = call ptr %153()
  %155 = load i64, ptr %154, align 8
  %156 = mul i64 %155, 5910
  %157 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %156)
  %158 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %18, 0
  %159 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %158, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %159, ptr %11, align 8
  %160 = load { i64, [24 x i8] }, ptr %11, align 8
  %161 = extractvalue { ptr, ptr, i64 } %8, 1
  %162 = load i64, ptr %161, align 8
  %163 = icmp eq i64 %162, 0
  %164 = sub i64 %162, 1
  %165 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %164, ptr %165, align 8
  br i1 %163, label %166, label %134

166:                                              ; preds = %151
  %167 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %19, 0
  %168 = insertvalue { i64, i64, { i64, [24 x i8] } } %167, i64 %157, 1
  %169 = insertvalue { i64, i64, { i64, [24 x i8] } } %168, { i64, [24 x i8] } %160, 2
  ret { i64, i64, { i64, [24 x i8] } } %169

170:                                              ; preds = %14
  %171 = phi { ptr, i32, i32, i32 } [ %18, %14 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %171)
  call void @"drop$399"({ { ptr, i32, i32, i32 } } %17)
  %172 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %173 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %172, 0
  %174 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %173, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %174, ptr %10, align 8
  %175 = load { i64, [24 x i8] }, ptr %10, align 8
  %176 = extractvalue { ptr, ptr, i64 } %8, 1
  %177 = load i64, ptr %176, align 8
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %177, 1
  %180 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %179, ptr %180, align 8
  br i1 %178, label %181, label %134

181:                                              ; preds = %170
  %182 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %19, 0
  %183 = insertvalue { i64, i64, { i64, [24 x i8] } } %182, i64 %16, 1
  %184 = insertvalue { i64, i64, { i64, [24 x i8] } } %183, { i64, [24 x i8] } %175, 2
  ret { i64, i64, { i64, [24 x i8] } } %184

185:                                              ; preds = %110
  call void @puts(ptr @assert_msg_134)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f65(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f65"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f65(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f65(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$283"(ptr %0) {
  %2 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %0, align 16
  call void @"drop$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$283"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 144)
  %3 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %0, align 16
  %4 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %3)
  %5 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %4, 0
  %6 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %4, 1
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %5, ptr %0, align 16
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f66"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { {} } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [48 x i8] }, i64 1, align 8
  %13 = alloca { i64, [48 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %16

16:                                               ; preds = %89, %6
  %17 = phi i64 [ %81, %89 ], [ %0, %6 ]
  %18 = phi i64 [ %94, %89 ], [ %1, %6 ]
  %19 = phi i64 [ %83, %89 ], [ %2, %6 ]
  %20 = phi ptr [ %84, %89 ], [ %3, %6 ]
  %21 = phi { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } [ %99, %89 ], [ %4, %6 ]
  %22 = phi { {} } [ %95, %89 ], [ %5, %6 ]
  %23 = add i64 %17, 1
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = getelementptr inbounds i64, ptr %25, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %25, align 8
  %29 = mul i64 %28, 125130
  %30 = add i64 %27, %29
  %31 = icmp uge i64 %18, %30
  %32 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %30)
  br i1 %31, label %33, label %182

33:                                               ; preds = %16
  %34 = phi { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } [ %21, %16 ]
  %35 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %34, 0
  %36 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %34, 1
  %37 = extractvalue { { ptr, i32, i32, i32 } } %35, 0
  %38 = extractvalue { ptr, i32, i32, i32 } %37, 1
  %39 = extractvalue { ptr, i32, i32, i32 } %37, 2
  %40 = sub i32 %39, %38
  %41 = icmp uge i32 %40, 1
  br i1 %41, label %42, label %148

42:                                               ; preds = %33
  %43 = extractvalue { ptr, i32, i32, i32 } %37, 0
  %44 = load ptr, ptr %43, align 8
  %45 = zext i32 %38 to i64
  %46 = mul i64 %45, 144
  %47 = getelementptr inbounds i8, ptr %44, i64 %46
  %48 = add i32 %38, 1
  %49 = insertvalue { ptr, i32, i32, i32 } %37, i32 %48, 1
  %50 = call ptr @realloc(ptr null, i64 144)
  %51 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %47, align 16
  %52 = call { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } @"dup$297"({ { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %51)
  %53 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %52, 0
  %54 = extractvalue { { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } } %52, 1
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %53, ptr %47, align 16
  store { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %54, ptr %50, align 16
  %55 = extractvalue { { ptr, i32, i32, i32 } } %36, 0
  %56 = extractvalue { ptr, i32, i32, i32 } %55, 1
  %57 = extractvalue { ptr, i32, i32, i32 } %55, 2
  %58 = sub i32 %57, %56
  %59 = icmp uge i32 %58, 1
  br i1 %59, label %60, label %137

60:                                               ; preds = %42
  %61 = extractvalue { ptr, i32, i32, i32 } %55, 0
  %62 = load ptr, ptr %61, align 8
  %63 = zext i32 %56 to i64
  %64 = mul i64 %63, 24
  %65 = getelementptr inbounds i8, ptr %62, i64 %64
  %66 = add i32 %56, 1
  %67 = insertvalue { ptr, i32, i32, i32 } %55, i32 %66, 1
  %68 = call ptr @realloc(ptr null, i64 24)
  %69 = load { ptr, i32, i32, i32 }, ptr %65, align 8
  %70 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %69)
  %71 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %70, 0
  %72 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %70, 1
  store { ptr, i32, i32, i32 } %71, ptr %65, align 8
  store { ptr, i32, i32, i32 } %72, ptr %68, align 8
  %73 = load { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } }, ptr %50, align 16
  call void @free(ptr %50)
  %74 = load { ptr, i32, i32, i32 }, ptr %68, align 8
  call void @free(ptr %68)
  %75 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %73, 0
  %76 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %73, 1
  %77 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %73, 2
  %78 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %73, 3
  %79 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, { ptr, i32, i32, i32 } } %73, 4
  call void @"drop$292"({ ptr, i32, i32, i32 } %79)
  %80 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f61"(i64 %23, i64 %32, i64 %19, ptr %20, { {} } %22, { i3, [0 x i8] } %75, i32 %76, { { ptr, i32, i32, i32 }, i252, i32 } %77, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %78, { ptr, i32, i32, i32 } %74)
  %81 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, 0
  %82 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, 1
  %83 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, 2
  %84 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, 3
  %85 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %80, 4
  store { i64, [24 x i8] } %85, ptr %14, align 8
  %86 = load i1, ptr %14, align 1
  switch i1 %86, label %87 [
    i1 false, label %89
    i1 true, label %104
  ]

87:                                               ; preds = %60
  br i1 false, label %88, label %199

88:                                               ; preds = %87
  unreachable

89:                                               ; preds = %60
  %90 = load { i1, { { {} }, {} } }, ptr %14, align 1
  %91 = extractvalue { i1, { { {} }, {} } } %90, 1
  %92 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %93 = call ptr %92()
  %94 = call i64 @llvm.uadd.sat.i64(i64 %82, i64 0)
  %95 = extractvalue { { {} }, {} } %91, 0
  %96 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %49, 0
  %97 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %67, 0
  %98 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %96, 0
  %99 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %98, { { ptr, i32, i32, i32 } } %97, 1
  %100 = extractvalue { ptr, ptr, i64 } %10, 1
  %101 = load i64, ptr %100, align 8
  %102 = add i64 %101, 1
  %103 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %102, ptr %103, align 8
  br label %16

104:                                              ; preds = %60
  %105 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %106 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %105, 1
  call void @"drop$286"({ ptr, i32, i32, i32 } %49)
  call void @"drop$284"({ ptr, i32, i32, i32 } %67)
  %107 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %106, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %107, ptr %15, align 8
  %108 = load { i64, [48 x i8] }, ptr %15, align 8
  %109 = extractvalue { ptr, ptr, i64 } %10, 1
  %110 = load i64, ptr %109, align 8
  %111 = icmp eq i64 %110, 0
  %112 = sub i64 %110, 1
  %113 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %112, ptr %113, align 8
  br i1 %111, label %131, label %114

114:                                              ; preds = %114, %104, %158, %182
  %115 = phi i64 [ %23, %182 ], [ %161, %158 ], [ %115, %114 ], [ %81, %104 ]
  %116 = phi i64 [ %18, %182 ], [ %162, %158 ], [ %116, %114 ], [ %82, %104 ]
  %117 = phi i64 [ %19, %182 ], [ %159, %158 ], [ %117, %114 ], [ %83, %104 ]
  %118 = phi ptr [ %20, %182 ], [ %160, %158 ], [ %118, %114 ], [ %84, %104 ]
  %119 = phi { i64, [48 x i8] } [ %187, %182 ], [ %170, %158 ], [ %119, %114 ], [ %108, %104 ]
  %120 = extractvalue { ptr, ptr, i64 } %10, 1
  %121 = load i64, ptr %120, align 8
  %122 = icmp eq i64 %121, 0
  %123 = sub i64 %121, 1
  %124 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %123, ptr %124, align 8
  br i1 %122, label %125, label %114

125:                                              ; preds = %114
  %126 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %115, 0
  %127 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %126, i64 %116, 1
  %128 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %127, i64 %117, 2
  %129 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %128, ptr %118, 3
  %130 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %129, { i64, [48 x i8] } %119, 4
  ret { i64, i64, i64, ptr, { i64, [48 x i8] } } %130

131:                                              ; preds = %104
  %132 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %81, 0
  %133 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %132, i64 %82, 1
  %134 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %133, i64 %83, 2
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %134, ptr %84, 3
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %135, { i64, [48 x i8] } %108, 4
  ret { i64, i64, i64, ptr, { i64, [48 x i8] } } %136

137:                                              ; preds = %42
  %138 = phi ptr [ %50, %42 ]
  call void @"drop$283"(ptr %138)
  %139 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %140 = call ptr %139()
  %141 = getelementptr inbounds i64, ptr %140, i32 1
  %142 = load i64, ptr %141, align 8
  %143 = load i64, ptr %140, align 8
  %144 = mul i64 %143, 124350
  %145 = add i64 %142, %144
  %146 = call i64 @llvm.uadd.sat.i64(i64 %32, i64 %145)
  %147 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %55, 0
  br label %158

148:                                              ; preds = %33
  %149 = phi i64 [ %32, %33 ]
  %150 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %151 = call ptr %150()
  %152 = getelementptr inbounds i64, ptr %151, i32 1
  %153 = load i64, ptr %152, align 8
  %154 = load i64, ptr %151, align 8
  %155 = mul i64 %154, 124720
  %156 = add i64 %153, %155
  %157 = call i64 @llvm.uadd.sat.i64(i64 %149, i64 %156)
  br label %158

158:                                              ; preds = %137, %148
  %159 = phi i64 [ %19, %148 ], [ %19, %137 ]
  %160 = phi ptr [ %20, %148 ], [ %20, %137 ]
  %161 = phi i64 [ %23, %148 ], [ %23, %137 ]
  %162 = phi i64 [ %157, %148 ], [ %146, %137 ]
  %163 = phi { ptr, i32, i32, i32 } [ %37, %148 ], [ %49, %137 ]
  %164 = phi { { ptr, i32, i32, i32 } } [ %36, %148 ], [ %147, %137 ]
  %165 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %163, 0
  %166 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %165, 0
  %167 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %166, { { ptr, i32, i32, i32 } } %164, 1
  %168 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %167, 0
  %169 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } undef }, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } %168, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { {} }, {} } } %169, ptr %13, align 8
  %170 = load { i64, [48 x i8] }, ptr %13, align 8
  %171 = extractvalue { ptr, ptr, i64 } %10, 1
  %172 = load i64, ptr %171, align 8
  %173 = icmp eq i64 %172, 0
  %174 = sub i64 %172, 1
  %175 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %174, ptr %175, align 8
  br i1 %173, label %176, label %114

176:                                              ; preds = %158
  %177 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %161, 0
  %178 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %177, i64 %162, 1
  %179 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %178, i64 %159, 2
  %180 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %179, ptr %160, 3
  %181 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %180, { i64, [48 x i8] } %170, 4
  ret { i64, i64, i64, ptr, { i64, [48 x i8] } } %181

182:                                              ; preds = %16
  %183 = phi { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } [ %21, %16 ]
  call void @"drop$395"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %183)
  %184 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %185 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %184, 0
  %186 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %185, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %186, ptr %12, align 8
  %187 = load { i64, [48 x i8] }, ptr %12, align 8
  %188 = extractvalue { ptr, ptr, i64 } %10, 1
  %189 = load i64, ptr %188, align 8
  %190 = icmp eq i64 %189, 0
  %191 = sub i64 %189, 1
  %192 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %191, ptr %192, align 8
  br i1 %190, label %193, label %114

193:                                              ; preds = %182
  %194 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %23, 0
  %195 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %194, i64 %18, 1
  %196 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %195, i64 %19, 2
  %197 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %196, ptr %20, 3
  %198 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %197, { i64, [48 x i8] } %187, 4
  ret { i64, i64, i64, ptr, { i64, [48 x i8] } } %198

199:                                              ; preds = %87
  call void @puts(ptr @assert_msg_135)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [48 x i8] } } @f66(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { {} } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f66"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { {} } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [48 x i8] } } %16, { i64, [48 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [48 x i8] } } %17
}

define void @_mlir_ciface_f66(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, { {} } %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [48 x i8] } } @f66(i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, { {} } %6)
  store { i64, i64, i64, ptr, { i64, [48 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f67"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, { {} } %5) {
  %7 = alloca i64, i64 1, align 8
  %8 = insertvalue { ptr, ptr, i64 } undef, ptr %7, 0
  %9 = insertvalue { ptr, ptr, i64 } %8, ptr %7, 1
  %10 = insertvalue { ptr, ptr, i64 } %9, i64 0, 2
  %11 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 0, ptr %11, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca i256, i64 1, align 16
  %15 = alloca i256, i64 1, align 16
  %16 = alloca i256, i64 1, align 16
  %17 = alloca { i1, [31 x i8] }, i64 1, align 8
  %18 = alloca i64, i64 1, align 8
  %19 = alloca i252, i64 1, align 16
  %20 = alloca i252, i64 1, align 16
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %22

22:                                               ; preds = %72, %6
  %23 = phi i64 [ %60, %72 ], [ %0, %6 ]
  %24 = phi i64 [ %76, %72 ], [ %1, %6 ]
  %25 = phi i64 [ %55, %72 ], [ %2, %6 ]
  %26 = phi ptr [ %26, %72 ], [ %3, %6 ]
  %27 = phi { { ptr, i32, i32, i32 } } [ %77, %72 ], [ %4, %6 ]
  %28 = add i64 %23, 1
  %29 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %30 = call ptr %29()
  %31 = getelementptr inbounds i64, ptr %30, i32 1
  %32 = load i64, ptr %31, align 8
  %33 = load i64, ptr %30, align 8
  %34 = mul i64 %33, 14780
  %35 = add i64 %32, %34
  %36 = icmp uge i64 %24, %35
  %37 = call i64 @llvm.usub.sat.i64(i64 %24, i64 %35)
  br i1 %36, label %38, label %140

38:                                               ; preds = %22
  %39 = phi { { ptr, i32, i32, i32 } } [ %27, %22 ]
  %40 = extractvalue { { ptr, i32, i32, i32 } } %39, 0
  %41 = extractvalue { ptr, i32, i32, i32 } %40, 1
  %42 = extractvalue { ptr, i32, i32, i32 } %40, 2
  %43 = sub i32 %42, %41
  %44 = icmp uge i32 %43, 1
  br i1 %44, label %45, label %115

45:                                               ; preds = %38
  %46 = extractvalue { ptr, i32, i32, i32 } %40, 0
  %47 = load ptr, ptr %46, align 8
  %48 = zext i32 %41 to i64
  %49 = mul i64 %48, 32
  %50 = getelementptr inbounds i8, ptr %47, i64 %49
  %51 = add i32 %41, 1
  %52 = insertvalue { ptr, i32, i32, i32 } %40, i32 %51, 1
  %53 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %53, ptr %50, i64 32, i1 false)
  %54 = load i252, ptr %53, align 16
  call void @free(ptr %53)
  %55 = add i64 %25, 3
  %56 = zext i252 %54 to i256
  store i256 1038721536386752126714616871058711680196540256345684263538672831881870690668, ptr %14, align 16
  store i256 %56, ptr %15, align 16
  %57 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %57(ptr %16, ptr %14, ptr %15)
  %58 = load i256, ptr %16, align 16
  %59 = trunc i256 %58 to i252
  %60 = add i64 %23, 4
  %61 = sub i252 %59, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %62 = icmp ult i252 %59, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %63 = select i1 %62, i252 %59, i252 %61
  %64 = load ptr, ptr %26, align 8
  store i64 %37, ptr %18, align 8
  store i252 %63, ptr %19, align 16
  store i252 1, ptr %20, align 16
  %65 = getelementptr inbounds ptr, ptr %26, i32 9
  %66 = load ptr, ptr %65, align 8
  call void %66(ptr %17, ptr %64, ptr %18, i32 0, ptr %19, ptr %20)
  %67 = load { i1, [31 x i8] }, ptr %17, align 1
  %68 = extractvalue { i1, [31 x i8] } %67, 0
  %69 = getelementptr inbounds i8, ptr %17, i32 8
  %70 = load { ptr, i32, i32, i32 }, ptr %69, align 8
  %71 = load i64, ptr %18, align 8
  br i1 %68, label %99, label %72

72:                                               ; preds = %45
  %73 = phi i64 [ %71, %45 ]
  %74 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %75 = call ptr %74()
  %76 = call i64 @llvm.uadd.sat.i64(i64 %73, i64 0)
  %77 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %52, 0
  %78 = extractvalue { ptr, ptr, i64 } %10, 1
  %79 = load i64, ptr %78, align 8
  %80 = add i64 %79, 1
  %81 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %80, ptr %81, align 8
  br label %22

82:                                               ; preds = %82, %99, %115, %140
  %83 = phi i64 [ %28, %140 ], [ %28, %115 ], [ %60, %99 ], [ %83, %82 ]
  %84 = phi i64 [ %24, %140 ], [ %124, %115 ], [ %71, %99 ], [ %84, %82 ]
  %85 = phi i64 [ %25, %140 ], [ %25, %115 ], [ %55, %99 ], [ %85, %82 ]
  %86 = phi ptr [ %26, %140 ], [ %26, %115 ], [ %26, %99 ], [ %86, %82 ]
  %87 = phi { i64, [24 x i8] } [ %145, %140 ], [ %128, %115 ], [ %103, %99 ], [ %87, %82 ]
  %88 = extractvalue { ptr, ptr, i64 } %10, 1
  %89 = load i64, ptr %88, align 8
  %90 = icmp eq i64 %89, 0
  %91 = sub i64 %89, 1
  %92 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %91, ptr %92, align 8
  br i1 %90, label %93, label %82

93:                                               ; preds = %82
  %94 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %83, 0
  %95 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %94, i64 %84, 1
  %96 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %95, i64 %85, 2
  %97 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %96, ptr %86, 3
  %98 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %97, { i64, [24 x i8] } %87, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %98

99:                                               ; preds = %45
  %100 = phi { ptr, i32, i32, i32 } [ %52, %45 ]
  call void @"drop$377"({ ptr, i32, i32, i32 } %100)
  %101 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %70, 1
  %102 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %101, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %102, ptr %21, align 8
  %103 = load { i64, [24 x i8] }, ptr %21, align 8
  %104 = extractvalue { ptr, ptr, i64 } %10, 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %105, 1
  %108 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %107, ptr %108, align 8
  br i1 %106, label %109, label %82

109:                                              ; preds = %99
  %110 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %60, 0
  %111 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %110, i64 %71, 1
  %112 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %111, i64 %55, 2
  %113 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %112, ptr %26, 3
  %114 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %113, { i64, [24 x i8] } %103, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %114

115:                                              ; preds = %38
  %116 = phi i64 [ %37, %38 ]
  %117 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %118 = call ptr %117()
  %119 = getelementptr inbounds i64, ptr %118, i32 1
  %120 = load i64, ptr %119, align 8
  %121 = load i64, ptr %118, align 8
  %122 = mul i64 %121, 14980
  %123 = add i64 %120, %122
  %124 = call i64 @llvm.uadd.sat.i64(i64 %116, i64 %123)
  %125 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %40, 0
  %126 = insertvalue { { { ptr, i32, i32, i32 } }, { {} }, {} } undef, { { ptr, i32, i32, i32 } } %125, 0
  %127 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { {} }, {} } undef }, { { { ptr, i32, i32, i32 } }, { {} }, {} } %126, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { {} }, {} } } %127, ptr %13, align 8
  %128 = load { i64, [24 x i8] }, ptr %13, align 8
  %129 = extractvalue { ptr, ptr, i64 } %10, 1
  %130 = load i64, ptr %129, align 8
  %131 = icmp eq i64 %130, 0
  %132 = sub i64 %130, 1
  %133 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %132, ptr %133, align 8
  br i1 %131, label %134, label %82

134:                                              ; preds = %115
  %135 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %28, 0
  %136 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %135, i64 %124, 1
  %137 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %136, i64 %25, 2
  %138 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %137, ptr %26, 3
  %139 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %138, { i64, [24 x i8] } %128, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %139

140:                                              ; preds = %22
  %141 = phi { { ptr, i32, i32, i32 } } [ %27, %22 ]
  call void @"drop$378"({ { ptr, i32, i32, i32 } } %141)
  %142 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %143 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %142, 0
  %144 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %143, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %144, ptr %12, align 8
  %145 = load { i64, [24 x i8] }, ptr %12, align 8
  %146 = extractvalue { ptr, ptr, i64 } %10, 1
  %147 = load i64, ptr %146, align 8
  %148 = icmp eq i64 %147, 0
  %149 = sub i64 %147, 1
  %150 = extractvalue { ptr, ptr, i64 } %10, 1
  store i64 %149, ptr %150, align 8
  br i1 %148, label %151, label %82

151:                                              ; preds = %140
  %152 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %28, 0
  %153 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %152, i64 %24, 1
  %154 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %153, i64 %25, 2
  %155 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %154, ptr %26, 3
  %156 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %155, { i64, [24 x i8] } %145, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %156
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f67(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, { {} } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f67"(i64 %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, { {} } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %17
}

define void @_mlir_ciface_f67(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6) {
  %8 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f67(i64 %1, i64 %2, i64 %3, ptr %4, { { ptr, i32, i32, i32 } } %5, { {} } %6)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$6"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$5"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$6"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$5"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$7"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$6"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$7"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$6"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  call void @"drop$7"({ { ptr, i32, i32, i32 } } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$7"({ { ptr, i32, i32, i32 } } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, { { ptr, i32, i32, i32 } } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10, { { ptr, i32, i32, i32 } } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } undef, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %17, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %18
}

define private void @"drop$278"({ i252, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { i128, [80 x i8] } } %0, 1
  call void @"drop$19"({ i128, [80 x i8] } %2)
  ret void
}

define private { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } @"dup$278"({ i252, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { i128, [80 x i8] } } %0, 0
  %3 = insertvalue { i252, { i128, [80 x i8] } } %0, i252 %2, 0
  %4 = insertvalue { i252, { i128, [80 x i8] } } undef, i252 %2, 0
  %5 = extractvalue { i252, { i128, [80 x i8] } } %0, 1
  %6 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$19"({ i128, [80 x i8] } %5)
  %7 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %6, 0
  %8 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %6, 1
  %9 = insertvalue { i252, { i128, [80 x i8] } } %3, { i128, [80 x i8] } %7, 1
  %10 = insertvalue { i252, { i128, [80 x i8] } } %4, { i128, [80 x i8] } %8, 1
  %11 = insertvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } undef, { i252, { i128, [80 x i8] } } %9, 0
  %12 = insertvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %11, { i252, { i128, [80 x i8] } } %10, 1
  ret { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %12
}

define private void @"drop$9"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 128
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i252, { i128, [80 x i8] } }, ptr %22, align 16
  call void @"drop$278"({ i252, { i128, [80 x i8] } } %23)
  %24 = add i64 %19, 128
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$9"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$10"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$9"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$10"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$9"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$11"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$10"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$11"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$10"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  call void @"drop$11"({ { ptr, i32, i32, i32 } } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %0, 2
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$11"({ { ptr, i32, i32, i32 } } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, { { ptr, i32, i32, i32 } } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10, { { ptr, i32, i32, i32 } } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } undef, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %17, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %18
}

define private void @"drop$13"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 96
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i128, [80 x i8] }, ptr %22, align 16
  call void @"drop$19"({ i128, [80 x i8] } %23)
  %24 = add i64 %19, 96
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$14"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$13"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$14"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$15"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$14"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$15"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$14"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$18"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  call void @"drop$15"({ { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$18"({ { { ptr, i32, i32, i32 } }, i32 } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$15"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %0, 1
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %6, i32 %8, 1
  %10 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %7, i32 %8, 1
  %11 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } undef, { { { ptr, i32, i32, i32 } }, i32 } %9, 0
  %12 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %11, { { { ptr, i32, i32, i32 } }, i32 } %10, 1
  ret { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %12
}

define private void @"drop$19"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i3, ptr %2, align 1
  switch i3 %3, label %18 [
    i3 0, label %4
    i3 1, label %5
    i3 2, label %8
    i3 3, label %11
    i3 -4, label %11
    i3 -3, label %14
    i3 -2, label %15
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %7 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %6, 1
  call void @"drop$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %7)
  ret void

8:                                                ; preds = %1
  %9 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %10 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %9, 1
  call void @"drop$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %10)
  ret void

11:                                               ; preds = %1, %1
  %12 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %13 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %12, 1
  call void @"drop$15"({ { ptr, i32, i32, i32 } } %13)
  ret void

14:                                               ; preds = %1
  ret void

15:                                               ; preds = %1
  %16 = load { i3, { { { ptr, i32, i32, i32 } }, i32 } }, ptr %2, align 8
  %17 = extractvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %16, 1
  call void @"drop$18"({ { { ptr, i32, i32, i32 } }, i32 } %17)
  ret void

18:                                               ; preds = %1
  unreachable
}

define private { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$19"({ i128, [80 x i8] } %0) {
  %2 = alloca { i128, [80 x i8] }, i64 1, align 16
  store { i128, [80 x i8] } %0, ptr %2, align 16
  %3 = load i3, ptr %2, align 1
  switch i3 %3, label %70 [
    i3 0, label %4
    i3 1, label %13
    i3 2, label %25
    i3 3, label %37
    i3 -4, label %37
    i3 -3, label %49
    i3 -2, label %58
  ]

4:                                                ; preds = %1
  %5 = load { i3, i252 }, ptr %2, align 16
  %6 = extractvalue { i3, i252 } %5, 1
  %7 = insertvalue { i3, i252 } %5, i252 %6, 1
  store { i3, i252 } %7, ptr %2, align 16
  %8 = load { i128, [80 x i8] }, ptr %2, align 16
  %9 = insertvalue { i3, i252 } %5, i252 %6, 1
  store { i3, i252 } %9, ptr %2, align 16
  %10 = load { i128, [80 x i8] }, ptr %2, align 16
  %11 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %8, 0
  %12 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %11, { i128, [80 x i8] } %10, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %15 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, 1
  %16 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %15)
  %17 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %16, 0
  %18 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %16, 1
  %19 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %17, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %19, ptr %2, align 16
  %20 = load { i128, [80 x i8] }, ptr %2, align 16
  %21 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %14, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %18, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %21, ptr %2, align 16
  %22 = load { i128, [80 x i8] }, ptr %2, align 16
  %23 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %20, 0
  %24 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %23, { i128, [80 x i8] } %22, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %24

25:                                               ; preds = %1
  %26 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %27 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %26, 1
  %28 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %27)
  %29 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %28, 0
  %30 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %28, 1
  %31 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %26, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %29, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %31, ptr %2, align 16
  %32 = load { i128, [80 x i8] }, ptr %2, align 16
  %33 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %26, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %30, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %33, ptr %2, align 16
  %34 = load { i128, [80 x i8] }, ptr %2, align 16
  %35 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %32, 0
  %36 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %35, { i128, [80 x i8] } %34, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %36

37:                                               ; preds = %1, %1
  %38 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %39 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %38, 1
  %40 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$15"({ { ptr, i32, i32, i32 } } %39)
  %41 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %40, 0
  %42 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %40, 1
  %43 = insertvalue { i3, { { ptr, i32, i32, i32 } } } %38, { { ptr, i32, i32, i32 } } %41, 1
  store { i3, { { ptr, i32, i32, i32 } } } %43, ptr %2, align 8
  %44 = load { i128, [80 x i8] }, ptr %2, align 16
  %45 = insertvalue { i3, { { ptr, i32, i32, i32 } } } %38, { { ptr, i32, i32, i32 } } %42, 1
  store { i3, { { ptr, i32, i32, i32 } } } %45, ptr %2, align 8
  %46 = load { i128, [80 x i8] }, ptr %2, align 16
  %47 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %44, 0
  %48 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %47, { i128, [80 x i8] } %46, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %48

49:                                               ; preds = %1
  %50 = load { i3, {} }, ptr %2, align 1
  %51 = extractvalue { i3, {} } %50, 1
  %52 = insertvalue { i3, {} } %50, {} %51, 1
  store { i3, {} } %52, ptr %2, align 1
  %53 = load { i128, [80 x i8] }, ptr %2, align 16
  %54 = insertvalue { i3, {} } %50, {} %51, 1
  store { i3, {} } %54, ptr %2, align 1
  %55 = load { i128, [80 x i8] }, ptr %2, align 16
  %56 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %53, 0
  %57 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %56, { i128, [80 x i8] } %55, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %57

58:                                               ; preds = %1
  %59 = load { i3, { { { ptr, i32, i32, i32 } }, i32 } }, ptr %2, align 8
  %60 = extractvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %59, 1
  %61 = call { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } @"dup$18"({ { { ptr, i32, i32, i32 } }, i32 } %60)
  %62 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %61, 0
  %63 = extractvalue { { { { ptr, i32, i32, i32 } }, i32 }, { { { ptr, i32, i32, i32 } }, i32 } } %61, 1
  %64 = insertvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %59, { { { ptr, i32, i32, i32 } }, i32 } %62, 1
  store { i3, { { { ptr, i32, i32, i32 } }, i32 } } %64, ptr %2, align 8
  %65 = load { i128, [80 x i8] }, ptr %2, align 16
  %66 = insertvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %59, { { { ptr, i32, i32, i32 } }, i32 } %63, 1
  store { i3, { { { ptr, i32, i32, i32 } }, i32 } } %66, ptr %2, align 8
  %67 = load { i128, [80 x i8] }, ptr %2, align 16
  %68 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } undef, { i128, [80 x i8] } %65, 0
  %69 = insertvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %68, { i128, [80 x i8] } %67, 1
  ret { { i128, [80 x i8] }, { i128, [80 x i8] } } %69

70:                                               ; preds = %1
  unreachable
}

define private void @"drop$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 2
  call void @"drop$19"({ i128, [80 x i8] } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %3, { { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %4, { { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %0, 2
  %12 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$19"({ i128, [80 x i8] } %11)
  %13 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %12, 0
  %14 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %9, { i128, [80 x i8] } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %10, { i128, [80 x i8] } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } undef, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %17, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %18
}

define private void @"drop$5"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %27

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %26

13:                                               ; preds = %6
  %14 = getelementptr inbounds i8, ptr %7, i32 -12
  %15 = load i32, ptr %14, align 4
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 160
  br label %18

18:                                               ; preds = %21, %13
  %19 = phi i64 [ %24, %21 ], [ 0, %13 ]
  %20 = icmp slt i64 %19, %17
  br i1 %20, label %21, label %25

21:                                               ; preds = %18
  %22 = getelementptr inbounds i8, ptr %7, i64 %19
  %23 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %22, align 16
  call void @"drop$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %23)
  %24 = add i64 %19, 160
  br label %18

25:                                               ; preds = %18
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %26

26:                                               ; preds = %11, %25
  br label %27

27:                                               ; preds = %5, %26
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$5"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -16
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f68"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = alloca { i128, [80 x i8] }, i64 1, align 16
  %7 = alloca { i128, [80 x i8] }, i64 1, align 16
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [80 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = alloca { i128, [80 x i8] }, i64 1, align 16
  %17 = alloca { i128, [80 x i8] }, i64 1, align 16
  %18 = alloca { i128, [80 x i8] }, i64 1, align 16
  %19 = alloca { i128, [80 x i8] }, i64 1, align 16
  %20 = alloca { i128, [80 x i8] }, i64 1, align 16
  %21 = alloca { i128, [80 x i8] }, i64 1, align 16
  %22 = alloca { i128, [80 x i8] }, i64 1, align 16
  %23 = alloca { i128, [80 x i8] }, i64 1, align 16
  %24 = alloca { i128, [80 x i8] }, i64 1, align 16
  %25 = alloca { i128, [80 x i8] }, i64 1, align 16
  %26 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %27 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %26, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %27)
  %29 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %30 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %29, 0
  %31 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %29, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %30)
  %32 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %33 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %32, 0
  %34 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %32, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %33)
  %35 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %36 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %35, 0
  %37 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %35, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %36)
  %38 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %37, 0
  %39 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %38, 1
  store { i3, { { ptr, i32, i32, i32 } } } %39, ptr %6, align 8
  %40 = load { i128, [80 x i8] }, ptr %6, align 16
  %41 = insertvalue { i252, { i128, [80 x i8] } } { i252 1315925605, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %40, 1
  %42 = call ptr @realloc(ptr null, i64 1040)
  store i32 1, ptr %42, align 4
  %43 = getelementptr inbounds i8, ptr %42, i32 4
  store i32 0, ptr %43, align 4
  %44 = getelementptr inbounds i8, ptr %42, i32 16
  %45 = call ptr @realloc(ptr null, i64 8)
  store ptr %44, ptr %45, align 8
  %46 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %45, 0
  %47 = insertvalue { ptr, i32, i32, i32 } %46, i32 8, 3
  %48 = load ptr, ptr %45, align 8
  store { i252, { i128, [80 x i8] } } %41, ptr %48, align 16
  %49 = insertvalue { ptr, i32, i32, i32 } %47, i32 1, 2
  %50 = getelementptr inbounds i8, ptr %48, i32 -12
  store i32 1, ptr %50, align 4
  %51 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %52 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %51, 0
  %53 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %51, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %52)
  %54 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %53, 0
  %55 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %54, 1
  store { i3, { { ptr, i32, i32, i32 } } } %55, ptr %7, align 8
  %56 = load { i128, [80 x i8] }, ptr %7, align 16
  %57 = insertvalue { i252, { i128, [80 x i8] } } { i252 313472685977919867416164, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %56, 1
  %58 = load ptr, ptr %45, align 8
  %59 = getelementptr inbounds i8, ptr %58, i32 128
  store { i252, { i128, [80 x i8] } } %57, ptr %59, align 16
  %60 = insertvalue { ptr, i32, i32, i32 } %49, i32 2, 2
  %61 = getelementptr inbounds i8, ptr %58, i32 -12
  store i32 2, ptr %61, align 4
  %62 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %63 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 0
  %64 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %62, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %63)
  %65 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %64, 0
  %66 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %65, 1
  store { i3, { { ptr, i32, i32, i32 } } } %66, ptr %8, align 8
  %67 = load { i128, [80 x i8] }, ptr %8, align 16
  %68 = insertvalue { i252, { i128, [80 x i8] } } { i252 71959718098290, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %67, 1
  %69 = load ptr, ptr %45, align 8
  %70 = getelementptr inbounds i8, ptr %69, i32 256
  store { i252, { i128, [80 x i8] } } %68, ptr %70, align 16
  %71 = insertvalue { ptr, i32, i32, i32 } %60, i32 3, 2
  %72 = getelementptr inbounds i8, ptr %69, i32 -12
  store i32 3, ptr %72, align 4
  %73 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %74 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %73, 0
  %75 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %73, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %74)
  %76 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %75, 0
  %77 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %76, 1
  store { i3, { { ptr, i32, i32, i32 } } } %77, ptr %9, align 8
  %78 = load { i128, [80 x i8] }, ptr %9, align 16
  %79 = insertvalue { i252, { i128, [80 x i8] } } { i252 20940711753708153, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %78, 1
  %80 = load ptr, ptr %45, align 8
  %81 = getelementptr inbounds i8, ptr %80, i32 384
  store { i252, { i128, [80 x i8] } } %79, ptr %81, align 16
  %82 = insertvalue { ptr, i32, i32, i32 } %71, i32 4, 2
  %83 = getelementptr inbounds i8, ptr %80, i32 -12
  store i32 4, ptr %83, align 4
  %84 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %85 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %84, 0
  %86 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %84, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %85)
  %87 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %86, 0
  %88 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %87, 1
  store { i3, { { ptr, i32, i32, i32 } } } %88, ptr %10, align 8
  %89 = load { i128, [80 x i8] }, ptr %10, align 16
  %90 = insertvalue { i252, { i128, [80 x i8] } } { i252 1298232171, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %89, 1
  %91 = load ptr, ptr %45, align 8
  %92 = getelementptr inbounds i8, ptr %91, i32 512
  store { i252, { i128, [80 x i8] } } %90, ptr %92, align 16
  %93 = insertvalue { ptr, i32, i32, i32 } %82, i32 5, 2
  %94 = getelementptr inbounds i8, ptr %91, i32 -12
  store i32 5, ptr %94, align 4
  %95 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %96 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 0
  %97 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %96)
  %98 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %97, 0
  %99 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %98, 1
  store { i3, { { ptr, i32, i32, i32 } } } %99, ptr %11, align 8
  %100 = load { i128, [80 x i8] }, ptr %11, align 16
  %101 = insertvalue { i252, { i128, [80 x i8] } } { i252 96092938071918, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %100, 1
  %102 = load ptr, ptr %45, align 8
  %103 = getelementptr inbounds i8, ptr %102, i32 640
  store { i252, { i128, [80 x i8] } } %101, ptr %103, align 16
  %104 = insertvalue { ptr, i32, i32, i32 } %93, i32 6, 2
  %105 = getelementptr inbounds i8, ptr %102, i32 -12
  store i32 6, ptr %105, align 4
  %106 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %107 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %106, 0
  %108 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %106, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %107)
  %109 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %108, 0
  %110 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %109, 1
  store { i3, { { ptr, i32, i32, i32 } } } %110, ptr %12, align 8
  %111 = load { i128, [80 x i8] }, ptr %12, align 16
  %112 = insertvalue { i252, { i128, [80 x i8] } } { i252 74171727245165, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %111, 1
  %113 = load ptr, ptr %45, align 8
  %114 = getelementptr inbounds i8, ptr %113, i32 768
  store { i252, { i128, [80 x i8] } } %112, ptr %114, align 16
  %115 = insertvalue { ptr, i32, i32, i32 } %104, i32 7, 2
  %116 = getelementptr inbounds i8, ptr %113, i32 -12
  store i32 7, ptr %116, align 4
  %117 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$9"({ ptr, i32, i32, i32 } %115)
  %118 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %117, 0
  %119 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %117, 1
  call void @"drop$9"({ ptr, i32, i32, i32 } %118)
  %120 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %34, 0
  %121 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %119, 0
  %122 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 20557100634497705292079393140, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %120, 1
  %123 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %122, { { ptr, i32, i32, i32 } } %121, 2
  %124 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } { i3 2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %123, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %124, ptr %13, align 16
  %125 = load { i128, [80 x i8] }, ptr %13, align 16
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %31, 0
  %127 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 7797918962887871369869233580404, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %126, 1
  %128 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %127, { i128, [80 x i8] } %125, 2
  %129 = call ptr @realloc(ptr null, i64 1296)
  store i32 1, ptr %129, align 4
  %130 = getelementptr inbounds i8, ptr %129, i32 4
  store i32 0, ptr %130, align 4
  %131 = getelementptr inbounds i8, ptr %129, i32 16
  %132 = call ptr @realloc(ptr null, i64 8)
  store ptr %131, ptr %132, align 8
  %133 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %132, 0
  %134 = insertvalue { ptr, i32, i32, i32 } %133, i32 8, 3
  %135 = load ptr, ptr %132, align 8
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %128, ptr %135, align 16
  %136 = insertvalue { ptr, i32, i32, i32 } %134, i32 1, 2
  %137 = getelementptr inbounds i8, ptr %135, i32 -12
  store i32 1, ptr %137, align 4
  %138 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %139 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %138, 0
  %140 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %138, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %139)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %14, align 16
  %141 = load { i128, [80 x i8] }, ptr %14, align 16
  %142 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %140, 0
  %143 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 452823639416, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %142, 1
  %144 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %143, { i128, [80 x i8] } %141, 2
  %145 = load ptr, ptr %132, align 8
  %146 = getelementptr inbounds i8, ptr %145, i32 160
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %144, ptr %146, align 16
  %147 = insertvalue { ptr, i32, i32, i32 } %136, i32 2, 2
  %148 = getelementptr inbounds i8, ptr %145, i32 -12
  store i32 2, ptr %148, align 4
  %149 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %150 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %149, 0
  %151 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %149, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %150)
  store { i3, [0 x i8] } { i3 -3, [0 x i8] undef }, ptr %15, align 1
  %152 = load { i128, [80 x i8] }, ptr %15, align 16
  %153 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %151, 0
  %154 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1851878757, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %153, 1
  %155 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %154, { i128, [80 x i8] } %152, 2
  %156 = load ptr, ptr %132, align 8
  %157 = getelementptr inbounds i8, ptr %156, i32 320
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %155, ptr %157, align 16
  %158 = insertvalue { ptr, i32, i32, i32 } %147, i32 3, 2
  %159 = getelementptr inbounds i8, ptr %156, i32 -12
  store i32 3, ptr %159, align 4
  %160 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %161 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %160, 0
  %162 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %160, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %161)
  store { i3, i252 } { i3 0, i252 26936 }, ptr %16, align 16
  %163 = load { i128, [80 x i8] }, ptr %16, align 16
  %164 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %162, 0
  %165 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 8319400191629685864, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %164, 1
  %166 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %165, { i128, [80 x i8] } %163, 2
  %167 = load ptr, ptr %132, align 8
  %168 = getelementptr inbounds i8, ptr %167, i32 480
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %166, ptr %168, align 16
  %169 = insertvalue { ptr, i32, i32, i32 } %158, i32 4, 2
  %170 = getelementptr inbounds i8, ptr %167, i32 -12
  store i32 4, ptr %170, align 4
  %171 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %172 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %171, 0
  %173 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %171, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %172)
  store { i3, i252 } { i3 0, i252 26936 }, ptr %17, align 16
  %174 = load { i128, [80 x i8] }, ptr %17, align 16
  %175 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %173, 0
  %176 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 8532478930809615481, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %175, 1
  %177 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %176, { i128, [80 x i8] } %174, 2
  %178 = load ptr, ptr %132, align 8
  %179 = getelementptr inbounds i8, ptr %178, i32 640
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %177, ptr %179, align 16
  %180 = insertvalue { ptr, i32, i32, i32 } %169, i32 5, 2
  %181 = getelementptr inbounds i8, ptr %178, i32 -12
  store i32 5, ptr %181, align 4
  %182 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %183 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %182, 0
  %184 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %182, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %183)
  store { i3, i252 } { i3 0, i252 26936 }, ptr %18, align 16
  %185 = load { i128, [80 x i8] }, ptr %18, align 16
  %186 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %184, 0
  %187 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1851986129345051194489, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %186, 1
  %188 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %187, { i128, [80 x i8] } %185, 2
  %189 = load ptr, ptr %132, align 8
  %190 = getelementptr inbounds i8, ptr %189, i32 800
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %188, ptr %190, align 16
  %191 = insertvalue { ptr, i32, i32, i32 } %180, i32 6, 2
  %192 = getelementptr inbounds i8, ptr %189, i32 -12
  store i32 6, ptr %192, align 4
  %193 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %194 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %193, 0
  %195 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %193, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %194)
  store { i3, i252 } { i3 0, i252 26936 }, ptr %19, align 16
  %196 = load { i128, [80 x i8] }, ptr %19, align 16
  %197 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %195, 0
  %198 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1819632491, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %197, 1
  %199 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %198, { i128, [80 x i8] } %196, 2
  %200 = load ptr, ptr %132, align 8
  %201 = getelementptr inbounds i8, ptr %200, i32 960
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %199, ptr %201, align 16
  %202 = insertvalue { ptr, i32, i32, i32 } %191, i32 7, 2
  %203 = getelementptr inbounds i8, ptr %200, i32 -12
  store i32 7, ptr %203, align 4
  %204 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %205 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %204, 0
  %206 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %204, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %205)
  store { i3, i252 } { i3 0, i252 30008 }, ptr %20, align 16
  %207 = load { i128, [80 x i8] }, ptr %20, align 16
  %208 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %206, 0
  %209 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 2194921102833224431083982679296372223826092901, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %208, 1
  %210 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %209, { i128, [80 x i8] } %207, 2
  %211 = load ptr, ptr %132, align 8
  %212 = getelementptr inbounds i8, ptr %211, i32 1120
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %210, ptr %212, align 16
  %213 = insertvalue { ptr, i32, i32, i32 } %202, i32 8, 2
  %214 = getelementptr inbounds i8, ptr %211, i32 -12
  store i32 8, ptr %214, align 4
  %215 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %216 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 0
  %217 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %216)
  store { i3, i252 } { i3 0, i252 30008 }, ptr %21, align 16
  %218 = load { i128, [80 x i8] }, ptr %21, align 16
  %219 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %217, 0
  %220 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 145391601773734352692684596893662995301, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %219, 1
  %221 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %220, { i128, [80 x i8] } %218, 2
  %222 = load ptr, ptr %132, align 8
  %223 = getelementptr inbounds i8, ptr %222, i32 -16
  %224 = call ptr @realloc(ptr %223, i64 3856)
  %225 = getelementptr inbounds i8, ptr %224, i32 16
  store ptr %225, ptr %132, align 8
  %226 = insertvalue { ptr, i32, i32, i32 } %213, i32 24, 3
  %227 = load ptr, ptr %132, align 8
  %228 = getelementptr inbounds i8, ptr %227, i32 1280
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %221, ptr %228, align 16
  %229 = insertvalue { ptr, i32, i32, i32 } %226, i32 9, 2
  %230 = getelementptr inbounds i8, ptr %227, i32 -12
  store i32 9, ptr %230, align 4
  %231 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %232 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %231, 0
  %233 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %231, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %232)
  store { i3, i252 } { i3 0, i252 30008 }, ptr %22, align 16
  %234 = load { i128, [80 x i8] }, ptr %22, align 16
  %235 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %233, 0
  %236 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 38251720776754892371511970850991848186725, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %235, 1
  %237 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %236, { i128, [80 x i8] } %234, 2
  %238 = load ptr, ptr %132, align 8
  %239 = getelementptr inbounds i8, ptr %238, i32 1440
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %237, ptr %239, align 16
  %240 = insertvalue { ptr, i32, i32, i32 } %229, i32 10, 2
  %241 = getelementptr inbounds i8, ptr %238, i32 -12
  store i32 10, ptr %241, align 4
  %242 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %243 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %242, 0
  %244 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %242, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %243)
  store { i3, i252 } { i3 0, i252 6893878 }, ptr %23, align 16
  %245 = load { i128, [80 x i8] }, ptr %23, align 16
  %246 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %244, 0
  %247 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 36824665445191218256773413406785051710968736556610681, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %246, 1
  %248 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %247, { i128, [80 x i8] } %245, 2
  %249 = load ptr, ptr %132, align 8
  %250 = getelementptr inbounds i8, ptr %249, i32 1600
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %248, ptr %250, align 16
  %251 = insertvalue { ptr, i32, i32, i32 } %240, i32 11, 2
  %252 = getelementptr inbounds i8, ptr %249, i32 -12
  store i32 11, ptr %252, align 4
  %253 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %254 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %253, 0
  %255 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %253, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %254)
  store { i3, i252 } { i3 0, i252 6893878 }, ptr %24, align 16
  %256 = load { i128, [80 x i8] }, ptr %24, align 16
  %257 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %255, 0
  %258 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 2439266307543924683601322188853351132892329081, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %257, 1
  %259 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %258, { i128, [80 x i8] } %256, 2
  %260 = load ptr, ptr %132, align 8
  %261 = getelementptr inbounds i8, ptr %260, i32 1760
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %259, ptr %261, align 16
  %262 = insertvalue { ptr, i32, i32, i32 } %251, i32 12, 2
  %263 = getelementptr inbounds i8, ptr %260, i32 -12
  store i32 12, ptr %263, align 4
  %264 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %265 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %264, 0
  %266 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %264, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %265)
  store { i3, i252 } { i3 0, i252 6893878 }, ptr %25, align 16
  %267 = load { i128, [80 x i8] }, ptr %25, align 16
  %268 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %266, 0
  %269 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 641757381843304608695464552639689489297414124665, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %268, 1
  %270 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %269, { i128, [80 x i8] } %267, 2
  %271 = load ptr, ptr %132, align 8
  %272 = getelementptr inbounds i8, ptr %271, i32 1920
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %270, ptr %272, align 16
  %273 = insertvalue { ptr, i32, i32, i32 } %262, i32 13, 2
  %274 = getelementptr inbounds i8, ptr %271, i32 -12
  store i32 13, ptr %274, align 4
  %275 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$5"({ ptr, i32, i32, i32 } %273)
  %276 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %275, 0
  %277 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %275, 1
  call void @"drop$5"({ ptr, i32, i32, i32 } %276)
  %278 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %28, 0
  %279 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %277, 0
  %280 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 88292074925748493264888317519795414387, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %278, 1
  %281 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %280, { { ptr, i32, i32, i32 } } %279, 2
  %282 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f94"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %281)
  %283 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %282, 0
  %284 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %282, 1
  %285 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %282, 2
  %286 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %282, 3
  %287 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %283, 0
  %288 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %287, i64 %284, 1
  %289 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %288, ptr %285, 2
  %290 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %289, { i64, [24 x i8] } %286, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %290
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f68(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f68"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f68(ptr %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f68(i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f69"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = alloca { i128, [80 x i8] }, i64 1, align 16
  %7 = alloca { i128, [80 x i8] }, i64 1, align 16
  %8 = alloca { i128, [80 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [80 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i128, [80 x i8] }, i64 1, align 16
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = alloca { i128, [80 x i8] }, i64 1, align 16
  %17 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %18 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %17, 0
  %19 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %17, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %18)
  %20 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %21 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %20, 0
  %22 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %20, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %21)
  %23 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %24 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %23, 0
  %25 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %23, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %24)
  %26 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %27 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %26, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %27)
  %29 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %28, 0
  %30 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %29, 1
  store { i3, { { ptr, i32, i32, i32 } } } %30, ptr %6, align 8
  %31 = load { i128, [80 x i8] }, ptr %6, align 16
  %32 = insertvalue { i252, { i128, [80 x i8] } } { i252 1315925605, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %31, 1
  %33 = call ptr @realloc(ptr null, i64 1040)
  store i32 1, ptr %33, align 4
  %34 = getelementptr inbounds i8, ptr %33, i32 4
  store i32 0, ptr %34, align 4
  %35 = getelementptr inbounds i8, ptr %33, i32 16
  %36 = call ptr @realloc(ptr null, i64 8)
  store ptr %35, ptr %36, align 8
  %37 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %36, 0
  %38 = insertvalue { ptr, i32, i32, i32 } %37, i32 8, 3
  %39 = load ptr, ptr %36, align 8
  store { i252, { i128, [80 x i8] } } %32, ptr %39, align 16
  %40 = insertvalue { ptr, i32, i32, i32 } %38, i32 1, 2
  %41 = getelementptr inbounds i8, ptr %39, i32 -12
  store i32 1, ptr %41, align 4
  %42 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %43 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %42, 0
  %44 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %42, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %43)
  %45 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %44, 0
  %46 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %45, 1
  store { i3, { { ptr, i32, i32, i32 } } } %46, ptr %7, align 8
  %47 = load { i128, [80 x i8] }, ptr %7, align 16
  %48 = insertvalue { i252, { i128, [80 x i8] } } { i252 313472685977919867416164, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %47, 1
  %49 = load ptr, ptr %36, align 8
  %50 = getelementptr inbounds i8, ptr %49, i32 128
  store { i252, { i128, [80 x i8] } } %48, ptr %50, align 16
  %51 = insertvalue { ptr, i32, i32, i32 } %40, i32 2, 2
  %52 = getelementptr inbounds i8, ptr %49, i32 -12
  store i32 2, ptr %52, align 4
  %53 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %54 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %53, 0
  %55 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %53, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %54)
  %56 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %55, 0
  %57 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %56, 1
  store { i3, { { ptr, i32, i32, i32 } } } %57, ptr %8, align 8
  %58 = load { i128, [80 x i8] }, ptr %8, align 16
  %59 = insertvalue { i252, { i128, [80 x i8] } } { i252 71959718098290, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %58, 1
  %60 = load ptr, ptr %36, align 8
  %61 = getelementptr inbounds i8, ptr %60, i32 256
  store { i252, { i128, [80 x i8] } } %59, ptr %61, align 16
  %62 = insertvalue { ptr, i32, i32, i32 } %51, i32 3, 2
  %63 = getelementptr inbounds i8, ptr %60, i32 -12
  store i32 3, ptr %63, align 4
  %64 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %65 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %64, 0
  %66 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %64, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %65)
  %67 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %66, 0
  %68 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %67, 1
  store { i3, { { ptr, i32, i32, i32 } } } %68, ptr %9, align 8
  %69 = load { i128, [80 x i8] }, ptr %9, align 16
  %70 = insertvalue { i252, { i128, [80 x i8] } } { i252 20940711753708153, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %69, 1
  %71 = load ptr, ptr %36, align 8
  %72 = getelementptr inbounds i8, ptr %71, i32 384
  store { i252, { i128, [80 x i8] } } %70, ptr %72, align 16
  %73 = insertvalue { ptr, i32, i32, i32 } %62, i32 4, 2
  %74 = getelementptr inbounds i8, ptr %71, i32 -12
  store i32 4, ptr %74, align 4
  %75 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %76 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %75, 0
  %77 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %75, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %76)
  %78 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %77, 0
  %79 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %78, 1
  store { i3, { { ptr, i32, i32, i32 } } } %79, ptr %10, align 8
  %80 = load { i128, [80 x i8] }, ptr %10, align 16
  %81 = insertvalue { i252, { i128, [80 x i8] } } { i252 1298232171, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %80, 1
  %82 = load ptr, ptr %36, align 8
  %83 = getelementptr inbounds i8, ptr %82, i32 512
  store { i252, { i128, [80 x i8] } } %81, ptr %83, align 16
  %84 = insertvalue { ptr, i32, i32, i32 } %73, i32 5, 2
  %85 = getelementptr inbounds i8, ptr %82, i32 -12
  store i32 5, ptr %85, align 4
  %86 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %87 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, 0
  %88 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %86, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %87)
  %89 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %88, 0
  %90 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %89, 1
  store { i3, { { ptr, i32, i32, i32 } } } %90, ptr %11, align 8
  %91 = load { i128, [80 x i8] }, ptr %11, align 16
  %92 = insertvalue { i252, { i128, [80 x i8] } } { i252 96092938071918, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %91, 1
  %93 = load ptr, ptr %36, align 8
  %94 = getelementptr inbounds i8, ptr %93, i32 640
  store { i252, { i128, [80 x i8] } } %92, ptr %94, align 16
  %95 = insertvalue { ptr, i32, i32, i32 } %84, i32 6, 2
  %96 = getelementptr inbounds i8, ptr %93, i32 -12
  store i32 6, ptr %96, align 4
  %97 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$13"({ ptr, i32, i32, i32 } zeroinitializer)
  %98 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 0
  %99 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %97, 1
  call void @"drop$13"({ ptr, i32, i32, i32 } %98)
  %100 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %99, 0
  %101 = insertvalue { i3, { { ptr, i32, i32, i32 } } } { i3 3, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %100, 1
  store { i3, { { ptr, i32, i32, i32 } } } %101, ptr %12, align 8
  %102 = load { i128, [80 x i8] }, ptr %12, align 16
  %103 = insertvalue { i252, { i128, [80 x i8] } } { i252 74171727245165, { i128, [80 x i8] } undef }, { i128, [80 x i8] } %102, 1
  %104 = load ptr, ptr %36, align 8
  %105 = getelementptr inbounds i8, ptr %104, i32 768
  store { i252, { i128, [80 x i8] } } %103, ptr %105, align 16
  %106 = insertvalue { ptr, i32, i32, i32 } %95, i32 7, 2
  %107 = getelementptr inbounds i8, ptr %104, i32 -12
  store i32 7, ptr %107, align 4
  %108 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$9"({ ptr, i32, i32, i32 } %106)
  %109 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %108, 0
  %110 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %108, 1
  call void @"drop$9"({ ptr, i32, i32, i32 } %109)
  %111 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %25, 0
  %112 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %110, 0
  %113 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 20557100634497705292079393140, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %111, 1
  %114 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %113, { { ptr, i32, i32, i32 } } %112, 2
  %115 = insertvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } { i3 2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %114, 1
  store { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %115, ptr %13, align 16
  %116 = load { i128, [80 x i8] }, ptr %13, align 16
  %117 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %22, 0
  %118 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 7797918962887871369869233580404, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %117, 1
  %119 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %118, { i128, [80 x i8] } %116, 2
  %120 = call ptr @realloc(ptr null, i64 1296)
  store i32 1, ptr %120, align 4
  %121 = getelementptr inbounds i8, ptr %120, i32 4
  store i32 0, ptr %121, align 4
  %122 = getelementptr inbounds i8, ptr %120, i32 16
  %123 = call ptr @realloc(ptr null, i64 8)
  store ptr %122, ptr %123, align 8
  %124 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %123, 0
  %125 = insertvalue { ptr, i32, i32, i32 } %124, i32 8, 3
  %126 = load ptr, ptr %123, align 8
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %119, ptr %126, align 16
  %127 = insertvalue { ptr, i32, i32, i32 } %125, i32 1, 2
  %128 = getelementptr inbounds i8, ptr %126, i32 -12
  store i32 1, ptr %128, align 4
  %129 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %130 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %129, 0
  %131 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %129, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %130)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %14, align 16
  %132 = load { i128, [80 x i8] }, ptr %14, align 16
  %133 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %131, 0
  %134 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 452823639416, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %133, 1
  %135 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %134, { i128, [80 x i8] } %132, 2
  %136 = load ptr, ptr %123, align 8
  %137 = getelementptr inbounds i8, ptr %136, i32 160
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %135, ptr %137, align 16
  %138 = insertvalue { ptr, i32, i32, i32 } %127, i32 2, 2
  %139 = getelementptr inbounds i8, ptr %136, i32 -12
  store i32 2, ptr %139, align 4
  %140 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %141 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %140, 0
  %142 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %140, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %141)
  store { i3, i252 } { i3 0, i252 7680818 }, ptr %15, align 16
  %143 = load { i128, [80 x i8] }, ptr %15, align 16
  %144 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %142, 0
  %145 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 1936486260, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %144, 1
  %146 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %145, { i128, [80 x i8] } %143, 2
  %147 = load ptr, ptr %123, align 8
  %148 = getelementptr inbounds i8, ptr %147, i32 320
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %146, ptr %148, align 16
  %149 = insertvalue { ptr, i32, i32, i32 } %138, i32 3, 2
  %150 = getelementptr inbounds i8, ptr %147, i32 -12
  store i32 3, ptr %150, align 4
  %151 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %152 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %151, 0
  %153 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %151, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %152)
  store { i3, i252 } { i3 0, i252 28821964104807730 }, ptr %16, align 16
  %154 = load { i128, [80 x i8] }, ptr %16, align 16
  %155 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %153, 0
  %156 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } { i252 107152796640107, { { ptr, i32, i32, i32 } } undef, { i128, [80 x i8] } undef }, { { ptr, i32, i32, i32 } } %155, 1
  %157 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %156, { i128, [80 x i8] } %154, 2
  %158 = load ptr, ptr %123, align 8
  %159 = getelementptr inbounds i8, ptr %158, i32 480
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %157, ptr %159, align 16
  %160 = insertvalue { ptr, i32, i32, i32 } %149, i32 4, 2
  %161 = getelementptr inbounds i8, ptr %158, i32 -12
  store i32 4, ptr %161, align 4
  %162 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$5"({ ptr, i32, i32, i32 } %160)
  %163 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %162, 0
  %164 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %162, 1
  call void @"drop$5"({ ptr, i32, i32, i32 } %163)
  %165 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %19, 0
  %166 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %164, 0
  %167 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } { i252 309102029792370999717748, { { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 } } undef }, { { ptr, i32, i32, i32 } } %165, 1
  %168 = insertvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %167, { { ptr, i32, i32, i32 } } %166, 2
  %169 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f94"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %168)
  %170 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 0
  %171 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 1
  %172 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 2
  %173 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %169, 3
  %174 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %170, 0
  %175 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %174, i64 %171, 1
  %176 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %175, ptr %172, 2
  %177 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %176, { i64, [24 x i8] } %173, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %177
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f69(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f69"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f69(ptr %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f69(i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @"impl$f70"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [20 x i8] }, i64 1, align 4
  %4 = alloca { i32, [20 x i8] }, i64 1, align 4
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %122

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp ult i252 %19, 4294967296
  %21 = add i64 %0, 2
  %22 = add i64 %0, 3
  %23 = select i1 %20, i64 %21, i64 %22
  %24 = trunc i252 %19 to i32
  br i1 %20, label %25, label %122

25:                                               ; preds = %10
  %26 = phi { ptr, i32, i32, i32 } [ %17, %10 ]
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %122

31:                                               ; preds = %25
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load i252, ptr %39, align 16
  call void @free(ptr %39)
  %41 = icmp ult i252 %40, 4294967296
  %42 = add i64 %23, 2
  %43 = add i64 %23, 3
  %44 = select i1 %41, i64 %42, i64 %43
  %45 = trunc i252 %40 to i32
  br i1 %41, label %46, label %122

46:                                               ; preds = %31
  %47 = phi { ptr, i32, i32, i32 } [ %38, %31 ]
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %52, label %122

52:                                               ; preds = %46
  %53 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %54 = load ptr, ptr %53, align 8
  %55 = zext i32 %48 to i64
  %56 = mul i64 %55, 32
  %57 = getelementptr inbounds i8, ptr %54, i64 %56
  %58 = add i32 %48, 1
  %59 = insertvalue { ptr, i32, i32, i32 } %47, i32 %58, 1
  %60 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %60, ptr %57, i64 32, i1 false)
  %61 = load i252, ptr %60, align 16
  call void @free(ptr %60)
  %62 = icmp ult i252 %61, 4294967296
  %63 = add i64 %44, 2
  %64 = add i64 %44, 3
  %65 = select i1 %62, i64 %63, i64 %64
  %66 = trunc i252 %61 to i32
  br i1 %62, label %67, label %122

67:                                               ; preds = %52
  %68 = phi { ptr, i32, i32, i32 } [ %59, %52 ]
  %69 = extractvalue { ptr, i32, i32, i32 } %68, 1
  %70 = extractvalue { ptr, i32, i32, i32 } %68, 2
  %71 = sub i32 %70, %69
  %72 = icmp uge i32 %71, 1
  br i1 %72, label %73, label %122

73:                                               ; preds = %67
  %74 = extractvalue { ptr, i32, i32, i32 } %68, 0
  %75 = load ptr, ptr %74, align 8
  %76 = zext i32 %69 to i64
  %77 = mul i64 %76, 32
  %78 = getelementptr inbounds i8, ptr %75, i64 %77
  %79 = add i32 %69, 1
  %80 = insertvalue { ptr, i32, i32, i32 } %68, i32 %79, 1
  %81 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %81, ptr %78, i64 32, i1 false)
  %82 = load i252, ptr %81, align 16
  call void @free(ptr %81)
  %83 = icmp ult i252 %82, 4294967296
  %84 = add i64 %65, 2
  %85 = add i64 %65, 3
  %86 = select i1 %83, i64 %84, i64 %85
  %87 = trunc i252 %82 to i32
  br i1 %83, label %88, label %122

88:                                               ; preds = %73
  %89 = phi { ptr, i32, i32, i32 } [ %80, %73 ]
  %90 = extractvalue { ptr, i32, i32, i32 } %89, 1
  %91 = extractvalue { ptr, i32, i32, i32 } %89, 2
  %92 = sub i32 %91, %90
  %93 = icmp uge i32 %92, 1
  br i1 %93, label %94, label %122

94:                                               ; preds = %88
  %95 = extractvalue { ptr, i32, i32, i32 } %89, 0
  %96 = load ptr, ptr %95, align 8
  %97 = zext i32 %90 to i64
  %98 = mul i64 %97, 32
  %99 = getelementptr inbounds i8, ptr %96, i64 %98
  %100 = add i32 %90, 1
  %101 = insertvalue { ptr, i32, i32, i32 } %89, i32 %100, 1
  %102 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %102, ptr %99, i64 32, i1 false)
  %103 = load i252, ptr %102, align 16
  call void @free(ptr %102)
  %104 = icmp ult i252 %103, 4294967296
  %105 = add i64 %86, 2
  %106 = add i64 %86, 3
  %107 = select i1 %104, i64 %105, i64 %106
  %108 = trunc i252 %103 to i32
  br i1 %104, label %109, label %122

109:                                              ; preds = %94
  %110 = phi { ptr, i32, i32, i32 } [ %101, %94 ]
  %111 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %110, 0
  %112 = insertvalue { i32, i32, i32, i32, i32 } undef, i32 %24, 0
  %113 = insertvalue { i32, i32, i32, i32, i32 } %112, i32 %45, 1
  %114 = insertvalue { i32, i32, i32, i32, i32 } %113, i32 %66, 2
  %115 = insertvalue { i32, i32, i32, i32, i32 } %114, i32 %87, 3
  %116 = insertvalue { i32, i32, i32, i32, i32 } %115, i32 %108, 4
  %117 = insertvalue { i1, { i32, i32, i32, i32, i32 } } { i1 false, { i32, i32, i32, i32, i32 } undef }, { i32, i32, i32, i32, i32 } %116, 1
  store { i1, { i32, i32, i32, i32, i32 } } %117, ptr %4, align 4
  %118 = load { i32, [20 x i8] }, ptr %4, align 4
  %119 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %107, 0
  %120 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %119, { { ptr, i32, i32, i32 } } %111, 1
  %121 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %120, { i32, [20 x i8] } %118, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %121

122:                                              ; preds = %94, %88, %73, %67, %52, %46, %31, %25, %10, %2
  %123 = phi i64 [ %107, %94 ], [ %86, %88 ], [ %86, %73 ], [ %65, %67 ], [ %65, %52 ], [ %44, %46 ], [ %44, %31 ], [ %23, %25 ], [ %23, %10 ], [ %0, %2 ]
  %124 = phi { ptr, i32, i32, i32 } [ %101, %94 ], [ %89, %88 ], [ %80, %73 ], [ %68, %67 ], [ %59, %52 ], [ %47, %46 ], [ %38, %31 ], [ %26, %25 ], [ %17, %10 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %125 = load { i32, [20 x i8] }, ptr %3, align 4
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %124, 0
  %127 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %123, 0
  %128 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %127, { { ptr, i32, i32, i32 } } %126, 1
  %129 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %128, { i32, [20 x i8] } %125, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %129
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @f70(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @"impl$f70"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %8, { i32, [20 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %9
}

define void @_mlir_ciface_f70(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } @f70(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [20 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$249"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %0, 0
  call void @"drop$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  ret void
}

define private { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } @"dup$249"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %0) {
  %2 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %0, 0
  %3 = call { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } @"dup$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %2)
  %4 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 0
  %5 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { { { { ptr, i32, i32, i32 } } }, { { {} } } } } %3, 1
  %6 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %0, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %4, 0
  %7 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 0
  %8 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %0, 1
  %9 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %6, { i16, [14 x i8] } %8, 1
  %10 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %7, { i16, [14 x i8] } %8, 1
  %11 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } undef, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %9, 0
  %12 = insertvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %11, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %10, 1
  ret { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %12
}

define private void @"drop$250"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %5, 1
  call void @"drop$249"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [40 x i8] }, { i64, [40 x i8] } } @"dup$250"({ i64, [40 x i8] } %0) {
  %2 = alloca { i64, [40 x i8] }, i64 1, align 8
  store { i64, [40 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %5, 1
  %7 = call { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } @"dup$249"({ { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %6)
  %8 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %7, 0
  %9 = extractvalue { { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %8, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [40 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %5, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %9, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [40 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %11, 0
  %15 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %14, { i64, [40 x i8] } %13, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [40 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [40 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } undef, { i64, [40 x i8] } %23, 0
  %27 = insertvalue { { i64, [40 x i8] }, { i64, [40 x i8] } } %26, { i64, [40 x i8] } %25, 1
  ret { { i64, [40 x i8] }, { i64, [40 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f71"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = alloca i64, i64 1, align 8
  %9 = insertvalue { ptr, ptr, i64 } undef, ptr %8, 0
  %10 = insertvalue { ptr, ptr, i64 } %9, ptr %8, 1
  %11 = insertvalue { ptr, ptr, i64 } %10, i64 0, 2
  %12 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 0, ptr %12, align 8
  %13 = alloca { i64, [48 x i8] }, i64 1, align 8
  %14 = alloca { i64, [40 x i8] }, i64 1, align 8
  %15 = alloca { i64, [48 x i8] }, i64 1, align 8
  %16 = alloca { i16, [14 x i8] }, i64 1, align 2
  %17 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %18

18:                                               ; preds = %115, %7
  %19 = phi i64 [ %43, %115 ], [ %0, %7 ]
  %20 = phi i64 [ %75, %115 ], [ %1, %7 ]
  %21 = phi i64 [ %45, %115 ], [ %2, %7 ]
  %22 = phi i64 [ %46, %115 ], [ %3, %7 ]
  %23 = phi ptr [ %47, %115 ], [ %4, %7 ]
  %24 = phi { { { { ptr, i32, i32, i32 } } }, { { {} } } } [ %55, %115 ], [ %5, %7 ]
  %25 = phi { ptr, i32, i32, i32 } [ %124, %115 ], [ %6, %7 ]
  %26 = add i64 %19, 1
  %27 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %28 = call ptr %27()
  %29 = getelementptr inbounds i64, ptr %28, i32 1
  %30 = load i64, ptr %29, align 8
  %31 = getelementptr inbounds i64, ptr %28, i32 2
  %32 = load i64, ptr %31, align 8
  %33 = mul i64 %32, 11
  %34 = add i64 %30, %33
  %35 = load i64, ptr %28, align 8
  %36 = mul i64 %35, 76480
  %37 = add i64 %34, %36
  %38 = icmp uge i64 %20, %37
  %39 = call i64 @llvm.usub.sat.i64(i64 %20, i64 %37)
  br i1 %38, label %40, label %178

40:                                               ; preds = %18
  %41 = phi i64 [ %26, %18 ]
  %42 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f95"(i64 %41, i64 %39, i64 %21, i64 %22, ptr %23, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %24)
  %43 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %42, 0
  %44 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %42, 1
  %45 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %42, 2
  %46 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %42, 3
  %47 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %42, 4
  %48 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %42, 5
  store { i64, [40 x i8] } %48, ptr %14, align 8
  %49 = load i1, ptr %14, align 1
  switch i1 %49, label %50 [
    i1 false, label %52
    i1 true, label %58
  ]

50:                                               ; preds = %40
  br i1 false, label %51, label %196

51:                                               ; preds = %50
  unreachable

52:                                               ; preds = %40
  %53 = load { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } }, ptr %14, align 8
  %54 = extractvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %53, 1
  %55 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %54, 0
  %56 = extractvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %54, 1
  store { i16, [14 x i8] } %56, ptr %16, align 2
  %57 = load i1, ptr %16, align 1
  switch i1 %57, label %68 [
    i1 false, label %70
    i1 true, label %130
  ]

58:                                               ; preds = %40
  %59 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %60 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %59, 1
  call void @"drop$360"({ ptr, i32, i32, i32 } %25)
  %61 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %60, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %61, ptr %15, align 8
  %62 = load { i64, [48 x i8] }, ptr %15, align 8
  %63 = extractvalue { ptr, ptr, i64 } %11, 1
  %64 = load i64, ptr %63, align 8
  %65 = icmp eq i64 %64, 0
  %66 = sub i64 %64, 1
  %67 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %66, ptr %67, align 8
  br i1 %65, label %171, label %145

68:                                               ; preds = %52
  br i1 false, label %69, label %197

69:                                               ; preds = %68
  unreachable

70:                                               ; preds = %52
  %71 = load { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } }, ptr %16, align 2
  %72 = extractvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %71, 1
  %73 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %74 = call ptr %73()
  %75 = call i64 @llvm.uadd.sat.i64(i64 %44, i64 0)
  %76 = extractvalue { ptr, i32, i32, i32 } %25, 3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %78, label %92

78:                                               ; preds = %70
  %79 = shl i32 %76, 1
  %80 = call i32 @llvm.umin.i32(i32 %79, i32 1024)
  %81 = add i32 %80, %76
  %82 = call i32 @llvm.umax.i32(i32 %81, i32 8)
  %83 = zext i32 %82 to i64
  %84 = mul i64 %83, 14
  %85 = add i64 %84, 8
  %86 = call ptr @realloc(ptr null, i64 %85)
  store i32 1, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %86, i32 4
  store i32 0, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %86, i32 8
  %89 = call ptr @realloc(ptr null, i64 8)
  store ptr %88, ptr %89, align 8
  %90 = insertvalue { ptr, i32, i32, i32 } %25, ptr %89, 0
  %91 = insertvalue { ptr, i32, i32, i32 } %90, i32 %82, 3
  br label %113

92:                                               ; preds = %70
  %93 = extractvalue { ptr, i32, i32, i32 } %25, 2
  %94 = icmp ult i32 %93, %76
  br i1 %94, label %95, label %96

95:                                               ; preds = %92
  br label %110

96:                                               ; preds = %92
  %97 = shl i32 %76, 1
  %98 = call i32 @llvm.umin.i32(i32 %97, i32 1024)
  %99 = add i32 %98, %76
  %100 = call i32 @llvm.umax.i32(i32 %99, i32 8)
  %101 = zext i32 %100 to i64
  %102 = mul i64 %101, 14
  %103 = add i64 %102, 8
  %104 = extractvalue { ptr, i32, i32, i32 } %25, 0
  %105 = load ptr, ptr %104, align 8
  %106 = getelementptr inbounds i8, ptr %105, i32 -8
  %107 = call ptr @realloc(ptr %106, i64 %103)
  %108 = getelementptr inbounds i8, ptr %107, i32 8
  store ptr %108, ptr %104, align 8
  %109 = insertvalue { ptr, i32, i32, i32 } %25, i32 %100, 3
  br label %110

110:                                              ; preds = %95, %96
  %111 = phi { ptr, i32, i32, i32 } [ %109, %96 ], [ %25, %95 ]
  br label %112

112:                                              ; preds = %110
  br label %113

113:                                              ; preds = %78, %112
  %114 = phi { ptr, i32, i32, i32 } [ %111, %112 ], [ %91, %78 ]
  br label %115

115:                                              ; preds = %113
  %116 = extractvalue { ptr, i32, i32, i32 } %114, 0
  %117 = load ptr, ptr %116, align 8
  %118 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %119 = zext i32 %118 to i64
  %120 = mul i64 %119, 14
  %121 = getelementptr inbounds i8, ptr %117, i64 %120
  store { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %72, ptr %121, align 2
  %122 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %123 = add i32 %122, 1
  %124 = insertvalue { ptr, i32, i32, i32 } %114, i32 %123, 2
  %125 = getelementptr inbounds i8, ptr %117, i32 -4
  store i32 %123, ptr %125, align 4
  %126 = extractvalue { ptr, ptr, i64 } %11, 1
  %127 = load i64, ptr %126, align 8
  %128 = add i64 %127, 1
  %129 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %128, ptr %129, align 8
  br label %18

130:                                              ; preds = %52
  %131 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %132 = call ptr %131()
  %133 = load i64, ptr %132, align 8
  %134 = mul i64 %133, 4570
  %135 = call i64 @llvm.uadd.sat.i64(i64 %44, i64 %134)
  %136 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %55, 0
  %137 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %136, { ptr, i32, i32, i32 } %25, 1
  %138 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } undef }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } %137, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { ptr, i32, i32, i32 }, {} } } %138, ptr %17, align 8
  %139 = load { i64, [48 x i8] }, ptr %17, align 8
  %140 = extractvalue { ptr, ptr, i64 } %11, 1
  %141 = load i64, ptr %140, align 8
  %142 = icmp eq i64 %141, 0
  %143 = sub i64 %141, 1
  %144 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %143, ptr %144, align 8
  br i1 %142, label %164, label %145

145:                                              ; preds = %145, %130, %58, %178
  %146 = phi i64 [ %26, %178 ], [ %146, %145 ], [ %43, %130 ], [ %43, %58 ]
  %147 = phi i64 [ %20, %178 ], [ %147, %145 ], [ %135, %130 ], [ %44, %58 ]
  %148 = phi i64 [ %21, %178 ], [ %148, %145 ], [ %45, %130 ], [ %45, %58 ]
  %149 = phi i64 [ %22, %178 ], [ %149, %145 ], [ %46, %130 ], [ %46, %58 ]
  %150 = phi ptr [ %23, %178 ], [ %150, %145 ], [ %47, %130 ], [ %47, %58 ]
  %151 = phi { i64, [48 x i8] } [ %183, %178 ], [ %151, %145 ], [ %139, %130 ], [ %62, %58 ]
  %152 = extractvalue { ptr, ptr, i64 } %11, 1
  %153 = load i64, ptr %152, align 8
  %154 = icmp eq i64 %153, 0
  %155 = sub i64 %153, 1
  %156 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %155, ptr %156, align 8
  br i1 %154, label %157, label %145

157:                                              ; preds = %145
  %158 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %146, 0
  %159 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %158, i64 %147, 1
  %160 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %159, i64 %148, 2
  %161 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %160, i64 %149, 3
  %162 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %161, ptr %150, 4
  %163 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %162, { i64, [48 x i8] } %151, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %163

164:                                              ; preds = %130
  %165 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %43, 0
  %166 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %165, i64 %135, 1
  %167 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %166, i64 %45, 2
  %168 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %167, i64 %46, 3
  %169 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %168, ptr %47, 4
  %170 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %169, { i64, [48 x i8] } %139, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %170

171:                                              ; preds = %58
  %172 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %43, 0
  %173 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %172, i64 %44, 1
  %174 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %173, i64 %45, 2
  %175 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %174, i64 %46, 3
  %176 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %175, ptr %47, 4
  %177 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %176, { i64, [48 x i8] } %62, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %177

178:                                              ; preds = %18
  %179 = phi { ptr, i32, i32, i32 } [ %25, %18 ]
  call void @"drop$360"({ ptr, i32, i32, i32 } %179)
  call void @"drop$247"({ { { { ptr, i32, i32, i32 } } }, { { {} } } } %24)
  %180 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %181 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %180, 0
  %182 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %181, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %182, ptr %13, align 8
  %183 = load { i64, [48 x i8] }, ptr %13, align 8
  %184 = extractvalue { ptr, ptr, i64 } %11, 1
  %185 = load i64, ptr %184, align 8
  %186 = icmp eq i64 %185, 0
  %187 = sub i64 %185, 1
  %188 = extractvalue { ptr, ptr, i64 } %11, 1
  store i64 %187, ptr %188, align 8
  br i1 %186, label %189, label %145

189:                                              ; preds = %178
  %190 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %26, 0
  %191 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %190, i64 %20, 1
  %192 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %191, i64 %21, 2
  %193 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %192, i64 %22, 3
  %194 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %193, ptr %23, 4
  %195 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %194, { i64, [48 x i8] } %183, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %195

196:                                              ; preds = %50
  call void @puts(ptr @assert_msg_136)
  call void @abort()
  unreachable

197:                                              ; preds = %68
  call void @puts(ptr @assert_msg_137)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @f71(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, { ptr, i32, i32, i32 } %6) {
  %8 = call fastcc { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @"impl$f71"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, { ptr, i32, i32, i32 } %6)
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, 2
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, 3
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, 4
  %14 = extractvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %8, 5
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } undef, i64 %9, 0
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %15, i64 %10, 1
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %16, i64 %11, 2
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %17, i64 %12, 3
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %18, ptr %13, 4
  %20 = insertvalue { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %19, { i64, [48 x i8] } %14, 5
  ret { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %20
}

define void @_mlir_ciface_f71(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6, { ptr, i32, i32, i32 } %7) {
  %9 = call { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } @f71(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6, { ptr, i32, i32, i32 } %7)
  store { i64, i64, i64, i64, ptr, { i64, [48 x i8] } } %9, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f72"(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4) {
  %6 = alloca { i1, [47 x i8] }, i64 1, align 16
  %7 = alloca i64, i64 1, align 8
  %8 = alloca i252, i64 1, align 16
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = extractvalue { i252 } %4, 0
  %12 = load ptr, ptr %3, align 8
  store i64 %1, ptr %7, align 8
  store i252 %11, ptr %8, align 16
  %13 = getelementptr inbounds ptr, ptr %3, i32 8
  %14 = load ptr, ptr %13, align 8
  call void %14(ptr %6, ptr %12, ptr %7, i32 0, ptr %8)
  %15 = load { i1, [47 x i8] }, ptr %6, align 1
  %16 = extractvalue { i1, [47 x i8] } %15, 0
  %17 = getelementptr inbounds i8, ptr %6, i32 16
  %18 = load i252, ptr %17, align 16
  %19 = getelementptr inbounds i8, ptr %6, i32 8
  %20 = load { ptr, i32, i32, i32 }, ptr %19, align 8
  %21 = load i64, ptr %7, align 8
  br i1 %16, label %56, label %22

22:                                               ; preds = %5
  %23 = phi i64 [ %0, %5 ]
  %24 = phi i252 [ %18, %5 ]
  %25 = trunc i252 %24 to i128
  %26 = lshr i252 %24, 128
  %27 = trunc i252 %26 to i128
  %28 = icmp ne i128 %27, 0
  %29 = add i64 %23, 3
  %30 = add i64 %23, 1
  %31 = select i1 %28, i64 %29, i64 %30
  br i1 %28, label %46, label %32

32:                                               ; preds = %22
  %33 = phi i64 [ %21, %22 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 0)
  %37 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %31, i64 %2, i128 %25)
  %38 = extractvalue { i64, i64, { i64, [24 x i8] } } %37, 0
  %39 = extractvalue { i64, i64, { i64, [24 x i8] } } %37, 1
  %40 = extractvalue { i64, i64, { i64, [24 x i8] } } %37, 2
  %41 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %38, 0
  %42 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %41, i64 %36, 1
  %43 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %42, i64 %39, 2
  %44 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %43, ptr %3, 3
  %45 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %40, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %45

46:                                               ; preds = %22
  %47 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f97"()
  %48 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %47, 0
  %49 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %48, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %49, ptr %10, align 8
  %50 = load { i64, [24 x i8] }, ptr %10, align 8
  %51 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %31, 0
  %52 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %51, i64 %21, 1
  %53 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %52, i64 %2, 2
  %54 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %53, ptr %3, 3
  %55 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %54, { i64, [24 x i8] } %50, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %55

56:                                               ; preds = %5
  %57 = phi { ptr, i32, i32, i32 } [ %20, %5 ]
  %58 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %57, 1
  %59 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %58, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %59, ptr %9, align 8
  %60 = load { i64, [24 x i8] }, ptr %9, align 8
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %21, 1
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, i64 %2, 2
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, ptr %3, 3
  %65 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %64, { i64, [24 x i8] } %60, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %65
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f72(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f72"(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f72(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { i252 } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f72(i64 %1, i64 %2, i64 %3, ptr %4, { i252 } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private void @"drop$242"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$242"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 14)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 14, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private void @"drop$241"({ i64, [32 x i8] } %0) {
  %2 = alloca { i64, [32 x i8] }, i64 1, align 8
  store { i64, [32 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [32 x i8] }, { i64, [32 x i8] } } @"dup$241"({ i64, [32 x i8] } %0) {
  %2 = alloca { i64, [32 x i8] }, i64 1, align 8
  store { i64, [32 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } }, ptr %2, align 4
  %6 = extractvalue { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, 1
  %7 = insertvalue { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %6, 1
  store { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %7, ptr %2, align 4
  %8 = load { i64, [32 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %5, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %6, 1
  store { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %9, ptr %2, align 4
  %10 = load { i64, [32 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } undef, { i64, [32 x i8] } %8, 0
  %12 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } %11, { i64, [32 x i8] } %10, 1
  ret { { i64, [32 x i8] }, { i64, [32 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [32 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [32 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } undef, { i64, [32 x i8] } %20, 0
  %24 = insertvalue { { i64, [32 x i8] }, { i64, [32 x i8] } } %23, { i64, [32 x i8] } %22, 1
  ret { { i64, [32 x i8] }, { i64, [32 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [64 x i8] } } @"impl$f73"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [64 x i8] }, i64 1, align 8
  %11 = alloca { i64, [64 x i8] }, i64 1, align 8
  %12 = alloca { i64, [32 x i8] }, i64 1, align 8
  %13 = alloca { i64, [64 x i8] }, i64 1, align 8
  br label %14

14:                                               ; preds = %49, %4
  %15 = phi i64 [ %44, %49 ], [ %0, %4 ]
  %16 = phi i64 [ %54, %49 ], [ %1, %4 ]
  %17 = phi { { ptr, i32, i32, i32 } } [ %56, %49 ], [ %2, %4 ]
  %18 = phi { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } [ %55, %49 ], [ %3, %4 ]
  %19 = add i64 %15, 1
  %20 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %21 = call ptr %20()
  %22 = load i64, ptr %21, align 8
  %23 = mul i64 %22, 25440
  %24 = icmp uge i64 %16, %23
  %25 = call i64 @llvm.usub.sat.i64(i64 %16, i64 %23)
  br i1 %24, label %26, label %109

26:                                               ; preds = %14
  %27 = phi { { ptr, i32, i32, i32 } } [ %17, %14 ]
  %28 = extractvalue { { ptr, i32, i32, i32 } } %27, 0
  %29 = extractvalue { ptr, i32, i32, i32 } %28, 1
  %30 = extractvalue { ptr, i32, i32, i32 } %28, 2
  %31 = sub i32 %30, %29
  %32 = icmp uge i32 %31, 1
  br i1 %32, label %33, label %88

33:                                               ; preds = %26
  %34 = extractvalue { ptr, i32, i32, i32 } %28, 0
  %35 = load ptr, ptr %34, align 8
  %36 = zext i32 %29 to i64
  %37 = mul i64 %36, 14
  %38 = getelementptr inbounds i8, ptr %35, i64 %37
  %39 = add i32 %29, 1
  %40 = insertvalue { ptr, i32, i32, i32 } %28, i32 %39, 1
  %41 = call ptr @realloc(ptr null, i64 14)
  call void @llvm.memcpy.p0.p0.i64(ptr %41, ptr %38, i64 14, i1 false)
  %42 = load { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 }, ptr %41, align 2
  call void @free(ptr %41)
  %43 = call fastcc { i64, { i64, [32 x i8] } } @"impl$f98"(i64 %19, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %18, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %42)
  %44 = extractvalue { i64, { i64, [32 x i8] } } %43, 0
  %45 = extractvalue { i64, { i64, [32 x i8] } } %43, 1
  store { i64, [32 x i8] } %45, ptr %12, align 8
  %46 = load i1, ptr %12, align 1
  switch i1 %46, label %47 [
    i1 false, label %49
    i1 true, label %61
  ]

47:                                               ; preds = %33
  br i1 false, label %48, label %124

48:                                               ; preds = %47
  unreachable

49:                                               ; preds = %33
  %50 = load { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } }, ptr %12, align 4
  %51 = extractvalue { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %50, 1
  %52 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %53 = call ptr %52()
  %54 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 0)
  %55 = extractvalue { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %51, 0
  %56 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %40, 0
  %57 = extractvalue { ptr, ptr, i64 } %8, 1
  %58 = load i64, ptr %57, align 8
  %59 = add i64 %58, 1
  %60 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %59, ptr %60, align 8
  br label %14

61:                                               ; preds = %33
  %62 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %63 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %62, 1
  call void @"drop$360"({ ptr, i32, i32, i32 } %40)
  %64 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %63, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %64, ptr %13, align 8
  %65 = load { i64, [64 x i8] }, ptr %13, align 8
  %66 = extractvalue { ptr, ptr, i64 } %8, 1
  %67 = load i64, ptr %66, align 8
  %68 = icmp eq i64 %67, 0
  %69 = sub i64 %67, 1
  %70 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %69, ptr %70, align 8
  br i1 %68, label %84, label %71

71:                                               ; preds = %71, %61, %88, %109
  %72 = phi i64 [ %19, %109 ], [ %19, %88 ], [ %72, %71 ], [ %44, %61 ]
  %73 = phi i64 [ %16, %109 ], [ %94, %88 ], [ %73, %71 ], [ %25, %61 ]
  %74 = phi { i64, [64 x i8] } [ %114, %109 ], [ %99, %88 ], [ %74, %71 ], [ %65, %61 ]
  %75 = extractvalue { ptr, ptr, i64 } %8, 1
  %76 = load i64, ptr %75, align 8
  %77 = icmp eq i64 %76, 0
  %78 = sub i64 %76, 1
  %79 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %78, ptr %79, align 8
  br i1 %77, label %80, label %71

80:                                               ; preds = %71
  %81 = insertvalue { i64, i64, { i64, [64 x i8] } } undef, i64 %72, 0
  %82 = insertvalue { i64, i64, { i64, [64 x i8] } } %81, i64 %73, 1
  %83 = insertvalue { i64, i64, { i64, [64 x i8] } } %82, { i64, [64 x i8] } %74, 2
  ret { i64, i64, { i64, [64 x i8] } } %83

84:                                               ; preds = %61
  %85 = insertvalue { i64, i64, { i64, [64 x i8] } } undef, i64 %44, 0
  %86 = insertvalue { i64, i64, { i64, [64 x i8] } } %85, i64 %25, 1
  %87 = insertvalue { i64, i64, { i64, [64 x i8] } } %86, { i64, [64 x i8] } %65, 2
  ret { i64, i64, { i64, [64 x i8] } } %87

88:                                               ; preds = %26
  %89 = phi i64 [ %25, %26 ]
  %90 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %91 = call ptr %90()
  %92 = load i64, ptr %91, align 8
  %93 = mul i64 %92, 26140
  %94 = call i64 @llvm.uadd.sat.i64(i64 %89, i64 %93)
  %95 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %28, 0
  %96 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %95, 0
  %97 = insertvalue { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %96, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %18, 1
  %98 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } undef }, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %97, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %98, ptr %11, align 8
  %99 = load { i64, [64 x i8] }, ptr %11, align 8
  %100 = extractvalue { ptr, ptr, i64 } %8, 1
  %101 = load i64, ptr %100, align 8
  %102 = icmp eq i64 %101, 0
  %103 = sub i64 %101, 1
  %104 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %103, ptr %104, align 8
  br i1 %102, label %105, label %71

105:                                              ; preds = %88
  %106 = insertvalue { i64, i64, { i64, [64 x i8] } } undef, i64 %19, 0
  %107 = insertvalue { i64, i64, { i64, [64 x i8] } } %106, i64 %94, 1
  %108 = insertvalue { i64, i64, { i64, [64 x i8] } } %107, { i64, [64 x i8] } %99, 2
  ret { i64, i64, { i64, [64 x i8] } } %108

109:                                              ; preds = %14
  %110 = phi { { ptr, i32, i32, i32 } } [ %17, %14 ]
  call void @"drop$361"({ { ptr, i32, i32, i32 } } %110)
  %111 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %112 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %111, 0
  %113 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %112, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %113, ptr %10, align 8
  %114 = load { i64, [64 x i8] }, ptr %10, align 8
  %115 = extractvalue { ptr, ptr, i64 } %8, 1
  %116 = load i64, ptr %115, align 8
  %117 = icmp eq i64 %116, 0
  %118 = sub i64 %116, 1
  %119 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %118, ptr %119, align 8
  br i1 %117, label %120, label %71

120:                                              ; preds = %109
  %121 = insertvalue { i64, i64, { i64, [64 x i8] } } undef, i64 %19, 0
  %122 = insertvalue { i64, i64, { i64, [64 x i8] } } %121, i64 %16, 1
  %123 = insertvalue { i64, i64, { i64, [64 x i8] } } %122, { i64, [64 x i8] } %114, 2
  ret { i64, i64, { i64, [64 x i8] } } %123

124:                                              ; preds = %47
  call void @puts(ptr @assert_msg_138)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [64 x i8] } } @f73(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [64 x i8] } } @"impl$f73"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [64 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [64 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [64 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [64 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [64 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [64 x i8] } } %10, { i64, [64 x i8] } %8, 2
  ret { i64, i64, { i64, [64 x i8] } } %11
}

define void @_mlir_ciface_f73(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [64 x i8] } } @f73(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %4)
  store { i64, i64, { i64, [64 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f74"(i64 %0, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 0
  %8 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 1
  %9 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 2
  %10 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 3
  %11 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 4
  %12 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 5
  %13 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 6
  %14 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 7
  %15 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 8
  %16 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 9
  %17 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 10
  %18 = add i64 %0, 1
  %19 = icmp sge i32 %7, 0
  br i1 %19, label %20, label %35

20:                                               ; preds = %2
  %21 = phi i32 [ %7, %2 ]
  %22 = add i64 %0, 2
  %23 = icmp sle i32 %21, 100
  br i1 %23, label %24, label %35

24:                                               ; preds = %20
  %25 = phi i64 [ %22, %20 ]
  %26 = phi i32 [ %21, %20 ]
  %27 = icmp sge i32 %26, 0
  %28 = icmp slt i32 %26, 256
  %29 = and i1 %27, %28
  %30 = and i1 %27, %28
  %31 = add i64 %25, 2
  %32 = add i64 %25, 1
  %33 = select i1 %30, i64 %31, i64 %32
  %34 = trunc i32 %26 to i8
  br i1 %29, label %35, label %213

35:                                               ; preds = %24, %20, %2
  %36 = phi i32 [ %8, %24 ], [ %8, %20 ], [ %8, %2 ]
  %37 = phi i32 [ %9, %24 ], [ %9, %20 ], [ %9, %2 ]
  %38 = phi i32 [ %10, %24 ], [ %10, %20 ], [ %10, %2 ]
  %39 = phi i16 [ %11, %24 ], [ %11, %20 ], [ %11, %2 ]
  %40 = phi i16 [ %12, %24 ], [ %12, %20 ], [ %12, %2 ]
  %41 = phi i16 [ %13, %24 ], [ %13, %20 ], [ %13, %2 ]
  %42 = phi i16 [ %14, %24 ], [ %14, %20 ], [ %14, %2 ]
  %43 = phi i32 [ %15, %24 ], [ %15, %20 ], [ %15, %2 ]
  %44 = phi i32 [ %16, %24 ], [ %16, %20 ], [ %16, %2 ]
  %45 = phi i32 [ %17, %24 ], [ %17, %20 ], [ %17, %2 ]
  %46 = phi i64 [ %33, %24 ], [ %22, %20 ], [ %18, %2 ]
  %47 = phi i8 [ %34, %24 ], [ 100, %20 ], [ 0, %2 ]
  %48 = add i64 %46, 1
  %49 = icmp sge i32 %36, 0
  br i1 %49, label %50, label %65

50:                                               ; preds = %35
  %51 = phi i32 [ %36, %35 ]
  %52 = add i64 %46, 2
  %53 = icmp sle i32 %51, 100
  br i1 %53, label %54, label %65

54:                                               ; preds = %50
  %55 = phi i64 [ %52, %50 ]
  %56 = phi i32 [ %51, %50 ]
  %57 = icmp sge i32 %56, 0
  %58 = icmp slt i32 %56, 256
  %59 = and i1 %57, %58
  %60 = and i1 %57, %58
  %61 = add i64 %55, 2
  %62 = add i64 %55, 1
  %63 = select i1 %60, i64 %61, i64 %62
  %64 = trunc i32 %56 to i8
  br i1 %59, label %65, label %213

65:                                               ; preds = %54, %50, %35
  %66 = phi i32 [ %37, %54 ], [ %37, %50 ], [ %37, %35 ]
  %67 = phi i32 [ %38, %54 ], [ %38, %50 ], [ %38, %35 ]
  %68 = phi i16 [ %39, %54 ], [ %39, %50 ], [ %39, %35 ]
  %69 = phi i16 [ %40, %54 ], [ %40, %50 ], [ %40, %35 ]
  %70 = phi i16 [ %41, %54 ], [ %41, %50 ], [ %41, %35 ]
  %71 = phi i16 [ %42, %54 ], [ %42, %50 ], [ %42, %35 ]
  %72 = phi i32 [ %43, %54 ], [ %43, %50 ], [ %43, %35 ]
  %73 = phi i32 [ %44, %54 ], [ %44, %50 ], [ %44, %35 ]
  %74 = phi i32 [ %45, %54 ], [ %45, %50 ], [ %45, %35 ]
  %75 = phi i8 [ %47, %54 ], [ %47, %50 ], [ %47, %35 ]
  %76 = phi i64 [ %63, %54 ], [ %52, %50 ], [ %48, %35 ]
  %77 = phi i8 [ %64, %54 ], [ 100, %50 ], [ 0, %35 ]
  %78 = add i64 %76, 1
  %79 = icmp sge i32 %66, 0
  br i1 %79, label %80, label %95

80:                                               ; preds = %65
  %81 = phi i32 [ %66, %65 ]
  %82 = add i64 %76, 2
  %83 = icmp sle i32 %81, 100
  br i1 %83, label %84, label %95

84:                                               ; preds = %80
  %85 = phi i64 [ %82, %80 ]
  %86 = phi i32 [ %81, %80 ]
  %87 = icmp sge i32 %86, 0
  %88 = icmp slt i32 %86, 256
  %89 = and i1 %87, %88
  %90 = and i1 %87, %88
  %91 = add i64 %85, 2
  %92 = add i64 %85, 1
  %93 = select i1 %90, i64 %91, i64 %92
  %94 = trunc i32 %86 to i8
  br i1 %89, label %95, label %213

95:                                               ; preds = %84, %80, %65
  %96 = phi i32 [ %67, %84 ], [ %67, %80 ], [ %67, %65 ]
  %97 = phi i16 [ %68, %84 ], [ %68, %80 ], [ %68, %65 ]
  %98 = phi i16 [ %69, %84 ], [ %69, %80 ], [ %69, %65 ]
  %99 = phi i16 [ %70, %84 ], [ %70, %80 ], [ %70, %65 ]
  %100 = phi i16 [ %71, %84 ], [ %71, %80 ], [ %71, %65 ]
  %101 = phi i32 [ %72, %84 ], [ %72, %80 ], [ %72, %65 ]
  %102 = phi i32 [ %73, %84 ], [ %73, %80 ], [ %73, %65 ]
  %103 = phi i32 [ %74, %84 ], [ %74, %80 ], [ %74, %65 ]
  %104 = phi i8 [ %75, %84 ], [ %75, %80 ], [ %75, %65 ]
  %105 = phi i8 [ %77, %84 ], [ %77, %80 ], [ %77, %65 ]
  %106 = phi i64 [ %93, %84 ], [ %82, %80 ], [ %78, %65 ]
  %107 = phi i8 [ %94, %84 ], [ 100, %80 ], [ 0, %65 ]
  %108 = add i64 %106, 1
  %109 = icmp sge i32 %96, 0
  br i1 %109, label %110, label %125

110:                                              ; preds = %95
  %111 = phi i32 [ %96, %95 ]
  %112 = add i64 %106, 2
  %113 = icmp sle i32 %111, 100
  br i1 %113, label %114, label %125

114:                                              ; preds = %110
  %115 = phi i64 [ %112, %110 ]
  %116 = phi i32 [ %111, %110 ]
  %117 = icmp sge i32 %116, 0
  %118 = icmp slt i32 %116, 256
  %119 = and i1 %117, %118
  %120 = and i1 %117, %118
  %121 = add i64 %115, 2
  %122 = add i64 %115, 1
  %123 = select i1 %120, i64 %121, i64 %122
  %124 = trunc i32 %116 to i8
  br i1 %119, label %125, label %213

125:                                              ; preds = %114, %110, %95
  %126 = phi i16 [ %97, %114 ], [ %97, %110 ], [ %97, %95 ]
  %127 = phi i16 [ %98, %114 ], [ %98, %110 ], [ %98, %95 ]
  %128 = phi i16 [ %99, %114 ], [ %99, %110 ], [ %99, %95 ]
  %129 = phi i16 [ %100, %114 ], [ %100, %110 ], [ %100, %95 ]
  %130 = phi i32 [ %101, %114 ], [ %101, %110 ], [ %101, %95 ]
  %131 = phi i32 [ %102, %114 ], [ %102, %110 ], [ %102, %95 ]
  %132 = phi i32 [ %103, %114 ], [ %103, %110 ], [ %103, %95 ]
  %133 = phi i8 [ %104, %114 ], [ %104, %110 ], [ %104, %95 ]
  %134 = phi i8 [ %105, %114 ], [ %105, %110 ], [ %105, %95 ]
  %135 = phi i8 [ %107, %114 ], [ %107, %110 ], [ %107, %95 ]
  %136 = phi i64 [ %123, %114 ], [ %112, %110 ], [ %108, %95 ]
  %137 = phi i8 [ %124, %114 ], [ 100, %110 ], [ 0, %95 ]
  %138 = add i64 %136, 1
  %139 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 100, i16 %126)
  %140 = extractvalue { i16, i1 } %139, 1
  br i1 %140, label %147, label %141

141:                                              ; preds = %125
  %142 = phi i64 [ %138, %125 ]
  %143 = phi i16 [ %126, %125 ]
  %144 = icmp ult i16 %143, 256
  %145 = add i64 %142, 1
  %146 = trunc i16 %143 to i8
  br i1 %144, label %147, label %213

147:                                              ; preds = %141, %125
  %148 = phi i16 [ %127, %141 ], [ %127, %125 ]
  %149 = phi i16 [ %128, %141 ], [ %128, %125 ]
  %150 = phi i16 [ %129, %141 ], [ %129, %125 ]
  %151 = phi i32 [ %130, %141 ], [ %130, %125 ]
  %152 = phi i32 [ %131, %141 ], [ %131, %125 ]
  %153 = phi i32 [ %132, %141 ], [ %132, %125 ]
  %154 = phi i8 [ %133, %141 ], [ %133, %125 ]
  %155 = phi i8 [ %134, %141 ], [ %134, %125 ]
  %156 = phi i8 [ %135, %141 ], [ %135, %125 ]
  %157 = phi i8 [ %137, %141 ], [ %137, %125 ]
  %158 = phi i64 [ %145, %141 ], [ %138, %125 ]
  %159 = phi i8 [ %146, %141 ], [ 100, %125 ]
  %160 = add i64 %158, 1
  %161 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 100, i16 %148)
  %162 = extractvalue { i16, i1 } %161, 1
  br i1 %162, label %169, label %163

163:                                              ; preds = %147
  %164 = phi i64 [ %160, %147 ]
  %165 = phi i16 [ %148, %147 ]
  %166 = icmp ult i16 %165, 256
  %167 = add i64 %164, 1
  %168 = trunc i16 %165 to i8
  br i1 %166, label %169, label %213

169:                                              ; preds = %163, %147
  %170 = phi i16 [ %149, %163 ], [ %149, %147 ]
  %171 = phi i16 [ %150, %163 ], [ %150, %147 ]
  %172 = phi i32 [ %151, %163 ], [ %151, %147 ]
  %173 = phi i32 [ %152, %163 ], [ %152, %147 ]
  %174 = phi i32 [ %153, %163 ], [ %153, %147 ]
  %175 = phi i8 [ %154, %163 ], [ %154, %147 ]
  %176 = phi i8 [ %155, %163 ], [ %155, %147 ]
  %177 = phi i8 [ %156, %163 ], [ %156, %147 ]
  %178 = phi i8 [ %157, %163 ], [ %157, %147 ]
  %179 = phi i8 [ %159, %163 ], [ %159, %147 ]
  %180 = phi i64 [ %167, %163 ], [ %160, %147 ]
  %181 = phi i8 [ %168, %163 ], [ 100, %147 ]
  %182 = add i64 %180, 1
  %183 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 100, i16 %170)
  %184 = extractvalue { i16, i1 } %183, 1
  br i1 %184, label %191, label %185

185:                                              ; preds = %169
  %186 = phi i64 [ %182, %169 ]
  %187 = phi i16 [ %170, %169 ]
  %188 = icmp ult i16 %187, 256
  %189 = add i64 %186, 1
  %190 = trunc i16 %187 to i8
  br i1 %188, label %191, label %213

191:                                              ; preds = %185, %169
  %192 = phi i16 [ %171, %185 ], [ %171, %169 ]
  %193 = phi i32 [ %172, %185 ], [ %172, %169 ]
  %194 = phi i32 [ %173, %185 ], [ %173, %169 ]
  %195 = phi i32 [ %174, %185 ], [ %174, %169 ]
  %196 = phi i8 [ %175, %185 ], [ %175, %169 ]
  %197 = phi i8 [ %176, %185 ], [ %176, %169 ]
  %198 = phi i8 [ %177, %185 ], [ %177, %169 ]
  %199 = phi i8 [ %178, %185 ], [ %178, %169 ]
  %200 = phi i8 [ %179, %185 ], [ %179, %169 ]
  %201 = phi i8 [ %181, %185 ], [ %181, %169 ]
  %202 = phi i64 [ %189, %185 ], [ %182, %169 ]
  %203 = phi i8 [ %190, %185 ], [ 100, %169 ]
  %204 = add i64 %202, 1
  %205 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 100, i16 %192)
  %206 = extractvalue { i16, i1 } %205, 1
  br i1 %206, label %221, label %207

207:                                              ; preds = %191
  %208 = phi i64 [ %204, %191 ]
  %209 = phi i16 [ %192, %191 ]
  %210 = icmp ult i16 %209, 256
  %211 = add i64 %208, 1
  %212 = trunc i16 %209 to i8
  br i1 %210, label %221, label %213

213:                                              ; preds = %207, %185, %163, %141, %114, %84, %54, %24
  %214 = phi i64 [ %211, %207 ], [ %189, %185 ], [ %167, %163 ], [ %145, %141 ], [ %123, %114 ], [ %93, %84 ], [ %63, %54 ], [ %33, %24 ]
  %215 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %216 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %215, 0
  %217 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %216, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %217, ptr %6, align 8
  %218 = load { i64, [24 x i8] }, ptr %6, align 8
  %219 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %214, 0
  %220 = insertvalue { i64, { i64, [24 x i8] } } %219, { i64, [24 x i8] } %218, 1
  ret { i64, { i64, [24 x i8] } } %220

221:                                              ; preds = %207, %191
  %222 = phi i32 [ %193, %207 ], [ %193, %191 ]
  %223 = phi i32 [ %194, %207 ], [ %194, %191 ]
  %224 = phi i32 [ %195, %207 ], [ %195, %191 ]
  %225 = phi i8 [ %196, %207 ], [ %196, %191 ]
  %226 = phi i8 [ %197, %207 ], [ %197, %191 ]
  %227 = phi i8 [ %198, %207 ], [ %198, %191 ]
  %228 = phi i8 [ %199, %207 ], [ %199, %191 ]
  %229 = phi i8 [ %200, %207 ], [ %200, %191 ]
  %230 = phi i8 [ %201, %207 ], [ %201, %191 ]
  %231 = phi i8 [ %203, %207 ], [ %203, %191 ]
  %232 = phi i64 [ %211, %207 ], [ %204, %191 ]
  %233 = phi i8 [ %212, %207 ], [ 100, %191 ]
  %234 = icmp sge i32 %222, 0
  %235 = icmp slt i32 %222, 65536
  %236 = and i1 %234, %235
  %237 = and i1 %234, %235
  %238 = add i64 %232, 2
  %239 = add i64 %232, 1
  %240 = select i1 %237, i64 %238, i64 %239
  %241 = trunc i32 %222 to i16
  br i1 %236, label %248, label %242

242:                                              ; preds = %221
  %243 = phi i64 [ %240, %221 ]
  %244 = phi i32 [ 0, %221 ]
  %245 = phi i32 [ %222, %221 ]
  %246 = add i64 %243, 1
  %247 = icmp sge i32 %244, %245
  br i1 %247, label %248, label %386

248:                                              ; preds = %386, %242, %221
  %249 = phi i32 [ %387, %386 ], [ %223, %242 ], [ %223, %221 ]
  %250 = phi i32 [ %388, %386 ], [ %224, %242 ], [ %224, %221 ]
  %251 = phi i8 [ %389, %386 ], [ %225, %242 ], [ %225, %221 ]
  %252 = phi i8 [ %390, %386 ], [ %226, %242 ], [ %226, %221 ]
  %253 = phi i8 [ %391, %386 ], [ %227, %242 ], [ %227, %221 ]
  %254 = phi i8 [ %392, %386 ], [ %228, %242 ], [ %228, %221 ]
  %255 = phi i8 [ %393, %386 ], [ %229, %242 ], [ %229, %221 ]
  %256 = phi i8 [ %394, %386 ], [ %230, %242 ], [ %230, %221 ]
  %257 = phi i8 [ %395, %386 ], [ %231, %242 ], [ %231, %221 ]
  %258 = phi i8 [ %396, %386 ], [ %233, %242 ], [ %233, %221 ]
  %259 = phi i64 [ %397, %386 ], [ %246, %242 ], [ %240, %221 ]
  %260 = phi i16 [ %398, %386 ], [ 0, %242 ], [ %241, %221 ]
  %261 = icmp sge i32 %249, 0
  %262 = icmp slt i32 %249, 65536
  %263 = and i1 %261, %262
  %264 = and i1 %261, %262
  %265 = add i64 %259, 2
  %266 = add i64 %259, 1
  %267 = select i1 %264, i64 %265, i64 %266
  %268 = trunc i32 %249 to i16
  br i1 %263, label %275, label %269

269:                                              ; preds = %248
  %270 = phi i64 [ %267, %248 ]
  %271 = phi i32 [ 0, %248 ]
  %272 = phi i32 [ %249, %248 ]
  %273 = add i64 %270, 1
  %274 = icmp sge i32 %271, %272
  br i1 %274, label %275, label %399

275:                                              ; preds = %399, %269, %248
  %276 = phi i32 [ %400, %399 ], [ %250, %269 ], [ %250, %248 ]
  %277 = phi i8 [ %401, %399 ], [ %251, %269 ], [ %251, %248 ]
  %278 = phi i8 [ %402, %399 ], [ %252, %269 ], [ %252, %248 ]
  %279 = phi i8 [ %403, %399 ], [ %253, %269 ], [ %253, %248 ]
  %280 = phi i8 [ %404, %399 ], [ %254, %269 ], [ %254, %248 ]
  %281 = phi i8 [ %405, %399 ], [ %255, %269 ], [ %255, %248 ]
  %282 = phi i8 [ %406, %399 ], [ %256, %269 ], [ %256, %248 ]
  %283 = phi i8 [ %407, %399 ], [ %257, %269 ], [ %257, %248 ]
  %284 = phi i8 [ %408, %399 ], [ %258, %269 ], [ %258, %248 ]
  %285 = phi i16 [ %409, %399 ], [ %260, %269 ], [ %260, %248 ]
  %286 = phi i64 [ %410, %399 ], [ %273, %269 ], [ %267, %248 ]
  %287 = phi i16 [ %411, %399 ], [ 0, %269 ], [ %268, %248 ]
  %288 = icmp sge i32 %276, 0
  %289 = icmp slt i32 %276, 65536
  %290 = and i1 %288, %289
  %291 = and i1 %288, %289
  %292 = add i64 %286, 2
  %293 = add i64 %286, 1
  %294 = select i1 %291, i64 %292, i64 %293
  %295 = trunc i32 %276 to i16
  br i1 %290, label %296, label %324

296:                                              ; preds = %275
  %297 = phi i8 [ %277, %275 ]
  %298 = phi i8 [ %278, %275 ]
  %299 = phi i8 [ %279, %275 ]
  %300 = phi i8 [ %280, %275 ]
  %301 = phi i8 [ %281, %275 ]
  %302 = phi i8 [ %282, %275 ]
  %303 = phi i8 [ %283, %275 ]
  %304 = phi i8 [ %284, %275 ]
  %305 = phi i16 [ %285, %275 ]
  %306 = phi i16 [ %287, %275 ]
  %307 = phi i16 [ %295, %275 ]
  %308 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %297, 0
  %309 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %308, i8 %298, 1
  %310 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %309, i8 %299, 2
  %311 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %310, i8 %300, 3
  %312 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %311, i8 %301, 4
  %313 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %312, i8 %302, 5
  %314 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %313, i8 %303, 6
  %315 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %314, i8 %304, 7
  %316 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %315, i16 %305, 8
  %317 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %316, i16 %306, 9
  %318 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %317, i16 %307, 10
  %319 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %318, 0
  %320 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } { i1 false, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %319, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %320, ptr %5, align 2
  %321 = load { i64, [24 x i8] }, ptr %5, align 8
  %322 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %294, 0
  %323 = insertvalue { i64, { i64, [24 x i8] } } %322, { i64, [24 x i8] } %321, 1
  ret { i64, { i64, [24 x i8] } } %323

324:                                              ; preds = %275
  %325 = phi i64 [ %294, %275 ]
  %326 = phi i32 [ 0, %275 ]
  %327 = phi i32 [ %276, %275 ]
  %328 = add i64 %325, 1
  %329 = icmp sge i32 %326, %327
  br i1 %329, label %330, label %358

330:                                              ; preds = %324
  %331 = phi i8 [ %277, %324 ]
  %332 = phi i8 [ %278, %324 ]
  %333 = phi i8 [ %279, %324 ]
  %334 = phi i8 [ %280, %324 ]
  %335 = phi i8 [ %281, %324 ]
  %336 = phi i8 [ %282, %324 ]
  %337 = phi i8 [ %283, %324 ]
  %338 = phi i8 [ %284, %324 ]
  %339 = phi i16 [ %285, %324 ]
  %340 = phi i16 [ %287, %324 ]
  %341 = phi i16 [ 0, %324 ]
  %342 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %331, 0
  %343 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %342, i8 %332, 1
  %344 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %343, i8 %333, 2
  %345 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %344, i8 %334, 3
  %346 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %345, i8 %335, 4
  %347 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %346, i8 %336, 5
  %348 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %347, i8 %337, 6
  %349 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %348, i8 %338, 7
  %350 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %349, i16 %339, 8
  %351 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %350, i16 %340, 9
  %352 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %351, i16 %341, 10
  %353 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %352, 0
  %354 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } { i1 false, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %353, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %354, ptr %4, align 2
  %355 = load { i64, [24 x i8] }, ptr %4, align 8
  %356 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %328, 0
  %357 = insertvalue { i64, { i64, [24 x i8] } } %356, { i64, [24 x i8] } %355, 1
  ret { i64, { i64, [24 x i8] } } %357

358:                                              ; preds = %324
  %359 = phi i8 [ %277, %324 ]
  %360 = phi i8 [ %278, %324 ]
  %361 = phi i8 [ %279, %324 ]
  %362 = phi i8 [ %280, %324 ]
  %363 = phi i8 [ %281, %324 ]
  %364 = phi i8 [ %282, %324 ]
  %365 = phi i8 [ %283, %324 ]
  %366 = phi i8 [ %284, %324 ]
  %367 = phi i16 [ %285, %324 ]
  %368 = phi i16 [ %287, %324 ]
  %369 = phi i16 [ -1, %324 ]
  %370 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %359, 0
  %371 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %370, i8 %360, 1
  %372 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %371, i8 %361, 2
  %373 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %372, i8 %362, 3
  %374 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %373, i8 %363, 4
  %375 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %374, i8 %364, 5
  %376 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %375, i8 %365, 6
  %377 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %376, i8 %366, 7
  %378 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %377, i16 %367, 8
  %379 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %378, i16 %368, 9
  %380 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %379, i16 %369, 10
  %381 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %380, 0
  %382 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } { i1 false, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %381, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %382, ptr %3, align 2
  %383 = load { i64, [24 x i8] }, ptr %3, align 8
  %384 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %328, 0
  %385 = insertvalue { i64, { i64, [24 x i8] } } %384, { i64, [24 x i8] } %383, 1
  ret { i64, { i64, [24 x i8] } } %385

386:                                              ; preds = %242
  %387 = phi i32 [ %223, %242 ]
  %388 = phi i32 [ %224, %242 ]
  %389 = phi i8 [ %225, %242 ]
  %390 = phi i8 [ %226, %242 ]
  %391 = phi i8 [ %227, %242 ]
  %392 = phi i8 [ %228, %242 ]
  %393 = phi i8 [ %229, %242 ]
  %394 = phi i8 [ %230, %242 ]
  %395 = phi i8 [ %231, %242 ]
  %396 = phi i8 [ %233, %242 ]
  %397 = phi i64 [ %246, %242 ]
  %398 = phi i16 [ -1, %242 ]
  br label %248

399:                                              ; preds = %269
  %400 = phi i32 [ %250, %269 ]
  %401 = phi i8 [ %251, %269 ]
  %402 = phi i8 [ %252, %269 ]
  %403 = phi i8 [ %253, %269 ]
  %404 = phi i8 [ %254, %269 ]
  %405 = phi i8 [ %255, %269 ]
  %406 = phi i8 [ %256, %269 ]
  %407 = phi i8 [ %257, %269 ]
  %408 = phi i8 [ %258, %269 ]
  %409 = phi i16 [ %260, %269 ]
  %410 = phi i64 [ %273, %269 ]
  %411 = phi i16 [ -1, %269 ]
  br label %275
}

define private { i64, { i64, [24 x i8] } } @f74(i64 %0, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1) {
  %3 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f74"(i64 %0, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1)
  %4 = extractvalue { i64, { i64, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { i64, [24 x i8] } } %3, 1
  %6 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %5, 1
  ret { i64, { i64, [24 x i8] } } %7
}

define void @_mlir_ciface_f74(ptr %0, i64 %1, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %2) {
  %4 = call { i64, { i64, [24 x i8] } } @f74(i64 %1, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %2)
  store { i64, { i64, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$230"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$230"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i32, [8 x i8] } } }, ptr %2, align 4
  %6 = extractvalue { i1, { { i32, [8 x i8] } } } %5, 1
  %7 = insertvalue { i1, { { i32, [8 x i8] } } } %5, { { i32, [8 x i8] } } %6, 1
  store { i1, { { i32, [8 x i8] } } } %7, ptr %2, align 4
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { i32, [8 x i8] } } } %5, { { i32, [8 x i8] } } %6, 1
  store { i1, { { i32, [8 x i8] } } } %9, ptr %2, align 4
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f75"(i64 %0, i64 %1, i64 %2, ptr %3, { { {} }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i128, [32 x i8] }, i64 1, align 16
  %9 = alloca { i32, [8 x i8] }, i64 1, align 4
  %10 = alloca { i128, [32 x i8] }, i64 1, align 16
  %11 = alloca { i128, [32 x i8] }, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca i256, i64 1, align 16
  %15 = alloca { i1, [47 x i8] }, i64 1, align 16
  %16 = alloca i64, i64 1, align 8
  %17 = alloca i252, i64 1, align 16
  %18 = alloca { i128, [32 x i8] }, i64 1, align 16
  %19 = alloca { i128, [32 x i8] }, i64 1, align 16
  %20 = extractvalue { { ptr, i32, i32, i32 } } %5, 0
  %21 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f99"(i64 %0, { ptr, i32, i32, i32 } %20)
  %22 = extractvalue { i64, { i64, [24 x i8] } } %21, 0
  %23 = extractvalue { i64, { i64, [24 x i8] } } %21, 1
  store { i64, [24 x i8] } %23, ptr %7, align 8
  %24 = load i1, ptr %7, align 1
  switch i1 %24, label %25 [
    i1 false, label %27
    i1 true, label %32
  ]

25:                                               ; preds = %6
  br i1 false, label %26, label %142

26:                                               ; preds = %25
  unreachable

27:                                               ; preds = %6
  %28 = load { i1, { { i32, [8 x i8] } } }, ptr %7, align 4
  %29 = extractvalue { i1, { { i32, [8 x i8] } } } %28, 1
  %30 = extractvalue { { i32, [8 x i8] } } %29, 0
  store { i32, [8 x i8] } %30, ptr %9, align 4
  %31 = load i1, ptr %9, align 1
  switch i1 %31, label %42 [
    i1 false, label %44
    i1 true, label %56
  ]

32:                                               ; preds = %6
  %33 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %34 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %33, 1
  call void @"drop$450"({ { {} }, { { ptr, i32, i32, i32 } } } %4)
  %35 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %34, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %35, ptr %8, align 8
  %36 = load { i128, [32 x i8] }, ptr %8, align 16
  %37 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %22, 0
  %38 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %37, i64 %1, 1
  %39 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %38, i64 %2, 2
  %40 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %39, ptr %3, 3
  %41 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %40, { i128, [32 x i8] } %36, 4
  ret { i64, i64, i64, ptr, { i128, [32 x i8] } } %41

42:                                               ; preds = %27
  br i1 false, label %43, label %143

43:                                               ; preds = %42
  unreachable

44:                                               ; preds = %27
  %45 = load { i1, { i32, i32 } }, ptr %9, align 4
  %46 = extractvalue { i1, { i32, i32 } } %45, 1
  %47 = extractvalue { i32, i32 } %46, 0
  %48 = extractvalue { i32, i32 } %46, 1
  %49 = extractvalue { { {} }, { { ptr, i32, i32, i32 } } } %4, 1
  %50 = extractvalue { { ptr, i32, i32, i32 } } %49, 0
  %51 = add i64 %22, 1
  %52 = extractvalue { ptr, i32, i32, i32 } %50, 1
  %53 = extractvalue { ptr, i32, i32, i32 } %50, 2
  %54 = sub i32 %53, %52
  %55 = icmp ult i32 %47, %54
  br i1 %55, label %66, label %107

56:                                               ; preds = %27
  call void @"drop$450"({ { {} }, { { ptr, i32, i32, i32 } } } %4)
  %57 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f101"()
  %58 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %57, 0
  %59 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %58, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %59, ptr %10, align 8
  %60 = load { i128, [32 x i8] }, ptr %10, align 16
  %61 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %22, 0
  %62 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %61, i64 %1, 1
  %63 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %62, i64 %2, 2
  %64 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %63, ptr %3, 3
  %65 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %64, { i128, [32 x i8] } %60, 4
  ret { i64, i64, i64, ptr, { i128, [32 x i8] } } %65

66:                                               ; preds = %44
  %67 = add i32 %52, %47
  %68 = zext i32 %67 to i64
  %69 = mul i64 %68, 32
  %70 = extractvalue { ptr, i32, i32, i32 } %50, 0
  %71 = load ptr, ptr %70, align 8
  %72 = getelementptr inbounds i8, ptr %71, i64 %69
  %73 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %73, ptr %72, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %50)
  %74 = load i252, ptr %73, align 16
  call void @free(ptr %73)
  %75 = zext i252 %74 to i512
  %76 = mul i512 %75, 4294967296
  %77 = urem i512 %76, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %78 = icmp uge i512 %76, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %79 = select i1 %78, i512 %77, i512 %76
  %80 = trunc i512 %79 to i252
  %81 = zext i252 %80 to i256
  %82 = zext i32 %48 to i256
  %83 = add i256 %81, %82
  %84 = sub i256 %83, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %85 = icmp uge i256 %83, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %86 = select i1 %85, i256 %84, i256 %83
  %87 = trunc i256 %86 to i252
  %88 = add i64 %2, 3
  %89 = zext i252 %87 to i256
  store i256 1436209994116032968217460821259974301319484759399248048177294919499399378304, ptr %12, align 16
  store i256 %89, ptr %13, align 16
  %90 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %90(ptr %14, ptr %12, ptr %13)
  %91 = load i256, ptr %14, align 16
  %92 = trunc i256 %91 to i252
  %93 = add i64 %22, 4
  %94 = sub i252 %92, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %95 = icmp ult i252 %92, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %96 = select i1 %95, i252 %92, i252 %94
  %97 = load ptr, ptr %3, align 8
  store i64 %1, ptr %16, align 8
  store i252 %96, ptr %17, align 16
  %98 = getelementptr inbounds ptr, ptr %3, i32 8
  %99 = load ptr, ptr %98, align 8
  call void %99(ptr %15, ptr %97, ptr %16, i32 0, ptr %17)
  %100 = load { i1, [47 x i8] }, ptr %15, align 1
  %101 = extractvalue { i1, [47 x i8] } %100, 0
  %102 = getelementptr inbounds i8, ptr %15, i32 16
  %103 = load i252, ptr %102, align 16
  %104 = getelementptr inbounds i8, ptr %15, i32 8
  %105 = load { ptr, i32, i32, i32 }, ptr %104, align 8
  %106 = load i64, ptr %16, align 8
  br i1 %101, label %132, label %117

107:                                              ; preds = %44
  call void @"drop$3"({ ptr, i32, i32, i32 } %50)
  %108 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f100"()
  %109 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %108, 0
  %110 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %109, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %110, ptr %11, align 8
  %111 = load { i128, [32 x i8] }, ptr %11, align 16
  %112 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %51, 0
  %113 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %112, i64 %1, 1
  %114 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %113, i64 %2, 2
  %115 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %114, ptr %3, 3
  %116 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %115, { i128, [32 x i8] } %111, 4
  ret { i64, i64, i64, ptr, { i128, [32 x i8] } } %116

117:                                              ; preds = %66
  %118 = phi i64 [ %106, %66 ]
  %119 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %120 = call ptr %119()
  %121 = load i64, ptr %120, align 8
  %122 = mul i64 %121, 10
  %123 = call i64 @llvm.uadd.sat.i64(i64 %118, i64 %122)
  %124 = insertvalue { i252 } undef, i252 %103, 0
  %125 = insertvalue { i1, { i252 } } { i1 false, { i252 } undef }, { i252 } %124, 1
  store { i1, { i252 } } %125, ptr %19, align 16
  %126 = load { i128, [32 x i8] }, ptr %19, align 16
  %127 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %93, 0
  %128 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %127, i64 %123, 1
  %129 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %128, i64 %88, 2
  %130 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %129, ptr %3, 3
  %131 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %130, { i128, [32 x i8] } %126, 4
  ret { i64, i64, i64, ptr, { i128, [32 x i8] } } %131

132:                                              ; preds = %66
  %133 = phi { ptr, i32, i32, i32 } [ %105, %66 ]
  %134 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %133, 1
  %135 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %134, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %135, ptr %18, align 8
  %136 = load { i128, [32 x i8] }, ptr %18, align 16
  %137 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %93, 0
  %138 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %137, i64 %106, 1
  %139 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %138, i64 %88, 2
  %140 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %139, ptr %3, 3
  %141 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %140, { i128, [32 x i8] } %136, 4
  ret { i64, i64, i64, ptr, { i128, [32 x i8] } } %141

142:                                              ; preds = %25
  call void @puts(ptr @assert_msg_139)
  call void @abort()
  unreachable

143:                                              ; preds = %42
  call void @puts(ptr @assert_msg_140)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i128, [32 x i8] } } @f75(i64 %0, i64 %1, i64 %2, ptr %3, { { {} }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %5) {
  %7 = call fastcc { i64, i64, i64, ptr, { i128, [32 x i8] } } @"impl$f75"(i64 %0, i64 %1, i64 %2, ptr %3, { { {} }, { { ptr, i32, i32, i32 } } } %4, { { ptr, i32, i32, i32 } } %5)
  %8 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %7, 4
  %13 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } undef, i64 %8, 0
  %14 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %13, i64 %9, 1
  %15 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %14, i64 %10, 2
  %16 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %15, ptr %11, 3
  %17 = insertvalue { i64, i64, i64, ptr, { i128, [32 x i8] } } %16, { i128, [32 x i8] } %12, 4
  ret { i64, i64, i64, ptr, { i128, [32 x i8] } } %17
}

define void @_mlir_ciface_f75(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %6) {
  %8 = call { i64, i64, i64, ptr, { i128, [32 x i8] } } @f75(i64 %1, i64 %2, i64 %3, ptr %4, { { {} }, { { ptr, i32, i32, i32 } } } %5, { { ptr, i32, i32, i32 } } %6)
  store { i64, i64, i64, ptr, { i128, [32 x i8] } } %8, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i128, [112 x i8] } } @"impl$f76"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4) {
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i128, [32 x i8] }, i64 1, align 16
  %9 = alloca { i128, [112 x i8] }, i64 1, align 16
  %10 = alloca { i128, [112 x i8] }, i64 1, align 16
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca { i1, [47 x i8] }, i64 1, align 16
  %15 = alloca i64, i64 1, align 8
  %16 = alloca i252, i64 1, align 16
  %17 = alloca { i128, [112 x i8] }, i64 1, align 16
  %18 = alloca { i128, [32 x i8] }, i64 1, align 16
  %19 = alloca { i128, [112 x i8] }, i64 1, align 16
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, 0
  %22 = extractvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4, 1
  %23 = extractvalue { { ptr, i32, i32, i32 } } %21, 0
  %24 = extractvalue { ptr, i32, i32, i32 } %23, 1
  %25 = extractvalue { ptr, i32, i32, i32 } %23, 2
  %26 = sub i32 %25, %24
  %27 = icmp uge i32 %26, 1
  br i1 %27, label %28, label %47

28:                                               ; preds = %5
  %29 = extractvalue { ptr, i32, i32, i32 } %23, 0
  %30 = load ptr, ptr %29, align 8
  %31 = zext i32 %24 to i64
  %32 = mul i64 %31, 24
  %33 = getelementptr inbounds i8, ptr %30, i64 %32
  %34 = add i32 %24, 1
  %35 = insertvalue { ptr, i32, i32, i32 } %23, i32 %34, 1
  %36 = call ptr @realloc(ptr null, i64 24)
  %37 = load { ptr, i32, i32, i32 }, ptr %33, align 8
  %38 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %37)
  %39 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %38, 0
  %40 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %38, 1
  store { ptr, i32, i32, i32 } %39, ptr %33, align 8
  store { ptr, i32, i32, i32 } %40, ptr %36, align 8
  %41 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %42 = call ptr %41()
  %43 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %44 = load { ptr, i32, i32, i32 }, ptr %36, align 8
  call void @free(ptr %36)
  %45 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %44, 1
  store { i1, { ptr, i32, i32, i32 } } %45, ptr %20, align 8
  %46 = load { i64, [24 x i8] }, ptr %20, align 8
  br label %53

47:                                               ; preds = %5
  %48 = phi i64 [ %1, %5 ]
  %49 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %50 = call ptr %49()
  %51 = call i64 @llvm.uadd.sat.i64(i64 %48, i64 0)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %6, align 1
  %52 = load { i64, [24 x i8] }, ptr %6, align 8
  br label %53

53:                                               ; preds = %28, %47
  %54 = phi i64 [ %0, %47 ], [ %0, %28 ]
  %55 = phi i64 [ %2, %47 ], [ %2, %28 ]
  %56 = phi ptr [ %3, %47 ], [ %3, %28 ]
  %57 = phi { { {} }, i252 } [ %22, %47 ], [ %22, %28 ]
  %58 = phi i64 [ %51, %47 ], [ %43, %28 ]
  %59 = phi { ptr, i32, i32, i32 } [ %23, %47 ], [ %35, %28 ]
  %60 = phi { i64, [24 x i8] } [ %52, %47 ], [ %46, %28 ]
  store { i64, [24 x i8] } %60, ptr %7, align 8
  %61 = load i1, ptr %7, align 1
  switch i1 %61, label %62 [
    i1 false, label %64
    i1 true, label %74
  ]

62:                                               ; preds = %53
  br i1 false, label %63, label %177

63:                                               ; preds = %62
  unreachable

64:                                               ; preds = %53
  %65 = load { i1, { ptr, i32, i32, i32 } }, ptr %7, align 8
  %66 = extractvalue { i1, { ptr, i32, i32, i32 } } %65, 1
  %67 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %66)
  %68 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %67, 0
  %69 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %67, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %68)
  %70 = extractvalue { ptr, i32, i32, i32 } %69, 1
  %71 = extractvalue { ptr, i32, i32, i32 } %69, 2
  %72 = sub i32 %71, %70
  %73 = icmp uge i32 %72, 1
  br i1 %73, label %96, label %164

74:                                               ; preds = %53
  %75 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %76 = call ptr %75()
  %77 = getelementptr inbounds i64, ptr %76, i32 1
  %78 = load i64, ptr %77, align 8
  %79 = load i64, ptr %76, align 8
  %80 = mul i64 %79, 12120
  %81 = add i64 %78, %80
  %82 = call i64 @llvm.uadd.sat.i64(i64 %58, i64 %81)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %8, align 1
  %83 = load { i128, [32 x i8] }, ptr %8, align 16
  %84 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %59, 0
  %85 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } undef, { { ptr, i32, i32, i32 } } %84, 0
  %86 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %85, { { {} }, i252 } %57, 1
  %87 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %86, 0
  %88 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %87, { i128, [32 x i8] } %83, 1
  %89 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } undef }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %88, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %89, ptr %9, align 16
  %90 = load { i128, [112 x i8] }, ptr %9, align 16
  %91 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } undef, i64 %54, 0
  %92 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %91, i64 %82, 1
  %93 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %92, i64 %55, 2
  %94 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %93, ptr %56, 3
  %95 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %94, { i128, [112 x i8] } %90, 4
  ret { i64, i64, i64, ptr, { i128, [112 x i8] } } %95

96:                                               ; preds = %64
  %97 = extractvalue { ptr, i32, i32, i32 } %69, 0
  %98 = load ptr, ptr %97, align 8
  %99 = zext i32 %70 to i64
  %100 = mul i64 %99, 32
  %101 = getelementptr inbounds i8, ptr %98, i64 %100
  %102 = add i32 %70, 1
  %103 = insertvalue { ptr, i32, i32, i32 } %69, i32 %102, 1
  %104 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %104, ptr %101, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %103)
  %105 = extractvalue { { {} }, i252 } %57, 1
  %106 = load i252, ptr %104, align 16
  call void @free(ptr %104)
  %107 = zext i252 %105 to i256
  %108 = zext i252 %106 to i256
  %109 = add i256 %107, %108
  %110 = sub i256 %109, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %111 = icmp uge i256 %109, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %112 = select i1 %111, i256 %110, i256 %109
  %113 = trunc i256 %112 to i252
  %114 = add i64 %55, 3
  %115 = zext i252 %113 to i256
  store i256 1436209994116032968217460821259974301319484759399248048177294919499399378304, ptr %11, align 16
  store i256 %115, ptr %12, align 16
  %116 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %116(ptr %13, ptr %11, ptr %12)
  %117 = load i256, ptr %13, align 16
  %118 = trunc i256 %117 to i252
  %119 = add i64 %54, 3
  %120 = sub i252 %118, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %121 = icmp ult i252 %118, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %122 = select i1 %121, i252 %118, i252 %120
  %123 = load ptr, ptr %56, align 8
  store i64 %58, ptr %15, align 8
  store i252 %122, ptr %16, align 16
  %124 = getelementptr inbounds ptr, ptr %56, i32 8
  %125 = load ptr, ptr %124, align 8
  call void %125(ptr %14, ptr %123, ptr %15, i32 0, ptr %16)
  %126 = load { i1, [47 x i8] }, ptr %14, align 1
  %127 = extractvalue { i1, [47 x i8] } %126, 0
  %128 = getelementptr inbounds i8, ptr %14, i32 16
  %129 = load i252, ptr %128, align 16
  %130 = getelementptr inbounds i8, ptr %14, i32 8
  %131 = load { ptr, i32, i32, i32 }, ptr %130, align 8
  %132 = load i64, ptr %15, align 8
  br i1 %127, label %154, label %133

133:                                              ; preds = %96
  %134 = phi i64 [ %132, %96 ]
  %135 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %136 = call ptr %135()
  %137 = load i64, ptr %136, align 8
  %138 = mul i64 %137, 10
  %139 = call i64 @llvm.uadd.sat.i64(i64 %134, i64 %138)
  %140 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %59, 0
  %141 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } undef, { { ptr, i32, i32, i32 } } %140, 0
  %142 = insertvalue { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %141, { { {} }, i252 } %57, 1
  %143 = insertvalue { i1, i252 } { i1 false, i252 undef }, i252 %129, 1
  store { i1, i252 } %143, ptr %18, align 16
  %144 = load { i128, [32 x i8] }, ptr %18, align 16
  %145 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } undef, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %142, 0
  %146 = insertvalue { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %145, { i128, [32 x i8] } %144, 1
  %147 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } { i1 false, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } undef }, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } %146, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, { { {} }, i252 } }, { i128, [32 x i8] } } } %147, ptr %19, align 16
  %148 = load { i128, [112 x i8] }, ptr %19, align 16
  %149 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } undef, i64 %119, 0
  %150 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %149, i64 %139, 1
  %151 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %150, i64 %114, 2
  %152 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %151, ptr %56, 3
  %153 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %152, { i128, [112 x i8] } %148, 4
  ret { i64, i64, i64, ptr, { i128, [112 x i8] } } %153

154:                                              ; preds = %96
  %155 = phi { ptr, i32, i32, i32 } [ %59, %96 ]
  call void @"drop$284"({ ptr, i32, i32, i32 } %155)
  %156 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %131, 1
  %157 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %156, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %157, ptr %17, align 8
  %158 = load { i128, [112 x i8] }, ptr %17, align 16
  %159 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } undef, i64 %119, 0
  %160 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %159, i64 %132, 1
  %161 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %160, i64 %114, 2
  %162 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %161, ptr %56, 3
  %163 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %162, { i128, [112 x i8] } %158, 4
  ret { i64, i64, i64, ptr, { i128, [112 x i8] } } %163

164:                                              ; preds = %64
  %165 = phi { ptr, i32, i32, i32 } [ %69, %64 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %165)
  call void @"drop$284"({ ptr, i32, i32, i32 } %59)
  %166 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f100"()
  %167 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %166, 0
  %168 = extractvalue { {}, { ptr, i32, i32, i32 } } %167, 1
  %169 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %168, 1
  %170 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %169, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %170, ptr %10, align 8
  %171 = load { i128, [112 x i8] }, ptr %10, align 16
  %172 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } undef, i64 %54, 0
  %173 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %172, i64 %58, 1
  %174 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %173, i64 %55, 2
  %175 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %174, ptr %56, 3
  %176 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %175, { i128, [112 x i8] } %171, 4
  ret { i64, i64, i64, ptr, { i128, [112 x i8] } } %176

177:                                              ; preds = %62
  call void @puts(ptr @assert_msg_141)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i128, [112 x i8] } } @f76(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i128, [112 x i8] } } @"impl$f76"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i128, [112 x i8] } } %15, { i128, [112 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i128, [112 x i8] } } %16
}

define void @_mlir_ciface_f76(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %5) {
  %7 = call { i64, i64, i64, ptr, { i128, [112 x i8] } } @f76(i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, { { {} }, i252 } } %5)
  store { i64, i64, i64, ptr, { i128, [112 x i8] } } %7, ptr %0, align 16
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 29721761890975875353235833581453094220424382983267374)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f77() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f77(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f77()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$212"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %3 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

5:                                                ; preds = %1
  br label %15

6:                                                ; preds = %1
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 1
  br i1 %10, label %11, label %13

11:                                               ; preds = %6
  %12 = sub i32 %9, 1
  store i32 %12, ptr %8, align 4
  br label %14

13:                                               ; preds = %6
  call void @free(ptr %8)
  call void @free(ptr %2)
  br label %14

14:                                               ; preds = %11, %13
  br label %15

15:                                               ; preds = %5, %14
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %0) {
  %2 = extractvalue { ptr, i32, i32, i32 } %0, 3
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

4:                                                ; preds = %1
  br label %11

5:                                                ; preds = %1
  %6 = extractvalue { ptr, i32, i32, i32 } %0, 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds i8, ptr %7, i32 -8
  %9 = load i32, ptr %8, align 4
  %10 = add i32 %9, 1
  store i32 %10, ptr %8, align 4
  br label %11

11:                                               ; preds = %4, %5
  %12 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %0, 0
  %13 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12, { ptr, i32, i32, i32 } %0, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13
}

define private void @"drop$219"({ { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } @"dup$219"({ { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0, { i128, i128 } %2, 0
  %4 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } undef, { i128, i128 } %2, 0
  %5 = extractvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0, 1
  %6 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %5)
  %7 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 0
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6, 1
  %9 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %3, { ptr, i32, i32, i32 } %7, 1
  %10 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %4, { ptr, i32, i32, i32 } %8, 1
  %11 = extractvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %0, 2
  %12 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %9, {} %11, 2
  %13 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %10, {} %11, 2
  %14 = insertvalue { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } undef, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %12, 0
  %15 = insertvalue { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %14, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %13, 1
  ret { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %15
}

define private void @"drop$220"({ i128, [64 x i8] } %0) {
  %2 = alloca { i128, [64 x i8] }, i64 1, align 16
  store { i128, [64 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$219"({ { i128, i128 }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [64 x i8] }, { i128, [64 x i8] } } @"dup$220"({ i128, [64 x i8] } %0) {
  %2 = alloca { i128, [64 x i8] }, i64 1, align 16
  store { i128, [64 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } @"dup$219"({ { i128, i128 }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { i128, i128 }, { ptr, i32, i32, i32 }, {} }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %5, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 16
  %11 = load { i128, [64 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %5, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 16
  %13 = load { i128, [64 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } undef, { i128, [64 x i8] } %11, 0
  %15 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } %14, { i128, [64 x i8] } %13, 1
  ret { { i128, [64 x i8] }, { i128, [64 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [64 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [64 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } undef, { i128, [64 x i8] } %23, 0
  %27 = insertvalue { { i128, [64 x i8] }, { i128, [64 x i8] } } %26, { i128, [64 x i8] } %25, 1
  ret { { i128, [64 x i8] }, { i128, [64 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$213"({ ptr, i32, i32, i32 } %0) {
  call void @"drop$212"({ ptr, i32, i32, i32 } %0)
  ret void
}

define private { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$213"({ ptr, i32, i32, i32 } %0) {
  %2 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %0)
  %3 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 0
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2, 1
  %5 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3, 0
  %6 = insertvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %4, 1
  ret { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %6
}

define private void @"drop$214"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  call void @"drop$213"({ ptr, i32, i32, i32 } %2)
  ret void
}

define private { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$214"({ { ptr, i32, i32, i32 } } %0) {
  %2 = extractvalue { { ptr, i32, i32, i32 } } %0, 0
  %3 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$213"({ ptr, i32, i32, i32 } %2)
  %4 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 0
  %5 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3, 1
  %6 = insertvalue { { ptr, i32, i32, i32 } } %0, { ptr, i32, i32, i32 } %4, 0
  %7 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %6, 0
  %9 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8, { { ptr, i32, i32, i32 } } %7, 1
  ret { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9
}

define private void @"drop$215"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 0
  call void @"drop$214"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } @"dup$215"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$214"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 1
  %9 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %8)
  %10 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 0
  %11 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6, { { ptr, i32, i32, i32 }, i252, i32 } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %7, { { ptr, i32, i32, i32 }, i252, i32 } %11, 1
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %0, 2
  %15 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } undef, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %15, 0
  %18 = insertvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %17, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %16, 1
  ret { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %18
}

define private void @"drop$216"({ i128, [112 x i8] } %0) {
  %2 = alloca { i128, [112 x i8] }, i64 1, align 16
  store { i128, [112 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, 1
  call void @"drop$215"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [112 x i8] }, { i128, [112 x i8] } } @"dup$216"({ i128, [112 x i8] } %0) {
  %2 = alloca { i128, [112 x i8] }, i64 1, align 16
  store { i128, [112 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } @"dup$215"({ { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %10, ptr %2, align 16
  %11 = load { i128, [112 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %12, ptr %2, align 16
  %13 = load { i128, [112 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } undef, { i128, [112 x i8] } %11, 0
  %15 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } %14, { i128, [112 x i8] } %13, 1
  ret { { i128, [112 x i8] }, { i128, [112 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [112 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [112 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } undef, { i128, [112 x i8] } %23, 0
  %27 = insertvalue { { i128, [112 x i8] }, { i128, [112 x i8] } } %26, { i128, [112 x i8] } %25, 1
  ret { { i128, [112 x i8] }, { i128, [112 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [80 x i8] } } @"impl$f78"(i64 %0, i64 %1, { i128, i128 } %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { i128, i128 } %4) {
  %6 = alloca { i128, [80 x i8] }, i64 1, align 16
  %7 = alloca { i128, [80 x i8] }, i64 1, align 16
  %8 = alloca { i128, [64 x i8] }, i64 1, align 16
  %9 = alloca { i128, [80 x i8] }, i64 1, align 16
  %10 = alloca { i128, [112 x i8] }, i64 1, align 16
  %11 = alloca { i128, [80 x i8] }, i64 1, align 16
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i128, [64 x i8] }, i64 1, align 16
  %14 = alloca { i128, [80 x i8] }, i64 1, align 16
  %15 = alloca { i128, [80 x i8] }, i64 1, align 16
  %16 = extractvalue { i128, i128 } %4, 0
  %17 = extractvalue { i128, i128 } %4, 1
  %18 = icmp eq i128 %17, 0
  br i1 %18, label %19, label %152

19:                                               ; preds = %5
  %20 = phi i64 [ %0, %5 ]
  %21 = phi i128 [ %16, %5 ]
  %22 = icmp ult i128 %21, 256
  %23 = add i64 %20, 1
  %24 = trunc i128 %21 to i8
  br i1 %22, label %25, label %145

25:                                               ; preds = %19
  %26 = phi i8 [ %24, %19 ]
  %27 = add i64 %20, 2
  %28 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 1, i8 %26)
  %29 = extractvalue { i8, i1 } %28, 1
  br i1 %29, label %39, label %30

30:                                               ; preds = %25
  %31 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %3, %25 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %31)
  %32 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f102"()
  %33 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %32, 0
  %34 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %33, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %34, ptr %15, align 8
  %35 = load { i128, [80 x i8] }, ptr %15, align 16
  %36 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %27, 0
  %37 = insertvalue { i64, i64, { i128, [80 x i8] } } %36, i64 %1, 1
  %38 = insertvalue { i64, i64, { i128, [80 x i8] } } %37, { i128, [80 x i8] } %35, 2
  ret { i64, i64, { i128, [80 x i8] } } %38

39:                                               ; preds = %25
  %40 = phi i8 [ %26, %25 ]
  %41 = add i64 %20, 3
  %42 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 36, i8 %40)
  %43 = extractvalue { i8, i1 } %42, 1
  br i1 %43, label %136, label %44

44:                                               ; preds = %39
  %45 = add i64 %20, 4
  %46 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 10, i8 %40)
  %47 = extractvalue { i8, i1 } %46, 1
  br i1 %47, label %74, label %48

48:                                               ; preds = %44
  %49 = phi i64 [ %45, %44 ]
  %50 = call fastcc { i64, i64, { i128, [64 x i8] } } @"impl$f103"(i64 %49, i64 %1, { i128, i128 } %2, { i128, i128 } %4, { ptr, i32, i32, i32 } zeroinitializer)
  %51 = extractvalue { i64, i64, { i128, [64 x i8] } } %50, 0
  %52 = extractvalue { i64, i64, { i128, [64 x i8] } } %50, 1
  %53 = extractvalue { i64, i64, { i128, [64 x i8] } } %50, 2
  store { i128, [64 x i8] } %53, ptr %13, align 16
  %54 = load i1, ptr %13, align 1
  switch i1 %54, label %55 [
    i1 false, label %57
    i1 true, label %66
  ]

55:                                               ; preds = %48
  br i1 false, label %56, label %171

56:                                               ; preds = %55
  unreachable

57:                                               ; preds = %48
  %58 = load { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } }, ptr %13, align 16
  %59 = extractvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %58, 1
  %60 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %61 = call ptr %60()
  %62 = load i64, ptr %61, align 8
  %63 = mul i64 %62, 100
  %64 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 %63)
  %65 = extractvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %59, 1
  br label %98

66:                                               ; preds = %48
  %67 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %68 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %67, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %3)
  %69 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %68, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %69, ptr %14, align 8
  %70 = load { i128, [80 x i8] }, ptr %14, align 16
  %71 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %51, 0
  %72 = insertvalue { i64, i64, { i128, [80 x i8] } } %71, i64 %52, 1
  %73 = insertvalue { i64, i64, { i128, [80 x i8] } } %72, { i128, [80 x i8] } %70, 2
  ret { i64, i64, { i128, [80 x i8] } } %73

74:                                               ; preds = %44
  %75 = phi i64 [ %45, %44 ]
  %76 = call fastcc { i64, i64, { i128, [64 x i8] } } @"impl$f104"(i64 %75, i64 %1, { i128, i128 } %2, { i128, i128 } %4, { ptr, i32, i32, i32 } zeroinitializer)
  %77 = extractvalue { i64, i64, { i128, [64 x i8] } } %76, 0
  %78 = extractvalue { i64, i64, { i128, [64 x i8] } } %76, 1
  %79 = extractvalue { i64, i64, { i128, [64 x i8] } } %76, 2
  store { i128, [64 x i8] } %79, ptr %8, align 16
  %80 = load i1, ptr %8, align 1
  switch i1 %80, label %81 [
    i1 false, label %83
    i1 true, label %90
  ]

81:                                               ; preds = %74
  br i1 false, label %82, label %169

82:                                               ; preds = %81
  unreachable

83:                                               ; preds = %74
  %84 = load { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } }, ptr %8, align 16
  %85 = extractvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %84, 1
  %86 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %87 = call ptr %86()
  %88 = call i64 @llvm.uadd.sat.i64(i64 %78, i64 0)
  %89 = extractvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %85, 1
  br label %98

90:                                               ; preds = %74
  %91 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %92 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %91, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %3)
  %93 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %92, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %93, ptr %9, align 8
  %94 = load { i128, [80 x i8] }, ptr %9, align 16
  %95 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %77, 0
  %96 = insertvalue { i64, i64, { i128, [80 x i8] } } %95, i64 %78, 1
  %97 = insertvalue { i64, i64, { i128, [80 x i8] } } %96, { i128, [80 x i8] } %94, 2
  ret { i64, i64, { i128, [80 x i8] } } %97

98:                                               ; preds = %83, %57
  %99 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %3, %83 ], [ %3, %57 ]
  %100 = phi i64 [ %77, %83 ], [ %51, %57 ]
  %101 = phi i64 [ %88, %83 ], [ %64, %57 ]
  %102 = phi { ptr, i32, i32, i32 } [ %89, %83 ], [ %65, %57 ]
  %103 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$212"({ ptr, i32, i32, i32 } %102)
  %104 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 0
  %105 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 1
  call void @"drop$212"({ ptr, i32, i32, i32 } %104)
  %106 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %105, 0
  %107 = call fastcc { i64, i64, { i128, [112 x i8] } } @"impl$f105"(i64 %100, i64 %101, { { ptr, i32, i32, i32 } } %106, { { ptr, i32, i32, i32 }, i252, i32 } %99)
  %108 = extractvalue { i64, i64, { i128, [112 x i8] } } %107, 0
  %109 = extractvalue { i64, i64, { i128, [112 x i8] } } %107, 1
  %110 = extractvalue { i64, i64, { i128, [112 x i8] } } %107, 2
  store { i128, [112 x i8] } %110, ptr %10, align 16
  %111 = load i1, ptr %10, align 1
  switch i1 %111, label %112 [
    i1 false, label %114
    i1 true, label %128
  ]

112:                                              ; preds = %98
  br i1 false, label %113, label %170

113:                                              ; preds = %112
  unreachable

114:                                              ; preds = %98
  %115 = load { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } }, ptr %10, align 16
  %116 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %115, 1
  %117 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %118 = call ptr %117()
  %119 = call i64 @llvm.uadd.sat.i64(i64 %109, i64 0)
  %120 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %116, 0
  %121 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %116, 1
  call void @"drop$214"({ { ptr, i32, i32, i32 } } %120)
  %122 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 }, i252, i32 } %121, 0
  %123 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } %122, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %123, ptr %12, align 16
  %124 = load { i128, [80 x i8] }, ptr %12, align 16
  %125 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %108, 0
  %126 = insertvalue { i64, i64, { i128, [80 x i8] } } %125, i64 %119, 1
  %127 = insertvalue { i64, i64, { i128, [80 x i8] } } %126, { i128, [80 x i8] } %124, 2
  ret { i64, i64, { i128, [80 x i8] } } %127

128:                                              ; preds = %98
  %129 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %10, align 8
  %130 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %129, 1
  %131 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %130, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %131, ptr %11, align 8
  %132 = load { i128, [80 x i8] }, ptr %11, align 16
  %133 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %108, 0
  %134 = insertvalue { i64, i64, { i128, [80 x i8] } } %133, i64 %109, 1
  %135 = insertvalue { i64, i64, { i128, [80 x i8] } } %134, { i128, [80 x i8] } %132, 2
  ret { i64, i64, { i128, [80 x i8] } } %135

136:                                              ; preds = %39
  %137 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %3, %39 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %137)
  %138 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f106"()
  %139 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %138, 0
  %140 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %139, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %140, ptr %7, align 8
  %141 = load { i128, [80 x i8] }, ptr %7, align 16
  %142 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %41, 0
  %143 = insertvalue { i64, i64, { i128, [80 x i8] } } %142, i64 %1, 1
  %144 = insertvalue { i64, i64, { i128, [80 x i8] } } %143, { i128, [80 x i8] } %141, 2
  ret { i64, i64, { i128, [80 x i8] } } %144

145:                                              ; preds = %19
  %146 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %3, %19 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %146)
  %147 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %148 = call ptr %147()
  %149 = load i64, ptr %148, align 8
  %150 = mul i64 %149, 7150
  %151 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %150)
  br label %159

152:                                              ; preds = %5
  %153 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %3, %5 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %153)
  %154 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %155 = call ptr %154()
  %156 = load i64, ptr %155, align 8
  %157 = mul i64 %156, 7720
  %158 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %157)
  br label %159

159:                                              ; preds = %145, %152
  %160 = phi i64 [ %0, %152 ], [ %23, %145 ]
  %161 = phi i64 [ %158, %152 ], [ %151, %145 ]
  %162 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %163 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %162, 0
  %164 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %163, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %164, ptr %6, align 8
  %165 = load { i128, [80 x i8] }, ptr %6, align 16
  %166 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %160, 0
  %167 = insertvalue { i64, i64, { i128, [80 x i8] } } %166, i64 %161, 1
  %168 = insertvalue { i64, i64, { i128, [80 x i8] } } %167, { i128, [80 x i8] } %165, 2
  ret { i64, i64, { i128, [80 x i8] } } %168

169:                                              ; preds = %81
  call void @puts(ptr @assert_msg_142)
  call void @abort()
  unreachable

170:                                              ; preds = %112
  call void @puts(ptr @assert_msg_143)
  call void @abort()
  unreachable

171:                                              ; preds = %55
  call void @puts(ptr @assert_msg_144)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [80 x i8] } } @f78(i64 %0, i64 %1, { i128, i128 } %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { i128, i128 } %4) {
  %6 = call fastcc { i64, i64, { i128, [80 x i8] } } @"impl$f78"(i64 %0, i64 %1, { i128, i128 } %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { i128, i128 } %4)
  %7 = extractvalue { i64, i64, { i128, [80 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i128, [80 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i128, [80 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i128, [80 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i128, [80 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i128, [80 x i8] } } %11, { i128, [80 x i8] } %9, 2
  ret { i64, i64, { i128, [80 x i8] } } %12
}

define void @_mlir_ciface_f78(ptr %0, i64 %1, i64 %2, { i128, i128 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i128, i128 } %5) {
  %7 = call { i64, i64, { i128, [80 x i8] } } @f78(i64 %1, i64 %2, { i128, i128 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i128, i128 } %5)
  store { i64, i64, { i128, [80 x i8] } } %7, ptr %0, align 16
  ret void
}

define private fastcc { i64, { i128, [16 x i8] } } @"impl$f79"(i64 %0, i32 %1) {
  %3 = alloca { i128, [16 x i8] }, i64 1, align 16
  %4 = alloca { i128, [16 x i8] }, i64 1, align 16
  %5 = alloca { i128, [16 x i8] }, i64 1, align 16
  %6 = alloca { i128, [16 x i8] }, i64 1, align 16
  %7 = alloca { i128, [16 x i8] }, i64 1, align 16
  %8 = alloca { i128, [16 x i8] }, i64 1, align 16
  %9 = alloca { i128, [16 x i8] }, i64 1, align 16
  %10 = alloca { i128, [16 x i8] }, i64 1, align 16
  %11 = alloca { i128, [16 x i8] }, i64 1, align 16
  %12 = alloca { i128, [16 x i8] }, i64 1, align 16
  %13 = alloca { i128, [16 x i8] }, i64 1, align 16
  %14 = alloca { i128, [16 x i8] }, i64 1, align 16
  %15 = alloca { i128, [16 x i8] }, i64 1, align 16
  %16 = alloca { i128, [16 x i8] }, i64 1, align 16
  %17 = alloca { i128, [16 x i8] }, i64 1, align 16
  %18 = alloca { i128, [16 x i8] }, i64 1, align 16
  %19 = alloca { i128, [16 x i8] }, i64 1, align 16
  %20 = icmp ult i32 %1, 16
  %21 = add i64 %0, 1
  %22 = trunc i32 %1 to i4
  br i1 %20, label %23, label %139

23:                                               ; preds = %2
  %24 = phi i4 [ %22, %2 ]
  switch i4 %24, label %25 [
    i4 0, label %27
    i4 1, label %34
    i4 2, label %41
    i4 3, label %48
    i4 4, label %55
    i4 5, label %62
    i4 6, label %69
    i4 7, label %76
    i4 -8, label %83
    i4 -7, label %90
    i4 -6, label %97
    i4 -5, label %104
    i4 -4, label %111
    i4 -3, label %118
    i4 -2, label %125
    i4 -1, label %132
  ]

25:                                               ; preds = %23
  br i1 false, label %26, label %146

26:                                               ; preds = %25
  unreachable

27:                                               ; preds = %23
  %28 = phi i128 [ 1, %23 ]
  %29 = insertvalue { i128 } undef, i128 %28, 0
  %30 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %29, 1
  store { i1, { i128 } } %30, ptr %19, align 16
  %31 = load { i128, [16 x i8] }, ptr %19, align 16
  %32 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %33 = insertvalue { i64, { i128, [16 x i8] } } %32, { i128, [16 x i8] } %31, 1
  ret { i64, { i128, [16 x i8] } } %33

34:                                               ; preds = %23
  %35 = phi i128 [ 256, %23 ]
  %36 = insertvalue { i128 } undef, i128 %35, 0
  %37 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %36, 1
  store { i1, { i128 } } %37, ptr %18, align 16
  %38 = load { i128, [16 x i8] }, ptr %18, align 16
  %39 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %40 = insertvalue { i64, { i128, [16 x i8] } } %39, { i128, [16 x i8] } %38, 1
  ret { i64, { i128, [16 x i8] } } %40

41:                                               ; preds = %23
  %42 = phi i128 [ 65536, %23 ]
  %43 = insertvalue { i128 } undef, i128 %42, 0
  %44 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %43, 1
  store { i1, { i128 } } %44, ptr %17, align 16
  %45 = load { i128, [16 x i8] }, ptr %17, align 16
  %46 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %47 = insertvalue { i64, { i128, [16 x i8] } } %46, { i128, [16 x i8] } %45, 1
  ret { i64, { i128, [16 x i8] } } %47

48:                                               ; preds = %23
  %49 = phi i128 [ 16777216, %23 ]
  %50 = insertvalue { i128 } undef, i128 %49, 0
  %51 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %50, 1
  store { i1, { i128 } } %51, ptr %16, align 16
  %52 = load { i128, [16 x i8] }, ptr %16, align 16
  %53 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %54 = insertvalue { i64, { i128, [16 x i8] } } %53, { i128, [16 x i8] } %52, 1
  ret { i64, { i128, [16 x i8] } } %54

55:                                               ; preds = %23
  %56 = phi i128 [ 4294967296, %23 ]
  %57 = insertvalue { i128 } undef, i128 %56, 0
  %58 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %57, 1
  store { i1, { i128 } } %58, ptr %15, align 16
  %59 = load { i128, [16 x i8] }, ptr %15, align 16
  %60 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %61 = insertvalue { i64, { i128, [16 x i8] } } %60, { i128, [16 x i8] } %59, 1
  ret { i64, { i128, [16 x i8] } } %61

62:                                               ; preds = %23
  %63 = phi i128 [ 1099511627776, %23 ]
  %64 = insertvalue { i128 } undef, i128 %63, 0
  %65 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %64, 1
  store { i1, { i128 } } %65, ptr %14, align 16
  %66 = load { i128, [16 x i8] }, ptr %14, align 16
  %67 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %68 = insertvalue { i64, { i128, [16 x i8] } } %67, { i128, [16 x i8] } %66, 1
  ret { i64, { i128, [16 x i8] } } %68

69:                                               ; preds = %23
  %70 = phi i128 [ 281474976710656, %23 ]
  %71 = insertvalue { i128 } undef, i128 %70, 0
  %72 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %71, 1
  store { i1, { i128 } } %72, ptr %13, align 16
  %73 = load { i128, [16 x i8] }, ptr %13, align 16
  %74 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %75 = insertvalue { i64, { i128, [16 x i8] } } %74, { i128, [16 x i8] } %73, 1
  ret { i64, { i128, [16 x i8] } } %75

76:                                               ; preds = %23
  %77 = phi i128 [ 72057594037927936, %23 ]
  %78 = insertvalue { i128 } undef, i128 %77, 0
  %79 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %78, 1
  store { i1, { i128 } } %79, ptr %12, align 16
  %80 = load { i128, [16 x i8] }, ptr %12, align 16
  %81 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %82 = insertvalue { i64, { i128, [16 x i8] } } %81, { i128, [16 x i8] } %80, 1
  ret { i64, { i128, [16 x i8] } } %82

83:                                               ; preds = %23
  %84 = phi i128 [ 18446744073709551616, %23 ]
  %85 = insertvalue { i128 } undef, i128 %84, 0
  %86 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %85, 1
  store { i1, { i128 } } %86, ptr %11, align 16
  %87 = load { i128, [16 x i8] }, ptr %11, align 16
  %88 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %89 = insertvalue { i64, { i128, [16 x i8] } } %88, { i128, [16 x i8] } %87, 1
  ret { i64, { i128, [16 x i8] } } %89

90:                                               ; preds = %23
  %91 = phi i128 [ 4722366482869645213696, %23 ]
  %92 = insertvalue { i128 } undef, i128 %91, 0
  %93 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %92, 1
  store { i1, { i128 } } %93, ptr %10, align 16
  %94 = load { i128, [16 x i8] }, ptr %10, align 16
  %95 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %96 = insertvalue { i64, { i128, [16 x i8] } } %95, { i128, [16 x i8] } %94, 1
  ret { i64, { i128, [16 x i8] } } %96

97:                                               ; preds = %23
  %98 = phi i128 [ 1208925819614629174706176, %23 ]
  %99 = insertvalue { i128 } undef, i128 %98, 0
  %100 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %99, 1
  store { i1, { i128 } } %100, ptr %9, align 16
  %101 = load { i128, [16 x i8] }, ptr %9, align 16
  %102 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %103 = insertvalue { i64, { i128, [16 x i8] } } %102, { i128, [16 x i8] } %101, 1
  ret { i64, { i128, [16 x i8] } } %103

104:                                              ; preds = %23
  %105 = phi i128 [ 309485009821345068724781056, %23 ]
  %106 = insertvalue { i128 } undef, i128 %105, 0
  %107 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %106, 1
  store { i1, { i128 } } %107, ptr %8, align 16
  %108 = load { i128, [16 x i8] }, ptr %8, align 16
  %109 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %110 = insertvalue { i64, { i128, [16 x i8] } } %109, { i128, [16 x i8] } %108, 1
  ret { i64, { i128, [16 x i8] } } %110

111:                                              ; preds = %23
  %112 = phi i128 [ 79228162514264337593543950336, %23 ]
  %113 = insertvalue { i128 } undef, i128 %112, 0
  %114 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %113, 1
  store { i1, { i128 } } %114, ptr %7, align 16
  %115 = load { i128, [16 x i8] }, ptr %7, align 16
  %116 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %117 = insertvalue { i64, { i128, [16 x i8] } } %116, { i128, [16 x i8] } %115, 1
  ret { i64, { i128, [16 x i8] } } %117

118:                                              ; preds = %23
  %119 = phi i128 [ 20282409603651670423947251286016, %23 ]
  %120 = insertvalue { i128 } undef, i128 %119, 0
  %121 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %120, 1
  store { i1, { i128 } } %121, ptr %6, align 16
  %122 = load { i128, [16 x i8] }, ptr %6, align 16
  %123 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %124 = insertvalue { i64, { i128, [16 x i8] } } %123, { i128, [16 x i8] } %122, 1
  ret { i64, { i128, [16 x i8] } } %124

125:                                              ; preds = %23
  %126 = phi i128 [ 5192296858534827628530496329220096, %23 ]
  %127 = insertvalue { i128 } undef, i128 %126, 0
  %128 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %127, 1
  store { i1, { i128 } } %128, ptr %5, align 16
  %129 = load { i128, [16 x i8] }, ptr %5, align 16
  %130 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %131 = insertvalue { i64, { i128, [16 x i8] } } %130, { i128, [16 x i8] } %129, 1
  ret { i64, { i128, [16 x i8] } } %131

132:                                              ; preds = %23
  %133 = phi i128 [ 1329227995784915872903807060280344576, %23 ]
  %134 = insertvalue { i128 } undef, i128 %133, 0
  %135 = insertvalue { i1, { i128 } } { i1 false, { i128 } undef }, { i128 } %134, 1
  store { i1, { i128 } } %135, ptr %4, align 16
  %136 = load { i128, [16 x i8] }, ptr %4, align 16
  %137 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %138 = insertvalue { i64, { i128, [16 x i8] } } %137, { i128, [16 x i8] } %136, 1
  ret { i64, { i128, [16 x i8] } } %138

139:                                              ; preds = %2
  %140 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f107"()
  %141 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %140, 0
  %142 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %141, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %142, ptr %3, align 8
  %143 = load { i128, [16 x i8] }, ptr %3, align 16
  %144 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %21, 0
  %145 = insertvalue { i64, { i128, [16 x i8] } } %144, { i128, [16 x i8] } %143, 1
  ret { i64, { i128, [16 x i8] } } %145

146:                                              ; preds = %25
  call void @puts(ptr @assert_msg_145)
  call void @abort()
  unreachable
}

define private { i64, { i128, [16 x i8] } } @f79(i64 %0, i32 %1) {
  %3 = call fastcc { i64, { i128, [16 x i8] } } @"impl$f79"(i64 %0, i32 %1)
  %4 = extractvalue { i64, { i128, [16 x i8] } } %3, 0
  %5 = extractvalue { i64, { i128, [16 x i8] } } %3, 1
  %6 = insertvalue { i64, { i128, [16 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i128, [16 x i8] } } %6, { i128, [16 x i8] } %5, 1
  ret { i64, { i128, [16 x i8] } } %7
}

define void @_mlir_ciface_f79(ptr %0, i64 %1, i32 %2) {
  %4 = call { i64, { i128, [16 x i8] } } @f79(i64 %1, i32 %2)
  store { i64, { i128, [16 x i8] } } %4, ptr %0, align 16
  ret void
}

define private fastcc { i64, { i128, [48 x i8] } } @"impl$f80"(i64 %0, i32 %1) {
  %3 = alloca { i128, [48 x i8] }, i64 1, align 16
  %4 = alloca { i128, [48 x i8] }, i64 1, align 16
  %5 = alloca { i128, [48 x i8] }, i64 1, align 16
  %6 = alloca { i128, [48 x i8] }, i64 1, align 16
  %7 = alloca { i128, [48 x i8] }, i64 1, align 16
  %8 = alloca { i128, [48 x i8] }, i64 1, align 16
  %9 = alloca { i128, [48 x i8] }, i64 1, align 16
  %10 = alloca { i128, [48 x i8] }, i64 1, align 16
  %11 = alloca { i128, [48 x i8] }, i64 1, align 16
  %12 = alloca { i128, [48 x i8] }, i64 1, align 16
  %13 = alloca { i128, [48 x i8] }, i64 1, align 16
  %14 = alloca { i128, [48 x i8] }, i64 1, align 16
  %15 = alloca { i128, [48 x i8] }, i64 1, align 16
  %16 = alloca { i128, [48 x i8] }, i64 1, align 16
  %17 = alloca { i128, [48 x i8] }, i64 1, align 16
  %18 = alloca { i128, [48 x i8] }, i64 1, align 16
  %19 = alloca { i128, [48 x i8] }, i64 1, align 16
  %20 = alloca { i128, [48 x i8] }, i64 1, align 16
  %21 = alloca { i128, [48 x i8] }, i64 1, align 16
  %22 = alloca { i128, [48 x i8] }, i64 1, align 16
  %23 = alloca { i128, [48 x i8] }, i64 1, align 16
  %24 = alloca { i128, [48 x i8] }, i64 1, align 16
  %25 = alloca { i128, [48 x i8] }, i64 1, align 16
  %26 = alloca { i128, [48 x i8] }, i64 1, align 16
  %27 = alloca { i128, [48 x i8] }, i64 1, align 16
  %28 = alloca { i128, [48 x i8] }, i64 1, align 16
  %29 = alloca { i128, [48 x i8] }, i64 1, align 16
  %30 = alloca { i128, [48 x i8] }, i64 1, align 16
  %31 = alloca { i128, [48 x i8] }, i64 1, align 16
  %32 = alloca { i128, [48 x i8] }, i64 1, align 16
  %33 = alloca { i128, [48 x i8] }, i64 1, align 16
  %34 = icmp ult i32 %1, 31
  %35 = add i64 %0, 1
  %36 = trunc i32 %1 to i5
  br i1 %34, label %37, label %278

37:                                               ; preds = %2
  %38 = phi i5 [ %36, %2 ]
  switch i5 %38, label %39 [
    i5 0, label %278
    i5 1, label %41
    i5 2, label %50
    i5 3, label %59
    i5 4, label %68
    i5 5, label %77
    i5 6, label %86
    i5 7, label %95
    i5 8, label %104
    i5 9, label %113
    i5 10, label %122
    i5 11, label %131
    i5 12, label %140
    i5 13, label %149
    i5 14, label %158
    i5 15, label %167
    i5 -16, label %176
    i5 -15, label %180
    i5 -14, label %187
    i5 -13, label %194
    i5 -12, label %201
    i5 -11, label %208
    i5 -10, label %215
    i5 -9, label %222
    i5 -8, label %229
    i5 -7, label %236
    i5 -6, label %243
    i5 -5, label %250
    i5 -4, label %257
    i5 -3, label %264
    i5 -2, label %271
  ]

39:                                               ; preds = %37
  br i1 false, label %40, label %283

40:                                               ; preds = %39
  unreachable

41:                                               ; preds = %37
  %42 = phi i128 [ 256, %37 ]
  %43 = phi i252 [ 1329227995784915872903807060280344576, %37 ]
  %44 = insertvalue { i128, i252 } undef, i128 %42, 0
  %45 = insertvalue { i128, i252 } %44, i252 %43, 1
  %46 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %45, 1
  store { i2, { i128, i252 } } %46, ptr %33, align 16
  %47 = load { i128, [48 x i8] }, ptr %33, align 16
  %48 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %49 = insertvalue { i64, { i128, [48 x i8] } } %48, { i128, [48 x i8] } %47, 1
  ret { i64, { i128, [48 x i8] } } %49

50:                                               ; preds = %37
  %51 = phi i128 [ 65536, %37 ]
  %52 = phi i252 [ 5192296858534827628530496329220096, %37 ]
  %53 = insertvalue { i128, i252 } undef, i128 %51, 0
  %54 = insertvalue { i128, i252 } %53, i252 %52, 1
  %55 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %54, 1
  store { i2, { i128, i252 } } %55, ptr %32, align 16
  %56 = load { i128, [48 x i8] }, ptr %32, align 16
  %57 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %58 = insertvalue { i64, { i128, [48 x i8] } } %57, { i128, [48 x i8] } %56, 1
  ret { i64, { i128, [48 x i8] } } %58

59:                                               ; preds = %37
  %60 = phi i128 [ 16777216, %37 ]
  %61 = phi i252 [ 20282409603651670423947251286016, %37 ]
  %62 = insertvalue { i128, i252 } undef, i128 %60, 0
  %63 = insertvalue { i128, i252 } %62, i252 %61, 1
  %64 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %63, 1
  store { i2, { i128, i252 } } %64, ptr %31, align 16
  %65 = load { i128, [48 x i8] }, ptr %31, align 16
  %66 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %67 = insertvalue { i64, { i128, [48 x i8] } } %66, { i128, [48 x i8] } %65, 1
  ret { i64, { i128, [48 x i8] } } %67

68:                                               ; preds = %37
  %69 = phi i128 [ 4294967296, %37 ]
  %70 = phi i252 [ 79228162514264337593543950336, %37 ]
  %71 = insertvalue { i128, i252 } undef, i128 %69, 0
  %72 = insertvalue { i128, i252 } %71, i252 %70, 1
  %73 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %72, 1
  store { i2, { i128, i252 } } %73, ptr %30, align 16
  %74 = load { i128, [48 x i8] }, ptr %30, align 16
  %75 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %76 = insertvalue { i64, { i128, [48 x i8] } } %75, { i128, [48 x i8] } %74, 1
  ret { i64, { i128, [48 x i8] } } %76

77:                                               ; preds = %37
  %78 = phi i128 [ 1099511627776, %37 ]
  %79 = phi i252 [ 309485009821345068724781056, %37 ]
  %80 = insertvalue { i128, i252 } undef, i128 %78, 0
  %81 = insertvalue { i128, i252 } %80, i252 %79, 1
  %82 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %81, 1
  store { i2, { i128, i252 } } %82, ptr %29, align 16
  %83 = load { i128, [48 x i8] }, ptr %29, align 16
  %84 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %85 = insertvalue { i64, { i128, [48 x i8] } } %84, { i128, [48 x i8] } %83, 1
  ret { i64, { i128, [48 x i8] } } %85

86:                                               ; preds = %37
  %87 = phi i128 [ 281474976710656, %37 ]
  %88 = phi i252 [ 1208925819614629174706176, %37 ]
  %89 = insertvalue { i128, i252 } undef, i128 %87, 0
  %90 = insertvalue { i128, i252 } %89, i252 %88, 1
  %91 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %90, 1
  store { i2, { i128, i252 } } %91, ptr %28, align 16
  %92 = load { i128, [48 x i8] }, ptr %28, align 16
  %93 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %94 = insertvalue { i64, { i128, [48 x i8] } } %93, { i128, [48 x i8] } %92, 1
  ret { i64, { i128, [48 x i8] } } %94

95:                                               ; preds = %37
  %96 = phi i128 [ 72057594037927936, %37 ]
  %97 = phi i252 [ 4722366482869645213696, %37 ]
  %98 = insertvalue { i128, i252 } undef, i128 %96, 0
  %99 = insertvalue { i128, i252 } %98, i252 %97, 1
  %100 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %99, 1
  store { i2, { i128, i252 } } %100, ptr %27, align 16
  %101 = load { i128, [48 x i8] }, ptr %27, align 16
  %102 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %103 = insertvalue { i64, { i128, [48 x i8] } } %102, { i128, [48 x i8] } %101, 1
  ret { i64, { i128, [48 x i8] } } %103

104:                                              ; preds = %37
  %105 = phi i128 [ 18446744073709551616, %37 ]
  %106 = phi i252 [ 18446744073709551616, %37 ]
  %107 = insertvalue { i128, i252 } undef, i128 %105, 0
  %108 = insertvalue { i128, i252 } %107, i252 %106, 1
  %109 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %108, 1
  store { i2, { i128, i252 } } %109, ptr %26, align 16
  %110 = load { i128, [48 x i8] }, ptr %26, align 16
  %111 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %112 = insertvalue { i64, { i128, [48 x i8] } } %111, { i128, [48 x i8] } %110, 1
  ret { i64, { i128, [48 x i8] } } %112

113:                                              ; preds = %37
  %114 = phi i128 [ 4722366482869645213696, %37 ]
  %115 = phi i252 [ 72057594037927936, %37 ]
  %116 = insertvalue { i128, i252 } undef, i128 %114, 0
  %117 = insertvalue { i128, i252 } %116, i252 %115, 1
  %118 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %117, 1
  store { i2, { i128, i252 } } %118, ptr %25, align 16
  %119 = load { i128, [48 x i8] }, ptr %25, align 16
  %120 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %121 = insertvalue { i64, { i128, [48 x i8] } } %120, { i128, [48 x i8] } %119, 1
  ret { i64, { i128, [48 x i8] } } %121

122:                                              ; preds = %37
  %123 = phi i128 [ 1208925819614629174706176, %37 ]
  %124 = phi i252 [ 281474976710656, %37 ]
  %125 = insertvalue { i128, i252 } undef, i128 %123, 0
  %126 = insertvalue { i128, i252 } %125, i252 %124, 1
  %127 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %126, 1
  store { i2, { i128, i252 } } %127, ptr %24, align 16
  %128 = load { i128, [48 x i8] }, ptr %24, align 16
  %129 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %130 = insertvalue { i64, { i128, [48 x i8] } } %129, { i128, [48 x i8] } %128, 1
  ret { i64, { i128, [48 x i8] } } %130

131:                                              ; preds = %37
  %132 = phi i128 [ 309485009821345068724781056, %37 ]
  %133 = phi i252 [ 1099511627776, %37 ]
  %134 = insertvalue { i128, i252 } undef, i128 %132, 0
  %135 = insertvalue { i128, i252 } %134, i252 %133, 1
  %136 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %135, 1
  store { i2, { i128, i252 } } %136, ptr %23, align 16
  %137 = load { i128, [48 x i8] }, ptr %23, align 16
  %138 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %139 = insertvalue { i64, { i128, [48 x i8] } } %138, { i128, [48 x i8] } %137, 1
  ret { i64, { i128, [48 x i8] } } %139

140:                                              ; preds = %37
  %141 = phi i128 [ 79228162514264337593543950336, %37 ]
  %142 = phi i252 [ 4294967296, %37 ]
  %143 = insertvalue { i128, i252 } undef, i128 %141, 0
  %144 = insertvalue { i128, i252 } %143, i252 %142, 1
  %145 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %144, 1
  store { i2, { i128, i252 } } %145, ptr %22, align 16
  %146 = load { i128, [48 x i8] }, ptr %22, align 16
  %147 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %148 = insertvalue { i64, { i128, [48 x i8] } } %147, { i128, [48 x i8] } %146, 1
  ret { i64, { i128, [48 x i8] } } %148

149:                                              ; preds = %37
  %150 = phi i128 [ 20282409603651670423947251286016, %37 ]
  %151 = phi i252 [ 16777216, %37 ]
  %152 = insertvalue { i128, i252 } undef, i128 %150, 0
  %153 = insertvalue { i128, i252 } %152, i252 %151, 1
  %154 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %153, 1
  store { i2, { i128, i252 } } %154, ptr %21, align 16
  %155 = load { i128, [48 x i8] }, ptr %21, align 16
  %156 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %157 = insertvalue { i64, { i128, [48 x i8] } } %156, { i128, [48 x i8] } %155, 1
  ret { i64, { i128, [48 x i8] } } %157

158:                                              ; preds = %37
  %159 = phi i128 [ 5192296858534827628530496329220096, %37 ]
  %160 = phi i252 [ 65536, %37 ]
  %161 = insertvalue { i128, i252 } undef, i128 %159, 0
  %162 = insertvalue { i128, i252 } %161, i252 %160, 1
  %163 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %162, 1
  store { i2, { i128, i252 } } %163, ptr %20, align 16
  %164 = load { i128, [48 x i8] }, ptr %20, align 16
  %165 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %166 = insertvalue { i64, { i128, [48 x i8] } } %165, { i128, [48 x i8] } %164, 1
  ret { i64, { i128, [48 x i8] } } %166

167:                                              ; preds = %37
  %168 = phi i128 [ 1329227995784915872903807060280344576, %37 ]
  %169 = phi i252 [ 256, %37 ]
  %170 = insertvalue { i128, i252 } undef, i128 %168, 0
  %171 = insertvalue { i128, i252 } %170, i252 %169, 1
  %172 = insertvalue { i2, { i128, i252 } } { i2 1, { i128, i252 } undef }, { i128, i252 } %171, 1
  store { i2, { i128, i252 } } %172, ptr %19, align 16
  %173 = load { i128, [48 x i8] }, ptr %19, align 16
  %174 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %175 = insertvalue { i64, { i128, [48 x i8] } } %174, { i128, [48 x i8] } %173, 1
  ret { i64, { i128, [48 x i8] } } %175

176:                                              ; preds = %37
  store { i2, [0 x i8] } { i2 0, [0 x i8] undef }, ptr %18, align 1
  %177 = load { i128, [48 x i8] }, ptr %18, align 16
  %178 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %179 = insertvalue { i64, { i128, [48 x i8] } } %178, { i128, [48 x i8] } %177, 1
  ret { i64, { i128, [48 x i8] } } %179

180:                                              ; preds = %37
  %181 = phi i128 [ 256, %37 ]
  %182 = insertvalue { i128 } undef, i128 %181, 0
  %183 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %182, 1
  store { i2, { i128 } } %183, ptr %17, align 16
  %184 = load { i128, [48 x i8] }, ptr %17, align 16
  %185 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %186 = insertvalue { i64, { i128, [48 x i8] } } %185, { i128, [48 x i8] } %184, 1
  ret { i64, { i128, [48 x i8] } } %186

187:                                              ; preds = %37
  %188 = phi i128 [ 65536, %37 ]
  %189 = insertvalue { i128 } undef, i128 %188, 0
  %190 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %189, 1
  store { i2, { i128 } } %190, ptr %16, align 16
  %191 = load { i128, [48 x i8] }, ptr %16, align 16
  %192 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %193 = insertvalue { i64, { i128, [48 x i8] } } %192, { i128, [48 x i8] } %191, 1
  ret { i64, { i128, [48 x i8] } } %193

194:                                              ; preds = %37
  %195 = phi i128 [ 16777216, %37 ]
  %196 = insertvalue { i128 } undef, i128 %195, 0
  %197 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %196, 1
  store { i2, { i128 } } %197, ptr %15, align 16
  %198 = load { i128, [48 x i8] }, ptr %15, align 16
  %199 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %200 = insertvalue { i64, { i128, [48 x i8] } } %199, { i128, [48 x i8] } %198, 1
  ret { i64, { i128, [48 x i8] } } %200

201:                                              ; preds = %37
  %202 = phi i128 [ 4294967296, %37 ]
  %203 = insertvalue { i128 } undef, i128 %202, 0
  %204 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %203, 1
  store { i2, { i128 } } %204, ptr %14, align 16
  %205 = load { i128, [48 x i8] }, ptr %14, align 16
  %206 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %207 = insertvalue { i64, { i128, [48 x i8] } } %206, { i128, [48 x i8] } %205, 1
  ret { i64, { i128, [48 x i8] } } %207

208:                                              ; preds = %37
  %209 = phi i128 [ 1099511627776, %37 ]
  %210 = insertvalue { i128 } undef, i128 %209, 0
  %211 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %210, 1
  store { i2, { i128 } } %211, ptr %13, align 16
  %212 = load { i128, [48 x i8] }, ptr %13, align 16
  %213 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %214 = insertvalue { i64, { i128, [48 x i8] } } %213, { i128, [48 x i8] } %212, 1
  ret { i64, { i128, [48 x i8] } } %214

215:                                              ; preds = %37
  %216 = phi i128 [ 281474976710656, %37 ]
  %217 = insertvalue { i128 } undef, i128 %216, 0
  %218 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %217, 1
  store { i2, { i128 } } %218, ptr %12, align 16
  %219 = load { i128, [48 x i8] }, ptr %12, align 16
  %220 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %221 = insertvalue { i64, { i128, [48 x i8] } } %220, { i128, [48 x i8] } %219, 1
  ret { i64, { i128, [48 x i8] } } %221

222:                                              ; preds = %37
  %223 = phi i128 [ 72057594037927936, %37 ]
  %224 = insertvalue { i128 } undef, i128 %223, 0
  %225 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %224, 1
  store { i2, { i128 } } %225, ptr %11, align 16
  %226 = load { i128, [48 x i8] }, ptr %11, align 16
  %227 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %228 = insertvalue { i64, { i128, [48 x i8] } } %227, { i128, [48 x i8] } %226, 1
  ret { i64, { i128, [48 x i8] } } %228

229:                                              ; preds = %37
  %230 = phi i128 [ 18446744073709551616, %37 ]
  %231 = insertvalue { i128 } undef, i128 %230, 0
  %232 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %231, 1
  store { i2, { i128 } } %232, ptr %10, align 16
  %233 = load { i128, [48 x i8] }, ptr %10, align 16
  %234 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %235 = insertvalue { i64, { i128, [48 x i8] } } %234, { i128, [48 x i8] } %233, 1
  ret { i64, { i128, [48 x i8] } } %235

236:                                              ; preds = %37
  %237 = phi i128 [ 4722366482869645213696, %37 ]
  %238 = insertvalue { i128 } undef, i128 %237, 0
  %239 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %238, 1
  store { i2, { i128 } } %239, ptr %9, align 16
  %240 = load { i128, [48 x i8] }, ptr %9, align 16
  %241 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %242 = insertvalue { i64, { i128, [48 x i8] } } %241, { i128, [48 x i8] } %240, 1
  ret { i64, { i128, [48 x i8] } } %242

243:                                              ; preds = %37
  %244 = phi i128 [ 1208925819614629174706176, %37 ]
  %245 = insertvalue { i128 } undef, i128 %244, 0
  %246 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %245, 1
  store { i2, { i128 } } %246, ptr %8, align 16
  %247 = load { i128, [48 x i8] }, ptr %8, align 16
  %248 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %249 = insertvalue { i64, { i128, [48 x i8] } } %248, { i128, [48 x i8] } %247, 1
  ret { i64, { i128, [48 x i8] } } %249

250:                                              ; preds = %37
  %251 = phi i128 [ 309485009821345068724781056, %37 ]
  %252 = insertvalue { i128 } undef, i128 %251, 0
  %253 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %252, 1
  store { i2, { i128 } } %253, ptr %7, align 16
  %254 = load { i128, [48 x i8] }, ptr %7, align 16
  %255 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %256 = insertvalue { i64, { i128, [48 x i8] } } %255, { i128, [48 x i8] } %254, 1
  ret { i64, { i128, [48 x i8] } } %256

257:                                              ; preds = %37
  %258 = phi i128 [ 79228162514264337593543950336, %37 ]
  %259 = insertvalue { i128 } undef, i128 %258, 0
  %260 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %259, 1
  store { i2, { i128 } } %260, ptr %6, align 16
  %261 = load { i128, [48 x i8] }, ptr %6, align 16
  %262 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %263 = insertvalue { i64, { i128, [48 x i8] } } %262, { i128, [48 x i8] } %261, 1
  ret { i64, { i128, [48 x i8] } } %263

264:                                              ; preds = %37
  %265 = phi i128 [ 20282409603651670423947251286016, %37 ]
  %266 = insertvalue { i128 } undef, i128 %265, 0
  %267 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %266, 1
  store { i2, { i128 } } %267, ptr %5, align 16
  %268 = load { i128, [48 x i8] }, ptr %5, align 16
  %269 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %270 = insertvalue { i64, { i128, [48 x i8] } } %269, { i128, [48 x i8] } %268, 1
  ret { i64, { i128, [48 x i8] } } %270

271:                                              ; preds = %37
  %272 = phi i128 [ 5192296858534827628530496329220096, %37 ]
  %273 = insertvalue { i128 } undef, i128 %272, 0
  %274 = insertvalue { i2, { i128 } } { i2 -2, { i128 } undef }, { i128 } %273, 1
  store { i2, { i128 } } %274, ptr %4, align 16
  %275 = load { i128, [48 x i8] }, ptr %4, align 16
  %276 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %35, 0
  %277 = insertvalue { i64, { i128, [48 x i8] } } %276, { i128, [48 x i8] } %275, 1
  ret { i64, { i128, [48 x i8] } } %277

278:                                              ; preds = %37, %2
  %279 = phi i64 [ %35, %37 ], [ %35, %2 ]
  store { i2, [0 x i8] } { i2 -1, [0 x i8] undef }, ptr %3, align 1
  %280 = load { i128, [48 x i8] }, ptr %3, align 16
  %281 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %279, 0
  %282 = insertvalue { i64, { i128, [48 x i8] } } %281, { i128, [48 x i8] } %280, 1
  ret { i64, { i128, [48 x i8] } } %282

283:                                              ; preds = %39
  call void @puts(ptr @assert_msg_146)
  call void @abort()
  unreachable
}

define private { i64, { i128, [48 x i8] } } @f80(i64 %0, i32 %1) {
  %3 = call fastcc { i64, { i128, [48 x i8] } } @"impl$f80"(i64 %0, i32 %1)
  %4 = extractvalue { i64, { i128, [48 x i8] } } %3, 0
  %5 = extractvalue { i64, { i128, [48 x i8] } } %3, 1
  %6 = insertvalue { i64, { i128, [48 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i128, [48 x i8] } } %6, { i128, [48 x i8] } %5, 1
  ret { i64, { i128, [48 x i8] } } %7
}

define void @_mlir_ciface_f80(ptr %0, i64 %1, i32 %2) {
  %4 = call { i64, { i128, [48 x i8] } } @f80(i64 %1, i32 %2)
  store { i64, { i128, [48 x i8] } } %4, ptr %0, align 16
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f81"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 1995392260568499387643902728889710)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f81() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f81"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f81(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f81()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f82"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 155785504329508738615720351733824384887)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f82() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f82"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f82(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f82()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f83"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 155785504323917466144735657540098748279)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f83() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f83"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f83(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f83()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private void @"drop$168"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$168"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 32, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %12

12:                                               ; preds = %84, %4
  %13 = phi i64 [ %17, %84 ], [ %0, %4 ]
  %14 = phi i64 [ %42, %84 ], [ %1, %4 ]
  %15 = phi { { ptr, i32, i32, i32 } } [ %95, %84 ], [ %2, %4 ]
  %16 = phi { ptr, i32, i32, i32 } [ %93, %84 ], [ %3, %4 ]
  %17 = add i64 %13, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 1570
  %22 = icmp uge i64 %14, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %14, i64 %21)
  br i1 %22, label %24, label %132

24:                                               ; preds = %12
  %25 = phi { { ptr, i32, i32, i32 } } [ %15, %12 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %113

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 0)
  %43 = load i248, ptr %39, align 16
  call void @free(ptr %39)
  %44 = zext i248 %43 to i252
  %45 = extractvalue { ptr, i32, i32, i32 } %16, 3
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %47, label %61

47:                                               ; preds = %31
  %48 = shl i32 %45, 1
  %49 = call i32 @llvm.umin.i32(i32 %48, i32 1024)
  %50 = add i32 %49, %45
  %51 = call i32 @llvm.umax.i32(i32 %50, i32 8)
  %52 = zext i32 %51 to i64
  %53 = mul i64 %52, 32
  %54 = add i64 %53, 16
  %55 = call ptr @realloc(ptr null, i64 %54)
  store i32 1, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %55, i32 4
  store i32 0, ptr %56, align 4
  %57 = getelementptr inbounds i8, ptr %55, i32 16
  %58 = call ptr @realloc(ptr null, i64 8)
  store ptr %57, ptr %58, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } %16, ptr %58, 0
  %60 = insertvalue { ptr, i32, i32, i32 } %59, i32 %51, 3
  br label %82

61:                                               ; preds = %31
  %62 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %63 = icmp ult i32 %62, %45
  br i1 %63, label %64, label %65

64:                                               ; preds = %61
  br label %79

65:                                               ; preds = %61
  %66 = shl i32 %45, 1
  %67 = call i32 @llvm.umin.i32(i32 %66, i32 1024)
  %68 = add i32 %67, %45
  %69 = call i32 @llvm.umax.i32(i32 %68, i32 8)
  %70 = zext i32 %69 to i64
  %71 = mul i64 %70, 32
  %72 = add i64 %71, 16
  %73 = extractvalue { ptr, i32, i32, i32 } %16, 0
  %74 = load ptr, ptr %73, align 8
  %75 = getelementptr inbounds i8, ptr %74, i32 -16
  %76 = call ptr @realloc(ptr %75, i64 %72)
  %77 = getelementptr inbounds i8, ptr %76, i32 16
  store ptr %77, ptr %73, align 8
  %78 = insertvalue { ptr, i32, i32, i32 } %16, i32 %69, 3
  br label %79

79:                                               ; preds = %64, %65
  %80 = phi { ptr, i32, i32, i32 } [ %78, %65 ], [ %16, %64 ]
  br label %81

81:                                               ; preds = %79
  br label %82

82:                                               ; preds = %47, %81
  %83 = phi { ptr, i32, i32, i32 } [ %80, %81 ], [ %60, %47 ]
  br label %84

84:                                               ; preds = %82
  %85 = extractvalue { ptr, i32, i32, i32 } %83, 0
  %86 = load ptr, ptr %85, align 8
  %87 = extractvalue { ptr, i32, i32, i32 } %83, 2
  %88 = zext i32 %87 to i64
  %89 = mul i64 %88, 32
  %90 = getelementptr inbounds i8, ptr %86, i64 %89
  store i252 %44, ptr %90, align 16
  %91 = extractvalue { ptr, i32, i32, i32 } %83, 2
  %92 = add i32 %91, 1
  %93 = insertvalue { ptr, i32, i32, i32 } %83, i32 %92, 2
  %94 = getelementptr inbounds i8, ptr %86, i32 -12
  store i32 %92, ptr %94, align 4
  %95 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %38, 0
  %96 = extractvalue { ptr, ptr, i64 } %8, 1
  %97 = load i64, ptr %96, align 8
  %98 = add i64 %97, 1
  %99 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %98, ptr %99, align 8
  br label %12

100:                                              ; preds = %100, %113, %132
  %101 = phi i64 [ %17, %132 ], [ %17, %113 ], [ %101, %100 ]
  %102 = phi i64 [ %14, %132 ], [ %119, %113 ], [ %102, %100 ]
  %103 = phi { i64, [24 x i8] } [ %137, %132 ], [ %122, %113 ], [ %103, %100 ]
  %104 = extractvalue { ptr, ptr, i64 } %8, 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %105, 1
  %108 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %107, ptr %108, align 8
  br i1 %106, label %109, label %100

109:                                              ; preds = %100
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %101, 0
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, i64 %102, 1
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %103, 2
  ret { i64, i64, { i64, [24 x i8] } } %112

113:                                              ; preds = %24
  %114 = phi { ptr, i32, i32, i32 } [ %26, %24 ]
  call void @"drop$43"({ ptr, i32, i32, i32 } %114)
  %115 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %116 = call ptr %115()
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, 2270
  %119 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %118)
  %120 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %16, 0
  %121 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %120, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %121, ptr %11, align 8
  %122 = load { i64, [24 x i8] }, ptr %11, align 8
  %123 = extractvalue { ptr, ptr, i64 } %8, 1
  %124 = load i64, ptr %123, align 8
  %125 = icmp eq i64 %124, 0
  %126 = sub i64 %124, 1
  %127 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %126, ptr %127, align 8
  br i1 %125, label %128, label %100

128:                                              ; preds = %113
  %129 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %130 = insertvalue { i64, i64, { i64, [24 x i8] } } %129, i64 %119, 1
  %131 = insertvalue { i64, i64, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %122, 2
  ret { i64, i64, { i64, [24 x i8] } } %131

132:                                              ; preds = %12
  %133 = phi { ptr, i32, i32, i32 } [ %16, %12 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %133)
  call void @"drop$44"({ { ptr, i32, i32, i32 } } %15)
  %134 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %135 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %134, 0
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %10, align 8
  %137 = load { i64, [24 x i8] }, ptr %10, align 8
  %138 = extractvalue { ptr, ptr, i64 } %8, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %143, label %100

143:                                              ; preds = %132
  %144 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %17, 0
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } %144, i64 %14, 1
  %146 = insertvalue { i64, i64, { i64, [24 x i8] } } %145, { i64, [24 x i8] } %137, 2
  ret { i64, i64, { i64, [24 x i8] } } %146
}

define private { i64, i64, { i64, [24 x i8] } } @f84(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f84(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f84(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$164"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  call void @"drop$37"({ ptr, i32, i32, i32 } %6)
  ret void

7:                                                ; preds = %1
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$164"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { ptr, i32, i32, i32 } }, ptr %2, align 8
  %6 = extractvalue { i1, { ptr, i32, i32, i32 } } %5, 1
  %7 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$37"({ ptr, i32, i32, i32 } %6)
  %8 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %7, 1
  %10 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %8, 1
  store { i1, { ptr, i32, i32, i32 } } %10, ptr %2, align 8
  %11 = load { i64, [24 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { ptr, i32, i32, i32 } } %5, { ptr, i32, i32, i32 } %9, 1
  store { i1, { ptr, i32, i32, i32 } } %12, ptr %2, align 8
  %13 = load { i64, [24 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %11, 0
  %15 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %13, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, {} }, ptr %2, align 1
  %18 = extractvalue { i1, {} } %17, 1
  %19 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %19, ptr %2, align 1
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, {} } %17, {} %18, 1
  store { i1, {} } %21, ptr %2, align 1
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$165"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  call void @"drop$164"({ i64, [24 x i8] } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$165"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %0, 1
  %9 = call { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$164"({ i64, [24 x i8] } %8)
  %10 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %11, 1
  %14 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } undef, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %12, 0
  %15 = insertvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %14, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %13, 1
  ret { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %15
}

define private void @"drop$166"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  call void @"drop$165"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [56 x i8] }, { i64, [56 x i8] } } @"dup$166"({ i64, [56 x i8] } %0) {
  %2 = alloca { i64, [56 x i8] }, i64 1, align 8
  store { i64, [56 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } @"dup$165"({ { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %10, ptr %2, align 8
  %11 = load { i64, [56 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %5, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %12, ptr %2, align 8
  %13 = load { i64, [56 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %11, 0
  %15 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %14, { i64, [56 x i8] } %13, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [56 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [56 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } undef, { i64, [56 x i8] } %23, 0
  %27 = insertvalue { { i64, [56 x i8] }, { i64, [56 x i8] } } %26, { i64, [56 x i8] } %25, 1
  ret { { i64, [56 x i8] }, { i64, [56 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f85"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i128, [128 x i8] }, i64 1, align 16
  %5 = alloca { i128, [192 x i8] }, i64 1, align 16
  %6 = alloca { i128, [80 x i8] }, i64 1, align 16
  %7 = alloca { i128, [144 x i8] }, i64 1, align 16
  %8 = alloca { i128, [192 x i8] }, i64 1, align 16
  %9 = alloca { i128, [144 x i8] }, i64 1, align 16
  %10 = alloca { i128, [192 x i8] }, i64 1, align 16
  %11 = alloca { i128, [144 x i8] }, i64 1, align 16
  %12 = alloca { i128, [192 x i8] }, i64 1, align 16
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i128, [192 x i8] }, i64 1, align 16
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [56 x i8] }, i64 1, align 8
  %17 = alloca { i128, [192 x i8] }, i64 1, align 16
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i128, [144 x i8] }, i64 1, align 16
  %20 = alloca { i128, [192 x i8] }, i64 1, align 16
  %21 = call fastcc { i64, i64, { i128, [128 x i8] } } @"impl$f26"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %22 = extractvalue { i64, i64, { i128, [128 x i8] } } %21, 0
  %23 = extractvalue { i64, i64, { i128, [128 x i8] } } %21, 1
  %24 = extractvalue { i64, i64, { i128, [128 x i8] } } %21, 2
  store { i128, [128 x i8] } %24, ptr %4, align 16
  %25 = load i1, ptr %4, align 1
  switch i1 %25, label %26 [
    i1 false, label %28
    i1 true, label %34
  ]

26:                                               ; preds = %3
  br i1 false, label %27, label %325

27:                                               ; preds = %26
  unreachable

28:                                               ; preds = %3
  %29 = load { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } }, ptr %4, align 16
  %30 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %29, 1
  %31 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %30, 0
  %32 = extractvalue { { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %30, 1
  store { i128, [80 x i8] } %32, ptr %6, align 16
  %33 = load i1, ptr %6, align 1
  switch i1 %33, label %42 [
    i1 false, label %44
    i1 true, label %52
  ]

34:                                               ; preds = %3
  %35 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %36 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %35, 1
  %37 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %36, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %37, ptr %5, align 8
  %38 = load { i128, [192 x i8] }, ptr %5, align 16
  %39 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %22, 0
  %40 = insertvalue { i64, i64, { i128, [192 x i8] } } %39, i64 %23, 1
  %41 = insertvalue { i64, i64, { i128, [192 x i8] } } %40, { i128, [192 x i8] } %38, 2
  ret { i64, i64, { i128, [192 x i8] } } %41

42:                                               ; preds = %28
  br i1 false, label %43, label %326

43:                                               ; preds = %42
  unreachable

44:                                               ; preds = %28
  %45 = load { i1, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %6, align 16
  %46 = extractvalue { i1, { { ptr, i32, i32, i32 }, i252, i32 } } %45, 1
  %47 = extractvalue { { ptr, i32, i32, i32 } } %31, 0
  %48 = extractvalue { ptr, i32, i32, i32 } %47, 1
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %50 = sub i32 %49, %48
  %51 = icmp uge i32 %50, 1
  br i1 %51, label %58, label %293

52:                                               ; preds = %28
  %53 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %54 = call ptr %53()
  %55 = load i64, ptr %54, align 8
  %56 = mul i64 %55, 10870
  %57 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %56)
  br label %313

58:                                               ; preds = %44
  %59 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %60 = load ptr, ptr %59, align 8
  %61 = zext i32 %48 to i64
  %62 = mul i64 %61, 32
  %63 = getelementptr inbounds i8, ptr %60, i64 %62
  %64 = add i32 %48, 1
  %65 = insertvalue { ptr, i32, i32, i32 } %47, i32 %64, 1
  %66 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %66, ptr %63, i64 32, i1 false)
  %67 = load i252, ptr %66, align 16
  call void @free(ptr %66)
  %68 = icmp ult i252 %67, 65536
  %69 = add i64 %22, 2
  %70 = add i64 %22, 3
  %71 = select i1 %68, i64 %69, i64 %70
  %72 = trunc i252 %67 to i16
  br i1 %68, label %73, label %286

73:                                               ; preds = %58
  %74 = phi { ptr, i32, i32, i32 } [ %65, %58 ]
  %75 = extractvalue { ptr, i32, i32, i32 } %74, 1
  %76 = extractvalue { ptr, i32, i32, i32 } %74, 2
  %77 = sub i32 %76, %75
  %78 = icmp uge i32 %77, 1
  br i1 %78, label %79, label %279

79:                                               ; preds = %73
  %80 = extractvalue { ptr, i32, i32, i32 } %74, 0
  %81 = load ptr, ptr %80, align 8
  %82 = zext i32 %75 to i64
  %83 = mul i64 %82, 32
  %84 = getelementptr inbounds i8, ptr %81, i64 %83
  %85 = add i32 %75, 1
  %86 = insertvalue { ptr, i32, i32, i32 } %74, i32 %85, 1
  %87 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %87, ptr %84, i64 32, i1 false)
  %88 = load i252, ptr %87, align 16
  call void @free(ptr %87)
  %89 = icmp ult i252 %88, 256
  %90 = add i64 %71, 2
  %91 = add i64 %71, 3
  %92 = select i1 %89, i64 %90, i64 %91
  %93 = trunc i252 %88 to i8
  br i1 %89, label %94, label %272

94:                                               ; preds = %79
  %95 = phi { ptr, i32, i32, i32 } [ %86, %79 ]
  %96 = extractvalue { ptr, i32, i32, i32 } %95, 1
  %97 = extractvalue { ptr, i32, i32, i32 } %95, 2
  %98 = sub i32 %97, %96
  %99 = icmp uge i32 %98, 1
  br i1 %99, label %100, label %265

100:                                              ; preds = %94
  %101 = extractvalue { ptr, i32, i32, i32 } %95, 0
  %102 = load ptr, ptr %101, align 8
  %103 = zext i32 %96 to i64
  %104 = mul i64 %103, 32
  %105 = getelementptr inbounds i8, ptr %102, i64 %104
  %106 = add i32 %96, 1
  %107 = insertvalue { ptr, i32, i32, i32 } %95, i32 %106, 1
  %108 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %108, ptr %105, i64 32, i1 false)
  %109 = load i252, ptr %108, align 16
  call void @free(ptr %108)
  %110 = icmp ult i252 %109, 4294967296
  %111 = add i64 %92, 2
  %112 = add i64 %92, 3
  %113 = select i1 %110, i64 %111, i64 %112
  %114 = trunc i252 %109 to i32
  br i1 %110, label %115, label %258

115:                                              ; preds = %100
  %116 = phi { ptr, i32, i32, i32 } [ %107, %100 ]
  %117 = extractvalue { ptr, i32, i32, i32 } %116, 1
  %118 = extractvalue { ptr, i32, i32, i32 } %116, 2
  %119 = sub i32 %118, %117
  %120 = icmp uge i32 %119, 1
  br i1 %120, label %121, label %238

121:                                              ; preds = %115
  %122 = extractvalue { ptr, i32, i32, i32 } %116, 0
  %123 = load ptr, ptr %122, align 8
  %124 = zext i32 %117 to i64
  %125 = mul i64 %124, 32
  %126 = getelementptr inbounds i8, ptr %123, i64 %125
  %127 = add i32 %117, 1
  %128 = insertvalue { ptr, i32, i32, i32 } %116, i32 %127, 1
  %129 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %129, ptr %126, i64 32, i1 false)
  %130 = load i252, ptr %129, align 16
  call void @free(ptr %129)
  %131 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %128, 0
  %132 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f108"(i64 %113, i64 %23, { { ptr, i32, i32, i32 } } %131, { ptr, i32, i32, i32 } zeroinitializer, i252 %130)
  %133 = extractvalue { i64, i64, { i64, [56 x i8] } } %132, 0
  %134 = extractvalue { i64, i64, { i64, [56 x i8] } } %132, 1
  %135 = extractvalue { i64, i64, { i64, [56 x i8] } } %132, 2
  store { i64, [56 x i8] } %135, ptr %13, align 8
  %136 = load i1, ptr %13, align 1
  switch i1 %136, label %137 [
    i1 false, label %139
    i1 true, label %146
  ]

137:                                              ; preds = %121
  br i1 false, label %138, label %327

138:                                              ; preds = %137
  unreachable

139:                                              ; preds = %121
  %140 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %13, align 8
  %141 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %140, 1
  %142 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %141, 0
  %143 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %141, 1
  %144 = extractvalue { { ptr, i32, i32, i32 } } %142, 0
  store { i64, [24 x i8] } %143, ptr %15, align 8
  %145 = load i1, ptr %15, align 1
  switch i1 %145, label %154 [
    i1 false, label %156
    i1 true, label %163
  ]

146:                                              ; preds = %121
  %147 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %148 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %147, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  %149 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %148, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %149, ptr %14, align 8
  %150 = load { i128, [192 x i8] }, ptr %14, align 16
  %151 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %133, 0
  %152 = insertvalue { i64, i64, { i128, [192 x i8] } } %151, i64 %134, 1
  %153 = insertvalue { i64, i64, { i128, [192 x i8] } } %152, { i128, [192 x i8] } %150, 2
  ret { i64, i64, { i128, [192 x i8] } } %153

154:                                              ; preds = %139
  br i1 false, label %155, label %328

155:                                              ; preds = %154
  unreachable

156:                                              ; preds = %139
  %157 = load { i1, { ptr, i32, i32, i32 } }, ptr %15, align 8
  %158 = extractvalue { i1, { ptr, i32, i32, i32 } } %157, 1
  %159 = extractvalue { ptr, i32, i32, i32 } %144, 1
  %160 = extractvalue { ptr, i32, i32, i32 } %144, 2
  %161 = sub i32 %160, %159
  %162 = icmp uge i32 %161, 1
  br i1 %162, label %169, label %230

163:                                              ; preds = %139
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  %164 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %165 = call ptr %164()
  %166 = load i64, ptr %165, align 8
  %167 = mul i64 %166, 3750
  %168 = call i64 @llvm.uadd.sat.i64(i64 %134, i64 %167)
  br label %245

169:                                              ; preds = %156
  %170 = extractvalue { ptr, i32, i32, i32 } %144, 0
  %171 = load ptr, ptr %170, align 8
  %172 = zext i32 %159 to i64
  %173 = mul i64 %172, 32
  %174 = getelementptr inbounds i8, ptr %171, i64 %173
  %175 = add i32 %159, 1
  %176 = insertvalue { ptr, i32, i32, i32 } %144, i32 %175, 1
  %177 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %177, ptr %174, i64 32, i1 false)
  %178 = load i252, ptr %177, align 16
  call void @free(ptr %177)
  %179 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %176, 0
  %180 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f108"(i64 %133, i64 %134, { { ptr, i32, i32, i32 } } %179, { ptr, i32, i32, i32 } zeroinitializer, i252 %178)
  %181 = extractvalue { i64, i64, { i64, [56 x i8] } } %180, 0
  %182 = extractvalue { i64, i64, { i64, [56 x i8] } } %180, 1
  %183 = extractvalue { i64, i64, { i64, [56 x i8] } } %180, 2
  store { i64, [56 x i8] } %183, ptr %16, align 8
  %184 = load i1, ptr %16, align 1
  switch i1 %184, label %185 [
    i1 false, label %187
    i1 true, label %193
  ]

185:                                              ; preds = %169
  br i1 false, label %186, label %329

186:                                              ; preds = %185
  unreachable

187:                                              ; preds = %169
  %188 = load { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } }, ptr %16, align 8
  %189 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %188, 1
  %190 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %189, 0
  %191 = extractvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %189, 1
  store { i64, [24 x i8] } %191, ptr %18, align 8
  %192 = load i1, ptr %18, align 1
  switch i1 %192, label %201 [
    i1 false, label %203
    i1 true, label %226
  ]

193:                                              ; preds = %169
  %194 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %195 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %194, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  call void @"drop$37"({ ptr, i32, i32, i32 } %158)
  %196 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %195, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %196, ptr %17, align 8
  %197 = load { i128, [192 x i8] }, ptr %17, align 16
  %198 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %181, 0
  %199 = insertvalue { i64, i64, { i128, [192 x i8] } } %198, i64 %182, 1
  %200 = insertvalue { i64, i64, { i128, [192 x i8] } } %199, { i128, [192 x i8] } %197, 2
  ret { i64, i64, { i128, [192 x i8] } } %200

201:                                              ; preds = %187
  br i1 false, label %202, label %330

202:                                              ; preds = %201
  unreachable

203:                                              ; preds = %187
  %204 = load { i1, { ptr, i32, i32, i32 } }, ptr %18, align 8
  %205 = extractvalue { i1, { ptr, i32, i32, i32 } } %204, 1
  %206 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %207 = call ptr %206()
  %208 = load i64, ptr %207, align 8
  %209 = mul i64 %208, 500
  %210 = call i64 @llvm.uadd.sat.i64(i64 %182, i64 %209)
  %211 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %46, 0
  %212 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %211, i16 %72, 1
  %213 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %212, i8 %93, 2
  %214 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %213, i32 %114, 3
  %215 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %214, { ptr, i32, i32, i32 } %158, 4
  %216 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %215, { ptr, i32, i32, i32 } %205, 5
  %217 = insertvalue { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } { i1 false, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %216, 1
  store { i1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %217, ptr %19, align 16
  %218 = load { i128, [144 x i8] }, ptr %19, align 16
  %219 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %190, 0
  %220 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %219, { i128, [144 x i8] } %218, 1
  %221 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %220, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %221, ptr %20, align 16
  %222 = load { i128, [192 x i8] }, ptr %20, align 16
  %223 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %181, 0
  %224 = insertvalue { i64, i64, { i128, [192 x i8] } } %223, i64 %210, 1
  %225 = insertvalue { i64, i64, { i128, [192 x i8] } } %224, { i128, [192 x i8] } %222, 2
  ret { i64, i64, { i128, [192 x i8] } } %225

226:                                              ; preds = %187
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %46)
  call void @"drop$37"({ ptr, i32, i32, i32 } %158)
  %227 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %228 = call ptr %227()
  %229 = call i64 @llvm.uadd.sat.i64(i64 %182, i64 0)
  br label %313

230:                                              ; preds = %156
  %231 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %156 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %231)
  call void @"drop$37"({ ptr, i32, i32, i32 } %158)
  %232 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %233 = call ptr %232()
  %234 = load i64, ptr %233, align 8
  %235 = mul i64 %234, 3270
  %236 = call i64 @llvm.uadd.sat.i64(i64 %134, i64 %235)
  %237 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %144, 0
  br label %313

238:                                              ; preds = %115
  %239 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %115 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %239)
  %240 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %241 = call ptr %240()
  %242 = load i64, ptr %241, align 8
  %243 = mul i64 %242, 7120
  %244 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %243)
  br label %245

245:                                              ; preds = %163, %238
  %246 = phi i64 [ %113, %238 ], [ %133, %163 ]
  %247 = phi i64 [ %244, %238 ], [ %168, %163 ]
  %248 = phi { ptr, i32, i32, i32 } [ %116, %238 ], [ %144, %163 ]
  %249 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %248, 0
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %11, align 1
  %250 = load { i128, [144 x i8] }, ptr %11, align 16
  %251 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %249, 0
  %252 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %251, { i128, [144 x i8] } %250, 1
  %253 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %252, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %253, ptr %12, align 16
  %254 = load { i128, [192 x i8] }, ptr %12, align 16
  %255 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %246, 0
  %256 = insertvalue { i64, i64, { i128, [192 x i8] } } %255, i64 %247, 1
  %257 = insertvalue { i64, i64, { i128, [192 x i8] } } %256, { i128, [192 x i8] } %254, 2
  ret { i64, i64, { i128, [192 x i8] } } %257

258:                                              ; preds = %100
  %259 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %100 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %259)
  %260 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %261 = call ptr %260()
  %262 = load i64, ptr %261, align 8
  %263 = mul i64 %262, 6850
  %264 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %263)
  br label %300

265:                                              ; preds = %94
  %266 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %94 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %266)
  %267 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %268 = call ptr %267()
  %269 = load i64, ptr %268, align 8
  %270 = mul i64 %269, 8050
  %271 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %270)
  br label %300

272:                                              ; preds = %79
  %273 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %79 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %273)
  %274 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %275 = call ptr %274()
  %276 = load i64, ptr %275, align 8
  %277 = mul i64 %276, 7880
  %278 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %277)
  br label %300

279:                                              ; preds = %73
  %280 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %73 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %280)
  %281 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %282 = call ptr %281()
  %283 = load i64, ptr %282, align 8
  %284 = mul i64 %283, 9080
  %285 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %284)
  br label %300

286:                                              ; preds = %58
  %287 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %58 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %287)
  %288 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %289 = call ptr %288()
  %290 = load i64, ptr %289, align 8
  %291 = mul i64 %290, 8910
  %292 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %291)
  br label %300

293:                                              ; preds = %44
  %294 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %46, %44 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %294)
  %295 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %296 = call ptr %295()
  %297 = load i64, ptr %296, align 8
  %298 = mul i64 %297, 10210
  %299 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %298)
  br label %300

300:                                              ; preds = %258, %265, %272, %279, %286, %293
  %301 = phi i64 [ %22, %293 ], [ %71, %286 ], [ %71, %279 ], [ %92, %272 ], [ %92, %265 ], [ %113, %258 ]
  %302 = phi i64 [ %299, %293 ], [ %292, %286 ], [ %285, %279 ], [ %278, %272 ], [ %271, %265 ], [ %264, %258 ]
  %303 = phi { ptr, i32, i32, i32 } [ %47, %293 ], [ %65, %286 ], [ %74, %279 ], [ %86, %272 ], [ %95, %265 ], [ %107, %258 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %304 = load { i128, [144 x i8] }, ptr %9, align 16
  %305 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %303, 0
  %306 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %305, 0
  %307 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %306, { i128, [144 x i8] } %304, 1
  %308 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %307, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %308, ptr %10, align 16
  %309 = load { i128, [192 x i8] }, ptr %10, align 16
  %310 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %301, 0
  %311 = insertvalue { i64, i64, { i128, [192 x i8] } } %310, i64 %302, 1
  %312 = insertvalue { i64, i64, { i128, [192 x i8] } } %311, { i128, [192 x i8] } %309, 2
  ret { i64, i64, { i128, [192 x i8] } } %312

313:                                              ; preds = %226, %230, %52
  %314 = phi i64 [ %133, %230 ], [ %181, %226 ], [ %22, %52 ]
  %315 = phi i64 [ %236, %230 ], [ %229, %226 ], [ %57, %52 ]
  %316 = phi { { ptr, i32, i32, i32 } } [ %237, %230 ], [ %190, %226 ], [ %31, %52 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %7, align 1
  %317 = load { i128, [144 x i8] }, ptr %7, align 16
  %318 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef, { { ptr, i32, i32, i32 } } %316, 0
  %319 = insertvalue { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %318, { i128, [144 x i8] } %317, 1
  %320 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } %319, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i128, [144 x i8] } } } %320, ptr %8, align 16
  %321 = load { i128, [192 x i8] }, ptr %8, align 16
  %322 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %314, 0
  %323 = insertvalue { i64, i64, { i128, [192 x i8] } } %322, i64 %315, 1
  %324 = insertvalue { i64, i64, { i128, [192 x i8] } } %323, { i128, [192 x i8] } %321, 2
  ret { i64, i64, { i128, [192 x i8] } } %324

325:                                              ; preds = %26
  call void @puts(ptr @assert_msg_147)
  call void @abort()
  unreachable

326:                                              ; preds = %42
  call void @puts(ptr @assert_msg_148)
  call void @abort()
  unreachable

327:                                              ; preds = %137
  call void @puts(ptr @assert_msg_149)
  call void @abort()
  unreachable

328:                                              ; preds = %154
  call void @puts(ptr @assert_msg_150)
  call void @abort()
  unreachable

329:                                              ; preds = %185
  call void @puts(ptr @assert_msg_151)
  call void @abort()
  unreachable

330:                                              ; preds = %201
  call void @puts(ptr @assert_msg_152)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [192 x i8] } } @f85(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [192 x i8] } } @"impl$f85"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [192 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [192 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [192 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [192 x i8] } } %9, { i128, [192 x i8] } %7, 2
  ret { i64, i64, { i128, [192 x i8] } } %10
}

define void @_mlir_ciface_f85(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [192 x i8] } } @f85(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [192 x i8] } } %5, ptr %0, align 16
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f86"(i64 %0, i8 %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = icmp eq i8 %1, -128
  br i1 %10, label %84, label %11

11:                                               ; preds = %2
  %12 = phi i8 [ %1, %2 ]
  %13 = add i64 %0, 1
  %14 = icmp sge i8 %12, 0
  br i1 %14, label %15, label %27

15:                                               ; preds = %11
  %16 = phi i64 [ %13, %11 ]
  %17 = phi i8 [ %12, %11 ]
  %18 = icmp sge i8 %17, 0
  %19 = add i64 %16, 1
  br i1 %18, label %20, label %62

20:                                               ; preds = %15
  %21 = phi i8 [ %17, %15 ]
  %22 = insertvalue { i8 } undef, i8 %21, 0
  %23 = insertvalue { i1, { i8 } } { i1 false, { i8 } undef }, { i8 } %22, 1
  store { i1, { i8 } } %23, ptr %9, align 1
  %24 = load { i64, [24 x i8] }, ptr %9, align 8
  %25 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %19, 0
  %26 = insertvalue { i64, { i64, [24 x i8] } } %25, { i64, [24 x i8] } %24, 1
  ret { i64, { i64, [24 x i8] } } %26

27:                                               ; preds = %11
  %28 = phi i64 [ %13, %11 ]
  %29 = phi i8 [ 0, %11 ]
  %30 = phi i8 [ %12, %11 ]
  %31 = add i64 %28, 1
  %32 = call { i8, i1 } @llvm.ssub.with.overflow.i8(i8 %29, i8 %30)
  %33 = extractvalue { i8, i1 } %32, 0
  %34 = extractvalue { i8, i1 } %32, 1
  br i1 %34, label %38, label %35

35:                                               ; preds = %27
  %36 = icmp sge i8 %33, 0
  %37 = add i64 %28, 3
  br i1 %36, label %40, label %62

38:                                               ; preds = %27
  %39 = icmp sge i8 %33, 0
  br i1 %39, label %70, label %77

40:                                               ; preds = %35
  %41 = phi i64 [ %37, %35 ]
  %42 = phi i8 [ -128, %35 ]
  %43 = phi i8 [ %33, %35 ]
  %44 = add i64 %41, 1
  %45 = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 %42, i8 %43)
  %46 = extractvalue { i8, i1 } %45, 0
  %47 = extractvalue { i8, i1 } %45, 1
  br i1 %47, label %55, label %48

48:                                               ; preds = %40
  %49 = phi i8 [ %46, %40 ]
  %50 = insertvalue { i8 } undef, i8 %49, 0
  %51 = insertvalue { i1, { i8 } } { i1 false, { i8 } undef }, { i8 } %50, 1
  store { i1, { i8 } } %51, ptr %8, align 1
  %52 = load { i64, [24 x i8] }, ptr %8, align 8
  %53 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %44, 0
  %54 = insertvalue { i64, { i64, [24 x i8] } } %53, { i64, [24 x i8] } %52, 1
  ret { i64, { i64, [24 x i8] } } %54

55:                                               ; preds = %40
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f109"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %57, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %58, ptr %7, align 8
  %59 = load { i64, [24 x i8] }, ptr %7, align 8
  %60 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %44, 0
  %61 = insertvalue { i64, { i64, [24 x i8] } } %60, { i64, [24 x i8] } %59, 1
  ret { i64, { i64, [24 x i8] } } %61

62:                                               ; preds = %15, %35
  %63 = phi i64 [ %37, %35 ], [ %19, %15 ]
  %64 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %65 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %64, 0
  %66 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %65, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %66, ptr %6, align 8
  %67 = load { i64, [24 x i8] }, ptr %6, align 8
  %68 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %63, 0
  %69 = insertvalue { i64, { i64, [24 x i8] } } %68, { i64, [24 x i8] } %67, 1
  ret { i64, { i64, [24 x i8] } } %69

70:                                               ; preds = %38
  %71 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f110"()
  %72 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %71, 0
  %73 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %72, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %73, ptr %5, align 8
  %74 = load { i64, [24 x i8] }, ptr %5, align 8
  %75 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %31, 0
  %76 = insertvalue { i64, { i64, [24 x i8] } } %75, { i64, [24 x i8] } %74, 1
  ret { i64, { i64, [24 x i8] } } %76

77:                                               ; preds = %38
  %78 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f111"()
  %79 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %78, 0
  %80 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %79, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %80, ptr %4, align 8
  %81 = load { i64, [24 x i8] }, ptr %4, align 8
  %82 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %31, 0
  %83 = insertvalue { i64, { i64, [24 x i8] } } %82, { i64, [24 x i8] } %81, 1
  ret { i64, { i64, [24 x i8] } } %83

84:                                               ; preds = %2
  %85 = phi i8 [ -1, %2 ]
  %86 = insertvalue { i8 } undef, i8 %85, 0
  %87 = insertvalue { i1, { i8 } } { i1 false, { i8 } undef }, { i8 } %86, 1
  store { i1, { i8 } } %87, ptr %3, align 1
  %88 = load { i64, [24 x i8] }, ptr %3, align 8
  %89 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %0, 0
  %90 = insertvalue { i64, { i64, [24 x i8] } } %89, { i64, [24 x i8] } %88, 1
  ret { i64, { i64, [24 x i8] } } %90
}

define private { i64, { i64, [24 x i8] } } @f86(i64 %0, i8 %1) {
  %3 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f86"(i64 %0, i8 %1)
  %4 = extractvalue { i64, { i64, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { i64, [24 x i8] } } %3, 1
  %6 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %5, 1
  ret { i64, { i64, [24 x i8] } } %7
}

define void @_mlir_ciface_f86(ptr %0, i64 %1, i8 %2) {
  %4 = call { i64, { i64, [24 x i8] } } @f86(i64 %1, i8 %2)
  store { i64, { i64, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f87"(i64 %0, i16 %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = icmp eq i16 %1, -32768
  br i1 %10, label %84, label %11

11:                                               ; preds = %2
  %12 = phi i16 [ %1, %2 ]
  %13 = add i64 %0, 1
  %14 = icmp sge i16 %12, 0
  br i1 %14, label %15, label %27

15:                                               ; preds = %11
  %16 = phi i64 [ %13, %11 ]
  %17 = phi i16 [ %12, %11 ]
  %18 = icmp sge i16 %17, 0
  %19 = add i64 %16, 1
  br i1 %18, label %20, label %62

20:                                               ; preds = %15
  %21 = phi i16 [ %17, %15 ]
  %22 = insertvalue { i16 } undef, i16 %21, 0
  %23 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %22, 1
  store { i1, { i16 } } %23, ptr %9, align 2
  %24 = load { i64, [24 x i8] }, ptr %9, align 8
  %25 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %19, 0
  %26 = insertvalue { i64, { i64, [24 x i8] } } %25, { i64, [24 x i8] } %24, 1
  ret { i64, { i64, [24 x i8] } } %26

27:                                               ; preds = %11
  %28 = phi i64 [ %13, %11 ]
  %29 = phi i16 [ 0, %11 ]
  %30 = phi i16 [ %12, %11 ]
  %31 = add i64 %28, 1
  %32 = call { i16, i1 } @llvm.ssub.with.overflow.i16(i16 %29, i16 %30)
  %33 = extractvalue { i16, i1 } %32, 0
  %34 = extractvalue { i16, i1 } %32, 1
  br i1 %34, label %38, label %35

35:                                               ; preds = %27
  %36 = icmp sge i16 %33, 0
  %37 = add i64 %28, 3
  br i1 %36, label %40, label %62

38:                                               ; preds = %27
  %39 = icmp sge i16 %33, 0
  br i1 %39, label %70, label %77

40:                                               ; preds = %35
  %41 = phi i64 [ %37, %35 ]
  %42 = phi i16 [ -32768, %35 ]
  %43 = phi i16 [ %33, %35 ]
  %44 = add i64 %41, 1
  %45 = call { i16, i1 } @llvm.uadd.with.overflow.i16(i16 %42, i16 %43)
  %46 = extractvalue { i16, i1 } %45, 0
  %47 = extractvalue { i16, i1 } %45, 1
  br i1 %47, label %55, label %48

48:                                               ; preds = %40
  %49 = phi i16 [ %46, %40 ]
  %50 = insertvalue { i16 } undef, i16 %49, 0
  %51 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %50, 1
  store { i1, { i16 } } %51, ptr %8, align 2
  %52 = load { i64, [24 x i8] }, ptr %8, align 8
  %53 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %44, 0
  %54 = insertvalue { i64, { i64, [24 x i8] } } %53, { i64, [24 x i8] } %52, 1
  ret { i64, { i64, [24 x i8] } } %54

55:                                               ; preds = %40
  %56 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f112"()
  %57 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %56, 0
  %58 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %57, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %58, ptr %7, align 8
  %59 = load { i64, [24 x i8] }, ptr %7, align 8
  %60 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %44, 0
  %61 = insertvalue { i64, { i64, [24 x i8] } } %60, { i64, [24 x i8] } %59, 1
  ret { i64, { i64, [24 x i8] } } %61

62:                                               ; preds = %15, %35
  %63 = phi i64 [ %37, %35 ], [ %19, %15 ]
  %64 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %65 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %64, 0
  %66 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %65, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %66, ptr %6, align 8
  %67 = load { i64, [24 x i8] }, ptr %6, align 8
  %68 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %63, 0
  %69 = insertvalue { i64, { i64, [24 x i8] } } %68, { i64, [24 x i8] } %67, 1
  ret { i64, { i64, [24 x i8] } } %69

70:                                               ; preds = %38
  %71 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f113"()
  %72 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %71, 0
  %73 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %72, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %73, ptr %5, align 8
  %74 = load { i64, [24 x i8] }, ptr %5, align 8
  %75 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %31, 0
  %76 = insertvalue { i64, { i64, [24 x i8] } } %75, { i64, [24 x i8] } %74, 1
  ret { i64, { i64, [24 x i8] } } %76

77:                                               ; preds = %38
  %78 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f114"()
  %79 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %78, 0
  %80 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %79, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %80, ptr %4, align 8
  %81 = load { i64, [24 x i8] }, ptr %4, align 8
  %82 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %31, 0
  %83 = insertvalue { i64, { i64, [24 x i8] } } %82, { i64, [24 x i8] } %81, 1
  ret { i64, { i64, [24 x i8] } } %83

84:                                               ; preds = %2
  %85 = phi i16 [ -1, %2 ]
  %86 = insertvalue { i16 } undef, i16 %85, 0
  %87 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %86, 1
  store { i1, { i16 } } %87, ptr %3, align 2
  %88 = load { i64, [24 x i8] }, ptr %3, align 8
  %89 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %0, 0
  %90 = insertvalue { i64, { i64, [24 x i8] } } %89, { i64, [24 x i8] } %88, 1
  ret { i64, { i64, [24 x i8] } } %90
}

define private { i64, { i64, [24 x i8] } } @f87(i64 %0, i16 %1) {
  %3 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f87"(i64 %0, i16 %1)
  %4 = extractvalue { i64, { i64, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { i64, [24 x i8] } } %3, 1
  %6 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %5, 1
  ret { i64, { i64, [24 x i8] } } %7
}

define void @_mlir_ciface_f87(ptr %0, i64 %1, i16 %2) {
  %4 = call { i64, { i64, [24 x i8] } } @f87(i64 %1, i16 %2)
  store { i64, { i64, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private void @"drop$156"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$156"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 20)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 20, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f88"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i32, [4 x i8] }, i64 1, align 4
  %13 = alloca { i16, [6 x i8] }, i64 1, align 2
  br label %14

14:                                               ; preds = %494, %4
  %15 = phi i64 [ %495, %494 ], [ %0, %4 ]
  %16 = phi i64 [ %498, %494 ], [ %1, %4 ]
  %17 = phi { { ptr, i32, i32, i32 } } [ %497, %494 ], [ %2, %4 ]
  %18 = phi { ptr, i32, i32, i32 } [ %502, %494 ], [ %3, %4 ]
  %19 = add i64 %15, 1
  %20 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %21 = call ptr %20()
  %22 = load i64, ptr %21, align 8
  %23 = mul i64 %22, 5990
  %24 = icmp uge i64 %16, %23
  %25 = call i64 @llvm.usub.sat.i64(i64 %16, i64 %23)
  br i1 %24, label %26, label %539

26:                                               ; preds = %14
  %27 = phi { { ptr, i32, i32, i32 } } [ %17, %14 ]
  %28 = extractvalue { { ptr, i32, i32, i32 } } %27, 0
  %29 = extractvalue { ptr, i32, i32, i32 } %28, 1
  %30 = extractvalue { ptr, i32, i32, i32 } %28, 2
  %31 = sub i32 %30, %29
  %32 = icmp uge i32 %31, 1
  br i1 %32, label %33, label %520

33:                                               ; preds = %26
  %34 = extractvalue { ptr, i32, i32, i32 } %28, 0
  %35 = load ptr, ptr %34, align 8
  %36 = zext i32 %29 to i64
  %37 = mul i64 %36, 20
  %38 = getelementptr inbounds i8, ptr %35, i64 %37
  %39 = add i32 %29, 1
  %40 = insertvalue { ptr, i32, i32, i32 } %28, i32 %39, 1
  %41 = call ptr @realloc(ptr null, i64 20)
  call void @llvm.memcpy.p0.p0.i64(ptr %41, ptr %38, i64 20, i1 false)
  %42 = load { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } }, ptr %41, align 4
  call void @free(ptr %41)
  %43 = extractvalue { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %42, 0
  %44 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %40, 0
  %45 = extractvalue { i1, [0 x i8] } %43, 0
  switch i1 %45, label %46 [
    i1 false, label %48
    i1 true, label %103
  ]

46:                                               ; preds = %33
  br i1 false, label %47, label %554

47:                                               ; preds = %46
  unreachable

48:                                               ; preds = %33
  %49 = phi i64 [ %25, %33 ]
  %50 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %51 = call ptr %50()
  %52 = call i64 @llvm.uadd.sat.i64(i64 %49, i64 0)
  %53 = extractvalue { ptr, i32, i32, i32 } %18, 3
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %55, label %69

55:                                               ; preds = %48
  %56 = shl i32 %53, 1
  %57 = call i32 @llvm.umin.i32(i32 %56, i32 1024)
  %58 = add i32 %57, %53
  %59 = call i32 @llvm.umax.i32(i32 %58, i32 8)
  %60 = zext i32 %59 to i64
  %61 = mul i64 %60, 32
  %62 = add i64 %61, 16
  %63 = call ptr @realloc(ptr null, i64 %62)
  store i32 1, ptr %63, align 4
  %64 = getelementptr inbounds i8, ptr %63, i32 4
  store i32 0, ptr %64, align 4
  %65 = getelementptr inbounds i8, ptr %63, i32 16
  %66 = call ptr @realloc(ptr null, i64 8)
  store ptr %65, ptr %66, align 8
  %67 = insertvalue { ptr, i32, i32, i32 } %18, ptr %66, 0
  %68 = insertvalue { ptr, i32, i32, i32 } %67, i32 %59, 3
  br label %90

69:                                               ; preds = %48
  %70 = extractvalue { ptr, i32, i32, i32 } %18, 2
  %71 = icmp ult i32 %70, %53
  br i1 %71, label %72, label %73

72:                                               ; preds = %69
  br label %87

73:                                               ; preds = %69
  %74 = shl i32 %53, 1
  %75 = call i32 @llvm.umin.i32(i32 %74, i32 1024)
  %76 = add i32 %75, %53
  %77 = call i32 @llvm.umax.i32(i32 %76, i32 8)
  %78 = zext i32 %77 to i64
  %79 = mul i64 %78, 32
  %80 = add i64 %79, 16
  %81 = extractvalue { ptr, i32, i32, i32 } %18, 0
  %82 = load ptr, ptr %81, align 8
  %83 = getelementptr inbounds i8, ptr %82, i32 -16
  %84 = call ptr @realloc(ptr %83, i64 %80)
  %85 = getelementptr inbounds i8, ptr %84, i32 16
  store ptr %85, ptr %81, align 8
  %86 = insertvalue { ptr, i32, i32, i32 } %18, i32 %77, 3
  br label %87

87:                                               ; preds = %72, %73
  %88 = phi { ptr, i32, i32, i32 } [ %86, %73 ], [ %18, %72 ]
  br label %89

89:                                               ; preds = %87
  br label %90

90:                                               ; preds = %55, %89
  %91 = phi { ptr, i32, i32, i32 } [ %88, %89 ], [ %68, %55 ]
  br label %92

92:                                               ; preds = %90
  %93 = extractvalue { ptr, i32, i32, i32 } %91, 0
  %94 = load ptr, ptr %93, align 8
  %95 = extractvalue { ptr, i32, i32, i32 } %91, 2
  %96 = zext i32 %95 to i64
  %97 = mul i64 %96, 32
  %98 = getelementptr inbounds i8, ptr %94, i64 %97
  store i252 0, ptr %98, align 16
  %99 = extractvalue { ptr, i32, i32, i32 } %91, 2
  %100 = add i32 %99, 1
  %101 = insertvalue { ptr, i32, i32, i32 } %91, i32 %100, 2
  %102 = getelementptr inbounds i8, ptr %94, i32 -12
  store i32 %100, ptr %102, align 4
  br label %160

103:                                              ; preds = %33
  %104 = phi i64 [ %25, %33 ]
  %105 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %106 = call ptr %105()
  %107 = load i64, ptr %106, align 8
  %108 = mul i64 %107, 100
  %109 = call i64 @llvm.uadd.sat.i64(i64 %104, i64 %108)
  %110 = extractvalue { ptr, i32, i32, i32 } %18, 3
  %111 = icmp eq i32 %110, 0
  br i1 %111, label %112, label %126

112:                                              ; preds = %103
  %113 = shl i32 %110, 1
  %114 = call i32 @llvm.umin.i32(i32 %113, i32 1024)
  %115 = add i32 %114, %110
  %116 = call i32 @llvm.umax.i32(i32 %115, i32 8)
  %117 = zext i32 %116 to i64
  %118 = mul i64 %117, 32
  %119 = add i64 %118, 16
  %120 = call ptr @realloc(ptr null, i64 %119)
  store i32 1, ptr %120, align 4
  %121 = getelementptr inbounds i8, ptr %120, i32 4
  store i32 0, ptr %121, align 4
  %122 = getelementptr inbounds i8, ptr %120, i32 16
  %123 = call ptr @realloc(ptr null, i64 8)
  store ptr %122, ptr %123, align 8
  %124 = insertvalue { ptr, i32, i32, i32 } %18, ptr %123, 0
  %125 = insertvalue { ptr, i32, i32, i32 } %124, i32 %116, 3
  br label %147

126:                                              ; preds = %103
  %127 = extractvalue { ptr, i32, i32, i32 } %18, 2
  %128 = icmp ult i32 %127, %110
  br i1 %128, label %129, label %130

129:                                              ; preds = %126
  br label %144

130:                                              ; preds = %126
  %131 = shl i32 %110, 1
  %132 = call i32 @llvm.umin.i32(i32 %131, i32 1024)
  %133 = add i32 %132, %110
  %134 = call i32 @llvm.umax.i32(i32 %133, i32 8)
  %135 = zext i32 %134 to i64
  %136 = mul i64 %135, 32
  %137 = add i64 %136, 16
  %138 = extractvalue { ptr, i32, i32, i32 } %18, 0
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr inbounds i8, ptr %139, i32 -16
  %141 = call ptr @realloc(ptr %140, i64 %137)
  %142 = getelementptr inbounds i8, ptr %141, i32 16
  store ptr %142, ptr %138, align 8
  %143 = insertvalue { ptr, i32, i32, i32 } %18, i32 %134, 3
  br label %144

144:                                              ; preds = %129, %130
  %145 = phi { ptr, i32, i32, i32 } [ %143, %130 ], [ %18, %129 ]
  br label %146

146:                                              ; preds = %144
  br label %147

147:                                              ; preds = %112, %146
  %148 = phi { ptr, i32, i32, i32 } [ %145, %146 ], [ %125, %112 ]
  br label %149

149:                                              ; preds = %147
  %150 = extractvalue { ptr, i32, i32, i32 } %148, 0
  %151 = load ptr, ptr %150, align 8
  %152 = extractvalue { ptr, i32, i32, i32 } %148, 2
  %153 = zext i32 %152 to i64
  %154 = mul i64 %153, 32
  %155 = getelementptr inbounds i8, ptr %151, i64 %154
  store i252 1, ptr %155, align 16
  %156 = extractvalue { ptr, i32, i32, i32 } %148, 2
  %157 = add i32 %156, 1
  %158 = insertvalue { ptr, i32, i32, i32 } %148, i32 %157, 2
  %159 = getelementptr inbounds i8, ptr %151, i32 -12
  store i32 %157, ptr %159, align 4
  br label %160

160:                                              ; preds = %92, %149
  %161 = phi i64 [ %19, %149 ], [ %19, %92 ]
  %162 = phi { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } [ %42, %149 ], [ %42, %92 ]
  %163 = phi { { ptr, i32, i32, i32 } } [ %44, %149 ], [ %44, %92 ]
  %164 = phi i64 [ %109, %149 ], [ %52, %92 ]
  %165 = phi { ptr, i32, i32, i32 } [ %158, %149 ], [ %101, %92 ]
  %166 = extractvalue { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %162, 1
  store { i32, [4 x i8] } %166, ptr %12, align 4
  %167 = load i2, ptr %12, align 1
  switch i2 %167, label %168 [
    i2 0, label %170
    i2 1, label %226
    i2 -2, label %332
    i2 -1, label %438
  ]

168:                                              ; preds = %160
  br i1 false, label %169, label %555

169:                                              ; preds = %168
  unreachable

170:                                              ; preds = %160
  %171 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %172 = call ptr %171()
  %173 = load i64, ptr %172, align 8
  %174 = mul i64 %173, 200
  %175 = call i64 @llvm.uadd.sat.i64(i64 %164, i64 %174)
  %176 = extractvalue { ptr, i32, i32, i32 } %165, 3
  %177 = icmp eq i32 %176, 0
  br i1 %177, label %178, label %192

178:                                              ; preds = %170
  %179 = shl i32 %176, 1
  %180 = call i32 @llvm.umin.i32(i32 %179, i32 1024)
  %181 = add i32 %180, %176
  %182 = call i32 @llvm.umax.i32(i32 %181, i32 8)
  %183 = zext i32 %182 to i64
  %184 = mul i64 %183, 32
  %185 = add i64 %184, 16
  %186 = call ptr @realloc(ptr null, i64 %185)
  store i32 1, ptr %186, align 4
  %187 = getelementptr inbounds i8, ptr %186, i32 4
  store i32 0, ptr %187, align 4
  %188 = getelementptr inbounds i8, ptr %186, i32 16
  %189 = call ptr @realloc(ptr null, i64 8)
  store ptr %188, ptr %189, align 8
  %190 = insertvalue { ptr, i32, i32, i32 } %165, ptr %189, 0
  %191 = insertvalue { ptr, i32, i32, i32 } %190, i32 %182, 3
  br label %213

192:                                              ; preds = %170
  %193 = extractvalue { ptr, i32, i32, i32 } %165, 2
  %194 = icmp ult i32 %193, %176
  br i1 %194, label %195, label %196

195:                                              ; preds = %192
  br label %210

196:                                              ; preds = %192
  %197 = shl i32 %176, 1
  %198 = call i32 @llvm.umin.i32(i32 %197, i32 1024)
  %199 = add i32 %198, %176
  %200 = call i32 @llvm.umax.i32(i32 %199, i32 8)
  %201 = zext i32 %200 to i64
  %202 = mul i64 %201, 32
  %203 = add i64 %202, 16
  %204 = extractvalue { ptr, i32, i32, i32 } %165, 0
  %205 = load ptr, ptr %204, align 8
  %206 = getelementptr inbounds i8, ptr %205, i32 -16
  %207 = call ptr @realloc(ptr %206, i64 %203)
  %208 = getelementptr inbounds i8, ptr %207, i32 16
  store ptr %208, ptr %204, align 8
  %209 = insertvalue { ptr, i32, i32, i32 } %165, i32 %200, 3
  br label %210

210:                                              ; preds = %195, %196
  %211 = phi { ptr, i32, i32, i32 } [ %209, %196 ], [ %165, %195 ]
  br label %212

212:                                              ; preds = %210
  br label %213

213:                                              ; preds = %178, %212
  %214 = phi { ptr, i32, i32, i32 } [ %211, %212 ], [ %191, %178 ]
  br label %215

215:                                              ; preds = %213
  %216 = extractvalue { ptr, i32, i32, i32 } %214, 0
  %217 = load ptr, ptr %216, align 8
  %218 = extractvalue { ptr, i32, i32, i32 } %214, 2
  %219 = zext i32 %218 to i64
  %220 = mul i64 %219, 32
  %221 = getelementptr inbounds i8, ptr %217, i64 %220
  store i252 0, ptr %221, align 16
  %222 = extractvalue { ptr, i32, i32, i32 } %214, 2
  %223 = add i32 %222, 1
  %224 = insertvalue { ptr, i32, i32, i32 } %214, i32 %223, 2
  %225 = getelementptr inbounds i8, ptr %217, i32 -12
  store i32 %223, ptr %225, align 4
  br label %494

226:                                              ; preds = %160
  %227 = load { i2, i32 }, ptr %12, align 4
  %228 = extractvalue { i2, i32 } %227, 1
  %229 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %230 = call ptr %229()
  %231 = call i64 @llvm.uadd.sat.i64(i64 %164, i64 0)
  %232 = zext i32 %228 to i252
  %233 = extractvalue { ptr, i32, i32, i32 } %165, 3
  %234 = icmp eq i32 %233, 0
  br i1 %234, label %235, label %249

235:                                              ; preds = %226
  %236 = shl i32 %233, 1
  %237 = call i32 @llvm.umin.i32(i32 %236, i32 1024)
  %238 = add i32 %237, %233
  %239 = call i32 @llvm.umax.i32(i32 %238, i32 8)
  %240 = zext i32 %239 to i64
  %241 = mul i64 %240, 32
  %242 = add i64 %241, 16
  %243 = call ptr @realloc(ptr null, i64 %242)
  store i32 1, ptr %243, align 4
  %244 = getelementptr inbounds i8, ptr %243, i32 4
  store i32 0, ptr %244, align 4
  %245 = getelementptr inbounds i8, ptr %243, i32 16
  %246 = call ptr @realloc(ptr null, i64 8)
  store ptr %245, ptr %246, align 8
  %247 = insertvalue { ptr, i32, i32, i32 } %165, ptr %246, 0
  %248 = insertvalue { ptr, i32, i32, i32 } %247, i32 %239, 3
  br label %270

249:                                              ; preds = %226
  %250 = extractvalue { ptr, i32, i32, i32 } %165, 2
  %251 = icmp ult i32 %250, %233
  br i1 %251, label %252, label %253

252:                                              ; preds = %249
  br label %267

253:                                              ; preds = %249
  %254 = shl i32 %233, 1
  %255 = call i32 @llvm.umin.i32(i32 %254, i32 1024)
  %256 = add i32 %255, %233
  %257 = call i32 @llvm.umax.i32(i32 %256, i32 8)
  %258 = zext i32 %257 to i64
  %259 = mul i64 %258, 32
  %260 = add i64 %259, 16
  %261 = extractvalue { ptr, i32, i32, i32 } %165, 0
  %262 = load ptr, ptr %261, align 8
  %263 = getelementptr inbounds i8, ptr %262, i32 -16
  %264 = call ptr @realloc(ptr %263, i64 %260)
  %265 = getelementptr inbounds i8, ptr %264, i32 16
  store ptr %265, ptr %261, align 8
  %266 = insertvalue { ptr, i32, i32, i32 } %165, i32 %257, 3
  br label %267

267:                                              ; preds = %252, %253
  %268 = phi { ptr, i32, i32, i32 } [ %266, %253 ], [ %165, %252 ]
  br label %269

269:                                              ; preds = %267
  br label %270

270:                                              ; preds = %235, %269
  %271 = phi { ptr, i32, i32, i32 } [ %268, %269 ], [ %248, %235 ]
  br label %272

272:                                              ; preds = %270
  %273 = extractvalue { ptr, i32, i32, i32 } %271, 0
  %274 = load ptr, ptr %273, align 8
  %275 = extractvalue { ptr, i32, i32, i32 } %271, 2
  %276 = zext i32 %275 to i64
  %277 = mul i64 %276, 32
  %278 = getelementptr inbounds i8, ptr %274, i64 %277
  store i252 1, ptr %278, align 16
  %279 = extractvalue { ptr, i32, i32, i32 } %271, 2
  %280 = add i32 %279, 1
  %281 = insertvalue { ptr, i32, i32, i32 } %271, i32 %280, 2
  %282 = getelementptr inbounds i8, ptr %274, i32 -12
  store i32 %280, ptr %282, align 4
  %283 = extractvalue { ptr, i32, i32, i32 } %271, 3
  %284 = icmp eq i32 %283, 0
  br i1 %284, label %285, label %299

285:                                              ; preds = %272
  %286 = shl i32 %283, 1
  %287 = call i32 @llvm.umin.i32(i32 %286, i32 1024)
  %288 = add i32 %287, %283
  %289 = call i32 @llvm.umax.i32(i32 %288, i32 8)
  %290 = zext i32 %289 to i64
  %291 = mul i64 %290, 32
  %292 = add i64 %291, 16
  %293 = call ptr @realloc(ptr null, i64 %292)
  store i32 1, ptr %293, align 4
  %294 = getelementptr inbounds i8, ptr %293, i32 4
  store i32 0, ptr %294, align 4
  %295 = getelementptr inbounds i8, ptr %293, i32 16
  %296 = call ptr @realloc(ptr null, i64 8)
  store ptr %295, ptr %296, align 8
  %297 = insertvalue { ptr, i32, i32, i32 } %281, ptr %296, 0
  %298 = insertvalue { ptr, i32, i32, i32 } %297, i32 %289, 3
  br label %319

299:                                              ; preds = %272
  %300 = icmp ult i32 %280, %283
  br i1 %300, label %301, label %302

301:                                              ; preds = %299
  br label %316

302:                                              ; preds = %299
  %303 = shl i32 %283, 1
  %304 = call i32 @llvm.umin.i32(i32 %303, i32 1024)
  %305 = add i32 %304, %283
  %306 = call i32 @llvm.umax.i32(i32 %305, i32 8)
  %307 = zext i32 %306 to i64
  %308 = mul i64 %307, 32
  %309 = add i64 %308, 16
  %310 = extractvalue { ptr, i32, i32, i32 } %271, 0
  %311 = load ptr, ptr %310, align 8
  %312 = getelementptr inbounds i8, ptr %311, i32 -16
  %313 = call ptr @realloc(ptr %312, i64 %309)
  %314 = getelementptr inbounds i8, ptr %313, i32 16
  store ptr %314, ptr %310, align 8
  %315 = insertvalue { ptr, i32, i32, i32 } %281, i32 %306, 3
  br label %316

316:                                              ; preds = %301, %302
  %317 = phi { ptr, i32, i32, i32 } [ %315, %302 ], [ %281, %301 ]
  br label %318

318:                                              ; preds = %316
  br label %319

319:                                              ; preds = %285, %318
  %320 = phi { ptr, i32, i32, i32 } [ %317, %318 ], [ %298, %285 ]
  br label %321

321:                                              ; preds = %319
  %322 = extractvalue { ptr, i32, i32, i32 } %320, 0
  %323 = load ptr, ptr %322, align 8
  %324 = extractvalue { ptr, i32, i32, i32 } %320, 2
  %325 = zext i32 %324 to i64
  %326 = mul i64 %325, 32
  %327 = getelementptr inbounds i8, ptr %323, i64 %326
  store i252 %232, ptr %327, align 16
  %328 = extractvalue { ptr, i32, i32, i32 } %320, 2
  %329 = add i32 %328, 1
  %330 = insertvalue { ptr, i32, i32, i32 } %320, i32 %329, 2
  %331 = getelementptr inbounds i8, ptr %323, i32 -12
  store i32 %329, ptr %331, align 4
  br label %494

332:                                              ; preds = %160
  %333 = load { i2, i32 }, ptr %12, align 4
  %334 = extractvalue { i2, i32 } %333, 1
  %335 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %336 = call ptr %335()
  %337 = call i64 @llvm.uadd.sat.i64(i64 %164, i64 0)
  %338 = zext i32 %334 to i252
  %339 = extractvalue { ptr, i32, i32, i32 } %165, 3
  %340 = icmp eq i32 %339, 0
  br i1 %340, label %341, label %355

341:                                              ; preds = %332
  %342 = shl i32 %339, 1
  %343 = call i32 @llvm.umin.i32(i32 %342, i32 1024)
  %344 = add i32 %343, %339
  %345 = call i32 @llvm.umax.i32(i32 %344, i32 8)
  %346 = zext i32 %345 to i64
  %347 = mul i64 %346, 32
  %348 = add i64 %347, 16
  %349 = call ptr @realloc(ptr null, i64 %348)
  store i32 1, ptr %349, align 4
  %350 = getelementptr inbounds i8, ptr %349, i32 4
  store i32 0, ptr %350, align 4
  %351 = getelementptr inbounds i8, ptr %349, i32 16
  %352 = call ptr @realloc(ptr null, i64 8)
  store ptr %351, ptr %352, align 8
  %353 = insertvalue { ptr, i32, i32, i32 } %165, ptr %352, 0
  %354 = insertvalue { ptr, i32, i32, i32 } %353, i32 %345, 3
  br label %376

355:                                              ; preds = %332
  %356 = extractvalue { ptr, i32, i32, i32 } %165, 2
  %357 = icmp ult i32 %356, %339
  br i1 %357, label %358, label %359

358:                                              ; preds = %355
  br label %373

359:                                              ; preds = %355
  %360 = shl i32 %339, 1
  %361 = call i32 @llvm.umin.i32(i32 %360, i32 1024)
  %362 = add i32 %361, %339
  %363 = call i32 @llvm.umax.i32(i32 %362, i32 8)
  %364 = zext i32 %363 to i64
  %365 = mul i64 %364, 32
  %366 = add i64 %365, 16
  %367 = extractvalue { ptr, i32, i32, i32 } %165, 0
  %368 = load ptr, ptr %367, align 8
  %369 = getelementptr inbounds i8, ptr %368, i32 -16
  %370 = call ptr @realloc(ptr %369, i64 %366)
  %371 = getelementptr inbounds i8, ptr %370, i32 16
  store ptr %371, ptr %367, align 8
  %372 = insertvalue { ptr, i32, i32, i32 } %165, i32 %363, 3
  br label %373

373:                                              ; preds = %358, %359
  %374 = phi { ptr, i32, i32, i32 } [ %372, %359 ], [ %165, %358 ]
  br label %375

375:                                              ; preds = %373
  br label %376

376:                                              ; preds = %341, %375
  %377 = phi { ptr, i32, i32, i32 } [ %374, %375 ], [ %354, %341 ]
  br label %378

378:                                              ; preds = %376
  %379 = extractvalue { ptr, i32, i32, i32 } %377, 0
  %380 = load ptr, ptr %379, align 8
  %381 = extractvalue { ptr, i32, i32, i32 } %377, 2
  %382 = zext i32 %381 to i64
  %383 = mul i64 %382, 32
  %384 = getelementptr inbounds i8, ptr %380, i64 %383
  store i252 2, ptr %384, align 16
  %385 = extractvalue { ptr, i32, i32, i32 } %377, 2
  %386 = add i32 %385, 1
  %387 = insertvalue { ptr, i32, i32, i32 } %377, i32 %386, 2
  %388 = getelementptr inbounds i8, ptr %380, i32 -12
  store i32 %386, ptr %388, align 4
  %389 = extractvalue { ptr, i32, i32, i32 } %377, 3
  %390 = icmp eq i32 %389, 0
  br i1 %390, label %391, label %405

391:                                              ; preds = %378
  %392 = shl i32 %389, 1
  %393 = call i32 @llvm.umin.i32(i32 %392, i32 1024)
  %394 = add i32 %393, %389
  %395 = call i32 @llvm.umax.i32(i32 %394, i32 8)
  %396 = zext i32 %395 to i64
  %397 = mul i64 %396, 32
  %398 = add i64 %397, 16
  %399 = call ptr @realloc(ptr null, i64 %398)
  store i32 1, ptr %399, align 4
  %400 = getelementptr inbounds i8, ptr %399, i32 4
  store i32 0, ptr %400, align 4
  %401 = getelementptr inbounds i8, ptr %399, i32 16
  %402 = call ptr @realloc(ptr null, i64 8)
  store ptr %401, ptr %402, align 8
  %403 = insertvalue { ptr, i32, i32, i32 } %387, ptr %402, 0
  %404 = insertvalue { ptr, i32, i32, i32 } %403, i32 %395, 3
  br label %425

405:                                              ; preds = %378
  %406 = icmp ult i32 %386, %389
  br i1 %406, label %407, label %408

407:                                              ; preds = %405
  br label %422

408:                                              ; preds = %405
  %409 = shl i32 %389, 1
  %410 = call i32 @llvm.umin.i32(i32 %409, i32 1024)
  %411 = add i32 %410, %389
  %412 = call i32 @llvm.umax.i32(i32 %411, i32 8)
  %413 = zext i32 %412 to i64
  %414 = mul i64 %413, 32
  %415 = add i64 %414, 16
  %416 = extractvalue { ptr, i32, i32, i32 } %377, 0
  %417 = load ptr, ptr %416, align 8
  %418 = getelementptr inbounds i8, ptr %417, i32 -16
  %419 = call ptr @realloc(ptr %418, i64 %415)
  %420 = getelementptr inbounds i8, ptr %419, i32 16
  store ptr %420, ptr %416, align 8
  %421 = insertvalue { ptr, i32, i32, i32 } %387, i32 %412, 3
  br label %422

422:                                              ; preds = %407, %408
  %423 = phi { ptr, i32, i32, i32 } [ %421, %408 ], [ %387, %407 ]
  br label %424

424:                                              ; preds = %422
  br label %425

425:                                              ; preds = %391, %424
  %426 = phi { ptr, i32, i32, i32 } [ %423, %424 ], [ %404, %391 ]
  br label %427

427:                                              ; preds = %425
  %428 = extractvalue { ptr, i32, i32, i32 } %426, 0
  %429 = load ptr, ptr %428, align 8
  %430 = extractvalue { ptr, i32, i32, i32 } %426, 2
  %431 = zext i32 %430 to i64
  %432 = mul i64 %431, 32
  %433 = getelementptr inbounds i8, ptr %429, i64 %432
  store i252 %338, ptr %433, align 16
  %434 = extractvalue { ptr, i32, i32, i32 } %426, 2
  %435 = add i32 %434, 1
  %436 = insertvalue { ptr, i32, i32, i32 } %426, i32 %435, 2
  %437 = getelementptr inbounds i8, ptr %429, i32 -12
  store i32 %435, ptr %437, align 4
  br label %494

438:                                              ; preds = %160
  %439 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %440 = call ptr %439()
  %441 = load i64, ptr %440, align 8
  %442 = mul i64 %441, 200
  %443 = call i64 @llvm.uadd.sat.i64(i64 %164, i64 %442)
  %444 = extractvalue { ptr, i32, i32, i32 } %165, 3
  %445 = icmp eq i32 %444, 0
  br i1 %445, label %446, label %460

446:                                              ; preds = %438
  %447 = shl i32 %444, 1
  %448 = call i32 @llvm.umin.i32(i32 %447, i32 1024)
  %449 = add i32 %448, %444
  %450 = call i32 @llvm.umax.i32(i32 %449, i32 8)
  %451 = zext i32 %450 to i64
  %452 = mul i64 %451, 32
  %453 = add i64 %452, 16
  %454 = call ptr @realloc(ptr null, i64 %453)
  store i32 1, ptr %454, align 4
  %455 = getelementptr inbounds i8, ptr %454, i32 4
  store i32 0, ptr %455, align 4
  %456 = getelementptr inbounds i8, ptr %454, i32 16
  %457 = call ptr @realloc(ptr null, i64 8)
  store ptr %456, ptr %457, align 8
  %458 = insertvalue { ptr, i32, i32, i32 } %165, ptr %457, 0
  %459 = insertvalue { ptr, i32, i32, i32 } %458, i32 %450, 3
  br label %481

460:                                              ; preds = %438
  %461 = extractvalue { ptr, i32, i32, i32 } %165, 2
  %462 = icmp ult i32 %461, %444
  br i1 %462, label %463, label %464

463:                                              ; preds = %460
  br label %478

464:                                              ; preds = %460
  %465 = shl i32 %444, 1
  %466 = call i32 @llvm.umin.i32(i32 %465, i32 1024)
  %467 = add i32 %466, %444
  %468 = call i32 @llvm.umax.i32(i32 %467, i32 8)
  %469 = zext i32 %468 to i64
  %470 = mul i64 %469, 32
  %471 = add i64 %470, 16
  %472 = extractvalue { ptr, i32, i32, i32 } %165, 0
  %473 = load ptr, ptr %472, align 8
  %474 = getelementptr inbounds i8, ptr %473, i32 -16
  %475 = call ptr @realloc(ptr %474, i64 %471)
  %476 = getelementptr inbounds i8, ptr %475, i32 16
  store ptr %476, ptr %472, align 8
  %477 = insertvalue { ptr, i32, i32, i32 } %165, i32 %468, 3
  br label %478

478:                                              ; preds = %463, %464
  %479 = phi { ptr, i32, i32, i32 } [ %477, %464 ], [ %165, %463 ]
  br label %480

480:                                              ; preds = %478
  br label %481

481:                                              ; preds = %446, %480
  %482 = phi { ptr, i32, i32, i32 } [ %479, %480 ], [ %459, %446 ]
  br label %483

483:                                              ; preds = %481
  %484 = extractvalue { ptr, i32, i32, i32 } %482, 0
  %485 = load ptr, ptr %484, align 8
  %486 = extractvalue { ptr, i32, i32, i32 } %482, 2
  %487 = zext i32 %486 to i64
  %488 = mul i64 %487, 32
  %489 = getelementptr inbounds i8, ptr %485, i64 %488
  store i252 3, ptr %489, align 16
  %490 = extractvalue { ptr, i32, i32, i32 } %482, 2
  %491 = add i32 %490, 1
  %492 = insertvalue { ptr, i32, i32, i32 } %482, i32 %491, 2
  %493 = getelementptr inbounds i8, ptr %485, i32 -12
  store i32 %491, ptr %493, align 4
  br label %494

494:                                              ; preds = %215, %321, %427, %483
  %495 = phi i64 [ %161, %483 ], [ %161, %427 ], [ %161, %321 ], [ %161, %215 ]
  %496 = phi { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } [ %162, %483 ], [ %162, %427 ], [ %162, %321 ], [ %162, %215 ]
  %497 = phi { { ptr, i32, i32, i32 } } [ %163, %483 ], [ %163, %427 ], [ %163, %321 ], [ %163, %215 ]
  %498 = phi i64 [ %443, %483 ], [ %337, %427 ], [ %231, %321 ], [ %175, %215 ]
  %499 = phi { ptr, i32, i32, i32 } [ %492, %483 ], [ %436, %427 ], [ %330, %321 ], [ %224, %215 ]
  %500 = extractvalue { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %496, 2
  store { i16, [6 x i8] } %500, ptr %13, align 2
  %501 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f115"(ptr %13, { ptr, i32, i32, i32 } %499)
  %502 = extractvalue { { ptr, i32, i32, i32 } } %501, 0
  %503 = extractvalue { ptr, ptr, i64 } %8, 1
  %504 = load i64, ptr %503, align 8
  %505 = add i64 %504, 1
  %506 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %505, ptr %506, align 8
  br label %14

507:                                              ; preds = %507, %520, %539
  %508 = phi i64 [ %19, %539 ], [ %19, %520 ], [ %508, %507 ]
  %509 = phi i64 [ %16, %539 ], [ %526, %520 ], [ %509, %507 ]
  %510 = phi { i64, [24 x i8] } [ %544, %539 ], [ %529, %520 ], [ %510, %507 ]
  %511 = extractvalue { ptr, ptr, i64 } %8, 1
  %512 = load i64, ptr %511, align 8
  %513 = icmp eq i64 %512, 0
  %514 = sub i64 %512, 1
  %515 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %514, ptr %515, align 8
  br i1 %513, label %516, label %507

516:                                              ; preds = %507
  %517 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %508, 0
  %518 = insertvalue { i64, i64, { i64, [24 x i8] } } %517, i64 %509, 1
  %519 = insertvalue { i64, i64, { i64, [24 x i8] } } %518, { i64, [24 x i8] } %510, 2
  ret { i64, i64, { i64, [24 x i8] } } %519

520:                                              ; preds = %26
  %521 = phi { ptr, i32, i32, i32 } [ %28, %26 ]
  call void @"drop$38"({ ptr, i32, i32, i32 } %521)
  %522 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %523 = call ptr %522()
  %524 = load i64, ptr %523, align 8
  %525 = mul i64 %524, 6690
  %526 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %525)
  %527 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %18, 0
  %528 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %527, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %528, ptr %11, align 8
  %529 = load { i64, [24 x i8] }, ptr %11, align 8
  %530 = extractvalue { ptr, ptr, i64 } %8, 1
  %531 = load i64, ptr %530, align 8
  %532 = icmp eq i64 %531, 0
  %533 = sub i64 %531, 1
  %534 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %533, ptr %534, align 8
  br i1 %532, label %535, label %507

535:                                              ; preds = %520
  %536 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %19, 0
  %537 = insertvalue { i64, i64, { i64, [24 x i8] } } %536, i64 %526, 1
  %538 = insertvalue { i64, i64, { i64, [24 x i8] } } %537, { i64, [24 x i8] } %529, 2
  ret { i64, i64, { i64, [24 x i8] } } %538

539:                                              ; preds = %14
  %540 = phi { { ptr, i32, i32, i32 } } [ %17, %14 ]
  call void @"drop$39"({ { ptr, i32, i32, i32 } } %540)
  call void @"drop$2"({ ptr, i32, i32, i32 } %18)
  %541 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %542 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %541, 0
  %543 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %542, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %543, ptr %10, align 8
  %544 = load { i64, [24 x i8] }, ptr %10, align 8
  %545 = extractvalue { ptr, ptr, i64 } %8, 1
  %546 = load i64, ptr %545, align 8
  %547 = icmp eq i64 %546, 0
  %548 = sub i64 %546, 1
  %549 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %548, ptr %549, align 8
  br i1 %547, label %550, label %507

550:                                              ; preds = %539
  %551 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %19, 0
  %552 = insertvalue { i64, i64, { i64, [24 x i8] } } %551, i64 %16, 1
  %553 = insertvalue { i64, i64, { i64, [24 x i8] } } %552, { i64, [24 x i8] } %544, 2
  ret { i64, i64, { i64, [24 x i8] } } %553

554:                                              ; preds = %46
  call void @puts(ptr @assert_msg_153)
  call void @abort()
  unreachable

555:                                              ; preds = %168
  call void @puts(ptr @assert_msg_154)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f88(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f88"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f88(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f88(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$152"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$152"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 96)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 96, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f89"(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i1, [31 x i8] }, i64 1, align 8
  %12 = alloca i64, i64 1, align 8
  %13 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %14 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5, 0
  %18 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5, 1
  %19 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5, 2
  %20 = extractvalue { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5, 3
  %21 = extractvalue { i3, [0 x i8] } %17, 0
  switch i3 %21, label %22 [
    i3 0, label %24
    i3 1, label %40
    i3 2, label %54
    i3 3, label %68
    i3 -4, label %82
    i3 -3, label %96
    i3 -2, label %110
  ]

22:                                               ; preds = %6
  br i1 false, label %23, label %1053

23:                                               ; preds = %22
  unreachable

24:                                               ; preds = %6
  %25 = phi i64 [ %1, %6 ]
  %26 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %27 = call ptr %26()
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %28, 100
  %30 = call i64 @llvm.uadd.sat.i64(i64 %25, i64 %29)
  %31 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %31, align 4
  %32 = getelementptr inbounds i8, ptr %31, i32 4
  store i32 0, ptr %32, align 4
  %33 = getelementptr inbounds i8, ptr %31, i32 16
  %34 = call ptr @realloc(ptr null, i64 8)
  store ptr %33, ptr %34, align 8
  %35 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %34, 0
  %36 = insertvalue { ptr, i32, i32, i32 } %35, i32 8, 3
  %37 = load ptr, ptr %34, align 8
  store i252 0, ptr %37, align 16
  %38 = insertvalue { ptr, i32, i32, i32 } %36, i32 1, 2
  %39 = getelementptr inbounds i8, ptr %37, i32 -12
  store i32 1, ptr %39, align 4
  br label %126

40:                                               ; preds = %6
  %41 = phi i64 [ %1, %6 ]
  %42 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %43 = call ptr %42()
  %44 = call i64 @llvm.uadd.sat.i64(i64 %41, i64 0)
  %45 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %45, align 4
  %46 = getelementptr inbounds i8, ptr %45, i32 4
  store i32 0, ptr %46, align 4
  %47 = getelementptr inbounds i8, ptr %45, i32 16
  %48 = call ptr @realloc(ptr null, i64 8)
  store ptr %47, ptr %48, align 8
  %49 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %48, 0
  %50 = insertvalue { ptr, i32, i32, i32 } %49, i32 8, 3
  %51 = load ptr, ptr %48, align 8
  store i252 1, ptr %51, align 16
  %52 = insertvalue { ptr, i32, i32, i32 } %50, i32 1, 2
  %53 = getelementptr inbounds i8, ptr %51, i32 -12
  store i32 1, ptr %53, align 4
  br label %126

54:                                               ; preds = %6
  %55 = phi i64 [ %1, %6 ]
  %56 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %57 = call ptr %56()
  %58 = call i64 @llvm.uadd.sat.i64(i64 %55, i64 0)
  %59 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %59, align 4
  %60 = getelementptr inbounds i8, ptr %59, i32 4
  store i32 0, ptr %60, align 4
  %61 = getelementptr inbounds i8, ptr %59, i32 16
  %62 = call ptr @realloc(ptr null, i64 8)
  store ptr %61, ptr %62, align 8
  %63 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %62, 0
  %64 = insertvalue { ptr, i32, i32, i32 } %63, i32 8, 3
  %65 = load ptr, ptr %62, align 8
  store i252 2, ptr %65, align 16
  %66 = insertvalue { ptr, i32, i32, i32 } %64, i32 1, 2
  %67 = getelementptr inbounds i8, ptr %65, i32 -12
  store i32 1, ptr %67, align 4
  br label %126

68:                                               ; preds = %6
  %69 = phi i64 [ %1, %6 ]
  %70 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %71 = call ptr %70()
  %72 = call i64 @llvm.uadd.sat.i64(i64 %69, i64 0)
  %73 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %73, align 4
  %74 = getelementptr inbounds i8, ptr %73, i32 4
  store i32 0, ptr %74, align 4
  %75 = getelementptr inbounds i8, ptr %73, i32 16
  %76 = call ptr @realloc(ptr null, i64 8)
  store ptr %75, ptr %76, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %76, 0
  %78 = insertvalue { ptr, i32, i32, i32 } %77, i32 8, 3
  %79 = load ptr, ptr %76, align 8
  store i252 3, ptr %79, align 16
  %80 = insertvalue { ptr, i32, i32, i32 } %78, i32 1, 2
  %81 = getelementptr inbounds i8, ptr %79, i32 -12
  store i32 1, ptr %81, align 4
  br label %126

82:                                               ; preds = %6
  %83 = phi i64 [ %1, %6 ]
  %84 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %85 = call ptr %84()
  %86 = call i64 @llvm.uadd.sat.i64(i64 %83, i64 0)
  %87 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %87, i32 4
  store i32 0, ptr %88, align 4
  %89 = getelementptr inbounds i8, ptr %87, i32 16
  %90 = call ptr @realloc(ptr null, i64 8)
  store ptr %89, ptr %90, align 8
  %91 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %90, 0
  %92 = insertvalue { ptr, i32, i32, i32 } %91, i32 8, 3
  %93 = load ptr, ptr %90, align 8
  store i252 4, ptr %93, align 16
  %94 = insertvalue { ptr, i32, i32, i32 } %92, i32 1, 2
  %95 = getelementptr inbounds i8, ptr %93, i32 -12
  store i32 1, ptr %95, align 4
  br label %126

96:                                               ; preds = %6
  %97 = phi i64 [ %1, %6 ]
  %98 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %99 = call ptr %98()
  %100 = call i64 @llvm.uadd.sat.i64(i64 %97, i64 0)
  %101 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %101, align 4
  %102 = getelementptr inbounds i8, ptr %101, i32 4
  store i32 0, ptr %102, align 4
  %103 = getelementptr inbounds i8, ptr %101, i32 16
  %104 = call ptr @realloc(ptr null, i64 8)
  store ptr %103, ptr %104, align 8
  %105 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %104, 0
  %106 = insertvalue { ptr, i32, i32, i32 } %105, i32 8, 3
  %107 = load ptr, ptr %104, align 8
  store i252 5, ptr %107, align 16
  %108 = insertvalue { ptr, i32, i32, i32 } %106, i32 1, 2
  %109 = getelementptr inbounds i8, ptr %107, i32 -12
  store i32 1, ptr %109, align 4
  br label %126

110:                                              ; preds = %6
  %111 = phi i64 [ %1, %6 ]
  %112 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %113 = call ptr %112()
  %114 = load i64, ptr %113, align 8
  %115 = mul i64 %114, 100
  %116 = call i64 @llvm.uadd.sat.i64(i64 %111, i64 %115)
  %117 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %117, align 4
  %118 = getelementptr inbounds i8, ptr %117, i32 4
  store i32 0, ptr %118, align 4
  %119 = getelementptr inbounds i8, ptr %117, i32 16
  %120 = call ptr @realloc(ptr null, i64 8)
  store ptr %119, ptr %120, align 8
  %121 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %120, 0
  %122 = insertvalue { ptr, i32, i32, i32 } %121, i32 8, 3
  %123 = load ptr, ptr %120, align 8
  store i252 6, ptr %123, align 16
  %124 = insertvalue { ptr, i32, i32, i32 } %122, i32 1, 2
  %125 = getelementptr inbounds i8, ptr %123, i32 -12
  store i32 1, ptr %125, align 4
  br label %126

126:                                              ; preds = %24, %40, %54, %68, %82, %96, %110
  %127 = phi i64 [ %0, %110 ], [ %0, %96 ], [ %0, %82 ], [ %0, %68 ], [ %0, %54 ], [ %0, %40 ], [ %0, %24 ]
  %128 = phi ptr [ %2, %110 ], [ %2, %96 ], [ %2, %82 ], [ %2, %68 ], [ %2, %54 ], [ %2, %40 ], [ %2, %24 ]
  %129 = phi i252 [ %3, %110 ], [ %3, %96 ], [ %3, %82 ], [ %3, %68 ], [ %3, %54 ], [ %3, %40 ], [ %3, %24 ]
  %130 = phi i252 [ %4, %110 ], [ %4, %96 ], [ %4, %82 ], [ %4, %68 ], [ %4, %54 ], [ %4, %40 ], [ %4, %24 ]
  %131 = phi i32 [ %18, %110 ], [ %18, %96 ], [ %18, %82 ], [ %18, %68 ], [ %18, %54 ], [ %18, %40 ], [ %18, %24 ]
  %132 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %19, %110 ], [ %19, %96 ], [ %19, %82 ], [ %19, %68 ], [ %19, %54 ], [ %19, %40 ], [ %19, %24 ]
  %133 = phi { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } [ %20, %110 ], [ %20, %96 ], [ %20, %82 ], [ %20, %68 ], [ %20, %54 ], [ %20, %40 ], [ %20, %24 ]
  %134 = phi i64 [ %116, %110 ], [ %100, %96 ], [ %86, %82 ], [ %72, %68 ], [ %58, %54 ], [ %44, %40 ], [ %30, %24 ]
  %135 = phi { ptr, i32, i32, i32 } [ %124, %110 ], [ %108, %96 ], [ %94, %82 ], [ %80, %68 ], [ %66, %54 ], [ %52, %40 ], [ %38, %24 ]
  %136 = zext i32 %131 to i252
  %137 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %132)
  %138 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %137, 0
  %139 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %137, 1
  %140 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %139, 0
  %141 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %140)
  %142 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %141, 0
  %143 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %141, 1
  %144 = extractvalue { ptr, i32, i32, i32 } %143, 1
  %145 = extractvalue { ptr, i32, i32, i32 } %143, 2
  %146 = sub i32 %145, %144
  call void @"drop$43"({ ptr, i32, i32, i32 } %143)
  %147 = zext i32 %146 to i252
  %148 = extractvalue { ptr, i32, i32, i32 } %135, 3
  %149 = icmp eq i32 %148, 0
  br i1 %149, label %150, label %164

150:                                              ; preds = %126
  %151 = shl i32 %148, 1
  %152 = call i32 @llvm.umin.i32(i32 %151, i32 1024)
  %153 = add i32 %152, %148
  %154 = call i32 @llvm.umax.i32(i32 %153, i32 8)
  %155 = zext i32 %154 to i64
  %156 = mul i64 %155, 32
  %157 = add i64 %156, 16
  %158 = call ptr @realloc(ptr null, i64 %157)
  store i32 1, ptr %158, align 4
  %159 = getelementptr inbounds i8, ptr %158, i32 4
  store i32 0, ptr %159, align 4
  %160 = getelementptr inbounds i8, ptr %158, i32 16
  %161 = call ptr @realloc(ptr null, i64 8)
  store ptr %160, ptr %161, align 8
  %162 = insertvalue { ptr, i32, i32, i32 } %135, ptr %161, 0
  %163 = insertvalue { ptr, i32, i32, i32 } %162, i32 %154, 3
  br label %185

164:                                              ; preds = %126
  %165 = extractvalue { ptr, i32, i32, i32 } %135, 2
  %166 = icmp ult i32 %165, %148
  br i1 %166, label %167, label %168

167:                                              ; preds = %164
  br label %182

168:                                              ; preds = %164
  %169 = shl i32 %148, 1
  %170 = call i32 @llvm.umin.i32(i32 %169, i32 1024)
  %171 = add i32 %170, %148
  %172 = call i32 @llvm.umax.i32(i32 %171, i32 8)
  %173 = zext i32 %172 to i64
  %174 = mul i64 %173, 32
  %175 = add i64 %174, 16
  %176 = extractvalue { ptr, i32, i32, i32 } %135, 0
  %177 = load ptr, ptr %176, align 8
  %178 = getelementptr inbounds i8, ptr %177, i32 -16
  %179 = call ptr @realloc(ptr %178, i64 %175)
  %180 = getelementptr inbounds i8, ptr %179, i32 16
  store ptr %180, ptr %176, align 8
  %181 = insertvalue { ptr, i32, i32, i32 } %135, i32 %172, 3
  br label %182

182:                                              ; preds = %167, %168
  %183 = phi { ptr, i32, i32, i32 } [ %181, %168 ], [ %135, %167 ]
  br label %184

184:                                              ; preds = %182
  br label %185

185:                                              ; preds = %150, %184
  %186 = phi { ptr, i32, i32, i32 } [ %183, %184 ], [ %163, %150 ]
  br label %187

187:                                              ; preds = %185
  %188 = extractvalue { ptr, i32, i32, i32 } %186, 0
  %189 = load ptr, ptr %188, align 8
  %190 = extractvalue { ptr, i32, i32, i32 } %186, 2
  %191 = zext i32 %190 to i64
  %192 = mul i64 %191, 32
  %193 = getelementptr inbounds i8, ptr %189, i64 %192
  store i252 %136, ptr %193, align 16
  %194 = extractvalue { ptr, i32, i32, i32 } %186, 2
  %195 = add i32 %194, 1
  %196 = insertvalue { ptr, i32, i32, i32 } %186, i32 %195, 2
  %197 = getelementptr inbounds i8, ptr %189, i32 -12
  store i32 %195, ptr %197, align 4
  %198 = extractvalue { ptr, i32, i32, i32 } %186, 3
  %199 = icmp eq i32 %198, 0
  br i1 %199, label %200, label %214

200:                                              ; preds = %187
  %201 = shl i32 %198, 1
  %202 = call i32 @llvm.umin.i32(i32 %201, i32 1024)
  %203 = add i32 %202, %198
  %204 = call i32 @llvm.umax.i32(i32 %203, i32 8)
  %205 = zext i32 %204 to i64
  %206 = mul i64 %205, 32
  %207 = add i64 %206, 16
  %208 = call ptr @realloc(ptr null, i64 %207)
  store i32 1, ptr %208, align 4
  %209 = getelementptr inbounds i8, ptr %208, i32 4
  store i32 0, ptr %209, align 4
  %210 = getelementptr inbounds i8, ptr %208, i32 16
  %211 = call ptr @realloc(ptr null, i64 8)
  store ptr %210, ptr %211, align 8
  %212 = insertvalue { ptr, i32, i32, i32 } %196, ptr %211, 0
  %213 = insertvalue { ptr, i32, i32, i32 } %212, i32 %204, 3
  br label %234

214:                                              ; preds = %187
  %215 = icmp ult i32 %195, %198
  br i1 %215, label %216, label %217

216:                                              ; preds = %214
  br label %231

217:                                              ; preds = %214
  %218 = shl i32 %198, 1
  %219 = call i32 @llvm.umin.i32(i32 %218, i32 1024)
  %220 = add i32 %219, %198
  %221 = call i32 @llvm.umax.i32(i32 %220, i32 8)
  %222 = zext i32 %221 to i64
  %223 = mul i64 %222, 32
  %224 = add i64 %223, 16
  %225 = extractvalue { ptr, i32, i32, i32 } %186, 0
  %226 = load ptr, ptr %225, align 8
  %227 = getelementptr inbounds i8, ptr %226, i32 -16
  %228 = call ptr @realloc(ptr %227, i64 %224)
  %229 = getelementptr inbounds i8, ptr %228, i32 16
  store ptr %229, ptr %225, align 8
  %230 = insertvalue { ptr, i32, i32, i32 } %196, i32 %221, 3
  br label %231

231:                                              ; preds = %216, %217
  %232 = phi { ptr, i32, i32, i32 } [ %230, %217 ], [ %196, %216 ]
  br label %233

233:                                              ; preds = %231
  br label %234

234:                                              ; preds = %200, %233
  %235 = phi { ptr, i32, i32, i32 } [ %232, %233 ], [ %213, %200 ]
  br label %236

236:                                              ; preds = %234
  %237 = extractvalue { ptr, i32, i32, i32 } %235, 0
  %238 = load ptr, ptr %237, align 8
  %239 = extractvalue { ptr, i32, i32, i32 } %235, 2
  %240 = zext i32 %239 to i64
  %241 = mul i64 %240, 32
  %242 = getelementptr inbounds i8, ptr %238, i64 %241
  store i252 %147, ptr %242, align 16
  %243 = extractvalue { ptr, i32, i32, i32 } %235, 2
  %244 = add i32 %243, 1
  %245 = insertvalue { ptr, i32, i32, i32 } %235, i32 %244, 2
  %246 = getelementptr inbounds i8, ptr %238, i32 -12
  store i32 %244, ptr %246, align 4
  %247 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %142, 0
  %248 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %127, i64 %134, { { ptr, i32, i32, i32 } } %247, { ptr, i32, i32, i32 } %245)
  %249 = extractvalue { i64, i64, { i64, [24 x i8] } } %248, 0
  %250 = extractvalue { i64, i64, { i64, [24 x i8] } } %248, 1
  %251 = extractvalue { i64, i64, { i64, [24 x i8] } } %248, 2
  store { i64, [24 x i8] } %251, ptr %7, align 8
  %252 = load i1, ptr %7, align 1
  switch i1 %252, label %253 [
    i1 false, label %255
    i1 true, label %997
  ]

253:                                              ; preds = %236
  br i1 false, label %254, label %1054

254:                                              ; preds = %253
  unreachable

255:                                              ; preds = %236
  %256 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %7, align 8
  %257 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %256, 1
  %258 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %138)
  %259 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %258, 0
  %260 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %258, 1
  %261 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %260, 0
  %262 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %260, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %261)
  %263 = zext i32 %262 to i252
  %264 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 0
  %265 = icmp slt i8 %264, 0
  %266 = zext i8 %264 to i252
  %267 = call i8 @llvm.abs.i8(i8 %264, i1 false)
  %268 = zext i8 %267 to i252
  %269 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %268
  %270 = select i1 %265, i252 %269, i252 %266
  %271 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 1
  %272 = icmp slt i8 %271, 0
  %273 = zext i8 %271 to i252
  %274 = call i8 @llvm.abs.i8(i8 %271, i1 false)
  %275 = zext i8 %274 to i252
  %276 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %275
  %277 = select i1 %272, i252 %276, i252 %273
  %278 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 2
  %279 = icmp slt i8 %278, 0
  %280 = zext i8 %278 to i252
  %281 = call i8 @llvm.abs.i8(i8 %278, i1 false)
  %282 = zext i8 %281 to i252
  %283 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %282
  %284 = select i1 %279, i252 %283, i252 %280
  %285 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 3
  %286 = icmp slt i8 %285, 0
  %287 = zext i8 %285 to i252
  %288 = call i8 @llvm.abs.i8(i8 %285, i1 false)
  %289 = zext i8 %288 to i252
  %290 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %289
  %291 = select i1 %286, i252 %290, i252 %287
  %292 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 4
  %293 = zext i8 %292 to i252
  %294 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 5
  %295 = zext i8 %294 to i252
  %296 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 6
  %297 = zext i8 %296 to i252
  %298 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 7
  %299 = zext i8 %298 to i252
  %300 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 8
  %301 = icmp slt i16 %300, 0
  %302 = zext i16 %300 to i252
  %303 = call i16 @llvm.abs.i16(i16 %300, i1 false)
  %304 = zext i16 %303 to i252
  %305 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %304
  %306 = select i1 %301, i252 %305, i252 %302
  %307 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 9
  %308 = icmp slt i16 %307, 0
  %309 = zext i16 %307 to i252
  %310 = call i16 @llvm.abs.i16(i16 %307, i1 false)
  %311 = zext i16 %310 to i252
  %312 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %311
  %313 = select i1 %308, i252 %312, i252 %309
  %314 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %133, 10
  %315 = icmp slt i16 %314, 0
  %316 = zext i16 %314 to i252
  %317 = call i16 @llvm.abs.i16(i16 %314, i1 false)
  %318 = zext i16 %317 to i252
  %319 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %318
  %320 = select i1 %315, i252 %319, i252 %316
  %321 = insertvalue { i252, i252, i252 } { i252 1062799989286861497646673457769309433976004466846907043354399004328696077865, i252 undef, i252 undef }, i252 %129, 1
  %322 = insertvalue { i252, i252, i252 } %321, i252 %130, 2
  %323 = call ptr @realloc(ptr null, i64 96)
  store { i252, i252, i252 } %322, ptr %323, align 16
  %324 = call ptr @realloc(ptr null, i64 112)
  store { i32, i32 } { i32 1, i32 3 }, ptr %324, align 4
  %325 = getelementptr inbounds i8, ptr %324, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %325, ptr %323, i64 96, i1 false)
  call void @free(ptr %323)
  %326 = call ptr @realloc(ptr null, i64 8)
  store ptr %325, ptr %326, align 8
  %327 = insertvalue { ptr, i32, i32, i32 } undef, ptr %326, 0
  %328 = insertvalue { ptr, i32, i32, i32 } %327, i32 0, 1
  %329 = insertvalue { ptr, i32, i32, i32 } %328, i32 3, 2
  %330 = insertvalue { ptr, i32, i32, i32 } %329, i32 3, 3
  %331 = extractvalue { { ptr, i32, i32, i32 }, {} } %257, 0
  %332 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %259, 0
  %333 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %259, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %332)
  %334 = extractvalue { ptr, i32, i32, i32 } %331, 3
  %335 = icmp eq i32 %334, 0
  br i1 %335, label %336, label %350

336:                                              ; preds = %255
  %337 = shl i32 %334, 1
  %338 = call i32 @llvm.umin.i32(i32 %337, i32 1024)
  %339 = add i32 %338, %334
  %340 = call i32 @llvm.umax.i32(i32 %339, i32 8)
  %341 = zext i32 %340 to i64
  %342 = mul i64 %341, 32
  %343 = add i64 %342, 16
  %344 = call ptr @realloc(ptr null, i64 %343)
  store i32 1, ptr %344, align 4
  %345 = getelementptr inbounds i8, ptr %344, i32 4
  store i32 0, ptr %345, align 4
  %346 = getelementptr inbounds i8, ptr %344, i32 16
  %347 = call ptr @realloc(ptr null, i64 8)
  store ptr %346, ptr %347, align 8
  %348 = insertvalue { ptr, i32, i32, i32 } %331, ptr %347, 0
  %349 = insertvalue { ptr, i32, i32, i32 } %348, i32 %340, 3
  br label %371

350:                                              ; preds = %255
  %351 = extractvalue { ptr, i32, i32, i32 } %331, 2
  %352 = icmp ult i32 %351, %334
  br i1 %352, label %353, label %354

353:                                              ; preds = %350
  br label %368

354:                                              ; preds = %350
  %355 = shl i32 %334, 1
  %356 = call i32 @llvm.umin.i32(i32 %355, i32 1024)
  %357 = add i32 %356, %334
  %358 = call i32 @llvm.umax.i32(i32 %357, i32 8)
  %359 = zext i32 %358 to i64
  %360 = mul i64 %359, 32
  %361 = add i64 %360, 16
  %362 = extractvalue { ptr, i32, i32, i32 } %331, 0
  %363 = load ptr, ptr %362, align 8
  %364 = getelementptr inbounds i8, ptr %363, i32 -16
  %365 = call ptr @realloc(ptr %364, i64 %361)
  %366 = getelementptr inbounds i8, ptr %365, i32 16
  store ptr %366, ptr %362, align 8
  %367 = insertvalue { ptr, i32, i32, i32 } %331, i32 %358, 3
  br label %368

368:                                              ; preds = %353, %354
  %369 = phi { ptr, i32, i32, i32 } [ %367, %354 ], [ %331, %353 ]
  br label %370

370:                                              ; preds = %368
  br label %371

371:                                              ; preds = %336, %370
  %372 = phi { ptr, i32, i32, i32 } [ %369, %370 ], [ %349, %336 ]
  br label %373

373:                                              ; preds = %371
  %374 = extractvalue { ptr, i32, i32, i32 } %372, 0
  %375 = load ptr, ptr %374, align 8
  %376 = extractvalue { ptr, i32, i32, i32 } %372, 2
  %377 = zext i32 %376 to i64
  %378 = mul i64 %377, 32
  %379 = getelementptr inbounds i8, ptr %375, i64 %378
  store i252 %333, ptr %379, align 16
  %380 = extractvalue { ptr, i32, i32, i32 } %372, 2
  %381 = add i32 %380, 1
  %382 = insertvalue { ptr, i32, i32, i32 } %372, i32 %381, 2
  %383 = getelementptr inbounds i8, ptr %375, i32 -12
  store i32 %381, ptr %383, align 4
  %384 = extractvalue { ptr, i32, i32, i32 } %372, 3
  %385 = icmp eq i32 %384, 0
  br i1 %385, label %386, label %400

386:                                              ; preds = %373
  %387 = shl i32 %384, 1
  %388 = call i32 @llvm.umin.i32(i32 %387, i32 1024)
  %389 = add i32 %388, %384
  %390 = call i32 @llvm.umax.i32(i32 %389, i32 8)
  %391 = zext i32 %390 to i64
  %392 = mul i64 %391, 32
  %393 = add i64 %392, 16
  %394 = call ptr @realloc(ptr null, i64 %393)
  store i32 1, ptr %394, align 4
  %395 = getelementptr inbounds i8, ptr %394, i32 4
  store i32 0, ptr %395, align 4
  %396 = getelementptr inbounds i8, ptr %394, i32 16
  %397 = call ptr @realloc(ptr null, i64 8)
  store ptr %396, ptr %397, align 8
  %398 = insertvalue { ptr, i32, i32, i32 } %382, ptr %397, 0
  %399 = insertvalue { ptr, i32, i32, i32 } %398, i32 %390, 3
  br label %420

400:                                              ; preds = %373
  %401 = icmp ult i32 %381, %384
  br i1 %401, label %402, label %403

402:                                              ; preds = %400
  br label %417

403:                                              ; preds = %400
  %404 = shl i32 %384, 1
  %405 = call i32 @llvm.umin.i32(i32 %404, i32 1024)
  %406 = add i32 %405, %384
  %407 = call i32 @llvm.umax.i32(i32 %406, i32 8)
  %408 = zext i32 %407 to i64
  %409 = mul i64 %408, 32
  %410 = add i64 %409, 16
  %411 = extractvalue { ptr, i32, i32, i32 } %372, 0
  %412 = load ptr, ptr %411, align 8
  %413 = getelementptr inbounds i8, ptr %412, i32 -16
  %414 = call ptr @realloc(ptr %413, i64 %410)
  %415 = getelementptr inbounds i8, ptr %414, i32 16
  store ptr %415, ptr %411, align 8
  %416 = insertvalue { ptr, i32, i32, i32 } %382, i32 %407, 3
  br label %417

417:                                              ; preds = %402, %403
  %418 = phi { ptr, i32, i32, i32 } [ %416, %403 ], [ %382, %402 ]
  br label %419

419:                                              ; preds = %417
  br label %420

420:                                              ; preds = %386, %419
  %421 = phi { ptr, i32, i32, i32 } [ %418, %419 ], [ %399, %386 ]
  br label %422

422:                                              ; preds = %420
  %423 = extractvalue { ptr, i32, i32, i32 } %421, 0
  %424 = load ptr, ptr %423, align 8
  %425 = extractvalue { ptr, i32, i32, i32 } %421, 2
  %426 = zext i32 %425 to i64
  %427 = mul i64 %426, 32
  %428 = getelementptr inbounds i8, ptr %424, i64 %427
  store i252 %263, ptr %428, align 16
  %429 = extractvalue { ptr, i32, i32, i32 } %421, 2
  %430 = add i32 %429, 1
  %431 = insertvalue { ptr, i32, i32, i32 } %421, i32 %430, 2
  %432 = getelementptr inbounds i8, ptr %424, i32 -12
  store i32 %430, ptr %432, align 4
  %433 = extractvalue { ptr, i32, i32, i32 } %421, 3
  %434 = icmp eq i32 %433, 0
  br i1 %434, label %435, label %449

435:                                              ; preds = %422
  %436 = shl i32 %433, 1
  %437 = call i32 @llvm.umin.i32(i32 %436, i32 1024)
  %438 = add i32 %437, %433
  %439 = call i32 @llvm.umax.i32(i32 %438, i32 8)
  %440 = zext i32 %439 to i64
  %441 = mul i64 %440, 32
  %442 = add i64 %441, 16
  %443 = call ptr @realloc(ptr null, i64 %442)
  store i32 1, ptr %443, align 4
  %444 = getelementptr inbounds i8, ptr %443, i32 4
  store i32 0, ptr %444, align 4
  %445 = getelementptr inbounds i8, ptr %443, i32 16
  %446 = call ptr @realloc(ptr null, i64 8)
  store ptr %445, ptr %446, align 8
  %447 = insertvalue { ptr, i32, i32, i32 } %431, ptr %446, 0
  %448 = insertvalue { ptr, i32, i32, i32 } %447, i32 %439, 3
  br label %469

449:                                              ; preds = %422
  %450 = icmp ult i32 %430, %433
  br i1 %450, label %451, label %452

451:                                              ; preds = %449
  br label %466

452:                                              ; preds = %449
  %453 = shl i32 %433, 1
  %454 = call i32 @llvm.umin.i32(i32 %453, i32 1024)
  %455 = add i32 %454, %433
  %456 = call i32 @llvm.umax.i32(i32 %455, i32 8)
  %457 = zext i32 %456 to i64
  %458 = mul i64 %457, 32
  %459 = add i64 %458, 16
  %460 = extractvalue { ptr, i32, i32, i32 } %421, 0
  %461 = load ptr, ptr %460, align 8
  %462 = getelementptr inbounds i8, ptr %461, i32 -16
  %463 = call ptr @realloc(ptr %462, i64 %459)
  %464 = getelementptr inbounds i8, ptr %463, i32 16
  store ptr %464, ptr %460, align 8
  %465 = insertvalue { ptr, i32, i32, i32 } %431, i32 %456, 3
  br label %466

466:                                              ; preds = %451, %452
  %467 = phi { ptr, i32, i32, i32 } [ %465, %452 ], [ %431, %451 ]
  br label %468

468:                                              ; preds = %466
  br label %469

469:                                              ; preds = %435, %468
  %470 = phi { ptr, i32, i32, i32 } [ %467, %468 ], [ %448, %435 ]
  br label %471

471:                                              ; preds = %469
  %472 = extractvalue { ptr, i32, i32, i32 } %470, 0
  %473 = load ptr, ptr %472, align 8
  %474 = extractvalue { ptr, i32, i32, i32 } %470, 2
  %475 = zext i32 %474 to i64
  %476 = mul i64 %475, 32
  %477 = getelementptr inbounds i8, ptr %473, i64 %476
  store i252 %270, ptr %477, align 16
  %478 = extractvalue { ptr, i32, i32, i32 } %470, 2
  %479 = add i32 %478, 1
  %480 = insertvalue { ptr, i32, i32, i32 } %470, i32 %479, 2
  %481 = getelementptr inbounds i8, ptr %473, i32 -12
  store i32 %479, ptr %481, align 4
  %482 = extractvalue { ptr, i32, i32, i32 } %470, 3
  %483 = icmp eq i32 %482, 0
  br i1 %483, label %484, label %498

484:                                              ; preds = %471
  %485 = shl i32 %482, 1
  %486 = call i32 @llvm.umin.i32(i32 %485, i32 1024)
  %487 = add i32 %486, %482
  %488 = call i32 @llvm.umax.i32(i32 %487, i32 8)
  %489 = zext i32 %488 to i64
  %490 = mul i64 %489, 32
  %491 = add i64 %490, 16
  %492 = call ptr @realloc(ptr null, i64 %491)
  store i32 1, ptr %492, align 4
  %493 = getelementptr inbounds i8, ptr %492, i32 4
  store i32 0, ptr %493, align 4
  %494 = getelementptr inbounds i8, ptr %492, i32 16
  %495 = call ptr @realloc(ptr null, i64 8)
  store ptr %494, ptr %495, align 8
  %496 = insertvalue { ptr, i32, i32, i32 } %480, ptr %495, 0
  %497 = insertvalue { ptr, i32, i32, i32 } %496, i32 %488, 3
  br label %518

498:                                              ; preds = %471
  %499 = icmp ult i32 %479, %482
  br i1 %499, label %500, label %501

500:                                              ; preds = %498
  br label %515

501:                                              ; preds = %498
  %502 = shl i32 %482, 1
  %503 = call i32 @llvm.umin.i32(i32 %502, i32 1024)
  %504 = add i32 %503, %482
  %505 = call i32 @llvm.umax.i32(i32 %504, i32 8)
  %506 = zext i32 %505 to i64
  %507 = mul i64 %506, 32
  %508 = add i64 %507, 16
  %509 = extractvalue { ptr, i32, i32, i32 } %470, 0
  %510 = load ptr, ptr %509, align 8
  %511 = getelementptr inbounds i8, ptr %510, i32 -16
  %512 = call ptr @realloc(ptr %511, i64 %508)
  %513 = getelementptr inbounds i8, ptr %512, i32 16
  store ptr %513, ptr %509, align 8
  %514 = insertvalue { ptr, i32, i32, i32 } %480, i32 %505, 3
  br label %515

515:                                              ; preds = %500, %501
  %516 = phi { ptr, i32, i32, i32 } [ %514, %501 ], [ %480, %500 ]
  br label %517

517:                                              ; preds = %515
  br label %518

518:                                              ; preds = %484, %517
  %519 = phi { ptr, i32, i32, i32 } [ %516, %517 ], [ %497, %484 ]
  br label %520

520:                                              ; preds = %518
  %521 = extractvalue { ptr, i32, i32, i32 } %519, 0
  %522 = load ptr, ptr %521, align 8
  %523 = extractvalue { ptr, i32, i32, i32 } %519, 2
  %524 = zext i32 %523 to i64
  %525 = mul i64 %524, 32
  %526 = getelementptr inbounds i8, ptr %522, i64 %525
  store i252 %277, ptr %526, align 16
  %527 = extractvalue { ptr, i32, i32, i32 } %519, 2
  %528 = add i32 %527, 1
  %529 = insertvalue { ptr, i32, i32, i32 } %519, i32 %528, 2
  %530 = getelementptr inbounds i8, ptr %522, i32 -12
  store i32 %528, ptr %530, align 4
  %531 = extractvalue { ptr, i32, i32, i32 } %519, 3
  %532 = icmp eq i32 %531, 0
  br i1 %532, label %533, label %547

533:                                              ; preds = %520
  %534 = shl i32 %531, 1
  %535 = call i32 @llvm.umin.i32(i32 %534, i32 1024)
  %536 = add i32 %535, %531
  %537 = call i32 @llvm.umax.i32(i32 %536, i32 8)
  %538 = zext i32 %537 to i64
  %539 = mul i64 %538, 32
  %540 = add i64 %539, 16
  %541 = call ptr @realloc(ptr null, i64 %540)
  store i32 1, ptr %541, align 4
  %542 = getelementptr inbounds i8, ptr %541, i32 4
  store i32 0, ptr %542, align 4
  %543 = getelementptr inbounds i8, ptr %541, i32 16
  %544 = call ptr @realloc(ptr null, i64 8)
  store ptr %543, ptr %544, align 8
  %545 = insertvalue { ptr, i32, i32, i32 } %529, ptr %544, 0
  %546 = insertvalue { ptr, i32, i32, i32 } %545, i32 %537, 3
  br label %567

547:                                              ; preds = %520
  %548 = icmp ult i32 %528, %531
  br i1 %548, label %549, label %550

549:                                              ; preds = %547
  br label %564

550:                                              ; preds = %547
  %551 = shl i32 %531, 1
  %552 = call i32 @llvm.umin.i32(i32 %551, i32 1024)
  %553 = add i32 %552, %531
  %554 = call i32 @llvm.umax.i32(i32 %553, i32 8)
  %555 = zext i32 %554 to i64
  %556 = mul i64 %555, 32
  %557 = add i64 %556, 16
  %558 = extractvalue { ptr, i32, i32, i32 } %519, 0
  %559 = load ptr, ptr %558, align 8
  %560 = getelementptr inbounds i8, ptr %559, i32 -16
  %561 = call ptr @realloc(ptr %560, i64 %557)
  %562 = getelementptr inbounds i8, ptr %561, i32 16
  store ptr %562, ptr %558, align 8
  %563 = insertvalue { ptr, i32, i32, i32 } %529, i32 %554, 3
  br label %564

564:                                              ; preds = %549, %550
  %565 = phi { ptr, i32, i32, i32 } [ %563, %550 ], [ %529, %549 ]
  br label %566

566:                                              ; preds = %564
  br label %567

567:                                              ; preds = %533, %566
  %568 = phi { ptr, i32, i32, i32 } [ %565, %566 ], [ %546, %533 ]
  br label %569

569:                                              ; preds = %567
  %570 = extractvalue { ptr, i32, i32, i32 } %568, 0
  %571 = load ptr, ptr %570, align 8
  %572 = extractvalue { ptr, i32, i32, i32 } %568, 2
  %573 = zext i32 %572 to i64
  %574 = mul i64 %573, 32
  %575 = getelementptr inbounds i8, ptr %571, i64 %574
  store i252 %284, ptr %575, align 16
  %576 = extractvalue { ptr, i32, i32, i32 } %568, 2
  %577 = add i32 %576, 1
  %578 = insertvalue { ptr, i32, i32, i32 } %568, i32 %577, 2
  %579 = getelementptr inbounds i8, ptr %571, i32 -12
  store i32 %577, ptr %579, align 4
  %580 = extractvalue { ptr, i32, i32, i32 } %568, 3
  %581 = icmp eq i32 %580, 0
  br i1 %581, label %582, label %596

582:                                              ; preds = %569
  %583 = shl i32 %580, 1
  %584 = call i32 @llvm.umin.i32(i32 %583, i32 1024)
  %585 = add i32 %584, %580
  %586 = call i32 @llvm.umax.i32(i32 %585, i32 8)
  %587 = zext i32 %586 to i64
  %588 = mul i64 %587, 32
  %589 = add i64 %588, 16
  %590 = call ptr @realloc(ptr null, i64 %589)
  store i32 1, ptr %590, align 4
  %591 = getelementptr inbounds i8, ptr %590, i32 4
  store i32 0, ptr %591, align 4
  %592 = getelementptr inbounds i8, ptr %590, i32 16
  %593 = call ptr @realloc(ptr null, i64 8)
  store ptr %592, ptr %593, align 8
  %594 = insertvalue { ptr, i32, i32, i32 } %578, ptr %593, 0
  %595 = insertvalue { ptr, i32, i32, i32 } %594, i32 %586, 3
  br label %616

596:                                              ; preds = %569
  %597 = icmp ult i32 %577, %580
  br i1 %597, label %598, label %599

598:                                              ; preds = %596
  br label %613

599:                                              ; preds = %596
  %600 = shl i32 %580, 1
  %601 = call i32 @llvm.umin.i32(i32 %600, i32 1024)
  %602 = add i32 %601, %580
  %603 = call i32 @llvm.umax.i32(i32 %602, i32 8)
  %604 = zext i32 %603 to i64
  %605 = mul i64 %604, 32
  %606 = add i64 %605, 16
  %607 = extractvalue { ptr, i32, i32, i32 } %568, 0
  %608 = load ptr, ptr %607, align 8
  %609 = getelementptr inbounds i8, ptr %608, i32 -16
  %610 = call ptr @realloc(ptr %609, i64 %606)
  %611 = getelementptr inbounds i8, ptr %610, i32 16
  store ptr %611, ptr %607, align 8
  %612 = insertvalue { ptr, i32, i32, i32 } %578, i32 %603, 3
  br label %613

613:                                              ; preds = %598, %599
  %614 = phi { ptr, i32, i32, i32 } [ %612, %599 ], [ %578, %598 ]
  br label %615

615:                                              ; preds = %613
  br label %616

616:                                              ; preds = %582, %615
  %617 = phi { ptr, i32, i32, i32 } [ %614, %615 ], [ %595, %582 ]
  br label %618

618:                                              ; preds = %616
  %619 = extractvalue { ptr, i32, i32, i32 } %617, 0
  %620 = load ptr, ptr %619, align 8
  %621 = extractvalue { ptr, i32, i32, i32 } %617, 2
  %622 = zext i32 %621 to i64
  %623 = mul i64 %622, 32
  %624 = getelementptr inbounds i8, ptr %620, i64 %623
  store i252 %291, ptr %624, align 16
  %625 = extractvalue { ptr, i32, i32, i32 } %617, 2
  %626 = add i32 %625, 1
  %627 = insertvalue { ptr, i32, i32, i32 } %617, i32 %626, 2
  %628 = getelementptr inbounds i8, ptr %620, i32 -12
  store i32 %626, ptr %628, align 4
  %629 = extractvalue { ptr, i32, i32, i32 } %617, 3
  %630 = icmp eq i32 %629, 0
  br i1 %630, label %631, label %645

631:                                              ; preds = %618
  %632 = shl i32 %629, 1
  %633 = call i32 @llvm.umin.i32(i32 %632, i32 1024)
  %634 = add i32 %633, %629
  %635 = call i32 @llvm.umax.i32(i32 %634, i32 8)
  %636 = zext i32 %635 to i64
  %637 = mul i64 %636, 32
  %638 = add i64 %637, 16
  %639 = call ptr @realloc(ptr null, i64 %638)
  store i32 1, ptr %639, align 4
  %640 = getelementptr inbounds i8, ptr %639, i32 4
  store i32 0, ptr %640, align 4
  %641 = getelementptr inbounds i8, ptr %639, i32 16
  %642 = call ptr @realloc(ptr null, i64 8)
  store ptr %641, ptr %642, align 8
  %643 = insertvalue { ptr, i32, i32, i32 } %627, ptr %642, 0
  %644 = insertvalue { ptr, i32, i32, i32 } %643, i32 %635, 3
  br label %665

645:                                              ; preds = %618
  %646 = icmp ult i32 %626, %629
  br i1 %646, label %647, label %648

647:                                              ; preds = %645
  br label %662

648:                                              ; preds = %645
  %649 = shl i32 %629, 1
  %650 = call i32 @llvm.umin.i32(i32 %649, i32 1024)
  %651 = add i32 %650, %629
  %652 = call i32 @llvm.umax.i32(i32 %651, i32 8)
  %653 = zext i32 %652 to i64
  %654 = mul i64 %653, 32
  %655 = add i64 %654, 16
  %656 = extractvalue { ptr, i32, i32, i32 } %617, 0
  %657 = load ptr, ptr %656, align 8
  %658 = getelementptr inbounds i8, ptr %657, i32 -16
  %659 = call ptr @realloc(ptr %658, i64 %655)
  %660 = getelementptr inbounds i8, ptr %659, i32 16
  store ptr %660, ptr %656, align 8
  %661 = insertvalue { ptr, i32, i32, i32 } %627, i32 %652, 3
  br label %662

662:                                              ; preds = %647, %648
  %663 = phi { ptr, i32, i32, i32 } [ %661, %648 ], [ %627, %647 ]
  br label %664

664:                                              ; preds = %662
  br label %665

665:                                              ; preds = %631, %664
  %666 = phi { ptr, i32, i32, i32 } [ %663, %664 ], [ %644, %631 ]
  br label %667

667:                                              ; preds = %665
  %668 = extractvalue { ptr, i32, i32, i32 } %666, 0
  %669 = load ptr, ptr %668, align 8
  %670 = extractvalue { ptr, i32, i32, i32 } %666, 2
  %671 = zext i32 %670 to i64
  %672 = mul i64 %671, 32
  %673 = getelementptr inbounds i8, ptr %669, i64 %672
  store i252 %293, ptr %673, align 16
  %674 = extractvalue { ptr, i32, i32, i32 } %666, 2
  %675 = add i32 %674, 1
  %676 = insertvalue { ptr, i32, i32, i32 } %666, i32 %675, 2
  %677 = getelementptr inbounds i8, ptr %669, i32 -12
  store i32 %675, ptr %677, align 4
  %678 = extractvalue { ptr, i32, i32, i32 } %666, 3
  %679 = icmp eq i32 %678, 0
  br i1 %679, label %680, label %694

680:                                              ; preds = %667
  %681 = shl i32 %678, 1
  %682 = call i32 @llvm.umin.i32(i32 %681, i32 1024)
  %683 = add i32 %682, %678
  %684 = call i32 @llvm.umax.i32(i32 %683, i32 8)
  %685 = zext i32 %684 to i64
  %686 = mul i64 %685, 32
  %687 = add i64 %686, 16
  %688 = call ptr @realloc(ptr null, i64 %687)
  store i32 1, ptr %688, align 4
  %689 = getelementptr inbounds i8, ptr %688, i32 4
  store i32 0, ptr %689, align 4
  %690 = getelementptr inbounds i8, ptr %688, i32 16
  %691 = call ptr @realloc(ptr null, i64 8)
  store ptr %690, ptr %691, align 8
  %692 = insertvalue { ptr, i32, i32, i32 } %676, ptr %691, 0
  %693 = insertvalue { ptr, i32, i32, i32 } %692, i32 %684, 3
  br label %714

694:                                              ; preds = %667
  %695 = icmp ult i32 %675, %678
  br i1 %695, label %696, label %697

696:                                              ; preds = %694
  br label %711

697:                                              ; preds = %694
  %698 = shl i32 %678, 1
  %699 = call i32 @llvm.umin.i32(i32 %698, i32 1024)
  %700 = add i32 %699, %678
  %701 = call i32 @llvm.umax.i32(i32 %700, i32 8)
  %702 = zext i32 %701 to i64
  %703 = mul i64 %702, 32
  %704 = add i64 %703, 16
  %705 = extractvalue { ptr, i32, i32, i32 } %666, 0
  %706 = load ptr, ptr %705, align 8
  %707 = getelementptr inbounds i8, ptr %706, i32 -16
  %708 = call ptr @realloc(ptr %707, i64 %704)
  %709 = getelementptr inbounds i8, ptr %708, i32 16
  store ptr %709, ptr %705, align 8
  %710 = insertvalue { ptr, i32, i32, i32 } %676, i32 %701, 3
  br label %711

711:                                              ; preds = %696, %697
  %712 = phi { ptr, i32, i32, i32 } [ %710, %697 ], [ %676, %696 ]
  br label %713

713:                                              ; preds = %711
  br label %714

714:                                              ; preds = %680, %713
  %715 = phi { ptr, i32, i32, i32 } [ %712, %713 ], [ %693, %680 ]
  br label %716

716:                                              ; preds = %714
  %717 = extractvalue { ptr, i32, i32, i32 } %715, 0
  %718 = load ptr, ptr %717, align 8
  %719 = extractvalue { ptr, i32, i32, i32 } %715, 2
  %720 = zext i32 %719 to i64
  %721 = mul i64 %720, 32
  %722 = getelementptr inbounds i8, ptr %718, i64 %721
  store i252 %295, ptr %722, align 16
  %723 = extractvalue { ptr, i32, i32, i32 } %715, 2
  %724 = add i32 %723, 1
  %725 = insertvalue { ptr, i32, i32, i32 } %715, i32 %724, 2
  %726 = getelementptr inbounds i8, ptr %718, i32 -12
  store i32 %724, ptr %726, align 4
  %727 = extractvalue { ptr, i32, i32, i32 } %715, 3
  %728 = icmp eq i32 %727, 0
  br i1 %728, label %729, label %743

729:                                              ; preds = %716
  %730 = shl i32 %727, 1
  %731 = call i32 @llvm.umin.i32(i32 %730, i32 1024)
  %732 = add i32 %731, %727
  %733 = call i32 @llvm.umax.i32(i32 %732, i32 8)
  %734 = zext i32 %733 to i64
  %735 = mul i64 %734, 32
  %736 = add i64 %735, 16
  %737 = call ptr @realloc(ptr null, i64 %736)
  store i32 1, ptr %737, align 4
  %738 = getelementptr inbounds i8, ptr %737, i32 4
  store i32 0, ptr %738, align 4
  %739 = getelementptr inbounds i8, ptr %737, i32 16
  %740 = call ptr @realloc(ptr null, i64 8)
  store ptr %739, ptr %740, align 8
  %741 = insertvalue { ptr, i32, i32, i32 } %725, ptr %740, 0
  %742 = insertvalue { ptr, i32, i32, i32 } %741, i32 %733, 3
  br label %763

743:                                              ; preds = %716
  %744 = icmp ult i32 %724, %727
  br i1 %744, label %745, label %746

745:                                              ; preds = %743
  br label %760

746:                                              ; preds = %743
  %747 = shl i32 %727, 1
  %748 = call i32 @llvm.umin.i32(i32 %747, i32 1024)
  %749 = add i32 %748, %727
  %750 = call i32 @llvm.umax.i32(i32 %749, i32 8)
  %751 = zext i32 %750 to i64
  %752 = mul i64 %751, 32
  %753 = add i64 %752, 16
  %754 = extractvalue { ptr, i32, i32, i32 } %715, 0
  %755 = load ptr, ptr %754, align 8
  %756 = getelementptr inbounds i8, ptr %755, i32 -16
  %757 = call ptr @realloc(ptr %756, i64 %753)
  %758 = getelementptr inbounds i8, ptr %757, i32 16
  store ptr %758, ptr %754, align 8
  %759 = insertvalue { ptr, i32, i32, i32 } %725, i32 %750, 3
  br label %760

760:                                              ; preds = %745, %746
  %761 = phi { ptr, i32, i32, i32 } [ %759, %746 ], [ %725, %745 ]
  br label %762

762:                                              ; preds = %760
  br label %763

763:                                              ; preds = %729, %762
  %764 = phi { ptr, i32, i32, i32 } [ %761, %762 ], [ %742, %729 ]
  br label %765

765:                                              ; preds = %763
  %766 = extractvalue { ptr, i32, i32, i32 } %764, 0
  %767 = load ptr, ptr %766, align 8
  %768 = extractvalue { ptr, i32, i32, i32 } %764, 2
  %769 = zext i32 %768 to i64
  %770 = mul i64 %769, 32
  %771 = getelementptr inbounds i8, ptr %767, i64 %770
  store i252 %297, ptr %771, align 16
  %772 = extractvalue { ptr, i32, i32, i32 } %764, 2
  %773 = add i32 %772, 1
  %774 = insertvalue { ptr, i32, i32, i32 } %764, i32 %773, 2
  %775 = getelementptr inbounds i8, ptr %767, i32 -12
  store i32 %773, ptr %775, align 4
  %776 = extractvalue { ptr, i32, i32, i32 } %764, 3
  %777 = icmp eq i32 %776, 0
  br i1 %777, label %778, label %792

778:                                              ; preds = %765
  %779 = shl i32 %776, 1
  %780 = call i32 @llvm.umin.i32(i32 %779, i32 1024)
  %781 = add i32 %780, %776
  %782 = call i32 @llvm.umax.i32(i32 %781, i32 8)
  %783 = zext i32 %782 to i64
  %784 = mul i64 %783, 32
  %785 = add i64 %784, 16
  %786 = call ptr @realloc(ptr null, i64 %785)
  store i32 1, ptr %786, align 4
  %787 = getelementptr inbounds i8, ptr %786, i32 4
  store i32 0, ptr %787, align 4
  %788 = getelementptr inbounds i8, ptr %786, i32 16
  %789 = call ptr @realloc(ptr null, i64 8)
  store ptr %788, ptr %789, align 8
  %790 = insertvalue { ptr, i32, i32, i32 } %774, ptr %789, 0
  %791 = insertvalue { ptr, i32, i32, i32 } %790, i32 %782, 3
  br label %812

792:                                              ; preds = %765
  %793 = icmp ult i32 %773, %776
  br i1 %793, label %794, label %795

794:                                              ; preds = %792
  br label %809

795:                                              ; preds = %792
  %796 = shl i32 %776, 1
  %797 = call i32 @llvm.umin.i32(i32 %796, i32 1024)
  %798 = add i32 %797, %776
  %799 = call i32 @llvm.umax.i32(i32 %798, i32 8)
  %800 = zext i32 %799 to i64
  %801 = mul i64 %800, 32
  %802 = add i64 %801, 16
  %803 = extractvalue { ptr, i32, i32, i32 } %764, 0
  %804 = load ptr, ptr %803, align 8
  %805 = getelementptr inbounds i8, ptr %804, i32 -16
  %806 = call ptr @realloc(ptr %805, i64 %802)
  %807 = getelementptr inbounds i8, ptr %806, i32 16
  store ptr %807, ptr %803, align 8
  %808 = insertvalue { ptr, i32, i32, i32 } %774, i32 %799, 3
  br label %809

809:                                              ; preds = %794, %795
  %810 = phi { ptr, i32, i32, i32 } [ %808, %795 ], [ %774, %794 ]
  br label %811

811:                                              ; preds = %809
  br label %812

812:                                              ; preds = %778, %811
  %813 = phi { ptr, i32, i32, i32 } [ %810, %811 ], [ %791, %778 ]
  br label %814

814:                                              ; preds = %812
  %815 = extractvalue { ptr, i32, i32, i32 } %813, 0
  %816 = load ptr, ptr %815, align 8
  %817 = extractvalue { ptr, i32, i32, i32 } %813, 2
  %818 = zext i32 %817 to i64
  %819 = mul i64 %818, 32
  %820 = getelementptr inbounds i8, ptr %816, i64 %819
  store i252 %299, ptr %820, align 16
  %821 = extractvalue { ptr, i32, i32, i32 } %813, 2
  %822 = add i32 %821, 1
  %823 = insertvalue { ptr, i32, i32, i32 } %813, i32 %822, 2
  %824 = getelementptr inbounds i8, ptr %816, i32 -12
  store i32 %822, ptr %824, align 4
  %825 = extractvalue { ptr, i32, i32, i32 } %813, 3
  %826 = icmp eq i32 %825, 0
  br i1 %826, label %827, label %841

827:                                              ; preds = %814
  %828 = shl i32 %825, 1
  %829 = call i32 @llvm.umin.i32(i32 %828, i32 1024)
  %830 = add i32 %829, %825
  %831 = call i32 @llvm.umax.i32(i32 %830, i32 8)
  %832 = zext i32 %831 to i64
  %833 = mul i64 %832, 32
  %834 = add i64 %833, 16
  %835 = call ptr @realloc(ptr null, i64 %834)
  store i32 1, ptr %835, align 4
  %836 = getelementptr inbounds i8, ptr %835, i32 4
  store i32 0, ptr %836, align 4
  %837 = getelementptr inbounds i8, ptr %835, i32 16
  %838 = call ptr @realloc(ptr null, i64 8)
  store ptr %837, ptr %838, align 8
  %839 = insertvalue { ptr, i32, i32, i32 } %823, ptr %838, 0
  %840 = insertvalue { ptr, i32, i32, i32 } %839, i32 %831, 3
  br label %861

841:                                              ; preds = %814
  %842 = icmp ult i32 %822, %825
  br i1 %842, label %843, label %844

843:                                              ; preds = %841
  br label %858

844:                                              ; preds = %841
  %845 = shl i32 %825, 1
  %846 = call i32 @llvm.umin.i32(i32 %845, i32 1024)
  %847 = add i32 %846, %825
  %848 = call i32 @llvm.umax.i32(i32 %847, i32 8)
  %849 = zext i32 %848 to i64
  %850 = mul i64 %849, 32
  %851 = add i64 %850, 16
  %852 = extractvalue { ptr, i32, i32, i32 } %813, 0
  %853 = load ptr, ptr %852, align 8
  %854 = getelementptr inbounds i8, ptr %853, i32 -16
  %855 = call ptr @realloc(ptr %854, i64 %851)
  %856 = getelementptr inbounds i8, ptr %855, i32 16
  store ptr %856, ptr %852, align 8
  %857 = insertvalue { ptr, i32, i32, i32 } %823, i32 %848, 3
  br label %858

858:                                              ; preds = %843, %844
  %859 = phi { ptr, i32, i32, i32 } [ %857, %844 ], [ %823, %843 ]
  br label %860

860:                                              ; preds = %858
  br label %861

861:                                              ; preds = %827, %860
  %862 = phi { ptr, i32, i32, i32 } [ %859, %860 ], [ %840, %827 ]
  br label %863

863:                                              ; preds = %861
  %864 = extractvalue { ptr, i32, i32, i32 } %862, 0
  %865 = load ptr, ptr %864, align 8
  %866 = extractvalue { ptr, i32, i32, i32 } %862, 2
  %867 = zext i32 %866 to i64
  %868 = mul i64 %867, 32
  %869 = getelementptr inbounds i8, ptr %865, i64 %868
  store i252 %306, ptr %869, align 16
  %870 = extractvalue { ptr, i32, i32, i32 } %862, 2
  %871 = add i32 %870, 1
  %872 = insertvalue { ptr, i32, i32, i32 } %862, i32 %871, 2
  %873 = getelementptr inbounds i8, ptr %865, i32 -12
  store i32 %871, ptr %873, align 4
  %874 = extractvalue { ptr, i32, i32, i32 } %862, 3
  %875 = icmp eq i32 %874, 0
  br i1 %875, label %876, label %890

876:                                              ; preds = %863
  %877 = shl i32 %874, 1
  %878 = call i32 @llvm.umin.i32(i32 %877, i32 1024)
  %879 = add i32 %878, %874
  %880 = call i32 @llvm.umax.i32(i32 %879, i32 8)
  %881 = zext i32 %880 to i64
  %882 = mul i64 %881, 32
  %883 = add i64 %882, 16
  %884 = call ptr @realloc(ptr null, i64 %883)
  store i32 1, ptr %884, align 4
  %885 = getelementptr inbounds i8, ptr %884, i32 4
  store i32 0, ptr %885, align 4
  %886 = getelementptr inbounds i8, ptr %884, i32 16
  %887 = call ptr @realloc(ptr null, i64 8)
  store ptr %886, ptr %887, align 8
  %888 = insertvalue { ptr, i32, i32, i32 } %872, ptr %887, 0
  %889 = insertvalue { ptr, i32, i32, i32 } %888, i32 %880, 3
  br label %910

890:                                              ; preds = %863
  %891 = icmp ult i32 %871, %874
  br i1 %891, label %892, label %893

892:                                              ; preds = %890
  br label %907

893:                                              ; preds = %890
  %894 = shl i32 %874, 1
  %895 = call i32 @llvm.umin.i32(i32 %894, i32 1024)
  %896 = add i32 %895, %874
  %897 = call i32 @llvm.umax.i32(i32 %896, i32 8)
  %898 = zext i32 %897 to i64
  %899 = mul i64 %898, 32
  %900 = add i64 %899, 16
  %901 = extractvalue { ptr, i32, i32, i32 } %862, 0
  %902 = load ptr, ptr %901, align 8
  %903 = getelementptr inbounds i8, ptr %902, i32 -16
  %904 = call ptr @realloc(ptr %903, i64 %900)
  %905 = getelementptr inbounds i8, ptr %904, i32 16
  store ptr %905, ptr %901, align 8
  %906 = insertvalue { ptr, i32, i32, i32 } %872, i32 %897, 3
  br label %907

907:                                              ; preds = %892, %893
  %908 = phi { ptr, i32, i32, i32 } [ %906, %893 ], [ %872, %892 ]
  br label %909

909:                                              ; preds = %907
  br label %910

910:                                              ; preds = %876, %909
  %911 = phi { ptr, i32, i32, i32 } [ %908, %909 ], [ %889, %876 ]
  br label %912

912:                                              ; preds = %910
  %913 = extractvalue { ptr, i32, i32, i32 } %911, 0
  %914 = load ptr, ptr %913, align 8
  %915 = extractvalue { ptr, i32, i32, i32 } %911, 2
  %916 = zext i32 %915 to i64
  %917 = mul i64 %916, 32
  %918 = getelementptr inbounds i8, ptr %914, i64 %917
  store i252 %313, ptr %918, align 16
  %919 = extractvalue { ptr, i32, i32, i32 } %911, 2
  %920 = add i32 %919, 1
  %921 = insertvalue { ptr, i32, i32, i32 } %911, i32 %920, 2
  %922 = getelementptr inbounds i8, ptr %914, i32 -12
  store i32 %920, ptr %922, align 4
  %923 = extractvalue { ptr, i32, i32, i32 } %911, 3
  %924 = icmp eq i32 %923, 0
  br i1 %924, label %925, label %939

925:                                              ; preds = %912
  %926 = shl i32 %923, 1
  %927 = call i32 @llvm.umin.i32(i32 %926, i32 1024)
  %928 = add i32 %927, %923
  %929 = call i32 @llvm.umax.i32(i32 %928, i32 8)
  %930 = zext i32 %929 to i64
  %931 = mul i64 %930, 32
  %932 = add i64 %931, 16
  %933 = call ptr @realloc(ptr null, i64 %932)
  store i32 1, ptr %933, align 4
  %934 = getelementptr inbounds i8, ptr %933, i32 4
  store i32 0, ptr %934, align 4
  %935 = getelementptr inbounds i8, ptr %933, i32 16
  %936 = call ptr @realloc(ptr null, i64 8)
  store ptr %935, ptr %936, align 8
  %937 = insertvalue { ptr, i32, i32, i32 } %921, ptr %936, 0
  %938 = insertvalue { ptr, i32, i32, i32 } %937, i32 %929, 3
  br label %959

939:                                              ; preds = %912
  %940 = icmp ult i32 %920, %923
  br i1 %940, label %941, label %942

941:                                              ; preds = %939
  br label %956

942:                                              ; preds = %939
  %943 = shl i32 %923, 1
  %944 = call i32 @llvm.umin.i32(i32 %943, i32 1024)
  %945 = add i32 %944, %923
  %946 = call i32 @llvm.umax.i32(i32 %945, i32 8)
  %947 = zext i32 %946 to i64
  %948 = mul i64 %947, 32
  %949 = add i64 %948, 16
  %950 = extractvalue { ptr, i32, i32, i32 } %911, 0
  %951 = load ptr, ptr %950, align 8
  %952 = getelementptr inbounds i8, ptr %951, i32 -16
  %953 = call ptr @realloc(ptr %952, i64 %949)
  %954 = getelementptr inbounds i8, ptr %953, i32 16
  store ptr %954, ptr %950, align 8
  %955 = insertvalue { ptr, i32, i32, i32 } %921, i32 %946, 3
  br label %956

956:                                              ; preds = %941, %942
  %957 = phi { ptr, i32, i32, i32 } [ %955, %942 ], [ %921, %941 ]
  br label %958

958:                                              ; preds = %956
  br label %959

959:                                              ; preds = %925, %958
  %960 = phi { ptr, i32, i32, i32 } [ %957, %958 ], [ %938, %925 ]
  br label %961

961:                                              ; preds = %959
  %962 = extractvalue { ptr, i32, i32, i32 } %960, 0
  %963 = load ptr, ptr %962, align 8
  %964 = extractvalue { ptr, i32, i32, i32 } %960, 2
  %965 = zext i32 %964 to i64
  %966 = mul i64 %965, 32
  %967 = getelementptr inbounds i8, ptr %963, i64 %966
  store i252 %320, ptr %967, align 16
  %968 = extractvalue { ptr, i32, i32, i32 } %960, 2
  %969 = add i32 %968, 1
  %970 = insertvalue { ptr, i32, i32, i32 } %960, i32 %969, 2
  %971 = getelementptr inbounds i8, ptr %963, i32 -12
  store i32 %969, ptr %971, align 4
  %972 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %970)
  %973 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %972, 0
  %974 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %972, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %973)
  %975 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %974)
  %976 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %975, 0
  %977 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %975, 1
  %978 = extractvalue { ptr, i32, i32, i32 } %977, 1
  %979 = extractvalue { ptr, i32, i32, i32 } %977, 2
  %980 = sub i32 %979, %978
  call void @"drop$3"({ ptr, i32, i32, i32 } %977)
  %981 = zext i32 %980 to i252
  %982 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %982, align 4
  %983 = getelementptr inbounds i8, ptr %982, i32 4
  store i32 0, ptr %983, align 4
  %984 = getelementptr inbounds i8, ptr %982, i32 16
  %985 = call ptr @realloc(ptr null, i64 8)
  store ptr %984, ptr %985, align 8
  %986 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %985, 0
  %987 = insertvalue { ptr, i32, i32, i32 } %986, i32 8, 3
  %988 = load ptr, ptr %985, align 8
  store i252 %981, ptr %988, align 16
  %989 = insertvalue { ptr, i32, i32, i32 } %987, i32 1, 2
  %990 = getelementptr inbounds i8, ptr %988, i32 -12
  store i32 1, ptr %990, align 4
  %991 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %976, 0
  %992 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %249, i64 %250, { { ptr, i32, i32, i32 } } %991, { ptr, i32, i32, i32 } %989)
  %993 = extractvalue { i64, i64, { i64, [24 x i8] } } %992, 0
  %994 = extractvalue { i64, i64, { i64, [24 x i8] } } %992, 1
  %995 = extractvalue { i64, i64, { i64, [24 x i8] } } %992, 2
  store { i64, [24 x i8] } %995, ptr %9, align 8
  %996 = load i1, ptr %9, align 1
  switch i1 %996, label %1006 [
    i1 false, label %1008
    i1 true, label %1025
  ]

997:                                              ; preds = %236
  %998 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %999 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %998, 1
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %138)
  %1000 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %999, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %1000, ptr %8, align 8
  %1001 = load { i64, [24 x i8] }, ptr %8, align 8
  %1002 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %249, 0
  %1003 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1002, i64 %250, 1
  %1004 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1003, ptr %128, 2
  %1005 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1004, { i64, [24 x i8] } %1001, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %1005

1006:                                             ; preds = %961
  br i1 false, label %1007, label %1055

1007:                                             ; preds = %1006
  unreachable

1008:                                             ; preds = %961
  %1009 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %9, align 8
  %1010 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %1009, 1
  %1011 = extractvalue { { ptr, i32, i32, i32 }, {} } %1010, 0
  %1012 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %1011)
  %1013 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %1012, 0
  %1014 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %1012, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %1013)
  %1015 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %330, 0
  %1016 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1014, 0
  %1017 = load ptr, ptr %128, align 8
  store i64 %994, ptr %12, align 8
  store { { ptr, i32, i32, i32 } } %1015, ptr %13, align 8
  store { { ptr, i32, i32, i32 } } %1016, ptr %14, align 8
  %1018 = getelementptr inbounds ptr, ptr %128, i32 10
  %1019 = load ptr, ptr %1018, align 8
  call void %1019(ptr %11, ptr %1017, ptr %12, ptr %13, ptr %14)
  %1020 = load { i1, [31 x i8] }, ptr %11, align 1
  %1021 = extractvalue { i1, [31 x i8] } %1020, 0
  %1022 = getelementptr inbounds i8, ptr %11, i32 8
  %1023 = load { ptr, i32, i32, i32 }, ptr %1022, align 8
  %1024 = load i64, ptr %12, align 8
  br i1 %1021, label %1044, label %1034

1025:                                             ; preds = %961
  %1026 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %1027 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %1026, 1
  call void @"drop$3"({ ptr, i32, i32, i32 } %330)
  %1028 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %1027, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %1028, ptr %10, align 8
  %1029 = load { i64, [24 x i8] }, ptr %10, align 8
  %1030 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %993, 0
  %1031 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1030, i64 %994, 1
  %1032 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1031, ptr %128, 2
  %1033 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1032, { i64, [24 x i8] } %1029, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %1033

1034:                                             ; preds = %1008
  %1035 = phi i64 [ %1024, %1008 ]
  %1036 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %1037 = call ptr %1036()
  %1038 = call i64 @llvm.uadd.sat.i64(i64 %1035, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %16, align 1
  %1039 = load { i64, [24 x i8] }, ptr %16, align 8
  %1040 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %993, 0
  %1041 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1040, i64 %1038, 1
  %1042 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1041, ptr %128, 2
  %1043 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1042, { i64, [24 x i8] } %1039, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %1043

1044:                                             ; preds = %1008
  %1045 = phi { ptr, i32, i32, i32 } [ %1023, %1008 ]
  %1046 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1045, 1
  %1047 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %1046, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %1047, ptr %15, align 8
  %1048 = load { i64, [24 x i8] }, ptr %15, align 8
  %1049 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %993, 0
  %1050 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1049, i64 %1024, 1
  %1051 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1050, ptr %128, 2
  %1052 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %1051, { i64, [24 x i8] } %1048, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %1052

1053:                                             ; preds = %22
  call void @puts(ptr @assert_msg_155)
  call void @abort()
  unreachable

1054:                                             ; preds = %253
  call void @puts(ptr @assert_msg_156)
  call void @abort()
  unreachable

1055:                                             ; preds = %1006
  call void @puts(ptr @assert_msg_157)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f89(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5) {
  %7 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f89"(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %5)
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %9, 1
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, ptr %10, 2
  %15 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %11, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %15
}

define void @_mlir_ciface_f89(ptr %0, i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6) {
  %8 = call { i64, i64, ptr, { i64, [24 x i8] } } @f89(i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { { i3, [0 x i8] }, i32, { { ptr, i32, i32, i32 }, i252, i32 }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6)
  store { i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i128, [64 x i8] } } @"impl$f90"(i64 %0, i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { i252 } %6, { ptr, i32, i32, i32 } %7) {
  %9 = alloca i64, i64 1, align 8
  %10 = insertvalue { ptr, ptr, i64 } undef, ptr %9, 0
  %11 = insertvalue { ptr, ptr, i64 } %10, ptr %9, 1
  %12 = insertvalue { ptr, ptr, i64 } %11, i64 0, 2
  %13 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 0, ptr %13, align 8
  %14 = alloca { i128, [64 x i8] }, i64 1, align 16
  %15 = alloca i256, i64 1, align 16
  %16 = alloca i256, i64 1, align 16
  %17 = alloca i256, i64 1, align 16
  %18 = alloca { i1, [47 x i8] }, i64 1, align 16
  %19 = alloca i64, i64 1, align 8
  %20 = alloca i252, i64 1, align 16
  %21 = alloca { i128, [64 x i8] }, i64 1, align 16
  %22 = alloca i256, i64 1, align 16
  %23 = alloca i256, i64 1, align 16
  %24 = alloca i256, i64 1, align 16
  %25 = alloca { i1, [31 x i8] }, i64 1, align 8
  %26 = alloca i64, i64 1, align 8
  %27 = alloca i252, i64 1, align 16
  %28 = alloca i252, i64 1, align 16
  %29 = alloca { i128, [64 x i8] }, i64 1, align 16
  %30 = alloca { i128, [64 x i8] }, i64 1, align 16
  br label %31

31:                                               ; preds = %174, %8
  %32 = phi i64 [ %118, %174 ], [ %0, %8 ]
  %33 = phi i64 [ %134, %174 ], [ %1, %8 ]
  %34 = phi i64 [ %112, %174 ], [ %2, %8 ]
  %35 = phi ptr [ %35, %174 ], [ %3, %8 ]
  %36 = phi i252 [ %52, %174 ], [ %4, %8 ]
  %37 = phi i252 [ %190, %174 ], [ %5, %8 ]
  %38 = phi { i252 } [ %110, %174 ], [ %6, %8 ]
  %39 = phi { ptr, i32, i32, i32 } [ %183, %174 ], [ %7, %8 ]
  %40 = add i64 %32, 1
  %41 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %42 = call ptr %41()
  %43 = getelementptr inbounds i64, ptr %42, i32 1
  %44 = load i64, ptr %43, align 8
  %45 = mul i64 %44, 2
  %46 = load i64, ptr %42, align 8
  %47 = mul i64 %46, 27590
  %48 = add i64 %45, %47
  %49 = icmp uge i64 %33, %48
  %50 = call i64 @llvm.usub.sat.i64(i64 %33, i64 %48)
  br i1 %49, label %51, label %244

51:                                               ; preds = %31
  %52 = phi i252 [ %36, %31 ]
  %53 = zext i252 %52 to i256
  %54 = zext i252 %37 to i256
  %55 = add i256 %53, %54
  %56 = sub i256 %55, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %57 = icmp uge i256 %55, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %58 = select i1 %57, i256 %56, i256 %55
  %59 = trunc i256 %58 to i252
  %60 = extractvalue { i252 } %38, 0
  %61 = add i64 %34, 3
  %62 = zext i252 %60 to i256
  %63 = zext i252 %59 to i256
  store i256 %62, ptr %15, align 16
  store i256 %63, ptr %16, align 16
  %64 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %64(ptr %17, ptr %15, ptr %16)
  %65 = load i256, ptr %17, align 16
  %66 = trunc i256 %65 to i252
  %67 = add i64 %32, 4
  %68 = sub i252 %66, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %69 = icmp ult i252 %66, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %70 = select i1 %69, i252 %66, i252 %68
  %71 = load ptr, ptr %35, align 8
  store i64 %50, ptr %19, align 8
  store i252 %70, ptr %20, align 16
  %72 = getelementptr inbounds ptr, ptr %35, i32 8
  %73 = load ptr, ptr %72, align 8
  call void %73(ptr %18, ptr %71, ptr %19, i32 0, ptr %20)
  %74 = load { i1, [47 x i8] }, ptr %18, align 1
  %75 = extractvalue { i1, [47 x i8] } %74, 0
  %76 = getelementptr inbounds i8, ptr %18, i32 16
  %77 = load i252, ptr %76, align 16
  %78 = getelementptr inbounds i8, ptr %18, i32 8
  %79 = load { ptr, i32, i32, i32 }, ptr %78, align 8
  %80 = load i64, ptr %19, align 8
  br i1 %75, label %228, label %81

81:                                               ; preds = %51
  %82 = phi i252 [ %77, %51 ]
  %83 = icmp eq i252 %82, 0
  br i1 %83, label %84, label %109

84:                                               ; preds = %81
  %85 = phi i64 [ %80, %81 ]
  %86 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %87 = call ptr %86()
  %88 = getelementptr inbounds i64, ptr %87, i32 1
  %89 = load i64, ptr %88, align 8
  %90 = load i64, ptr %87, align 8
  %91 = mul i64 %90, 15380
  %92 = add i64 %89, %91
  %93 = call i64 @llvm.uadd.sat.i64(i64 %85, i64 %92)
  %94 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } undef, { ptr, i32, i32, i32 } %39, 0
  %95 = insertvalue { { ptr, i32, i32, i32 }, i252, {} } %94, i252 %37, 1
  %96 = insertvalue { i1, { { ptr, i32, i32, i32 }, i252, {} } } { i1 false, { { ptr, i32, i32, i32 }, i252, {} } undef }, { { ptr, i32, i32, i32 }, i252, {} } %95, 1
  store { i1, { { ptr, i32, i32, i32 }, i252, {} } } %96, ptr %30, align 16
  %97 = load { i128, [64 x i8] }, ptr %30, align 16
  %98 = extractvalue { ptr, ptr, i64 } %12, 1
  %99 = load i64, ptr %98, align 8
  %100 = icmp eq i64 %99, 0
  %101 = sub i64 %99, 1
  %102 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %101, ptr %102, align 8
  br i1 %100, label %103, label %195

103:                                              ; preds = %84
  %104 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } undef, i64 %67, 0
  %105 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %104, i64 %93, 1
  %106 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %105, i64 %61, 2
  %107 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %106, ptr %35, 3
  %108 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %107, { i128, [64 x i8] } %97, 4
  ret { i64, i64, i64, ptr, { i128, [64 x i8] } } %108

109:                                              ; preds = %81
  %110 = phi { i252 } [ %38, %81 ]
  %111 = extractvalue { i252 } %110, 0
  %112 = add i64 %34, 6
  %113 = zext i252 %111 to i256
  %114 = zext i252 %59 to i256
  store i256 %113, ptr %22, align 16
  store i256 %114, ptr %23, align 16
  %115 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %115(ptr %24, ptr %22, ptr %23)
  %116 = load i256, ptr %24, align 16
  %117 = trunc i256 %116 to i252
  %118 = add i64 %32, 7
  %119 = sub i252 %117, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %120 = icmp ult i252 %117, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %121 = select i1 %120, i252 %117, i252 %119
  %122 = load ptr, ptr %35, align 8
  store i64 %80, ptr %26, align 8
  store i252 %121, ptr %27, align 16
  store i252 0, ptr %28, align 16
  %123 = getelementptr inbounds ptr, ptr %35, i32 9
  %124 = load ptr, ptr %123, align 8
  call void %124(ptr %25, ptr %122, ptr %26, i32 0, ptr %27, ptr %28)
  %125 = load { i1, [31 x i8] }, ptr %25, align 1
  %126 = extractvalue { i1, [31 x i8] } %125, 0
  %127 = getelementptr inbounds i8, ptr %25, i32 8
  %128 = load { ptr, i32, i32, i32 }, ptr %127, align 8
  %129 = load i64, ptr %26, align 8
  br i1 %126, label %212, label %130

130:                                              ; preds = %109
  %131 = phi i64 [ %129, %109 ]
  %132 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %133 = call ptr %132()
  %134 = call i64 @llvm.uadd.sat.i64(i64 %131, i64 0)
  %135 = extractvalue { ptr, i32, i32, i32 } %39, 3
  %136 = icmp eq i32 %135, 0
  br i1 %136, label %137, label %151

137:                                              ; preds = %130
  %138 = shl i32 %135, 1
  %139 = call i32 @llvm.umin.i32(i32 %138, i32 1024)
  %140 = add i32 %139, %135
  %141 = call i32 @llvm.umax.i32(i32 %140, i32 8)
  %142 = zext i32 %141 to i64
  %143 = mul i64 %142, 32
  %144 = add i64 %143, 16
  %145 = call ptr @realloc(ptr null, i64 %144)
  store i32 1, ptr %145, align 4
  %146 = getelementptr inbounds i8, ptr %145, i32 4
  store i32 0, ptr %146, align 4
  %147 = getelementptr inbounds i8, ptr %145, i32 16
  %148 = call ptr @realloc(ptr null, i64 8)
  store ptr %147, ptr %148, align 8
  %149 = insertvalue { ptr, i32, i32, i32 } %39, ptr %148, 0
  %150 = insertvalue { ptr, i32, i32, i32 } %149, i32 %141, 3
  br label %172

151:                                              ; preds = %130
  %152 = extractvalue { ptr, i32, i32, i32 } %39, 2
  %153 = icmp ult i32 %152, %135
  br i1 %153, label %154, label %155

154:                                              ; preds = %151
  br label %169

155:                                              ; preds = %151
  %156 = shl i32 %135, 1
  %157 = call i32 @llvm.umin.i32(i32 %156, i32 1024)
  %158 = add i32 %157, %135
  %159 = call i32 @llvm.umax.i32(i32 %158, i32 8)
  %160 = zext i32 %159 to i64
  %161 = mul i64 %160, 32
  %162 = add i64 %161, 16
  %163 = extractvalue { ptr, i32, i32, i32 } %39, 0
  %164 = load ptr, ptr %163, align 8
  %165 = getelementptr inbounds i8, ptr %164, i32 -16
  %166 = call ptr @realloc(ptr %165, i64 %162)
  %167 = getelementptr inbounds i8, ptr %166, i32 16
  store ptr %167, ptr %163, align 8
  %168 = insertvalue { ptr, i32, i32, i32 } %39, i32 %159, 3
  br label %169

169:                                              ; preds = %154, %155
  %170 = phi { ptr, i32, i32, i32 } [ %168, %155 ], [ %39, %154 ]
  br label %171

171:                                              ; preds = %169
  br label %172

172:                                              ; preds = %137, %171
  %173 = phi { ptr, i32, i32, i32 } [ %170, %171 ], [ %150, %137 ]
  br label %174

174:                                              ; preds = %172
  %175 = extractvalue { ptr, i32, i32, i32 } %173, 0
  %176 = load ptr, ptr %175, align 8
  %177 = extractvalue { ptr, i32, i32, i32 } %173, 2
  %178 = zext i32 %177 to i64
  %179 = mul i64 %178, 32
  %180 = getelementptr inbounds i8, ptr %176, i64 %179
  store i252 %59, ptr %180, align 16
  %181 = extractvalue { ptr, i32, i32, i32 } %173, 2
  %182 = add i32 %181, 1
  %183 = insertvalue { ptr, i32, i32, i32 } %173, i32 %182, 2
  %184 = getelementptr inbounds i8, ptr %176, i32 -12
  store i32 %182, ptr %184, align 4
  %185 = zext i252 %37 to i256
  %186 = add i256 %185, 1
  %187 = add i256 %185, -3618502788666131213697322783095070105623107215331596699973092056135872020480
  %188 = icmp uge i256 %186, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %189 = select i1 %188, i256 %187, i256 %186
  %190 = trunc i256 %189 to i252
  %191 = extractvalue { ptr, ptr, i64 } %12, 1
  %192 = load i64, ptr %191, align 8
  %193 = add i64 %192, 1
  %194 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %193, ptr %194, align 8
  br label %31

195:                                              ; preds = %195, %228, %84, %212, %244
  %196 = phi i64 [ %40, %244 ], [ %67, %228 ], [ %118, %212 ], [ %196, %195 ], [ %67, %84 ]
  %197 = phi i64 [ %33, %244 ], [ %80, %228 ], [ %129, %212 ], [ %197, %195 ], [ %93, %84 ]
  %198 = phi i64 [ %34, %244 ], [ %61, %228 ], [ %112, %212 ], [ %198, %195 ], [ %61, %84 ]
  %199 = phi ptr [ %35, %244 ], [ %35, %228 ], [ %35, %212 ], [ %199, %195 ], [ %35, %84 ]
  %200 = phi { i128, [64 x i8] } [ %249, %244 ], [ %232, %228 ], [ %216, %212 ], [ %200, %195 ], [ %97, %84 ]
  %201 = extractvalue { ptr, ptr, i64 } %12, 1
  %202 = load i64, ptr %201, align 8
  %203 = icmp eq i64 %202, 0
  %204 = sub i64 %202, 1
  %205 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %204, ptr %205, align 8
  br i1 %203, label %206, label %195

206:                                              ; preds = %195
  %207 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } undef, i64 %196, 0
  %208 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %207, i64 %197, 1
  %209 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %208, i64 %198, 2
  %210 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %209, ptr %199, 3
  %211 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %210, { i128, [64 x i8] } %200, 4
  ret { i64, i64, i64, ptr, { i128, [64 x i8] } } %211

212:                                              ; preds = %109
  %213 = phi { ptr, i32, i32, i32 } [ %39, %109 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %213)
  %214 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %128, 1
  %215 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %214, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %215, ptr %29, align 8
  %216 = load { i128, [64 x i8] }, ptr %29, align 16
  %217 = extractvalue { ptr, ptr, i64 } %12, 1
  %218 = load i64, ptr %217, align 8
  %219 = icmp eq i64 %218, 0
  %220 = sub i64 %218, 1
  %221 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %220, ptr %221, align 8
  br i1 %219, label %222, label %195

222:                                              ; preds = %212
  %223 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } undef, i64 %118, 0
  %224 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %223, i64 %129, 1
  %225 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %224, i64 %112, 2
  %226 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %225, ptr %35, 3
  %227 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %226, { i128, [64 x i8] } %216, 4
  ret { i64, i64, i64, ptr, { i128, [64 x i8] } } %227

228:                                              ; preds = %51
  %229 = phi { ptr, i32, i32, i32 } [ %39, %51 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %229)
  %230 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %79, 1
  %231 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %230, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %231, ptr %21, align 8
  %232 = load { i128, [64 x i8] }, ptr %21, align 16
  %233 = extractvalue { ptr, ptr, i64 } %12, 1
  %234 = load i64, ptr %233, align 8
  %235 = icmp eq i64 %234, 0
  %236 = sub i64 %234, 1
  %237 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %236, ptr %237, align 8
  br i1 %235, label %238, label %195

238:                                              ; preds = %228
  %239 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } undef, i64 %67, 0
  %240 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %239, i64 %80, 1
  %241 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %240, i64 %61, 2
  %242 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %241, ptr %35, 3
  %243 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %242, { i128, [64 x i8] } %232, 4
  ret { i64, i64, i64, ptr, { i128, [64 x i8] } } %243

244:                                              ; preds = %31
  %245 = phi { ptr, i32, i32, i32 } [ %39, %31 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %245)
  %246 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %247 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %246, 0
  %248 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %247, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %248, ptr %14, align 8
  %249 = load { i128, [64 x i8] }, ptr %14, align 16
  %250 = extractvalue { ptr, ptr, i64 } %12, 1
  %251 = load i64, ptr %250, align 8
  %252 = icmp eq i64 %251, 0
  %253 = sub i64 %251, 1
  %254 = extractvalue { ptr, ptr, i64 } %12, 1
  store i64 %253, ptr %254, align 8
  br i1 %252, label %255, label %195

255:                                              ; preds = %244
  %256 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } undef, i64 %40, 0
  %257 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %256, i64 %33, 1
  %258 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %257, i64 %34, 2
  %259 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %258, ptr %35, 3
  %260 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %259, { i128, [64 x i8] } %249, 4
  ret { i64, i64, i64, ptr, { i128, [64 x i8] } } %260
}

define private { i64, i64, i64, ptr, { i128, [64 x i8] } } @f90(i64 %0, i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { i252 } %6, { ptr, i32, i32, i32 } %7) {
  %9 = call fastcc { i64, i64, i64, ptr, { i128, [64 x i8] } } @"impl$f90"(i64 %0, i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { i252 } %6, { ptr, i32, i32, i32 } %7)
  %10 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %9, 2
  %13 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %9, 3
  %14 = extractvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %9, 4
  %15 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } undef, i64 %10, 0
  %16 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %15, i64 %11, 1
  %17 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %16, i64 %12, 2
  %18 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %17, ptr %13, 3
  %19 = insertvalue { i64, i64, i64, ptr, { i128, [64 x i8] } } %18, { i128, [64 x i8] } %14, 4
  ret { i64, i64, i64, ptr, { i128, [64 x i8] } } %19
}

define void @_mlir_ciface_f90(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, i252 %5, i252 %6, { i252 } %7, { ptr, i32, i32, i32 } %8) {
  %10 = call { i64, i64, i64, ptr, { i128, [64 x i8] } } @f90(i64 %1, i64 %2, i64 %3, ptr %4, i252 %5, i252 %6, { i252 } %7, { ptr, i32, i32, i32 } %8)
  store { i64, i64, i64, ptr, { i128, [64 x i8] } } %10, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f91"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 } } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i1, [31 x i8] }, i64 1, align 8
  %14 = alloca i64, i64 1, align 8
  %15 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %16 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %18

18:                                               ; preds = %71, %5
  %19 = phi i64 [ %24, %71 ], [ %0, %5 ]
  %20 = phi i64 [ %75, %71 ], [ %1, %5 ]
  %21 = phi ptr [ %21, %71 ], [ %2, %5 ]
  %22 = phi { { ptr, i32, i32, i32 } } [ %76, %71 ], [ %3, %5 ]
  %23 = phi i252 [ %23, %71 ], [ %4, %5 ]
  %24 = add i64 %19, 1
  %25 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %26 = call ptr %25()
  %27 = load i64, ptr %26, align 8
  %28 = mul i64 %27, 13270
  %29 = icmp uge i64 %20, %28
  %30 = call i64 @llvm.usub.sat.i64(i64 %20, i64 %28)
  br i1 %29, label %31, label %132

31:                                               ; preds = %18
  %32 = phi { { ptr, i32, i32, i32 } } [ %22, %18 ]
  %33 = extractvalue { { ptr, i32, i32, i32 } } %32, 0
  %34 = extractvalue { ptr, i32, i32, i32 } %33, 1
  %35 = extractvalue { ptr, i32, i32, i32 } %33, 2
  %36 = sub i32 %35, %34
  %37 = icmp uge i32 %36, 1
  br i1 %37, label %38, label %111

38:                                               ; preds = %31
  %39 = extractvalue { ptr, i32, i32, i32 } %33, 0
  %40 = load ptr, ptr %39, align 8
  %41 = zext i32 %34 to i64
  %42 = mul i64 %41, 32
  %43 = getelementptr inbounds i8, ptr %40, i64 %42
  %44 = add i32 %34, 1
  %45 = insertvalue { ptr, i32, i32, i32 } %33, i32 %44, 1
  %46 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %46, ptr %43, i64 32, i1 false)
  %47 = load i252, ptr %46, align 16
  call void @free(ptr %46)
  %48 = insertvalue { i252, i252, i252 } { i252 181315633587806608749396046320465637423067733253841877734401949135886786816, i252 undef, i252 undef }, i252 %23, 1
  %49 = insertvalue { i252, i252, i252 } %48, i252 %47, 2
  %50 = call ptr @realloc(ptr null, i64 96)
  store { i252, i252, i252 } %49, ptr %50, align 16
  %51 = call ptr @realloc(ptr null, i64 112)
  store { i32, i32 } { i32 1, i32 3 }, ptr %51, align 4
  %52 = getelementptr inbounds i8, ptr %51, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %52, ptr %50, i64 96, i1 false)
  call void @free(ptr %50)
  %53 = call ptr @realloc(ptr null, i64 8)
  store ptr %52, ptr %53, align 8
  %54 = insertvalue { ptr, i32, i32, i32 } undef, ptr %53, 0
  %55 = insertvalue { ptr, i32, i32, i32 } %54, i32 0, 1
  %56 = insertvalue { ptr, i32, i32, i32 } %55, i32 3, 2
  %57 = insertvalue { ptr, i32, i32, i32 } %56, i32 3, 3
  %58 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } zeroinitializer)
  %59 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %58, 0
  %60 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %58, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %59)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %57, 0
  %62 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %60, 0
  %63 = load ptr, ptr %21, align 8
  store i64 %30, ptr %14, align 8
  store { { ptr, i32, i32, i32 } } %61, ptr %15, align 8
  store { { ptr, i32, i32, i32 } } %62, ptr %16, align 8
  %64 = getelementptr inbounds ptr, ptr %21, i32 10
  %65 = load ptr, ptr %64, align 8
  call void %65(ptr %13, ptr %63, ptr %14, ptr %15, ptr %16)
  %66 = load { i1, [31 x i8] }, ptr %13, align 1
  %67 = extractvalue { i1, [31 x i8] } %66, 0
  %68 = getelementptr inbounds i8, ptr %13, i32 8
  %69 = load { ptr, i32, i32, i32 }, ptr %68, align 8
  %70 = load i64, ptr %14, align 8
  br i1 %67, label %96, label %71

71:                                               ; preds = %38
  %72 = phi i64 [ %70, %38 ]
  %73 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %74 = call ptr %73()
  %75 = call i64 @llvm.uadd.sat.i64(i64 %72, i64 0)
  %76 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %45, 0
  %77 = extractvalue { ptr, ptr, i64 } %9, 1
  %78 = load i64, ptr %77, align 8
  %79 = add i64 %78, 1
  %80 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %79, ptr %80, align 8
  br label %18

81:                                               ; preds = %81, %96, %111, %132
  %82 = phi i64 [ %24, %132 ], [ %24, %111 ], [ %24, %96 ], [ %82, %81 ]
  %83 = phi i64 [ %20, %132 ], [ %117, %111 ], [ %70, %96 ], [ %83, %81 ]
  %84 = phi ptr [ %21, %132 ], [ %21, %111 ], [ %21, %96 ], [ %84, %81 ]
  %85 = phi { i64, [24 x i8] } [ %137, %132 ], [ %121, %111 ], [ %100, %96 ], [ %85, %81 ]
  %86 = extractvalue { ptr, ptr, i64 } %9, 1
  %87 = load i64, ptr %86, align 8
  %88 = icmp eq i64 %87, 0
  %89 = sub i64 %87, 1
  %90 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %89, ptr %90, align 8
  br i1 %88, label %91, label %81

91:                                               ; preds = %81
  %92 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %82, 0
  %93 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %92, i64 %83, 1
  %94 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %93, ptr %84, 2
  %95 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %94, { i64, [24 x i8] } %85, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %95

96:                                               ; preds = %38
  %97 = phi { ptr, i32, i32, i32 } [ %45, %38 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %97)
  %98 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %69, 1
  %99 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %98, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %99, ptr %17, align 8
  %100 = load { i64, [24 x i8] }, ptr %17, align 8
  %101 = extractvalue { ptr, ptr, i64 } %9, 1
  %102 = load i64, ptr %101, align 8
  %103 = icmp eq i64 %102, 0
  %104 = sub i64 %102, 1
  %105 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %104, ptr %105, align 8
  br i1 %103, label %106, label %81

106:                                              ; preds = %96
  %107 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %24, 0
  %108 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %107, i64 %70, 1
  %109 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %108, ptr %21, 2
  %110 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %109, { i64, [24 x i8] } %100, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %110

111:                                              ; preds = %31
  %112 = phi i64 [ %30, %31 ]
  %113 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %114 = call ptr %113()
  %115 = load i64, ptr %114, align 8
  %116 = mul i64 %115, 13970
  %117 = call i64 @llvm.uadd.sat.i64(i64 %112, i64 %116)
  %118 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %33, 0
  %119 = insertvalue { { { ptr, i32, i32, i32 } }, {} } undef, { { ptr, i32, i32, i32 } } %118, 0
  %120 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, {} } undef }, { { { ptr, i32, i32, i32 } }, {} } %119, 1
  store { i1, { { { ptr, i32, i32, i32 } }, {} } } %120, ptr %12, align 8
  %121 = load { i64, [24 x i8] }, ptr %12, align 8
  %122 = extractvalue { ptr, ptr, i64 } %9, 1
  %123 = load i64, ptr %122, align 8
  %124 = icmp eq i64 %123, 0
  %125 = sub i64 %123, 1
  %126 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %125, ptr %126, align 8
  br i1 %124, label %127, label %81

127:                                              ; preds = %111
  %128 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %24, 0
  %129 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %128, i64 %117, 1
  %130 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %129, ptr %21, 2
  %131 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %121, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %131

132:                                              ; preds = %18
  %133 = phi { { ptr, i32, i32, i32 } } [ %22, %18 ]
  call void @"drop$303"({ { ptr, i32, i32, i32 } } %133)
  %134 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %135 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %134, 0
  %136 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %135, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %136, ptr %11, align 8
  %137 = load { i64, [24 x i8] }, ptr %11, align 8
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  %139 = load i64, ptr %138, align 8
  %140 = icmp eq i64 %139, 0
  %141 = sub i64 %139, 1
  %142 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %141, ptr %142, align 8
  br i1 %140, label %143, label %81

143:                                              ; preds = %132
  %144 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %24, 0
  %145 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %144, i64 %20, 1
  %146 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %145, ptr %21, 2
  %147 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %146, { i64, [24 x i8] } %137, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %147
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f91(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 } } %3, i252 %4) {
  %6 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f91"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 } } %3, i252 %4)
  %7 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %11, i64 %8, 1
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, ptr %9, 2
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %10, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %14
}

define void @_mlir_ciface_f91(ptr %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, i252 %5) {
  %7 = call { i64, i64, ptr, { i64, [24 x i8] } } @f91(i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 } } %4, i252 %5)
  store { i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [32 x i8] } } @"impl$f92"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, i32 } %4, i252 %5, i32 %6, { {} } %7, { i3, [0 x i8] } %8) {
  %10 = alloca i64, i64 1, align 8
  %11 = insertvalue { ptr, ptr, i64 } undef, ptr %10, 0
  %12 = insertvalue { ptr, ptr, i64 } %11, ptr %10, 1
  %13 = insertvalue { ptr, ptr, i64 } %12, i64 0, 2
  %14 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 0, ptr %14, align 8
  %15 = alloca { i64, [32 x i8] }, i64 1, align 8
  %16 = alloca { i64, [32 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [32 x i8] }, i64 1, align 8
  %19 = alloca i256, i64 1, align 16
  %20 = alloca i256, i64 1, align 16
  %21 = alloca i256, i64 1, align 16
  %22 = alloca { i1, [31 x i8] }, i64 1, align 8
  %23 = alloca i64, i64 1, align 8
  %24 = alloca i252, i64 1, align 16
  %25 = alloca i252, i64 1, align 16
  %26 = alloca { i64, [32 x i8] }, i64 1, align 8
  %27 = alloca { i64, [32 x i8] }, i64 1, align 8
  br label %28

28:                                               ; preds = %137, %9
  %29 = phi i64 [ %115, %137 ], [ %0, %9 ]
  %30 = phi i64 [ %141, %137 ], [ %1, %9 ]
  %31 = phi i64 [ %110, %137 ], [ %2, %9 ]
  %32 = phi ptr [ %104, %137 ], [ %3, %9 ]
  %33 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %144, %137 ], [ %4, %9 ]
  %34 = phi i252 [ %34, %137 ], [ %5, %9 ]
  %35 = phi i32 [ %35, %137 ], [ %6, %9 ]
  %36 = phi { i3, [0 x i8] } [ %36, %137 ], [ %8, %9 ]
  %37 = add i64 %29, 1
  %38 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %39 = call ptr %38()
  %40 = getelementptr inbounds i64, ptr %39, i32 1
  %41 = load i64, ptr %40, align 8
  %42 = load i64, ptr %39, align 8
  %43 = mul i64 %42, 33950
  %44 = add i64 %41, %43
  %45 = icmp uge i64 %30, %44
  %46 = call i64 @llvm.usub.sat.i64(i64 %30, i64 %44)
  br i1 %45, label %47, label %215

47:                                               ; preds = %28
  %48 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %33, %28 ]
  %49 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %48, 0
  %50 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %48, 1
  %51 = extractvalue { { ptr, i32, i32, i32 } } %49, 0
  %52 = extractvalue { ptr, i32, i32, i32 } %51, 1
  %53 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %54 = sub i32 %53, %52
  %55 = icmp uge i32 %54, 1
  br i1 %55, label %56, label %188

56:                                               ; preds = %47
  %57 = extractvalue { ptr, i32, i32, i32 } %51, 0
  %58 = load ptr, ptr %57, align 8
  %59 = zext i32 %52 to i64
  %60 = mul i64 %59, 32
  %61 = getelementptr inbounds i8, ptr %58, i64 %60
  %62 = add i32 %52, 1
  %63 = insertvalue { ptr, i32, i32, i32 } %51, i32 %62, 1
  %64 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %64, ptr %61, i64 32, i1 false)
  %65 = icmp eq i32 %50, -1
  br i1 %65, label %66, label %83

66:                                               ; preds = %56
  %67 = phi { ptr, i32, i32, i32 } [ %63, %56 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %67)
  call void @"drop$555"(ptr %64)
  %68 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f83"()
  %69 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %68, 0
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %27, align 8
  %71 = load { i64, [32 x i8] }, ptr %27, align 8
  %72 = extractvalue { ptr, ptr, i64 } %13, 1
  %73 = load i64, ptr %72, align 8
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %73, 1
  %76 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %75, ptr %76, align 8
  br i1 %74, label %77, label %149

77:                                               ; preds = %66
  %78 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %37, 0
  %79 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %78, i64 %46, 1
  %80 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %79, i64 %31, 2
  %81 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %80, ptr %32, 3
  %82 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %81, { i64, [32 x i8] } %71, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %82

83:                                               ; preds = %56
  %84 = phi i32 [ %50, %56 ]
  %85 = phi i1 [ false, %56 ]
  %86 = zext i1 %85 to i32
  %87 = add i32 %86, 1
  %88 = add i32 %84, %87
  %89 = load i252, ptr %64, align 16
  call void @free(ptr %64)
  %90 = zext i252 %34 to i256
  %91 = zext i32 %50 to i256
  %92 = add i256 %90, %91
  %93 = sub i256 %92, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %94 = icmp uge i256 %92, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %95 = select i1 %94, i256 %93, i256 %92
  %96 = trunc i256 %95 to i252
  %97 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } undef, { i3, [0 x i8] } %36, 0
  %98 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %97, i32 %35, 1
  %99 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %98, i32 %50, 2
  %100 = insertvalue { { i3, [0 x i8] }, i32, i32, i252 } %99, i252 %89, 3
  %101 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f116"(i64 %37, i64 %46, ptr %32, i252 3055551908028526501914924269284987698957048785899022598052704863388955138917, i252 %96, { { i3, [0 x i8] }, i32, i32, i252 } %100)
  %102 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %101, 0
  %103 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %101, 1
  %104 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %101, 2
  %105 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %101, 3
  store { i64, [24 x i8] } %105, ptr %17, align 8
  %106 = load i1, ptr %17, align 1
  switch i1 %106, label %107 [
    i1 false, label %109
    i1 true, label %127
  ]

107:                                              ; preds = %83
  br i1 false, label %108, label %232

108:                                              ; preds = %107
  unreachable

109:                                              ; preds = %83
  %110 = add i64 %31, 3
  %111 = zext i252 %96 to i256
  store i256 1436209994116032968217460821259974301319484759399248048177294919499399378304, ptr %19, align 16
  store i256 %111, ptr %20, align 16
  %112 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %112(ptr %21, ptr %19, ptr %20)
  %113 = load i256, ptr %21, align 16
  %114 = trunc i256 %113 to i252
  %115 = add i64 %102, 3
  %116 = sub i252 %114, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %117 = icmp ult i252 %114, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %118 = select i1 %117, i252 %114, i252 %116
  %119 = load ptr, ptr %104, align 8
  store i64 %103, ptr %23, align 8
  store i252 %118, ptr %24, align 16
  store i252 %89, ptr %25, align 16
  %120 = getelementptr inbounds ptr, ptr %104, i32 9
  %121 = load ptr, ptr %120, align 8
  call void %121(ptr %22, ptr %119, ptr %23, i32 0, ptr %24, ptr %25)
  %122 = load { i1, [31 x i8] }, ptr %22, align 1
  %123 = extractvalue { i1, [31 x i8] } %122, 0
  %124 = getelementptr inbounds i8, ptr %22, i32 8
  %125 = load { ptr, i32, i32, i32 }, ptr %124, align 8
  %126 = load i64, ptr %23, align 8
  br i1 %123, label %166, label %137

127:                                              ; preds = %83
  %128 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %17, align 8
  %129 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %128, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %63)
  %130 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %129, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %130, ptr %18, align 8
  %131 = load { i64, [32 x i8] }, ptr %18, align 8
  %132 = extractvalue { ptr, ptr, i64 } %13, 1
  %133 = load i64, ptr %132, align 8
  %134 = icmp eq i64 %133, 0
  %135 = sub i64 %133, 1
  %136 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %135, ptr %136, align 8
  br i1 %134, label %182, label %149

137:                                              ; preds = %109
  %138 = phi i64 [ %126, %109 ]
  %139 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %140 = call ptr %139()
  %141 = call i64 @llvm.uadd.sat.i64(i64 %138, i64 0)
  %142 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %63, 0
  %143 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %142, 0
  %144 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %143, i32 %88, 1
  %145 = extractvalue { ptr, ptr, i64 } %13, 1
  %146 = load i64, ptr %145, align 8
  %147 = add i64 %146, 1
  %148 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %147, ptr %148, align 8
  br label %28

149:                                              ; preds = %149, %66, %166, %127, %188, %215
  %150 = phi i64 [ %37, %215 ], [ %37, %188 ], [ %115, %166 ], [ %150, %149 ], [ %102, %127 ], [ %37, %66 ]
  %151 = phi i64 [ %30, %215 ], [ %197, %188 ], [ %126, %166 ], [ %151, %149 ], [ %103, %127 ], [ %46, %66 ]
  %152 = phi i64 [ %31, %215 ], [ %31, %188 ], [ %110, %166 ], [ %152, %149 ], [ %31, %127 ], [ %31, %66 ]
  %153 = phi ptr [ %32, %215 ], [ %32, %188 ], [ %104, %166 ], [ %153, %149 ], [ %104, %127 ], [ %32, %66 ]
  %154 = phi { i64, [32 x i8] } [ %220, %215 ], [ %203, %188 ], [ %170, %166 ], [ %154, %149 ], [ %131, %127 ], [ %71, %66 ]
  %155 = extractvalue { ptr, ptr, i64 } %13, 1
  %156 = load i64, ptr %155, align 8
  %157 = icmp eq i64 %156, 0
  %158 = sub i64 %156, 1
  %159 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %158, ptr %159, align 8
  br i1 %157, label %160, label %149

160:                                              ; preds = %149
  %161 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %150, 0
  %162 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %161, i64 %151, 1
  %163 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %162, i64 %152, 2
  %164 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %163, ptr %153, 3
  %165 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %164, { i64, [32 x i8] } %154, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %165

166:                                              ; preds = %109
  %167 = phi { ptr, i32, i32, i32 } [ %63, %109 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %167)
  %168 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %125, 1
  %169 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %168, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %169, ptr %26, align 8
  %170 = load { i64, [32 x i8] }, ptr %26, align 8
  %171 = extractvalue { ptr, ptr, i64 } %13, 1
  %172 = load i64, ptr %171, align 8
  %173 = icmp eq i64 %172, 0
  %174 = sub i64 %172, 1
  %175 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %174, ptr %175, align 8
  br i1 %173, label %176, label %149

176:                                              ; preds = %166
  %177 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %115, 0
  %178 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %177, i64 %126, 1
  %179 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %178, i64 %110, 2
  %180 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %179, ptr %104, 3
  %181 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %180, { i64, [32 x i8] } %170, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %181

182:                                              ; preds = %127
  %183 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %102, 0
  %184 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %183, i64 %103, 1
  %185 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %184, i64 %31, 2
  %186 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %185, ptr %104, 3
  %187 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %186, { i64, [32 x i8] } %131, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %187

188:                                              ; preds = %47
  %189 = phi i64 [ %46, %47 ]
  %190 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %191 = call ptr %190()
  %192 = getelementptr inbounds i64, ptr %191, i32 1
  %193 = load i64, ptr %192, align 8
  %194 = load i64, ptr %191, align 8
  %195 = mul i64 %194, 34150
  %196 = add i64 %193, %195
  %197 = call i64 @llvm.uadd.sat.i64(i64 %189, i64 %196)
  %198 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %51, 0
  %199 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %198, 0
  %200 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %199, i32 %50, 1
  %201 = insertvalue { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } undef, { { { ptr, i32, i32, i32 } }, i32 } %200, 0
  %202 = insertvalue { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } { i1 false, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } undef }, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } %201, 1
  store { i1, { { { { ptr, i32, i32, i32 } }, i32 }, { {} }, {} } } %202, ptr %16, align 8
  %203 = load { i64, [32 x i8] }, ptr %16, align 8
  %204 = extractvalue { ptr, ptr, i64 } %13, 1
  %205 = load i64, ptr %204, align 8
  %206 = icmp eq i64 %205, 0
  %207 = sub i64 %205, 1
  %208 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %207, ptr %208, align 8
  br i1 %206, label %209, label %149

209:                                              ; preds = %188
  %210 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %37, 0
  %211 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %210, i64 %197, 1
  %212 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %211, i64 %31, 2
  %213 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %212, ptr %32, 3
  %214 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %213, { i64, [32 x i8] } %203, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %214

215:                                              ; preds = %28
  %216 = phi { { { ptr, i32, i32, i32 } }, i32 } [ %33, %28 ]
  call void @"drop$304"({ { { ptr, i32, i32, i32 } }, i32 } %216)
  %217 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %218 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %217, 0
  %219 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %218, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %219, ptr %15, align 8
  %220 = load { i64, [32 x i8] }, ptr %15, align 8
  %221 = extractvalue { ptr, ptr, i64 } %13, 1
  %222 = load i64, ptr %221, align 8
  %223 = icmp eq i64 %222, 0
  %224 = sub i64 %222, 1
  %225 = extractvalue { ptr, ptr, i64 } %13, 1
  store i64 %224, ptr %225, align 8
  br i1 %223, label %226, label %149

226:                                              ; preds = %215
  %227 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %37, 0
  %228 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %227, i64 %30, 1
  %229 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %228, i64 %31, 2
  %230 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %229, ptr %32, 3
  %231 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %230, { i64, [32 x i8] } %220, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %231

232:                                              ; preds = %107
  call void @puts(ptr @assert_msg_158)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, ptr, { i64, [32 x i8] } } @f92(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, i32 } %4, i252 %5, i32 %6, { {} } %7, { i3, [0 x i8] } %8) {
  %10 = call fastcc { i64, i64, i64, ptr, { i64, [32 x i8] } } @"impl$f92"(i64 %0, i64 %1, i64 %2, ptr %3, { { { ptr, i32, i32, i32 } }, i32 } %4, i252 %5, i32 %6, { {} } %7, { i3, [0 x i8] } %8)
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %10, 2
  %14 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %10, 3
  %15 = extractvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %10, 4
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } undef, i64 %11, 0
  %17 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %16, i64 %12, 1
  %18 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %17, i64 %13, 2
  %19 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %18, ptr %14, 3
  %20 = insertvalue { i64, i64, i64, ptr, { i64, [32 x i8] } } %19, { i64, [32 x i8] } %15, 4
  ret { i64, i64, i64, ptr, { i64, [32 x i8] } } %20
}

define void @_mlir_ciface_f92(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, i32 } %5, i252 %6, i32 %7, { {} } %8, { i3, [0 x i8] } %9) {
  %11 = call { i64, i64, i64, ptr, { i64, [32 x i8] } } @f92(i64 %1, i64 %2, i64 %3, ptr %4, { { { ptr, i32, i32, i32 } }, i32 } %5, i252 %6, i32 %7, { {} } %8, { i3, [0 x i8] } %9)
  store { i64, i64, i64, ptr, { i64, [32 x i8] } } %11, ptr %0, align 8
  ret void
}

define private void @"drop$141"({ { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { i128, [144 x i8] } } %0, 0
  call void @"drop$140"({ i128, [144 x i8] } %2)
  ret void
}

define private { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } @"dup$141"({ { i128, [144 x i8] } } %0) {
  %2 = extractvalue { { i128, [144 x i8] } } %0, 0
  %3 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$140"({ i128, [144 x i8] } %2)
  %4 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %3, 0
  %5 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %3, 1
  %6 = insertvalue { { i128, [144 x i8] } } %0, { i128, [144 x i8] } %4, 0
  %7 = insertvalue { { i128, [144 x i8] } } undef, { i128, [144 x i8] } %5, 0
  %8 = insertvalue { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } undef, { { i128, [144 x i8] } } %6, 0
  %9 = insertvalue { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } %8, { { i128, [144 x i8] } } %7, 1
  ret { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } %9
}

define private void @"drop$142"({ i128, [160 x i8] } %0) {
  %2 = alloca { i128, [160 x i8] }, i64 1, align 16
  store { i128, [160 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i128, [144 x i8] } } } %5, 1
  call void @"drop$141"({ { i128, [144 x i8] } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [160 x i8] }, { i128, [160 x i8] } } @"dup$142"({ i128, [160 x i8] } %0) {
  %2 = alloca { i128, [160 x i8] }, i64 1, align 16
  store { i128, [160 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i128, [144 x i8] } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { i128, [144 x i8] } } } %5, 1
  %7 = call { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } @"dup$141"({ { i128, [144 x i8] } } %6)
  %8 = extractvalue { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } %7, 0
  %9 = extractvalue { { { i128, [144 x i8] } }, { { i128, [144 x i8] } } } %7, 1
  %10 = insertvalue { i1, { { i128, [144 x i8] } } } %5, { { i128, [144 x i8] } } %8, 1
  store { i1, { { i128, [144 x i8] } } } %10, ptr %2, align 16
  %11 = load { i128, [160 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { i128, [144 x i8] } } } %5, { { i128, [144 x i8] } } %9, 1
  store { i1, { { i128, [144 x i8] } } } %12, ptr %2, align 16
  %13 = load { i128, [160 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } undef, { i128, [160 x i8] } %11, 0
  %15 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %14, { i128, [160 x i8] } %13, 1
  ret { { i128, [160 x i8] }, { i128, [160 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [160 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [160 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } undef, { i128, [160 x i8] } %23, 0
  %27 = insertvalue { { i128, [160 x i8] }, { i128, [160 x i8] } } %26, { i128, [160 x i8] } %25, 1
  ret { { i128, [160 x i8] }, { i128, [160 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f93"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [48 x i8] }, i64 1, align 8
  %11 = alloca { i64, [48 x i8] }, i64 1, align 8
  %12 = alloca { i128, [144 x i8] }, i64 1, align 16
  %13 = alloca { i128, [160 x i8] }, i64 1, align 16
  %14 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %102, %4
  %16 = phi i64 [ %49, %102 ], [ %0, %4 ]
  %17 = phi i64 [ %60, %102 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %61, %102 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %111, %102 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 19380
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %165

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %144

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 160
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 160)
  %43 = load { i128, [144 x i8] }, ptr %39, align 16
  %44 = call { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$140"({ i128, [144 x i8] } %43)
  %45 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %44, 0
  %46 = extractvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %44, 1
  store { i128, [144 x i8] } %45, ptr %39, align 16
  store { i128, [144 x i8] } %46, ptr %42, align 16
  %47 = load { i128, [144 x i8] }, ptr %42, align 16
  call void @free(ptr %42)
  store { i128, [144 x i8] } %47, ptr %12, align 16
  %48 = call fastcc { i64, i64, { i128, [160 x i8] } } @"impl$f117"(i64 %20, i64 %26, ptr %12)
  %49 = extractvalue { i64, i64, { i128, [160 x i8] } } %48, 0
  %50 = extractvalue { i64, i64, { i128, [160 x i8] } } %48, 1
  %51 = extractvalue { i64, i64, { i128, [160 x i8] } } %48, 2
  store { i128, [160 x i8] } %51, ptr %13, align 16
  %52 = load i1, ptr %13, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %117
  ]

53:                                               ; preds = %34
  br i1 false, label %54, label %180

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %34
  %56 = load { i1, { { i128, [144 x i8] } } }, ptr %13, align 16
  %57 = extractvalue { i1, { { i128, [144 x i8] } } } %56, 1
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 0)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %62 = extractvalue { { i128, [144 x i8] } } %57, 0
  %63 = extractvalue { ptr, i32, i32, i32 } %19, 3
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %65, label %79

65:                                               ; preds = %55
  %66 = shl i32 %63, 1
  %67 = call i32 @llvm.umin.i32(i32 %66, i32 1024)
  %68 = add i32 %67, %63
  %69 = call i32 @llvm.umax.i32(i32 %68, i32 8)
  %70 = zext i32 %69 to i64
  %71 = mul i64 %70, 160
  %72 = add i64 %71, 16
  %73 = call ptr @realloc(ptr null, i64 %72)
  store i32 1, ptr %73, align 4
  %74 = getelementptr inbounds i8, ptr %73, i32 4
  store i32 0, ptr %74, align 4
  %75 = getelementptr inbounds i8, ptr %73, i32 16
  %76 = call ptr @realloc(ptr null, i64 8)
  store ptr %75, ptr %76, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } %19, ptr %76, 0
  %78 = insertvalue { ptr, i32, i32, i32 } %77, i32 %69, 3
  br label %100

79:                                               ; preds = %55
  %80 = extractvalue { ptr, i32, i32, i32 } %19, 2
  %81 = icmp ult i32 %80, %63
  br i1 %81, label %82, label %83

82:                                               ; preds = %79
  br label %97

83:                                               ; preds = %79
  %84 = shl i32 %63, 1
  %85 = call i32 @llvm.umin.i32(i32 %84, i32 1024)
  %86 = add i32 %85, %63
  %87 = call i32 @llvm.umax.i32(i32 %86, i32 8)
  %88 = zext i32 %87 to i64
  %89 = mul i64 %88, 160
  %90 = add i64 %89, 16
  %91 = extractvalue { ptr, i32, i32, i32 } %19, 0
  %92 = load ptr, ptr %91, align 8
  %93 = getelementptr inbounds i8, ptr %92, i32 -16
  %94 = call ptr @realloc(ptr %93, i64 %90)
  %95 = getelementptr inbounds i8, ptr %94, i32 16
  store ptr %95, ptr %91, align 8
  %96 = insertvalue { ptr, i32, i32, i32 } %19, i32 %87, 3
  br label %97

97:                                               ; preds = %82, %83
  %98 = phi { ptr, i32, i32, i32 } [ %96, %83 ], [ %19, %82 ]
  br label %99

99:                                               ; preds = %97
  br label %100

100:                                              ; preds = %65, %99
  %101 = phi { ptr, i32, i32, i32 } [ %98, %99 ], [ %78, %65 ]
  br label %102

102:                                              ; preds = %100
  %103 = extractvalue { ptr, i32, i32, i32 } %101, 0
  %104 = load ptr, ptr %103, align 8
  %105 = extractvalue { ptr, i32, i32, i32 } %101, 2
  %106 = zext i32 %105 to i64
  %107 = mul i64 %106, 160
  %108 = getelementptr inbounds i8, ptr %104, i64 %107
  store { i128, [144 x i8] } %62, ptr %108, align 16
  %109 = extractvalue { ptr, i32, i32, i32 } %101, 2
  %110 = add i32 %109, 1
  %111 = insertvalue { ptr, i32, i32, i32 } %101, i32 %110, 2
  %112 = getelementptr inbounds i8, ptr %104, i32 -12
  store i32 %110, ptr %112, align 4
  %113 = extractvalue { ptr, ptr, i64 } %8, 1
  %114 = load i64, ptr %113, align 8
  %115 = add i64 %114, 1
  %116 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %115, ptr %116, align 8
  br label %15

117:                                              ; preds = %34
  %118 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %119 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %118, 1
  call void @"drop$293"({ ptr, i32, i32, i32 } %41)
  call void @"drop$292"({ ptr, i32, i32, i32 } %19)
  %120 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %119, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %120, ptr %14, align 8
  %121 = load { i64, [48 x i8] }, ptr %14, align 8
  %122 = extractvalue { ptr, ptr, i64 } %8, 1
  %123 = load i64, ptr %122, align 8
  %124 = icmp eq i64 %123, 0
  %125 = sub i64 %123, 1
  %126 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %125, ptr %126, align 8
  br i1 %124, label %140, label %127

127:                                              ; preds = %127, %117, %144, %165
  %128 = phi i64 [ %20, %165 ], [ %20, %144 ], [ %128, %127 ], [ %49, %117 ]
  %129 = phi i64 [ %17, %165 ], [ %150, %144 ], [ %129, %127 ], [ %50, %117 ]
  %130 = phi { i64, [48 x i8] } [ %170, %165 ], [ %155, %144 ], [ %130, %127 ], [ %121, %117 ]
  %131 = extractvalue { ptr, ptr, i64 } %8, 1
  %132 = load i64, ptr %131, align 8
  %133 = icmp eq i64 %132, 0
  %134 = sub i64 %132, 1
  %135 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %134, ptr %135, align 8
  br i1 %133, label %136, label %127

136:                                              ; preds = %127
  %137 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %128, 0
  %138 = insertvalue { i64, i64, { i64, [48 x i8] } } %137, i64 %129, 1
  %139 = insertvalue { i64, i64, { i64, [48 x i8] } } %138, { i64, [48 x i8] } %130, 2
  ret { i64, i64, { i64, [48 x i8] } } %139

140:                                              ; preds = %117
  %141 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %49, 0
  %142 = insertvalue { i64, i64, { i64, [48 x i8] } } %141, i64 %50, 1
  %143 = insertvalue { i64, i64, { i64, [48 x i8] } } %142, { i64, [48 x i8] } %121, 2
  ret { i64, i64, { i64, [48 x i8] } } %143

144:                                              ; preds = %27
  %145 = phi i64 [ %26, %27 ]
  %146 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %147 = call ptr %146()
  %148 = load i64, ptr %147, align 8
  %149 = mul i64 %148, 20080
  %150 = call i64 @llvm.uadd.sat.i64(i64 %145, i64 %149)
  %151 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %29, 0
  %152 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %151, 0
  %153 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %152, { ptr, i32, i32, i32 } %19, 1
  %154 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %153, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %154, ptr %11, align 8
  %155 = load { i64, [48 x i8] }, ptr %11, align 8
  %156 = extractvalue { ptr, ptr, i64 } %8, 1
  %157 = load i64, ptr %156, align 8
  %158 = icmp eq i64 %157, 0
  %159 = sub i64 %157, 1
  %160 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %159, ptr %160, align 8
  br i1 %158, label %161, label %127

161:                                              ; preds = %144
  %162 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %20, 0
  %163 = insertvalue { i64, i64, { i64, [48 x i8] } } %162, i64 %150, 1
  %164 = insertvalue { i64, i64, { i64, [48 x i8] } } %163, { i64, [48 x i8] } %155, 2
  ret { i64, i64, { i64, [48 x i8] } } %164

165:                                              ; preds = %15
  %166 = phi { ptr, i32, i32, i32 } [ %19, %15 ]
  call void @"drop$292"({ ptr, i32, i32, i32 } %166)
  call void @"drop$294"({ { ptr, i32, i32, i32 } } %18)
  %167 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %168 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %167, 0
  %169 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %168, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %169, ptr %10, align 8
  %170 = load { i64, [48 x i8] }, ptr %10, align 8
  %171 = extractvalue { ptr, ptr, i64 } %8, 1
  %172 = load i64, ptr %171, align 8
  %173 = icmp eq i64 %172, 0
  %174 = sub i64 %172, 1
  %175 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %174, ptr %175, align 8
  br i1 %173, label %176, label %127

176:                                              ; preds = %165
  %177 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %20, 0
  %178 = insertvalue { i64, i64, { i64, [48 x i8] } } %177, i64 %17, 1
  %179 = insertvalue { i64, i64, { i64, [48 x i8] } } %178, { i64, [48 x i8] } %170, 2
  ret { i64, i64, { i64, [48 x i8] } } %179

180:                                              ; preds = %53
  call void @puts(ptr @assert_msg_159)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [48 x i8] } } @f93(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f93"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [48 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [48 x i8] } } %10, { i64, [48 x i8] } %8, 2
  ret { i64, i64, { i64, [48 x i8] } } %11
}

define void @_mlir_ciface_f93(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [48 x i8] } } @f93(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [48 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$135"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 1
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %2)
  %3 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 2
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %3)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$135"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 0
  %3 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, i252 %2, 0
  %4 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } undef, i252 %2, 0
  %5 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 1
  %6 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %5)
  %7 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %6, 1
  %9 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, { { ptr, i32, i32, i32 }, i252, i32 } %7, 1
  %10 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %4, { { ptr, i32, i32, i32 }, i252, i32 } %8, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0, 2
  %12 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$66"({ { ptr, i32, i32, i32 }, i252, i32 } %11)
  %13 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %12, 1
  %15 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %9, { { ptr, i32, i32, i32 }, i252, i32 } %13, 2
  %16 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %10, { { ptr, i32, i32, i32 }, i252, i32 } %14, 2
  %17 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } undef, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %15, 0
  %18 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %17, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %16, 1
  ret { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %18
}

define private void @"drop$136"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  call void @"drop$135"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0)
  ret void
}

define private { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$136"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0) {
  %2 = call { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$135"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %0)
  %3 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %2, 0
  %4 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %2, 1
  %5 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } undef, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %3, 0
  %6 = insertvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %5, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %4, 1
  ret { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %6
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f94"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i1, [31 x i8] }, i64 1, align 8
  %14 = alloca i64, i64 1, align 8
  %15 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %16 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } { i252 313215164569295318208292514394769381779806795543033682241894454505053143643, { { ptr, i32, i32, i32 }, i252, i32 } undef, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %4, 1
  %20 = insertvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %19, { { ptr, i32, i32, i32 }, i252, i32 } %3, 2
  %21 = call { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } @"dup$135"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %20)
  %22 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %21, 0
  %23 = extractvalue { { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } }, { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } } %21, 1
  call void @"drop$135"({ i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %22)
  %24 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %23, 0
  %25 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %23, 1
  %26 = extractvalue { i252, { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %23, 2
  %27 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %25)
  %28 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %27, 0
  %29 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %27, 1
  %30 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %29, 0
  %31 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %30)
  %32 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %31, 0
  %33 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %31, 1
  %34 = extractvalue { ptr, i32, i32, i32 } %33, 1
  %35 = extractvalue { ptr, i32, i32, i32 } %33, 2
  %36 = sub i32 %35, %34
  call void @"drop$43"({ ptr, i32, i32, i32 } %33)
  %37 = zext i32 %36 to i252
  %38 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %38, align 4
  %39 = getelementptr inbounds i8, ptr %38, i32 4
  store i32 0, ptr %39, align 4
  %40 = getelementptr inbounds i8, ptr %38, i32 16
  %41 = call ptr @realloc(ptr null, i64 8)
  store ptr %40, ptr %41, align 8
  %42 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %41, 0
  %43 = insertvalue { ptr, i32, i32, i32 } %42, i32 8, 3
  %44 = load ptr, ptr %41, align 8
  store i252 %24, ptr %44, align 16
  %45 = insertvalue { ptr, i32, i32, i32 } %43, i32 1, 2
  %46 = getelementptr inbounds i8, ptr %44, i32 -12
  store i32 1, ptr %46, align 4
  %47 = load ptr, ptr %41, align 8
  %48 = getelementptr inbounds i8, ptr %47, i32 32
  store i252 %37, ptr %48, align 16
  %49 = insertvalue { ptr, i32, i32, i32 } %45, i32 2, 2
  %50 = getelementptr inbounds i8, ptr %47, i32 -12
  store i32 2, ptr %50, align 4
  %51 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %32, 0
  %52 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %51, { ptr, i32, i32, i32 } %49)
  %53 = extractvalue { i64, i64, { i64, [24 x i8] } } %52, 0
  %54 = extractvalue { i64, i64, { i64, [24 x i8] } } %52, 1
  %55 = extractvalue { i64, i64, { i64, [24 x i8] } } %52, 2
  store { i64, [24 x i8] } %55, ptr %7, align 8
  %56 = load i1, ptr %7, align 1
  switch i1 %56, label %57 [
    i1 false, label %59
    i1 true, label %236
  ]

57:                                               ; preds = %6
  br i1 false, label %58, label %425

58:                                               ; preds = %57
  unreachable

59:                                               ; preds = %6
  %60 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %7, align 8
  %61 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %60, 1
  %62 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %28)
  %63 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %62, 0
  %64 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %62, 1
  %65 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %64, 0
  %66 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %64, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %65)
  %67 = zext i32 %66 to i252
  %68 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %26)
  %69 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %68, 1
  %71 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %70, 0
  %72 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$43"({ ptr, i32, i32, i32 } %71)
  %73 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %72, 0
  %74 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %72, 1
  %75 = extractvalue { ptr, i32, i32, i32 } %74, 1
  %76 = extractvalue { ptr, i32, i32, i32 } %74, 2
  %77 = sub i32 %76, %75
  call void @"drop$43"({ ptr, i32, i32, i32 } %74)
  %78 = zext i32 %77 to i252
  %79 = extractvalue { { ptr, i32, i32, i32 }, {} } %61, 0
  %80 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %63, 0
  %81 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %63, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %80)
  %82 = extractvalue { ptr, i32, i32, i32 } %79, 3
  %83 = icmp eq i32 %82, 0
  br i1 %83, label %84, label %98

84:                                               ; preds = %59
  %85 = shl i32 %82, 1
  %86 = call i32 @llvm.umin.i32(i32 %85, i32 1024)
  %87 = add i32 %86, %82
  %88 = call i32 @llvm.umax.i32(i32 %87, i32 8)
  %89 = zext i32 %88 to i64
  %90 = mul i64 %89, 32
  %91 = add i64 %90, 16
  %92 = call ptr @realloc(ptr null, i64 %91)
  store i32 1, ptr %92, align 4
  %93 = getelementptr inbounds i8, ptr %92, i32 4
  store i32 0, ptr %93, align 4
  %94 = getelementptr inbounds i8, ptr %92, i32 16
  %95 = call ptr @realloc(ptr null, i64 8)
  store ptr %94, ptr %95, align 8
  %96 = insertvalue { ptr, i32, i32, i32 } %79, ptr %95, 0
  %97 = insertvalue { ptr, i32, i32, i32 } %96, i32 %88, 3
  br label %119

98:                                               ; preds = %59
  %99 = extractvalue { ptr, i32, i32, i32 } %79, 2
  %100 = icmp ult i32 %99, %82
  br i1 %100, label %101, label %102

101:                                              ; preds = %98
  br label %116

102:                                              ; preds = %98
  %103 = shl i32 %82, 1
  %104 = call i32 @llvm.umin.i32(i32 %103, i32 1024)
  %105 = add i32 %104, %82
  %106 = call i32 @llvm.umax.i32(i32 %105, i32 8)
  %107 = zext i32 %106 to i64
  %108 = mul i64 %107, 32
  %109 = add i64 %108, 16
  %110 = extractvalue { ptr, i32, i32, i32 } %79, 0
  %111 = load ptr, ptr %110, align 8
  %112 = getelementptr inbounds i8, ptr %111, i32 -16
  %113 = call ptr @realloc(ptr %112, i64 %109)
  %114 = getelementptr inbounds i8, ptr %113, i32 16
  store ptr %114, ptr %110, align 8
  %115 = insertvalue { ptr, i32, i32, i32 } %79, i32 %106, 3
  br label %116

116:                                              ; preds = %101, %102
  %117 = phi { ptr, i32, i32, i32 } [ %115, %102 ], [ %79, %101 ]
  br label %118

118:                                              ; preds = %116
  br label %119

119:                                              ; preds = %84, %118
  %120 = phi { ptr, i32, i32, i32 } [ %117, %118 ], [ %97, %84 ]
  br label %121

121:                                              ; preds = %119
  %122 = extractvalue { ptr, i32, i32, i32 } %120, 0
  %123 = load ptr, ptr %122, align 8
  %124 = extractvalue { ptr, i32, i32, i32 } %120, 2
  %125 = zext i32 %124 to i64
  %126 = mul i64 %125, 32
  %127 = getelementptr inbounds i8, ptr %123, i64 %126
  store i252 %81, ptr %127, align 16
  %128 = extractvalue { ptr, i32, i32, i32 } %120, 2
  %129 = add i32 %128, 1
  %130 = insertvalue { ptr, i32, i32, i32 } %120, i32 %129, 2
  %131 = getelementptr inbounds i8, ptr %123, i32 -12
  store i32 %129, ptr %131, align 4
  %132 = extractvalue { ptr, i32, i32, i32 } %120, 3
  %133 = icmp eq i32 %132, 0
  br i1 %133, label %134, label %148

134:                                              ; preds = %121
  %135 = shl i32 %132, 1
  %136 = call i32 @llvm.umin.i32(i32 %135, i32 1024)
  %137 = add i32 %136, %132
  %138 = call i32 @llvm.umax.i32(i32 %137, i32 8)
  %139 = zext i32 %138 to i64
  %140 = mul i64 %139, 32
  %141 = add i64 %140, 16
  %142 = call ptr @realloc(ptr null, i64 %141)
  store i32 1, ptr %142, align 4
  %143 = getelementptr inbounds i8, ptr %142, i32 4
  store i32 0, ptr %143, align 4
  %144 = getelementptr inbounds i8, ptr %142, i32 16
  %145 = call ptr @realloc(ptr null, i64 8)
  store ptr %144, ptr %145, align 8
  %146 = insertvalue { ptr, i32, i32, i32 } %130, ptr %145, 0
  %147 = insertvalue { ptr, i32, i32, i32 } %146, i32 %138, 3
  br label %168

148:                                              ; preds = %121
  %149 = icmp ult i32 %129, %132
  br i1 %149, label %150, label %151

150:                                              ; preds = %148
  br label %165

151:                                              ; preds = %148
  %152 = shl i32 %132, 1
  %153 = call i32 @llvm.umin.i32(i32 %152, i32 1024)
  %154 = add i32 %153, %132
  %155 = call i32 @llvm.umax.i32(i32 %154, i32 8)
  %156 = zext i32 %155 to i64
  %157 = mul i64 %156, 32
  %158 = add i64 %157, 16
  %159 = extractvalue { ptr, i32, i32, i32 } %120, 0
  %160 = load ptr, ptr %159, align 8
  %161 = getelementptr inbounds i8, ptr %160, i32 -16
  %162 = call ptr @realloc(ptr %161, i64 %158)
  %163 = getelementptr inbounds i8, ptr %162, i32 16
  store ptr %163, ptr %159, align 8
  %164 = insertvalue { ptr, i32, i32, i32 } %130, i32 %155, 3
  br label %165

165:                                              ; preds = %150, %151
  %166 = phi { ptr, i32, i32, i32 } [ %164, %151 ], [ %130, %150 ]
  br label %167

167:                                              ; preds = %165
  br label %168

168:                                              ; preds = %134, %167
  %169 = phi { ptr, i32, i32, i32 } [ %166, %167 ], [ %147, %134 ]
  br label %170

170:                                              ; preds = %168
  %171 = extractvalue { ptr, i32, i32, i32 } %169, 0
  %172 = load ptr, ptr %171, align 8
  %173 = extractvalue { ptr, i32, i32, i32 } %169, 2
  %174 = zext i32 %173 to i64
  %175 = mul i64 %174, 32
  %176 = getelementptr inbounds i8, ptr %172, i64 %175
  store i252 %67, ptr %176, align 16
  %177 = extractvalue { ptr, i32, i32, i32 } %169, 2
  %178 = add i32 %177, 1
  %179 = insertvalue { ptr, i32, i32, i32 } %169, i32 %178, 2
  %180 = getelementptr inbounds i8, ptr %172, i32 -12
  store i32 %178, ptr %180, align 4
  %181 = extractvalue { ptr, i32, i32, i32 } %169, 3
  %182 = icmp eq i32 %181, 0
  br i1 %182, label %183, label %197

183:                                              ; preds = %170
  %184 = shl i32 %181, 1
  %185 = call i32 @llvm.umin.i32(i32 %184, i32 1024)
  %186 = add i32 %185, %181
  %187 = call i32 @llvm.umax.i32(i32 %186, i32 8)
  %188 = zext i32 %187 to i64
  %189 = mul i64 %188, 32
  %190 = add i64 %189, 16
  %191 = call ptr @realloc(ptr null, i64 %190)
  store i32 1, ptr %191, align 4
  %192 = getelementptr inbounds i8, ptr %191, i32 4
  store i32 0, ptr %192, align 4
  %193 = getelementptr inbounds i8, ptr %191, i32 16
  %194 = call ptr @realloc(ptr null, i64 8)
  store ptr %193, ptr %194, align 8
  %195 = insertvalue { ptr, i32, i32, i32 } %179, ptr %194, 0
  %196 = insertvalue { ptr, i32, i32, i32 } %195, i32 %187, 3
  br label %217

197:                                              ; preds = %170
  %198 = icmp ult i32 %178, %181
  br i1 %198, label %199, label %200

199:                                              ; preds = %197
  br label %214

200:                                              ; preds = %197
  %201 = shl i32 %181, 1
  %202 = call i32 @llvm.umin.i32(i32 %201, i32 1024)
  %203 = add i32 %202, %181
  %204 = call i32 @llvm.umax.i32(i32 %203, i32 8)
  %205 = zext i32 %204 to i64
  %206 = mul i64 %205, 32
  %207 = add i64 %206, 16
  %208 = extractvalue { ptr, i32, i32, i32 } %169, 0
  %209 = load ptr, ptr %208, align 8
  %210 = getelementptr inbounds i8, ptr %209, i32 -16
  %211 = call ptr @realloc(ptr %210, i64 %207)
  %212 = getelementptr inbounds i8, ptr %211, i32 16
  store ptr %212, ptr %208, align 8
  %213 = insertvalue { ptr, i32, i32, i32 } %179, i32 %204, 3
  br label %214

214:                                              ; preds = %199, %200
  %215 = phi { ptr, i32, i32, i32 } [ %213, %200 ], [ %179, %199 ]
  br label %216

216:                                              ; preds = %214
  br label %217

217:                                              ; preds = %183, %216
  %218 = phi { ptr, i32, i32, i32 } [ %215, %216 ], [ %196, %183 ]
  br label %219

219:                                              ; preds = %217
  %220 = extractvalue { ptr, i32, i32, i32 } %218, 0
  %221 = load ptr, ptr %220, align 8
  %222 = extractvalue { ptr, i32, i32, i32 } %218, 2
  %223 = zext i32 %222 to i64
  %224 = mul i64 %223, 32
  %225 = getelementptr inbounds i8, ptr %221, i64 %224
  store i252 %78, ptr %225, align 16
  %226 = extractvalue { ptr, i32, i32, i32 } %218, 2
  %227 = add i32 %226, 1
  %228 = insertvalue { ptr, i32, i32, i32 } %218, i32 %227, 2
  %229 = getelementptr inbounds i8, ptr %221, i32 -12
  store i32 %227, ptr %229, align 4
  %230 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %73, 0
  %231 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f84"(i64 %53, i64 %54, { { ptr, i32, i32, i32 } } %230, { ptr, i32, i32, i32 } %228)
  %232 = extractvalue { i64, i64, { i64, [24 x i8] } } %231, 0
  %233 = extractvalue { i64, i64, { i64, [24 x i8] } } %231, 1
  %234 = extractvalue { i64, i64, { i64, [24 x i8] } } %231, 2
  store { i64, [24 x i8] } %234, ptr %9, align 8
  %235 = load i1, ptr %9, align 1
  switch i1 %235, label %245 [
    i1 false, label %247
    i1 true, label %264
  ]

236:                                              ; preds = %6
  %237 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %238 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %237, 1
  call void @"drop$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %26)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %28)
  %239 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %238, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %239, ptr %8, align 8
  %240 = load { i64, [24 x i8] }, ptr %8, align 8
  %241 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %53, 0
  %242 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %241, i64 %54, 1
  %243 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %242, ptr %2, 2
  %244 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %243, { i64, [24 x i8] } %240, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %244

245:                                              ; preds = %219
  br i1 false, label %246, label %426

246:                                              ; preds = %245
  unreachable

247:                                              ; preds = %219
  %248 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %9, align 8
  %249 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %248, 1
  %250 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %69)
  %251 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %250, 0
  %252 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %250, 1
  %253 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %252, 0
  %254 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %252, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %253)
  %255 = zext i32 %254 to i252
  %256 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5)
  %257 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %256, 0
  %258 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %256, 1
  call void @"drop$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %257)
  %259 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f118"(i64 %232, i64 %233, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %258, { ptr, i32, i32, i32 } zeroinitializer)
  %260 = extractvalue { i64, i64, { i64, [24 x i8] } } %259, 0
  %261 = extractvalue { i64, i64, { i64, [24 x i8] } } %259, 1
  %262 = extractvalue { i64, i64, { i64, [24 x i8] } } %259, 2
  store { i64, [24 x i8] } %262, ptr %11, align 8
  %263 = load i1, ptr %11, align 1
  switch i1 %263, label %273 [
    i1 false, label %275
    i1 true, label %397
  ]

264:                                              ; preds = %219
  %265 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %266 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %265, 1
  call void @"drop$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %69)
  %267 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %266, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %267, ptr %10, align 8
  %268 = load { i64, [24 x i8] }, ptr %10, align 8
  %269 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %232, 0
  %270 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %269, i64 %233, 1
  %271 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %270, ptr %2, 2
  %272 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %271, { i64, [24 x i8] } %268, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %272

273:                                              ; preds = %247
  br i1 false, label %274, label %427

274:                                              ; preds = %273
  unreachable

275:                                              ; preds = %247
  %276 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %11, align 8
  %277 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %276, 1
  %278 = extractvalue { { ptr, i32, i32, i32 }, {} } %249, 0
  %279 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %251, 0
  %280 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %251, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %279)
  %281 = extractvalue { ptr, i32, i32, i32 } %278, 3
  %282 = icmp eq i32 %281, 0
  br i1 %282, label %283, label %297

283:                                              ; preds = %275
  %284 = shl i32 %281, 1
  %285 = call i32 @llvm.umin.i32(i32 %284, i32 1024)
  %286 = add i32 %285, %281
  %287 = call i32 @llvm.umax.i32(i32 %286, i32 8)
  %288 = zext i32 %287 to i64
  %289 = mul i64 %288, 32
  %290 = add i64 %289, 16
  %291 = call ptr @realloc(ptr null, i64 %290)
  store i32 1, ptr %291, align 4
  %292 = getelementptr inbounds i8, ptr %291, i32 4
  store i32 0, ptr %292, align 4
  %293 = getelementptr inbounds i8, ptr %291, i32 16
  %294 = call ptr @realloc(ptr null, i64 8)
  store ptr %293, ptr %294, align 8
  %295 = insertvalue { ptr, i32, i32, i32 } %278, ptr %294, 0
  %296 = insertvalue { ptr, i32, i32, i32 } %295, i32 %287, 3
  br label %318

297:                                              ; preds = %275
  %298 = extractvalue { ptr, i32, i32, i32 } %278, 2
  %299 = icmp ult i32 %298, %281
  br i1 %299, label %300, label %301

300:                                              ; preds = %297
  br label %315

301:                                              ; preds = %297
  %302 = shl i32 %281, 1
  %303 = call i32 @llvm.umin.i32(i32 %302, i32 1024)
  %304 = add i32 %303, %281
  %305 = call i32 @llvm.umax.i32(i32 %304, i32 8)
  %306 = zext i32 %305 to i64
  %307 = mul i64 %306, 32
  %308 = add i64 %307, 16
  %309 = extractvalue { ptr, i32, i32, i32 } %278, 0
  %310 = load ptr, ptr %309, align 8
  %311 = getelementptr inbounds i8, ptr %310, i32 -16
  %312 = call ptr @realloc(ptr %311, i64 %308)
  %313 = getelementptr inbounds i8, ptr %312, i32 16
  store ptr %313, ptr %309, align 8
  %314 = insertvalue { ptr, i32, i32, i32 } %278, i32 %305, 3
  br label %315

315:                                              ; preds = %300, %301
  %316 = phi { ptr, i32, i32, i32 } [ %314, %301 ], [ %278, %300 ]
  br label %317

317:                                              ; preds = %315
  br label %318

318:                                              ; preds = %283, %317
  %319 = phi { ptr, i32, i32, i32 } [ %316, %317 ], [ %296, %283 ]
  br label %320

320:                                              ; preds = %318
  %321 = extractvalue { ptr, i32, i32, i32 } %319, 0
  %322 = load ptr, ptr %321, align 8
  %323 = extractvalue { ptr, i32, i32, i32 } %319, 2
  %324 = zext i32 %323 to i64
  %325 = mul i64 %324, 32
  %326 = getelementptr inbounds i8, ptr %322, i64 %325
  store i252 %280, ptr %326, align 16
  %327 = extractvalue { ptr, i32, i32, i32 } %319, 2
  %328 = add i32 %327, 1
  %329 = insertvalue { ptr, i32, i32, i32 } %319, i32 %328, 2
  %330 = getelementptr inbounds i8, ptr %322, i32 -12
  store i32 %328, ptr %330, align 4
  %331 = extractvalue { ptr, i32, i32, i32 } %319, 3
  %332 = icmp eq i32 %331, 0
  br i1 %332, label %333, label %347

333:                                              ; preds = %320
  %334 = shl i32 %331, 1
  %335 = call i32 @llvm.umin.i32(i32 %334, i32 1024)
  %336 = add i32 %335, %331
  %337 = call i32 @llvm.umax.i32(i32 %336, i32 8)
  %338 = zext i32 %337 to i64
  %339 = mul i64 %338, 32
  %340 = add i64 %339, 16
  %341 = call ptr @realloc(ptr null, i64 %340)
  store i32 1, ptr %341, align 4
  %342 = getelementptr inbounds i8, ptr %341, i32 4
  store i32 0, ptr %342, align 4
  %343 = getelementptr inbounds i8, ptr %341, i32 16
  %344 = call ptr @realloc(ptr null, i64 8)
  store ptr %343, ptr %344, align 8
  %345 = insertvalue { ptr, i32, i32, i32 } %329, ptr %344, 0
  %346 = insertvalue { ptr, i32, i32, i32 } %345, i32 %337, 3
  br label %367

347:                                              ; preds = %320
  %348 = icmp ult i32 %328, %331
  br i1 %348, label %349, label %350

349:                                              ; preds = %347
  br label %364

350:                                              ; preds = %347
  %351 = shl i32 %331, 1
  %352 = call i32 @llvm.umin.i32(i32 %351, i32 1024)
  %353 = add i32 %352, %331
  %354 = call i32 @llvm.umax.i32(i32 %353, i32 8)
  %355 = zext i32 %354 to i64
  %356 = mul i64 %355, 32
  %357 = add i64 %356, 16
  %358 = extractvalue { ptr, i32, i32, i32 } %319, 0
  %359 = load ptr, ptr %358, align 8
  %360 = getelementptr inbounds i8, ptr %359, i32 -16
  %361 = call ptr @realloc(ptr %360, i64 %357)
  %362 = getelementptr inbounds i8, ptr %361, i32 16
  store ptr %362, ptr %358, align 8
  %363 = insertvalue { ptr, i32, i32, i32 } %329, i32 %354, 3
  br label %364

364:                                              ; preds = %349, %350
  %365 = phi { ptr, i32, i32, i32 } [ %363, %350 ], [ %329, %349 ]
  br label %366

366:                                              ; preds = %364
  br label %367

367:                                              ; preds = %333, %366
  %368 = phi { ptr, i32, i32, i32 } [ %365, %366 ], [ %346, %333 ]
  br label %369

369:                                              ; preds = %367
  %370 = extractvalue { ptr, i32, i32, i32 } %368, 0
  %371 = load ptr, ptr %370, align 8
  %372 = extractvalue { ptr, i32, i32, i32 } %368, 2
  %373 = zext i32 %372 to i64
  %374 = mul i64 %373, 32
  %375 = getelementptr inbounds i8, ptr %371, i64 %374
  store i252 %255, ptr %375, align 16
  %376 = extractvalue { ptr, i32, i32, i32 } %368, 2
  %377 = add i32 %376, 1
  %378 = insertvalue { ptr, i32, i32, i32 } %368, i32 %377, 2
  %379 = getelementptr inbounds i8, ptr %371, i32 -12
  store i32 %377, ptr %379, align 4
  %380 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %378)
  %381 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %380, 0
  %382 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %380, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %381)
  %383 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %382, 0
  %384 = extractvalue { { ptr, i32, i32, i32 }, {} } %277, 0
  %385 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %384)
  %386 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %385, 0
  %387 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %385, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %386)
  %388 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %387, 0
  %389 = load ptr, ptr %2, align 8
  store i64 %261, ptr %14, align 8
  store { { ptr, i32, i32, i32 } } %383, ptr %15, align 8
  store { { ptr, i32, i32, i32 } } %388, ptr %16, align 8
  %390 = getelementptr inbounds ptr, ptr %2, i32 10
  %391 = load ptr, ptr %390, align 8
  call void %391(ptr %13, ptr %389, ptr %14, ptr %15, ptr %16)
  %392 = load { i1, [31 x i8] }, ptr %13, align 1
  %393 = extractvalue { i1, [31 x i8] } %392, 0
  %394 = getelementptr inbounds i8, ptr %13, i32 8
  %395 = load { ptr, i32, i32, i32 }, ptr %394, align 8
  %396 = load i64, ptr %14, align 8
  br i1 %393, label %416, label %406

397:                                              ; preds = %247
  %398 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %399 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %398, 1
  call void @"drop$138"({ { ptr, i32, i32, i32 }, {} } %249)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %251)
  %400 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %399, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %400, ptr %12, align 8
  %401 = load { i64, [24 x i8] }, ptr %12, align 8
  %402 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %260, 0
  %403 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %402, i64 %261, 1
  %404 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %403, ptr %2, 2
  %405 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %404, { i64, [24 x i8] } %401, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %405

406:                                              ; preds = %369
  %407 = phi i64 [ %396, %369 ]
  %408 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %409 = call ptr %408()
  %410 = call i64 @llvm.uadd.sat.i64(i64 %407, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %18, align 1
  %411 = load { i64, [24 x i8] }, ptr %18, align 8
  %412 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %260, 0
  %413 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %412, i64 %410, 1
  %414 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %413, ptr %2, 2
  %415 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %414, { i64, [24 x i8] } %411, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %415

416:                                              ; preds = %369
  %417 = phi { ptr, i32, i32, i32 } [ %395, %369 ]
  %418 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %417, 1
  %419 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %418, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %419, ptr %17, align 8
  %420 = load { i64, [24 x i8] }, ptr %17, align 8
  %421 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %260, 0
  %422 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %421, i64 %396, 1
  %423 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %422, ptr %2, 2
  %424 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %423, { i64, [24 x i8] } %420, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %424

425:                                              ; preds = %57
  call void @puts(ptr @assert_msg_160)
  call void @abort()
  unreachable

426:                                              ; preds = %245
  call void @puts(ptr @assert_msg_161)
  call void @abort()
  unreachable

427:                                              ; preds = %273
  call void @puts(ptr @assert_msg_162)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f94(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5) {
  %7 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f94"(i64 %0, i64 %1, ptr %2, { { ptr, i32, i32, i32 }, i252, i32 } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5)
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %9, 1
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, ptr %10, 2
  %15 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %11, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %15
}

define void @_mlir_ciface_f94(ptr %0, i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6) {
  %8 = call { i64, i64, ptr, { i64, [24 x i8] } } @f94(i64 %1, i64 %2, ptr %3, { { ptr, i32, i32, i32 }, i252, i32 } %4, { { ptr, i32, i32, i32 }, i252, i32 } %5, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %6)
  store { i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$130"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$130"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } }, ptr %2, align 2
  %6 = extractvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, 1
  %7 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %7, ptr %2, align 2
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %5, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %6, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %9, ptr %2, align 2
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f95"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5) {
  %7 = alloca { i128, [32 x i8] }, i64 1, align 16
  %8 = alloca { i128, [32 x i8] }, i64 1, align 16
  %9 = alloca { i16, [14 x i8] }, i64 1, align 2
  %10 = alloca { i64, [40 x i8] }, i64 1, align 8
  %11 = alloca i256, i64 1, align 16
  %12 = alloca i256, i64 1, align 16
  %13 = alloca i256, i64 1, align 16
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [40 x i8] }, i64 1, align 8
  %16 = alloca { i16, [14 x i8] }, i64 1, align 2
  %17 = alloca { i64, [40 x i8] }, i64 1, align 8
  %18 = alloca { i128, [32 x i8] }, i64 1, align 16
  %19 = extractvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5, 0
  %20 = extractvalue { { { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { ptr, i32, i32, i32 } } %20, 0
  %22 = extractvalue { ptr, i32, i32, i32 } %21, 1
  %23 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %24 = sub i32 %23, %22
  %25 = icmp uge i32 %24, 1
  br i1 %25, label %26, label %41

26:                                               ; preds = %6
  %27 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %28 = load ptr, ptr %27, align 8
  %29 = zext i32 %22 to i64
  %30 = mul i64 %29, 32
  %31 = getelementptr inbounds i8, ptr %28, i64 %30
  %32 = add i32 %22, 1
  %33 = insertvalue { ptr, i32, i32, i32 } %21, i32 %32, 1
  %34 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %34, ptr %31, i64 32, i1 false)
  %35 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %36 = call ptr %35()
  %37 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %38 = load i252, ptr %34, align 16
  call void @free(ptr %34)
  %39 = insertvalue { i1, i252 } { i1 false, i252 undef }, i252 %38, 1
  store { i1, i252 } %39, ptr %18, align 16
  %40 = load { i128, [32 x i8] }, ptr %18, align 16
  br label %47

41:                                               ; preds = %6
  %42 = phi i64 [ %1, %6 ]
  %43 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %44 = call ptr %43()
  %45 = call i64 @llvm.uadd.sat.i64(i64 %42, i64 0)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %7, align 1
  %46 = load { i128, [32 x i8] }, ptr %7, align 16
  br label %47

47:                                               ; preds = %26, %41
  %48 = phi i64 [ %0, %41 ], [ %0, %26 ]
  %49 = phi i64 [ %2, %41 ], [ %2, %26 ]
  %50 = phi i64 [ %3, %41 ], [ %3, %26 ]
  %51 = phi ptr [ %4, %41 ], [ %4, %26 ]
  %52 = phi i64 [ %45, %41 ], [ %37, %26 ]
  %53 = phi { ptr, i32, i32, i32 } [ %21, %41 ], [ %33, %26 ]
  %54 = phi { i128, [32 x i8] } [ %46, %41 ], [ %40, %26 ]
  %55 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %53, 0
  %56 = insertvalue { { { ptr, i32, i32, i32 } } } undef, { { ptr, i32, i32, i32 } } %55, 0
  store { i128, [32 x i8] } %54, ptr %8, align 16
  %57 = load i1, ptr %8, align 1
  switch i1 %57, label %58 [
    i1 false, label %60
    i1 true, label %80
  ]

58:                                               ; preds = %47
  br i1 false, label %59, label %138

59:                                               ; preds = %58
  unreachable

60:                                               ; preds = %47
  %61 = load { i1, i252 }, ptr %8, align 16
  %62 = extractvalue { i1, i252 } %61, 1
  %63 = add i64 %50, 3
  %64 = zext i252 %62 to i256
  store i256 1555170125836447351353653902862745931305207776976209346350698701924491819, ptr %11, align 16
  store i256 %64, ptr %12, align 16
  %65 = load ptr, ptr @cairo_native__libfunc__pedersen, align 8
  call void %65(ptr %13, ptr %11, ptr %12)
  %66 = load i256, ptr %13, align 16
  %67 = trunc i256 %66 to i252
  %68 = add i64 %48, 3
  %69 = sub i252 %67, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %70 = icmp ult i252 %67, 3618502788666131106986593281521497120414687020801267626233049500247285300992
  %71 = select i1 %70, i252 %67, i252 %69
  %72 = insertvalue { i252 } undef, i252 %71, 0
  %73 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f119"(i64 %68, i64 %52, i64 %49, ptr %51, { i252 } %72)
  %74 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, 0
  %75 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, 1
  %76 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, 2
  %77 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, 3
  %78 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %73, 4
  store { i64, [24 x i8] } %78, ptr %14, align 8
  %79 = load i1, ptr %14, align 1
  switch i1 %79, label %105 [
    i1 false, label %107
    i1 true, label %127
  ]

80:                                               ; preds = %47
  %81 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %82 = call ptr %81()
  %83 = getelementptr inbounds i64, ptr %82, i32 1
  %84 = load i64, ptr %83, align 8
  %85 = getelementptr inbounds i64, ptr %82, i32 2
  %86 = load i64, ptr %85, align 8
  %87 = mul i64 %86, 11
  %88 = add i64 %84, %87
  %89 = load i64, ptr %82, align 8
  %90 = mul i64 %89, 64190
  %91 = add i64 %88, %90
  %92 = call i64 @llvm.uadd.sat.i64(i64 %52, i64 %91)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %9, align 1
  %93 = load { i16, [14 x i8] }, ptr %9, align 2
  %94 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %56, 0
  %95 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %94, 0
  %96 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %95, { i16, [14 x i8] } %93, 1
  %97 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } undef }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %96, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %97, ptr %10, align 8
  %98 = load { i64, [40 x i8] }, ptr %10, align 8
  %99 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %48, 0
  %100 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %99, i64 %92, 1
  %101 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %100, i64 %49, 2
  %102 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %101, i64 %50, 3
  %103 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %102, ptr %51, 4
  %104 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %103, { i64, [40 x i8] } %98, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %104

105:                                              ; preds = %60
  br i1 false, label %106, label %139

106:                                              ; preds = %105
  unreachable

107:                                              ; preds = %60
  %108 = load { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } }, ptr %14, align 2
  %109 = extractvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %108, 1
  %110 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %111 = call ptr %110()
  %112 = call i64 @llvm.uadd.sat.i64(i64 %75, i64 0)
  %113 = extractvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %109, 0
  %114 = insertvalue { { { { ptr, i32, i32, i32 } } }, { { {} } } } undef, { { { ptr, i32, i32, i32 } } } %56, 0
  %115 = insertvalue { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } { i1 false, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef }, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %113, 1
  store { i1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %115, ptr %16, align 2
  %116 = load { i16, [14 x i8] }, ptr %16, align 2
  %117 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } undef, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %114, 0
  %118 = insertvalue { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %117, { i16, [14 x i8] } %116, 1
  %119 = insertvalue { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } { i1 false, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } undef }, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } %118, 1
  store { i1, { { { { { ptr, i32, i32, i32 } } }, { { {} } } }, { i16, [14 x i8] } } } %119, ptr %17, align 8
  %120 = load { i64, [40 x i8] }, ptr %17, align 8
  %121 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %74, 0
  %122 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %121, i64 %112, 1
  %123 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %122, i64 %76, 2
  %124 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %123, i64 %63, 3
  %125 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %124, ptr %77, 4
  %126 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %125, { i64, [40 x i8] } %120, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %126

127:                                              ; preds = %60
  %128 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %129 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %128, 1
  call void @"drop$243"({ { { ptr, i32, i32, i32 } } } %56)
  %130 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %129, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %130, ptr %15, align 8
  %131 = load { i64, [40 x i8] }, ptr %15, align 8
  %132 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %74, 0
  %133 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %132, i64 %75, 1
  %134 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %133, i64 %76, 2
  %135 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %134, i64 %63, 3
  %136 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %135, ptr %77, 4
  %137 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %136, { i64, [40 x i8] } %131, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %137

138:                                              ; preds = %58
  call void @puts(ptr @assert_msg_163)
  call void @abort()
  unreachable

139:                                              ; preds = %105
  call void @puts(ptr @assert_msg_164)
  call void @abort()
  unreachable
}

define private { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f95(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5) {
  %7 = call fastcc { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @"impl$f95"(i64 %0, i64 %1, i64 %2, i64 %3, ptr %4, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %5)
  %8 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %7, 3
  %12 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %7, 4
  %13 = extractvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %7, 5
  %14 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } undef, i64 %8, 0
  %15 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %14, i64 %9, 1
  %16 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %15, i64 %10, 2
  %17 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %16, i64 %11, 3
  %18 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %17, ptr %12, 4
  %19 = insertvalue { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %18, { i64, [40 x i8] } %13, 5
  ret { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %19
}

define void @_mlir_ciface_f95(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6) {
  %8 = call { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } @f95(i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, { { { { ptr, i32, i32, i32 } } }, { { {} } } } %6)
  store { i64, i64, i64, i64, ptr, { i64, [40 x i8] } } %8, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %0, i64 %1, i128 %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = add i64 %1, 5
  %7 = and i128 %2, 255
  %8 = icmp ult i128 %7, 256
  %9 = add i64 %0, 1
  %10 = trunc i128 %7 to i8
  br i1 %8, label %11, label %122

11:                                               ; preds = %3
  %12 = phi i128 [ %2, %3 ]
  %13 = udiv i128 %12, 256
  %14 = add i64 %1, 10
  %15 = and i128 %13, 255
  %16 = icmp ult i128 %15, 256
  %17 = add i64 %0, 6
  %18 = trunc i128 %15 to i8
  br i1 %16, label %19, label %122

19:                                               ; preds = %11
  %20 = phi i128 [ %12, %11 ]
  %21 = udiv i128 %20, 65536
  %22 = add i64 %1, 15
  %23 = and i128 %21, 255
  %24 = icmp ult i128 %23, 256
  %25 = add i64 %0, 11
  %26 = trunc i128 %23 to i8
  br i1 %24, label %27, label %122

27:                                               ; preds = %19
  %28 = phi i128 [ %20, %19 ]
  %29 = udiv i128 %28, 16777216
  %30 = add i64 %1, 20
  %31 = and i128 %29, 255
  %32 = icmp ult i128 %31, 256
  %33 = add i64 %0, 16
  %34 = trunc i128 %31 to i8
  br i1 %32, label %35, label %122

35:                                               ; preds = %27
  %36 = phi i128 [ %28, %27 ]
  %37 = udiv i128 %36, 4294967296
  %38 = add i64 %1, 25
  %39 = and i128 %37, 255
  %40 = icmp ult i128 %39, 256
  %41 = add i64 %0, 21
  %42 = trunc i128 %39 to i8
  br i1 %40, label %43, label %122

43:                                               ; preds = %35
  %44 = phi i128 [ %36, %35 ]
  %45 = udiv i128 %44, 1099511627776
  %46 = add i64 %1, 30
  %47 = and i128 %45, 255
  %48 = icmp ult i128 %47, 256
  %49 = add i64 %0, 26
  %50 = trunc i128 %47 to i8
  br i1 %48, label %51, label %122

51:                                               ; preds = %43
  %52 = phi i128 [ %44, %43 ]
  %53 = udiv i128 %52, 281474976710656
  %54 = add i64 %1, 35
  %55 = and i128 %53, 255
  %56 = icmp ult i128 %55, 256
  %57 = add i64 %0, 31
  %58 = trunc i128 %55 to i8
  br i1 %56, label %59, label %122

59:                                               ; preds = %51
  %60 = phi i128 [ %52, %51 ]
  %61 = udiv i128 %60, 72057594037927936
  %62 = add i64 %1, 40
  %63 = and i128 %61, 255
  %64 = icmp ult i128 %63, 256
  %65 = add i64 %0, 36
  %66 = trunc i128 %63 to i8
  br i1 %64, label %67, label %122

67:                                               ; preds = %59
  %68 = phi i128 [ %60, %59 ]
  %69 = udiv i128 %68, 18446744073709551616
  %70 = add i64 %1, 45
  %71 = and i128 %69, 65535
  %72 = icmp ult i128 %71, 65536
  %73 = add i64 %0, 41
  %74 = trunc i128 %71 to i16
  br i1 %72, label %75, label %122

75:                                               ; preds = %67
  %76 = phi i128 [ %68, %67 ]
  %77 = udiv i128 %76, 1208925819614629174706176
  %78 = add i64 %1, 50
  %79 = and i128 %77, 65535
  %80 = icmp ult i128 %79, 65536
  %81 = add i64 %0, 46
  %82 = trunc i128 %79 to i16
  br i1 %80, label %83, label %122

83:                                               ; preds = %75
  %84 = phi i64 [ %81, %75 ]
  %85 = phi i128 [ %76, %75 ]
  %86 = phi i128 [ 79228162514264337593543950336, %75 ]
  %87 = udiv i128 %85, %86
  %88 = add i64 %1, 55
  %89 = and i128 %87, 65535
  %90 = icmp ult i128 %89, 65536
  %91 = add i64 %84, 5
  %92 = trunc i128 %89 to i16
  br i1 %90, label %93, label %122

93:                                               ; preds = %83
  %94 = phi i8 [ %10, %83 ]
  %95 = phi i8 [ %18, %83 ]
  %96 = phi i8 [ %26, %83 ]
  %97 = phi i8 [ %34, %83 ]
  %98 = phi i8 [ %42, %83 ]
  %99 = phi i8 [ %50, %83 ]
  %100 = phi i8 [ %58, %83 ]
  %101 = phi i8 [ %66, %83 ]
  %102 = phi i16 [ %74, %83 ]
  %103 = phi i16 [ %82, %83 ]
  %104 = phi i16 [ %92, %83 ]
  %105 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %94, 0
  %106 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %105, i8 %95, 1
  %107 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %106, i8 %96, 2
  %108 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %107, i8 %97, 3
  %109 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %108, i8 %98, 4
  %110 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %109, i8 %99, 5
  %111 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %110, i8 %100, 6
  %112 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %111, i8 %101, 7
  %113 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %112, i16 %102, 8
  %114 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %113, i16 %103, 9
  %115 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %114, i16 %104, 10
  %116 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %115, 0
  %117 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } { i1 false, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %116, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %117, ptr %5, align 2
  %118 = load { i64, [24 x i8] }, ptr %5, align 8
  %119 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %91, 0
  %120 = insertvalue { i64, i64, { i64, [24 x i8] } } %119, i64 %88, 1
  %121 = insertvalue { i64, i64, { i64, [24 x i8] } } %120, { i64, [24 x i8] } %118, 2
  ret { i64, i64, { i64, [24 x i8] } } %121

122:                                              ; preds = %83, %75, %67, %59, %51, %43, %35, %27, %19, %11, %3
  %123 = phi i64 [ %91, %83 ], [ %81, %75 ], [ %73, %67 ], [ %65, %59 ], [ %57, %51 ], [ %49, %43 ], [ %41, %35 ], [ %33, %27 ], [ %25, %19 ], [ %17, %11 ], [ %9, %3 ]
  %124 = phi i64 [ %88, %83 ], [ %78, %75 ], [ %70, %67 ], [ %62, %59 ], [ %54, %51 ], [ %46, %43 ], [ %38, %35 ], [ %30, %27 ], [ %22, %19 ], [ %14, %11 ], [ %6, %3 ]
  %125 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %126 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %125, 0
  %127 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %126, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %127, ptr %4, align 8
  %128 = load { i64, [24 x i8] }, ptr %4, align 8
  %129 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %123, 0
  %130 = insertvalue { i64, i64, { i64, [24 x i8] } } %129, i64 %124, 1
  %131 = insertvalue { i64, i64, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %128, 2
  ret { i64, i64, { i64, [24 x i8] } } %131
}

define private { i64, i64, { i64, [24 x i8] } } @f96(i64 %0, i64 %1, i128 %2) {
  %4 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f96"(i64 %0, i64 %1, i128 %2)
  %5 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, { i64, [24 x i8] } %7, 2
  ret { i64, i64, { i64, [24 x i8] } } %10
}

define void @_mlir_ciface_f96(ptr %0, i64 %1, i64 %2, i128 %3) {
  %5 = call { i64, i64, { i64, [24 x i8] } } @f96(i64 %1, i64 %2, i128 %3)
  store { i64, i64, { i64, [24 x i8] } } %5, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f97"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 476442828812030857794232422692155113556837216824)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f97() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f97"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f97(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f97()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [32 x i8] } } @"impl$f98"(i64 %0, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2) {
  %4 = alloca { i64, [32 x i8] }, i64 1, align 8
  %5 = alloca { i64, [32 x i8] }, i64 1, align 8
  %6 = alloca { i64, [32 x i8] }, i64 1, align 8
  %7 = alloca { i64, [32 x i8] }, i64 1, align 8
  %8 = alloca { i64, [32 x i8] }, i64 1, align 8
  %9 = alloca { i64, [32 x i8] }, i64 1, align 8
  %10 = alloca { i64, [32 x i8] }, i64 1, align 8
  %11 = alloca { i64, [32 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [32 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [32 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [32 x i8] }, i64 1, align 8
  %18 = alloca { i64, [32 x i8] }, i64 1, align 8
  %19 = alloca { i64, [32 x i8] }, i64 1, align 8
  %20 = alloca { i64, [32 x i8] }, i64 1, align 8
  %21 = alloca { i64, [32 x i8] }, i64 1, align 8
  %22 = alloca { i64, [32 x i8] }, i64 1, align 8
  %23 = alloca { i64, [32 x i8] }, i64 1, align 8
  %24 = alloca { i64, [32 x i8] }, i64 1, align 8
  %25 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 0
  %26 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 1
  %27 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 2
  %28 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 3
  %29 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 5
  %30 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 6
  %31 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 7
  %32 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 8
  %33 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 9
  %34 = extractvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2, 10
  %35 = sext i8 %25 to i32
  %36 = sext i8 %26 to i32
  %37 = sext i8 %27 to i32
  %38 = sext i8 %28 to i32
  %39 = zext i8 %29 to i16
  %40 = zext i8 %30 to i16
  %41 = zext i8 %31 to i16
  %42 = sext i16 %32 to i32
  %43 = sext i16 %33 to i32
  %44 = sext i16 %34 to i32
  %45 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 0
  %46 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 1
  %47 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 2
  %48 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 3
  %49 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 4
  %50 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 5
  %51 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 6
  %52 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 7
  %53 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 8
  %54 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 9
  %55 = extractvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, 10
  %56 = add i64 %0, 1
  %57 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %45, i32 %35)
  %58 = extractvalue { i32, i1 } %57, 0
  %59 = extractvalue { i32, i1 } %57, 1
  br i1 %59, label %65, label %60

60:                                               ; preds = %3
  %61 = add i64 %0, 3
  %62 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %46, i32 %36)
  %63 = extractvalue { i32, i1 } %62, 0
  %64 = extractvalue { i32, i1 } %62, 1
  br i1 %64, label %72, label %67

65:                                               ; preds = %3
  %66 = icmp sge i32 %58, 0
  br i1 %66, label %258, label %265

67:                                               ; preds = %60
  %68 = add i64 %0, 5
  %69 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %47, i32 %37)
  %70 = extractvalue { i32, i1 } %69, 0
  %71 = extractvalue { i32, i1 } %69, 1
  br i1 %71, label %79, label %74

72:                                               ; preds = %60
  %73 = icmp sge i32 %63, 0
  br i1 %73, label %244, label %251

74:                                               ; preds = %67
  %75 = add i64 %0, 7
  %76 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %48, i32 %38)
  %77 = extractvalue { i32, i1 } %76, 0
  %78 = extractvalue { i32, i1 } %76, 1
  br i1 %78, label %87, label %81

79:                                               ; preds = %67
  %80 = icmp sge i32 %70, 0
  br i1 %80, label %230, label %237

81:                                               ; preds = %74
  %82 = add i64 %0, 8
  %83 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f120"(i64 %82, i16 %50, i16 %39)
  %84 = extractvalue { i64, { i64, [24 x i8] } } %83, 0
  %85 = extractvalue { i64, { i64, [24 x i8] } } %83, 1
  store { i64, [24 x i8] } %85, ptr %12, align 8
  %86 = load i1, ptr %12, align 1
  switch i1 %86, label %89 [
    i1 false, label %91
    i1 true, label %98
  ]

87:                                               ; preds = %74
  %88 = icmp sge i32 %77, 0
  br i1 %88, label %216, label %223

89:                                               ; preds = %81
  br i1 false, label %90, label %272

90:                                               ; preds = %89
  unreachable

91:                                               ; preds = %81
  %92 = load { i1, { i16 } }, ptr %12, align 2
  %93 = extractvalue { i1, { i16 } } %92, 1
  %94 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f120"(i64 %84, i16 %51, i16 %40)
  %95 = extractvalue { i64, { i64, [24 x i8] } } %94, 0
  %96 = extractvalue { i64, { i64, [24 x i8] } } %94, 1
  store { i64, [24 x i8] } %96, ptr %14, align 8
  %97 = load i1, ptr %14, align 1
  switch i1 %97, label %105 [
    i1 false, label %107
    i1 true, label %114
  ]

98:                                               ; preds = %81
  %99 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %12, align 8
  %100 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %99, 1
  %101 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %100, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %101, ptr %13, align 8
  %102 = load { i64, [32 x i8] }, ptr %13, align 8
  %103 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %84, 0
  %104 = insertvalue { i64, { i64, [32 x i8] } } %103, { i64, [32 x i8] } %102, 1
  ret { i64, { i64, [32 x i8] } } %104

105:                                              ; preds = %91
  br i1 false, label %106, label %273

106:                                              ; preds = %105
  unreachable

107:                                              ; preds = %91
  %108 = load { i1, { i16 } }, ptr %14, align 2
  %109 = extractvalue { i1, { i16 } } %108, 1
  %110 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f120"(i64 %95, i16 %52, i16 %41)
  %111 = extractvalue { i64, { i64, [24 x i8] } } %110, 0
  %112 = extractvalue { i64, { i64, [24 x i8] } } %110, 1
  store { i64, [24 x i8] } %112, ptr %16, align 8
  %113 = load i1, ptr %16, align 1
  switch i1 %113, label %121 [
    i1 false, label %123
    i1 true, label %130
  ]

114:                                              ; preds = %91
  %115 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %116 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %115, 1
  %117 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %116, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %117, ptr %15, align 8
  %118 = load { i64, [32 x i8] }, ptr %15, align 8
  %119 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %95, 0
  %120 = insertvalue { i64, { i64, [32 x i8] } } %119, { i64, [32 x i8] } %118, 1
  ret { i64, { i64, [32 x i8] } } %120

121:                                              ; preds = %107
  br i1 false, label %122, label %274

122:                                              ; preds = %121
  unreachable

123:                                              ; preds = %107
  %124 = load { i1, { i16 } }, ptr %16, align 2
  %125 = extractvalue { i1, { i16 } } %124, 1
  %126 = add i64 %111, 1
  %127 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %53, i32 %42)
  %128 = extractvalue { i32, i1 } %127, 0
  %129 = extractvalue { i32, i1 } %127, 1
  br i1 %129, label %142, label %137

130:                                              ; preds = %107
  %131 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %16, align 8
  %132 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %131, 1
  %133 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %132, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %133, ptr %17, align 8
  %134 = load { i64, [32 x i8] }, ptr %17, align 8
  %135 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %111, 0
  %136 = insertvalue { i64, { i64, [32 x i8] } } %135, { i64, [32 x i8] } %134, 1
  ret { i64, { i64, [32 x i8] } } %136

137:                                              ; preds = %123
  %138 = add i64 %111, 3
  %139 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %54, i32 %43)
  %140 = extractvalue { i32, i1 } %139, 0
  %141 = extractvalue { i32, i1 } %139, 1
  br i1 %141, label %149, label %144

142:                                              ; preds = %123
  %143 = icmp sge i32 %128, 0
  br i1 %143, label %202, label %209

144:                                              ; preds = %137
  %145 = add i64 %111, 5
  %146 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %55, i32 %44)
  %147 = extractvalue { i32, i1 } %146, 0
  %148 = extractvalue { i32, i1 } %146, 1
  br i1 %148, label %172, label %151

149:                                              ; preds = %137
  %150 = icmp sge i32 %140, 0
  br i1 %150, label %188, label %195

151:                                              ; preds = %144
  %152 = add i64 %111, 6
  %153 = extractvalue { i16 } %93, 0
  %154 = extractvalue { i16 } %109, 0
  %155 = extractvalue { i16 } %125, 0
  %156 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } undef, i32 %58, 0
  %157 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %156, i32 %63, 1
  %158 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %157, i32 %70, 2
  %159 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %158, i32 %77, 3
  %160 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %159, i16 %49, 4
  %161 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %160, i16 %153, 5
  %162 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %161, i16 %154, 6
  %163 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %162, i16 %155, 7
  %164 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %163, i32 %128, 8
  %165 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %164, i32 %140, 9
  %166 = insertvalue { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %165, i32 %147, 10
  %167 = insertvalue { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } undef, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %166, 0
  %168 = insertvalue { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } { i1 false, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } undef }, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } %167, 1
  store { i1, { { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 }, {} } } %168, ptr %24, align 4
  %169 = load { i64, [32 x i8] }, ptr %24, align 8
  %170 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %152, 0
  %171 = insertvalue { i64, { i64, [32 x i8] } } %170, { i64, [32 x i8] } %169, 1
  ret { i64, { i64, [32 x i8] } } %171

172:                                              ; preds = %144
  %173 = icmp sge i32 %147, 0
  br i1 %173, label %174, label %181

174:                                              ; preds = %172
  %175 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %176 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %175, 0
  %177 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %176, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %177, ptr %23, align 8
  %178 = load { i64, [32 x i8] }, ptr %23, align 8
  %179 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %145, 0
  %180 = insertvalue { i64, { i64, [32 x i8] } } %179, { i64, [32 x i8] } %178, 1
  ret { i64, { i64, [32 x i8] } } %180

181:                                              ; preds = %172
  %182 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %183 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %182, 0
  %184 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %183, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %184, ptr %22, align 8
  %185 = load { i64, [32 x i8] }, ptr %22, align 8
  %186 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %145, 0
  %187 = insertvalue { i64, { i64, [32 x i8] } } %186, { i64, [32 x i8] } %185, 1
  ret { i64, { i64, [32 x i8] } } %187

188:                                              ; preds = %149
  %189 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %190 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %189, 0
  %191 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %190, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %191, ptr %21, align 8
  %192 = load { i64, [32 x i8] }, ptr %21, align 8
  %193 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %138, 0
  %194 = insertvalue { i64, { i64, [32 x i8] } } %193, { i64, [32 x i8] } %192, 1
  ret { i64, { i64, [32 x i8] } } %194

195:                                              ; preds = %149
  %196 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %197 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %196, 0
  %198 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %197, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %198, ptr %20, align 8
  %199 = load { i64, [32 x i8] }, ptr %20, align 8
  %200 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %138, 0
  %201 = insertvalue { i64, { i64, [32 x i8] } } %200, { i64, [32 x i8] } %199, 1
  ret { i64, { i64, [32 x i8] } } %201

202:                                              ; preds = %142
  %203 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %204 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %203, 0
  %205 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %204, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %205, ptr %19, align 8
  %206 = load { i64, [32 x i8] }, ptr %19, align 8
  %207 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %126, 0
  %208 = insertvalue { i64, { i64, [32 x i8] } } %207, { i64, [32 x i8] } %206, 1
  ret { i64, { i64, [32 x i8] } } %208

209:                                              ; preds = %142
  %210 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %211 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %210, 0
  %212 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %211, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %212, ptr %18, align 8
  %213 = load { i64, [32 x i8] }, ptr %18, align 8
  %214 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %126, 0
  %215 = insertvalue { i64, { i64, [32 x i8] } } %214, { i64, [32 x i8] } %213, 1
  ret { i64, { i64, [32 x i8] } } %215

216:                                              ; preds = %87
  %217 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %218 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %217, 0
  %219 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %218, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %219, ptr %11, align 8
  %220 = load { i64, [32 x i8] }, ptr %11, align 8
  %221 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %75, 0
  %222 = insertvalue { i64, { i64, [32 x i8] } } %221, { i64, [32 x i8] } %220, 1
  ret { i64, { i64, [32 x i8] } } %222

223:                                              ; preds = %87
  %224 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %225 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %224, 0
  %226 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %225, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %226, ptr %10, align 8
  %227 = load { i64, [32 x i8] }, ptr %10, align 8
  %228 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %75, 0
  %229 = insertvalue { i64, { i64, [32 x i8] } } %228, { i64, [32 x i8] } %227, 1
  ret { i64, { i64, [32 x i8] } } %229

230:                                              ; preds = %79
  %231 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %232 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %231, 0
  %233 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %232, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %233, ptr %9, align 8
  %234 = load { i64, [32 x i8] }, ptr %9, align 8
  %235 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %68, 0
  %236 = insertvalue { i64, { i64, [32 x i8] } } %235, { i64, [32 x i8] } %234, 1
  ret { i64, { i64, [32 x i8] } } %236

237:                                              ; preds = %79
  %238 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %239 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %238, 0
  %240 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %239, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %240, ptr %8, align 8
  %241 = load { i64, [32 x i8] }, ptr %8, align 8
  %242 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %68, 0
  %243 = insertvalue { i64, { i64, [32 x i8] } } %242, { i64, [32 x i8] } %241, 1
  ret { i64, { i64, [32 x i8] } } %243

244:                                              ; preds = %72
  %245 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %246 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %245, 0
  %247 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %246, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %247, ptr %7, align 8
  %248 = load { i64, [32 x i8] }, ptr %7, align 8
  %249 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %61, 0
  %250 = insertvalue { i64, { i64, [32 x i8] } } %249, { i64, [32 x i8] } %248, 1
  ret { i64, { i64, [32 x i8] } } %250

251:                                              ; preds = %72
  %252 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %253 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %252, 0
  %254 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %253, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %254, ptr %6, align 8
  %255 = load { i64, [32 x i8] }, ptr %6, align 8
  %256 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %61, 0
  %257 = insertvalue { i64, { i64, [32 x i8] } } %256, { i64, [32 x i8] } %255, 1
  ret { i64, { i64, [32 x i8] } } %257

258:                                              ; preds = %65
  %259 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %260 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %259, 0
  %261 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %260, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %261, ptr %5, align 8
  %262 = load { i64, [32 x i8] }, ptr %5, align 8
  %263 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %56, 0
  %264 = insertvalue { i64, { i64, [32 x i8] } } %263, { i64, [32 x i8] } %262, 1
  ret { i64, { i64, [32 x i8] } } %264

265:                                              ; preds = %65
  %266 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %267 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %266, 0
  %268 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %267, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %268, ptr %4, align 8
  %269 = load { i64, [32 x i8] }, ptr %4, align 8
  %270 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %56, 0
  %271 = insertvalue { i64, { i64, [32 x i8] } } %270, { i64, [32 x i8] } %269, 1
  ret { i64, { i64, [32 x i8] } } %271

272:                                              ; preds = %89
  call void @puts(ptr @assert_msg_165)
  call void @abort()
  unreachable

273:                                              ; preds = %105
  call void @puts(ptr @assert_msg_166)
  call void @abort()
  unreachable

274:                                              ; preds = %121
  call void @puts(ptr @assert_msg_167)
  call void @abort()
  unreachable
}

define private { i64, { i64, [32 x i8] } } @f98(i64 %0, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2) {
  %4 = call fastcc { i64, { i64, [32 x i8] } } @"impl$f98"(i64 %0, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %1, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %2)
  %5 = extractvalue { i64, { i64, [32 x i8] } } %4, 0
  %6 = extractvalue { i64, { i64, [32 x i8] } } %4, 1
  %7 = insertvalue { i64, { i64, [32 x i8] } } undef, i64 %5, 0
  %8 = insertvalue { i64, { i64, [32 x i8] } } %7, { i64, [32 x i8] } %6, 1
  ret { i64, { i64, [32 x i8] } } %8
}

define void @_mlir_ciface_f98(ptr %0, i64 %1, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %2, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %3) {
  %5 = call { i64, { i64, [32 x i8] } } @f98(i64 %1, { i32, i32, i32, i32, i16, i16, i16, i16, i32, i32, i32 } %2, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %3)
  store { i64, { i64, [32 x i8] } } %5, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f99"(i64 %0, { ptr, i32, i32, i32 } %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i32, [8 x i8] }, i64 1, align 4
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i32, [8 x i8] }, i64 1, align 4
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %1)
  %9 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %8, 0
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %8, 1
  %11 = extractvalue { ptr, i32, i32, i32 } %10, 1
  %12 = extractvalue { ptr, i32, i32, i32 } %10, 2
  %13 = sub i32 %12, %11
  call void @"drop$3"({ ptr, i32, i32, i32 } %10)
  %14 = icmp eq i32 %13, 2
  br i1 %14, label %17, label %15

15:                                               ; preds = %2
  %16 = phi { ptr, i32, i32, i32 } [ %9, %2 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %16)
  br label %80

17:                                               ; preds = %2
  %18 = phi { ptr, i32, i32, i32 } [ %9, %2 ]
  %19 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %18)
  %20 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 0
  %21 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %19, 1
  %22 = extractvalue { ptr, i32, i32, i32 } %21, 1
  %23 = extractvalue { ptr, i32, i32, i32 } %21, 2
  %24 = sub i32 %23, %22
  %25 = icmp uge i32 %24, 1
  br i1 %25, label %26, label %88

26:                                               ; preds = %17
  %27 = extractvalue { ptr, i32, i32, i32 } %21, 0
  %28 = load ptr, ptr %27, align 8
  %29 = zext i32 %22 to i64
  %30 = mul i64 %29, 32
  %31 = getelementptr inbounds i8, ptr %28, i64 %30
  %32 = add i32 %22, 1
  %33 = insertvalue { ptr, i32, i32, i32 } %21, i32 %32, 1
  %34 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %34, ptr %31, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %33)
  %35 = load i252, ptr %34, align 16
  call void @free(ptr %34)
  %36 = icmp ult i252 %35, 4294967296
  %37 = add i64 %0, 2
  %38 = add i64 %0, 3
  %39 = select i1 %36, i64 %37, i64 %38
  %40 = trunc i252 %35 to i32
  br i1 %36, label %41, label %78

41:                                               ; preds = %26
  %42 = phi { ptr, i32, i32, i32 } [ %20, %26 ]
  %43 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %42)
  %44 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %43, 0
  %45 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %43, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %44)
  %46 = add i64 %39, 1
  %47 = extractvalue { ptr, i32, i32, i32 } %45, 1
  %48 = extractvalue { ptr, i32, i32, i32 } %45, 2
  %49 = sub i32 %48, %47
  %50 = icmp ugt i32 %49, 1
  br i1 %50, label %51, label %65

51:                                               ; preds = %41
  %52 = add i32 %47, 1
  %53 = zext i32 %52 to i64
  %54 = mul i64 %53, 32
  %55 = extractvalue { ptr, i32, i32, i32 } %45, 0
  %56 = load ptr, ptr %55, align 8
  %57 = getelementptr inbounds i8, ptr %56, i64 %54
  %58 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %58, ptr %57, i64 32, i1 false)
  call void @"drop$3"({ ptr, i32, i32, i32 } %45)
  %59 = load i252, ptr %58, align 16
  call void @free(ptr %58)
  %60 = icmp ult i252 %59, 4294967296
  %61 = add i64 %39, 3
  %62 = add i64 %39, 4
  %63 = select i1 %60, i64 %61, i64 %62
  %64 = trunc i252 %59 to i32
  br i1 %60, label %66, label %80

65:                                               ; preds = %41
  call void @"drop$3"({ ptr, i32, i32, i32 } %45)
  br label %90

66:                                               ; preds = %51
  %67 = phi i32 [ %40, %51 ]
  %68 = phi i32 [ %64, %51 ]
  %69 = insertvalue { i32, i32 } undef, i32 %67, 0
  %70 = insertvalue { i32, i32 } %69, i32 %68, 1
  %71 = insertvalue { i1, { i32, i32 } } { i1 false, { i32, i32 } undef }, { i32, i32 } %70, 1
  store { i1, { i32, i32 } } %71, ptr %6, align 4
  %72 = load { i32, [8 x i8] }, ptr %6, align 4
  %73 = insertvalue { { i32, [8 x i8] } } undef, { i32, [8 x i8] } %72, 0
  %74 = insertvalue { i1, { { i32, [8 x i8] } } } { i1 false, { { i32, [8 x i8] } } undef }, { { i32, [8 x i8] } } %73, 1
  store { i1, { { i32, [8 x i8] } } } %74, ptr %7, align 4
  %75 = load { i64, [24 x i8] }, ptr %7, align 8
  %76 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %63, 0
  %77 = insertvalue { i64, { i64, [24 x i8] } } %76, { i64, [24 x i8] } %75, 1
  ret { i64, { i64, [24 x i8] } } %77

78:                                               ; preds = %26
  %79 = phi { ptr, i32, i32, i32 } [ %20, %26 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %79)
  br label %80

80:                                               ; preds = %51, %78, %15
  %81 = phi i64 [ %39, %78 ], [ %63, %51 ], [ %0, %15 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %82 = load { i32, [8 x i8] }, ptr %4, align 4
  %83 = insertvalue { { i32, [8 x i8] } } undef, { i32, [8 x i8] } %82, 0
  %84 = insertvalue { i1, { { i32, [8 x i8] } } } { i1 false, { { i32, [8 x i8] } } undef }, { { i32, [8 x i8] } } %83, 1
  store { i1, { { i32, [8 x i8] } } } %84, ptr %5, align 4
  %85 = load { i64, [24 x i8] }, ptr %5, align 8
  %86 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %81, 0
  %87 = insertvalue { i64, { i64, [24 x i8] } } %86, { i64, [24 x i8] } %85, 1
  ret { i64, { i64, [24 x i8] } } %87

88:                                               ; preds = %17
  %89 = phi { ptr, i32, i32, i32 } [ %21, %17 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %89)
  call void @"drop$2"({ ptr, i32, i32, i32 } %20)
  br label %90

90:                                               ; preds = %65, %88
  %91 = phi i64 [ %0, %88 ], [ %46, %65 ]
  %92 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f100"()
  %93 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %92, 0
  %94 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %93, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %94, ptr %3, align 8
  %95 = load { i64, [24 x i8] }, ptr %3, align 8
  %96 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %91, 0
  %97 = insertvalue { i64, { i64, [24 x i8] } } %96, { i64, [24 x i8] } %95, 1
  ret { i64, { i64, [24 x i8] } } %97
}

define private { i64, { i64, [24 x i8] } } @f99(i64 %0, { ptr, i32, i32, i32 } %1) {
  %3 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f99"(i64 %0, { ptr, i32, i32, i32 } %1)
  %4 = extractvalue { i64, { i64, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { i64, [24 x i8] } } %3, 1
  %6 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %5, 1
  ret { i64, { i64, [24 x i8] } } %7
}

define void @_mlir_ciface_f99(ptr %0, i64 %1, { ptr, i32, i32, i32 } %2) {
  %4 = call { i64, { i64, [24 x i8] } } @f99(i64 %1, { ptr, i32, i32, i32 } %2)
  store { i64, { i64, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f100"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 1637570914057682275393755530660268060279989363)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f100() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f100"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f100(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f100()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f101"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 1637577033762547024928219503506405592178450804)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f101() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f101"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f101(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f101()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f102"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 130770336871384315582580298231695941681)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f102() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f102"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f102(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f102()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i128, [64 x i8] } } @"impl$f103"(i64 %0, i64 %1, { i128, i128 } %2, { i128, i128 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i128, [64 x i8] }, i64 1, align 16
  %12 = alloca { i128, [64 x i8] }, i64 1, align 16
  %13 = alloca { i128, [64 x i8] }, i64 1, align 16
  %14 = alloca { i128, [64 x i8] }, i64 1, align 16
  br label %15

15:                                               ; preds = %155, %5
  %16 = phi i64 [ %157, %155 ], [ %0, %5 ]
  %17 = phi i64 [ %160, %155 ], [ %1, %5 ]
  %18 = phi { i128, i128 } [ %158, %155 ], [ %2, %5 ]
  %19 = phi { i128, i128 } [ %156, %155 ], [ %3, %5 ]
  %20 = phi { ptr, i32, i32, i32 } [ %159, %155 ], [ %4, %5 ]
  %21 = add i64 %16, 1
  %22 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %23 = call ptr %22()
  %24 = load i64, ptr %23, align 8
  %25 = mul i64 %24, 8860
  %26 = icmp uge i64 %17, %25
  %27 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %25)
  br i1 %26, label %28, label %223

28:                                               ; preds = %15
  %29 = phi { i128, i128 } [ %18, %15 ]
  %30 = extractvalue { i128, i128 } %29, 0
  %31 = extractvalue { i128, i128 } %29, 1
  %32 = extractvalue { i128, i128 } %19, 0
  %33 = extractvalue { i128, i128 } %19, 1
  %34 = zext i128 %30 to i256
  %35 = zext i128 %31 to i256
  %36 = zext i128 %32 to i256
  %37 = zext i128 %33 to i256
  %38 = shl i256 %35, 128
  %39 = shl i256 %37, 128
  %40 = or i256 %38, %34
  %41 = or i256 %39, %36
  %42 = udiv i256 %40, %41
  %43 = urem i256 %40, %41
  %44 = trunc i256 %42 to i128
  %45 = lshr i256 %42, 128
  %46 = trunc i256 %45 to i128
  %47 = trunc i256 %43 to i128
  %48 = lshr i256 %43, 128
  %49 = trunc i256 %48 to i128
  %50 = insertvalue { i128, i128 } undef, i128 %44, 0
  %51 = insertvalue { i128, i128 } %50, i128 %46, 1
  %52 = add i64 %16, 16
  %53 = icmp eq i128 %49, 0
  br i1 %53, label %54, label %200

54:                                               ; preds = %28
  %55 = phi i64 [ %52, %28 ]
  %56 = phi i128 [ %47, %28 ]
  %57 = icmp ult i128 %56, 256
  %58 = add i64 %55, 1
  %59 = trunc i128 %56 to i8
  br i1 %57, label %60, label %193

60:                                               ; preds = %54
  %61 = phi i64 [ %58, %54 ]
  %62 = phi i8 [ %59, %54 ]
  %63 = phi i8 [ 48, %54 ]
  %64 = add i64 %61, 1
  %65 = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 %62, i8 %63)
  %66 = extractvalue { i8, i1 } %65, 0
  %67 = extractvalue { i8, i1 } %65, 1
  br i1 %67, label %178, label %68

68:                                               ; preds = %60
  %69 = phi { i128, i128 } [ %51, %60 ]
  %70 = extractvalue { ptr, i32, i32, i32 } %20, 3
  %71 = icmp eq i32 %70, 0
  br i1 %71, label %72, label %85

72:                                               ; preds = %68
  %73 = shl i32 %70, 1
  %74 = call i32 @llvm.umin.i32(i32 %73, i32 1024)
  %75 = add i32 %74, %70
  %76 = call i32 @llvm.umax.i32(i32 %75, i32 8)
  %77 = zext i32 %76 to i64
  %78 = add i64 %77, 8
  %79 = call ptr @realloc(ptr null, i64 %78)
  store i32 1, ptr %79, align 4
  %80 = getelementptr inbounds i8, ptr %79, i32 4
  store i32 0, ptr %80, align 4
  %81 = getelementptr inbounds i8, ptr %79, i32 8
  %82 = call ptr @realloc(ptr null, i64 8)
  store ptr %81, ptr %82, align 8
  %83 = insertvalue { ptr, i32, i32, i32 } %20, ptr %82, 0
  %84 = insertvalue { ptr, i32, i32, i32 } %83, i32 %76, 3
  br label %105

85:                                               ; preds = %68
  %86 = extractvalue { ptr, i32, i32, i32 } %20, 2
  %87 = icmp ult i32 %86, %70
  br i1 %87, label %88, label %89

88:                                               ; preds = %85
  br label %102

89:                                               ; preds = %85
  %90 = shl i32 %70, 1
  %91 = call i32 @llvm.umin.i32(i32 %90, i32 1024)
  %92 = add i32 %91, %70
  %93 = call i32 @llvm.umax.i32(i32 %92, i32 8)
  %94 = zext i32 %93 to i64
  %95 = add i64 %94, 8
  %96 = extractvalue { ptr, i32, i32, i32 } %20, 0
  %97 = load ptr, ptr %96, align 8
  %98 = getelementptr inbounds i8, ptr %97, i32 -8
  %99 = call ptr @realloc(ptr %98, i64 %95)
  %100 = getelementptr inbounds i8, ptr %99, i32 8
  store ptr %100, ptr %96, align 8
  %101 = insertvalue { ptr, i32, i32, i32 } %20, i32 %93, 3
  br label %102

102:                                              ; preds = %88, %89
  %103 = phi { ptr, i32, i32, i32 } [ %101, %89 ], [ %20, %88 ]
  br label %104

104:                                              ; preds = %102
  br label %105

105:                                              ; preds = %72, %104
  %106 = phi { ptr, i32, i32, i32 } [ %103, %104 ], [ %84, %72 ]
  br label %107

107:                                              ; preds = %105
  %108 = extractvalue { ptr, i32, i32, i32 } %106, 0
  %109 = load ptr, ptr %108, align 8
  %110 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %111 = zext i32 %110 to i64
  %112 = getelementptr inbounds i8, ptr %109, i64 %111
  store i8 %66, ptr %112, align 1
  %113 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %114 = add i32 %113, 1
  %115 = insertvalue { ptr, i32, i32, i32 } %106, i32 %114, 2
  %116 = getelementptr inbounds i8, ptr %109, i32 -4
  store i32 %114, ptr %116, align 4
  %117 = extractvalue { i128, i128 } %69, 0
  %118 = icmp eq i128 %117, 0
  br i1 %118, label %119, label %148

119:                                              ; preds = %107
  %120 = phi { i128, i128 } [ %69, %107 ]
  %121 = extractvalue { i128, i128 } %120, 1
  %122 = icmp eq i128 %121, 0
  br i1 %122, label %123, label %143

123:                                              ; preds = %119
  %124 = phi i64 [ %27, %119 ]
  %125 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %126 = call ptr %125()
  %127 = load i64, ptr %126, align 8
  %128 = mul i64 %127, 2570
  %129 = call i64 @llvm.uadd.sat.i64(i64 %124, i64 %128)
  %130 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } undef, { i128, i128 } %69, 0
  %131 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %130, { ptr, i32, i32, i32 } %115, 1
  %132 = insertvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } undef }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %131, 1
  store { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %132, ptr %14, align 16
  %133 = load { i128, [64 x i8] }, ptr %14, align 16
  %134 = extractvalue { ptr, ptr, i64 } %9, 1
  %135 = load i64, ptr %134, align 8
  %136 = icmp eq i64 %135, 0
  %137 = sub i64 %135, 1
  %138 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %137, ptr %138, align 8
  br i1 %136, label %139, label %165

139:                                              ; preds = %123
  %140 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %64, 0
  %141 = insertvalue { i64, i64, { i128, [64 x i8] } } %140, i64 %129, 1
  %142 = insertvalue { i64, i64, { i128, [64 x i8] } } %141, { i128, [64 x i8] } %133, 2
  ret { i64, i64, { i128, [64 x i8] } } %142

143:                                              ; preds = %119
  %144 = phi i64 [ %27, %119 ]
  %145 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %146 = call ptr %145()
  %147 = call i64 @llvm.uadd.sat.i64(i64 %144, i64 0)
  br label %155

148:                                              ; preds = %107
  %149 = phi i64 [ %27, %107 ]
  %150 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %151 = call ptr %150()
  %152 = load i64, ptr %151, align 8
  %153 = mul i64 %152, 200
  %154 = call i64 @llvm.uadd.sat.i64(i64 %149, i64 %153)
  br label %155

155:                                              ; preds = %143, %148
  %156 = phi { i128, i128 } [ %19, %148 ], [ %19, %143 ]
  %157 = phi i64 [ %64, %148 ], [ %64, %143 ]
  %158 = phi { i128, i128 } [ %69, %148 ], [ %69, %143 ]
  %159 = phi { ptr, i32, i32, i32 } [ %115, %148 ], [ %115, %143 ]
  %160 = phi i64 [ %154, %148 ], [ %147, %143 ]
  %161 = extractvalue { ptr, ptr, i64 } %9, 1
  %162 = load i64, ptr %161, align 8
  %163 = add i64 %162, 1
  %164 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %163, ptr %164, align 8
  br label %15

165:                                              ; preds = %165, %178, %123, %207, %223
  %166 = phi i64 [ %21, %223 ], [ %208, %207 ], [ %64, %178 ], [ %166, %165 ], [ %64, %123 ]
  %167 = phi i64 [ %17, %223 ], [ %209, %207 ], [ %27, %178 ], [ %167, %165 ], [ %129, %123 ]
  %168 = phi { i128, [64 x i8] } [ %228, %223 ], [ %213, %207 ], [ %183, %178 ], [ %168, %165 ], [ %133, %123 ]
  %169 = extractvalue { ptr, ptr, i64 } %9, 1
  %170 = load i64, ptr %169, align 8
  %171 = icmp eq i64 %170, 0
  %172 = sub i64 %170, 1
  %173 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %172, ptr %173, align 8
  br i1 %171, label %174, label %165

174:                                              ; preds = %165
  %175 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %166, 0
  %176 = insertvalue { i64, i64, { i128, [64 x i8] } } %175, i64 %167, 1
  %177 = insertvalue { i64, i64, { i128, [64 x i8] } } %176, { i128, [64 x i8] } %168, 2
  ret { i64, i64, { i128, [64 x i8] } } %177

178:                                              ; preds = %60
  %179 = phi { ptr, i32, i32, i32 } [ %20, %60 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %179)
  %180 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f109"()
  %181 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %180, 0
  %182 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %181, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %182, ptr %13, align 8
  %183 = load { i128, [64 x i8] }, ptr %13, align 16
  %184 = extractvalue { ptr, ptr, i64 } %9, 1
  %185 = load i64, ptr %184, align 8
  %186 = icmp eq i64 %185, 0
  %187 = sub i64 %185, 1
  %188 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %187, ptr %188, align 8
  br i1 %186, label %189, label %165

189:                                              ; preds = %178
  %190 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %64, 0
  %191 = insertvalue { i64, i64, { i128, [64 x i8] } } %190, i64 %27, 1
  %192 = insertvalue { i64, i64, { i128, [64 x i8] } } %191, { i128, [64 x i8] } %183, 2
  ret { i64, i64, { i128, [64 x i8] } } %192

193:                                              ; preds = %54
  %194 = phi { ptr, i32, i32, i32 } [ %20, %54 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %194)
  %195 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %196 = call ptr %195()
  %197 = load i64, ptr %196, align 8
  %198 = mul i64 %197, 2140
  %199 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %198)
  br label %207

200:                                              ; preds = %28
  %201 = phi { ptr, i32, i32, i32 } [ %20, %28 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %201)
  %202 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %203 = call ptr %202()
  %204 = load i64, ptr %203, align 8
  %205 = mul i64 %204, 2710
  %206 = call i64 @llvm.uadd.sat.i64(i64 %27, i64 %205)
  br label %207

207:                                              ; preds = %193, %200
  %208 = phi i64 [ %52, %200 ], [ %58, %193 ]
  %209 = phi i64 [ %206, %200 ], [ %199, %193 ]
  %210 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %211 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %210, 0
  %212 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %211, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %212, ptr %12, align 8
  %213 = load { i128, [64 x i8] }, ptr %12, align 16
  %214 = extractvalue { ptr, ptr, i64 } %9, 1
  %215 = load i64, ptr %214, align 8
  %216 = icmp eq i64 %215, 0
  %217 = sub i64 %215, 1
  %218 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %217, ptr %218, align 8
  br i1 %216, label %219, label %165

219:                                              ; preds = %207
  %220 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %208, 0
  %221 = insertvalue { i64, i64, { i128, [64 x i8] } } %220, i64 %209, 1
  %222 = insertvalue { i64, i64, { i128, [64 x i8] } } %221, { i128, [64 x i8] } %213, 2
  ret { i64, i64, { i128, [64 x i8] } } %222

223:                                              ; preds = %15
  %224 = phi { ptr, i32, i32, i32 } [ %20, %15 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %224)
  %225 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %226 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %225, 0
  %227 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %226, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %227, ptr %11, align 8
  %228 = load { i128, [64 x i8] }, ptr %11, align 16
  %229 = extractvalue { ptr, ptr, i64 } %9, 1
  %230 = load i64, ptr %229, align 8
  %231 = icmp eq i64 %230, 0
  %232 = sub i64 %230, 1
  %233 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %232, ptr %233, align 8
  br i1 %231, label %234, label %165

234:                                              ; preds = %223
  %235 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %21, 0
  %236 = insertvalue { i64, i64, { i128, [64 x i8] } } %235, i64 %17, 1
  %237 = insertvalue { i64, i64, { i128, [64 x i8] } } %236, { i128, [64 x i8] } %228, 2
  ret { i64, i64, { i128, [64 x i8] } } %237
}

define private { i64, i64, { i128, [64 x i8] } } @f103(i64 %0, i64 %1, { i128, i128 } %2, { i128, i128 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call fastcc { i64, i64, { i128, [64 x i8] } } @"impl$f103"(i64 %0, i64 %1, { i128, i128 } %2, { i128, i128 } %3, { ptr, i32, i32, i32 } %4)
  %7 = extractvalue { i64, i64, { i128, [64 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i128, [64 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i128, [64 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i128, [64 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i128, [64 x i8] } } %11, { i128, [64 x i8] } %9, 2
  ret { i64, i64, { i128, [64 x i8] } } %12
}

define void @_mlir_ciface_f103(ptr %0, i64 %1, i64 %2, { i128, i128 } %3, { i128, i128 } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call { i64, i64, { i128, [64 x i8] } } @f103(i64 %1, i64 %2, { i128, i128 } %3, { i128, i128 } %4, { ptr, i32, i32, i32 } %5)
  store { i64, i64, { i128, [64 x i8] } } %7, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, { i128, [64 x i8] } } @"impl$f104"(i64 %0, i64 %1, { i128, i128 } %2, { i128, i128 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i128, [64 x i8] }, i64 1, align 16
  %12 = alloca { i128, [64 x i8] }, i64 1, align 16
  %13 = alloca { i128, [64 x i8] }, i64 1, align 16
  %14 = alloca { i128, [64 x i8] }, i64 1, align 16
  %15 = alloca { i128, [64 x i8] }, i64 1, align 16
  br label %16

16:                                               ; preds = %217, %5
  %17 = phi i64 [ %220, %217 ], [ %0, %5 ]
  %18 = phi i64 [ %222, %217 ], [ %1, %5 ]
  %19 = phi { i128, i128 } [ %219, %217 ], [ %2, %5 ]
  %20 = phi { i128, i128 } [ %218, %217 ], [ %3, %5 ]
  %21 = phi { ptr, i32, i32, i32 } [ %221, %217 ], [ %4, %5 ]
  %22 = add i64 %17, 1
  %23 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %24 = call ptr %23()
  %25 = load i64, ptr %24, align 8
  %26 = mul i64 %25, 10200
  %27 = icmp uge i64 %18, %26
  %28 = call i64 @llvm.usub.sat.i64(i64 %18, i64 %26)
  br i1 %27, label %29, label %293

29:                                               ; preds = %16
  %30 = phi { i128, i128 } [ %19, %16 ]
  %31 = extractvalue { i128, i128 } %30, 0
  %32 = extractvalue { i128, i128 } %30, 1
  %33 = extractvalue { i128, i128 } %20, 0
  %34 = extractvalue { i128, i128 } %20, 1
  %35 = zext i128 %31 to i256
  %36 = zext i128 %32 to i256
  %37 = zext i128 %33 to i256
  %38 = zext i128 %34 to i256
  %39 = shl i256 %36, 128
  %40 = shl i256 %38, 128
  %41 = or i256 %39, %35
  %42 = or i256 %40, %37
  %43 = udiv i256 %41, %42
  %44 = urem i256 %41, %42
  %45 = trunc i256 %43 to i128
  %46 = lshr i256 %43, 128
  %47 = trunc i256 %46 to i128
  %48 = trunc i256 %44 to i128
  %49 = lshr i256 %44, 128
  %50 = trunc i256 %49 to i128
  %51 = insertvalue { i128, i128 } undef, i128 %45, 0
  %52 = insertvalue { i128, i128 } %51, i128 %47, 1
  %53 = add i64 %17, 16
  %54 = icmp eq i128 %50, 0
  br i1 %54, label %55, label %270

55:                                               ; preds = %29
  %56 = phi i64 [ %53, %29 ]
  %57 = phi i128 [ %48, %29 ]
  %58 = icmp ult i128 %57, 256
  %59 = add i64 %56, 1
  %60 = trunc i128 %57 to i8
  br i1 %58, label %61, label %263

61:                                               ; preds = %55
  %62 = phi { i128, i128 } [ %52, %55 ]
  %63 = add i64 %56, 2
  %64 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 %60, i8 10)
  %65 = extractvalue { i8, i1 } %64, 1
  br i1 %65, label %109, label %66

66:                                               ; preds = %61
  %67 = phi i64 [ %63, %61 ]
  %68 = phi i8 [ %60, %61 ]
  %69 = phi i8 [ 10, %61 ]
  %70 = add i64 %67, 1
  %71 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 %68, i8 %69)
  %72 = extractvalue { i8, i1 } %71, 0
  %73 = extractvalue { i8, i1 } %71, 1
  br i1 %73, label %94, label %74

74:                                               ; preds = %66
  %75 = phi i64 [ %70, %66 ]
  %76 = phi i8 [ %72, %66 ]
  %77 = phi i8 [ 97, %66 ]
  %78 = add i64 %75, 1
  %79 = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 %76, i8 %77)
  %80 = extractvalue { i8, i1 } %79, 0
  %81 = extractvalue { i8, i1 } %79, 1
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = phi i64 [ %28, %74 ]
  %84 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %85 = call ptr %84()
  %86 = call i64 @llvm.uadd.sat.i64(i64 %83, i64 0)
  br label %124

87:                                               ; preds = %74
  %88 = phi { ptr, i32, i32, i32 } [ %21, %74 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %88)
  %89 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %90 = call ptr %89()
  %91 = load i64, ptr %90, align 8
  %92 = mul i64 %91, 1970
  %93 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %92)
  br label %247

94:                                               ; preds = %66
  %95 = phi { ptr, i32, i32, i32 } [ %21, %66 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %95)
  %96 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f123"()
  %97 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %96, 0
  %98 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %97, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %98, ptr %15, align 8
  %99 = load { i128, [64 x i8] }, ptr %15, align 16
  %100 = extractvalue { ptr, ptr, i64 } %9, 1
  %101 = load i64, ptr %100, align 8
  %102 = icmp eq i64 %101, 0
  %103 = sub i64 %101, 1
  %104 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %103, ptr %104, align 8
  br i1 %102, label %105, label %227

105:                                              ; preds = %94
  %106 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %70, 0
  %107 = insertvalue { i64, i64, { i128, [64 x i8] } } %106, i64 %28, 1
  %108 = insertvalue { i64, i64, { i128, [64 x i8] } } %107, { i128, [64 x i8] } %99, 2
  ret { i64, i64, { i128, [64 x i8] } } %108

109:                                              ; preds = %61
  %110 = phi i64 [ %63, %61 ]
  %111 = phi i8 [ %60, %61 ]
  %112 = phi i8 [ 48, %61 ]
  %113 = add i64 %110, 1
  %114 = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 %111, i8 %112)
  %115 = extractvalue { i8, i1 } %114, 0
  %116 = extractvalue { i8, i1 } %114, 1
  br i1 %116, label %240, label %117

117:                                              ; preds = %109
  %118 = phi i64 [ %28, %109 ]
  %119 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %120 = call ptr %119()
  %121 = load i64, ptr %120, align 8
  %122 = mul i64 %121, 250
  %123 = call i64 @llvm.uadd.sat.i64(i64 %118, i64 %122)
  br label %124

124:                                              ; preds = %117, %82
  %125 = phi { i128, i128 } [ %20, %117 ], [ %20, %82 ]
  %126 = phi { ptr, i32, i32, i32 } [ %21, %117 ], [ %21, %82 ]
  %127 = phi { i128, i128 } [ %62, %117 ], [ %62, %82 ]
  %128 = phi { i128, i128 } [ %62, %117 ], [ %62, %82 ]
  %129 = phi i64 [ %113, %117 ], [ %78, %82 ]
  %130 = phi i64 [ %123, %117 ], [ %86, %82 ]
  %131 = phi i8 [ %115, %117 ], [ %80, %82 ]
  %132 = extractvalue { ptr, i32, i32, i32 } %126, 3
  %133 = icmp eq i32 %132, 0
  br i1 %133, label %134, label %147

134:                                              ; preds = %124
  %135 = shl i32 %132, 1
  %136 = call i32 @llvm.umin.i32(i32 %135, i32 1024)
  %137 = add i32 %136, %132
  %138 = call i32 @llvm.umax.i32(i32 %137, i32 8)
  %139 = zext i32 %138 to i64
  %140 = add i64 %139, 8
  %141 = call ptr @realloc(ptr null, i64 %140)
  store i32 1, ptr %141, align 4
  %142 = getelementptr inbounds i8, ptr %141, i32 4
  store i32 0, ptr %142, align 4
  %143 = getelementptr inbounds i8, ptr %141, i32 8
  %144 = call ptr @realloc(ptr null, i64 8)
  store ptr %143, ptr %144, align 8
  %145 = insertvalue { ptr, i32, i32, i32 } %126, ptr %144, 0
  %146 = insertvalue { ptr, i32, i32, i32 } %145, i32 %138, 3
  br label %167

147:                                              ; preds = %124
  %148 = extractvalue { ptr, i32, i32, i32 } %126, 2
  %149 = icmp ult i32 %148, %132
  br i1 %149, label %150, label %151

150:                                              ; preds = %147
  br label %164

151:                                              ; preds = %147
  %152 = shl i32 %132, 1
  %153 = call i32 @llvm.umin.i32(i32 %152, i32 1024)
  %154 = add i32 %153, %132
  %155 = call i32 @llvm.umax.i32(i32 %154, i32 8)
  %156 = zext i32 %155 to i64
  %157 = add i64 %156, 8
  %158 = extractvalue { ptr, i32, i32, i32 } %126, 0
  %159 = load ptr, ptr %158, align 8
  %160 = getelementptr inbounds i8, ptr %159, i32 -8
  %161 = call ptr @realloc(ptr %160, i64 %157)
  %162 = getelementptr inbounds i8, ptr %161, i32 8
  store ptr %162, ptr %158, align 8
  %163 = insertvalue { ptr, i32, i32, i32 } %126, i32 %155, 3
  br label %164

164:                                              ; preds = %150, %151
  %165 = phi { ptr, i32, i32, i32 } [ %163, %151 ], [ %126, %150 ]
  br label %166

166:                                              ; preds = %164
  br label %167

167:                                              ; preds = %134, %166
  %168 = phi { ptr, i32, i32, i32 } [ %165, %166 ], [ %146, %134 ]
  br label %169

169:                                              ; preds = %167
  %170 = extractvalue { ptr, i32, i32, i32 } %168, 0
  %171 = load ptr, ptr %170, align 8
  %172 = extractvalue { ptr, i32, i32, i32 } %168, 2
  %173 = zext i32 %172 to i64
  %174 = getelementptr inbounds i8, ptr %171, i64 %173
  store i8 %131, ptr %174, align 1
  %175 = extractvalue { ptr, i32, i32, i32 } %168, 2
  %176 = add i32 %175, 1
  %177 = insertvalue { ptr, i32, i32, i32 } %168, i32 %176, 2
  %178 = getelementptr inbounds i8, ptr %171, i32 -4
  store i32 %176, ptr %178, align 4
  %179 = extractvalue { i128, i128 } %127, 0
  %180 = icmp eq i128 %179, 0
  br i1 %180, label %181, label %210

181:                                              ; preds = %169
  %182 = phi { i128, i128 } [ %127, %169 ]
  %183 = extractvalue { i128, i128 } %182, 1
  %184 = icmp eq i128 %183, 0
  br i1 %184, label %185, label %205

185:                                              ; preds = %181
  %186 = phi i64 [ %130, %181 ]
  %187 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %188 = call ptr %187()
  %189 = load i64, ptr %188, align 8
  %190 = mul i64 %189, 2570
  %191 = call i64 @llvm.uadd.sat.i64(i64 %186, i64 %190)
  %192 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } undef, { i128, i128 } %128, 0
  %193 = insertvalue { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %192, { ptr, i32, i32, i32 } %177, 1
  %194 = insertvalue { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } undef }, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } %193, 1
  store { i1, { { i128, i128 }, { ptr, i32, i32, i32 }, {} } } %194, ptr %14, align 16
  %195 = load { i128, [64 x i8] }, ptr %14, align 16
  %196 = extractvalue { ptr, ptr, i64 } %9, 1
  %197 = load i64, ptr %196, align 8
  %198 = icmp eq i64 %197, 0
  %199 = sub i64 %197, 1
  %200 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %199, ptr %200, align 8
  br i1 %198, label %201, label %227

201:                                              ; preds = %185
  %202 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %129, 0
  %203 = insertvalue { i64, i64, { i128, [64 x i8] } } %202, i64 %191, 1
  %204 = insertvalue { i64, i64, { i128, [64 x i8] } } %203, { i128, [64 x i8] } %195, 2
  ret { i64, i64, { i128, [64 x i8] } } %204

205:                                              ; preds = %181
  %206 = phi i64 [ %130, %181 ]
  %207 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %208 = call ptr %207()
  %209 = call i64 @llvm.uadd.sat.i64(i64 %206, i64 0)
  br label %217

210:                                              ; preds = %169
  %211 = phi i64 [ %130, %169 ]
  %212 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %213 = call ptr %212()
  %214 = load i64, ptr %213, align 8
  %215 = mul i64 %214, 200
  %216 = call i64 @llvm.uadd.sat.i64(i64 %211, i64 %215)
  br label %217

217:                                              ; preds = %205, %210
  %218 = phi { i128, i128 } [ %125, %210 ], [ %125, %205 ]
  %219 = phi { i128, i128 } [ %128, %210 ], [ %128, %205 ]
  %220 = phi i64 [ %129, %210 ], [ %129, %205 ]
  %221 = phi { ptr, i32, i32, i32 } [ %177, %210 ], [ %177, %205 ]
  %222 = phi i64 [ %216, %210 ], [ %209, %205 ]
  %223 = extractvalue { ptr, ptr, i64 } %9, 1
  %224 = load i64, ptr %223, align 8
  %225 = add i64 %224, 1
  %226 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %225, ptr %226, align 8
  br label %16

227:                                              ; preds = %227, %247, %185, %94, %277, %293
  %228 = phi i64 [ %22, %293 ], [ %278, %277 ], [ %248, %247 ], [ %228, %227 ], [ %129, %185 ], [ %70, %94 ]
  %229 = phi i64 [ %18, %293 ], [ %279, %277 ], [ %249, %247 ], [ %229, %227 ], [ %191, %185 ], [ %28, %94 ]
  %230 = phi { i128, [64 x i8] } [ %298, %293 ], [ %283, %277 ], [ %253, %247 ], [ %230, %227 ], [ %195, %185 ], [ %99, %94 ]
  %231 = extractvalue { ptr, ptr, i64 } %9, 1
  %232 = load i64, ptr %231, align 8
  %233 = icmp eq i64 %232, 0
  %234 = sub i64 %232, 1
  %235 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %234, ptr %235, align 8
  br i1 %233, label %236, label %227

236:                                              ; preds = %227
  %237 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %228, 0
  %238 = insertvalue { i64, i64, { i128, [64 x i8] } } %237, i64 %229, 1
  %239 = insertvalue { i64, i64, { i128, [64 x i8] } } %238, { i128, [64 x i8] } %230, 2
  ret { i64, i64, { i128, [64 x i8] } } %239

240:                                              ; preds = %109
  %241 = phi { ptr, i32, i32, i32 } [ %21, %109 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %241)
  %242 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %243 = call ptr %242()
  %244 = load i64, ptr %243, align 8
  %245 = mul i64 %244, 2340
  %246 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %245)
  br label %247

247:                                              ; preds = %240, %87
  %248 = phi i64 [ %113, %240 ], [ %78, %87 ]
  %249 = phi i64 [ %246, %240 ], [ %93, %87 ]
  %250 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f109"()
  %251 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %250, 0
  %252 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %251, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %252, ptr %13, align 8
  %253 = load { i128, [64 x i8] }, ptr %13, align 16
  %254 = extractvalue { ptr, ptr, i64 } %9, 1
  %255 = load i64, ptr %254, align 8
  %256 = icmp eq i64 %255, 0
  %257 = sub i64 %255, 1
  %258 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %257, ptr %258, align 8
  br i1 %256, label %259, label %227

259:                                              ; preds = %247
  %260 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %248, 0
  %261 = insertvalue { i64, i64, { i128, [64 x i8] } } %260, i64 %249, 1
  %262 = insertvalue { i64, i64, { i128, [64 x i8] } } %261, { i128, [64 x i8] } %253, 2
  ret { i64, i64, { i128, [64 x i8] } } %262

263:                                              ; preds = %55
  %264 = phi { ptr, i32, i32, i32 } [ %21, %55 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %264)
  %265 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %266 = call ptr %265()
  %267 = load i64, ptr %266, align 8
  %268 = mul i64 %267, 3480
  %269 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %268)
  br label %277

270:                                              ; preds = %29
  %271 = phi { ptr, i32, i32, i32 } [ %21, %29 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %271)
  %272 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %273 = call ptr %272()
  %274 = load i64, ptr %273, align 8
  %275 = mul i64 %274, 4050
  %276 = call i64 @llvm.uadd.sat.i64(i64 %28, i64 %275)
  br label %277

277:                                              ; preds = %263, %270
  %278 = phi i64 [ %53, %270 ], [ %59, %263 ]
  %279 = phi i64 [ %276, %270 ], [ %269, %263 ]
  %280 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %281 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %280, 0
  %282 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %281, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %282, ptr %12, align 8
  %283 = load { i128, [64 x i8] }, ptr %12, align 16
  %284 = extractvalue { ptr, ptr, i64 } %9, 1
  %285 = load i64, ptr %284, align 8
  %286 = icmp eq i64 %285, 0
  %287 = sub i64 %285, 1
  %288 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %287, ptr %288, align 8
  br i1 %286, label %289, label %227

289:                                              ; preds = %277
  %290 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %278, 0
  %291 = insertvalue { i64, i64, { i128, [64 x i8] } } %290, i64 %279, 1
  %292 = insertvalue { i64, i64, { i128, [64 x i8] } } %291, { i128, [64 x i8] } %283, 2
  ret { i64, i64, { i128, [64 x i8] } } %292

293:                                              ; preds = %16
  %294 = phi { ptr, i32, i32, i32 } [ %21, %16 ]
  call void @"drop$212"({ ptr, i32, i32, i32 } %294)
  %295 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %296 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %295, 0
  %297 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %296, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %297, ptr %11, align 8
  %298 = load { i128, [64 x i8] }, ptr %11, align 16
  %299 = extractvalue { ptr, ptr, i64 } %9, 1
  %300 = load i64, ptr %299, align 8
  %301 = icmp eq i64 %300, 0
  %302 = sub i64 %300, 1
  %303 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %302, ptr %303, align 8
  br i1 %301, label %304, label %227

304:                                              ; preds = %293
  %305 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %22, 0
  %306 = insertvalue { i64, i64, { i128, [64 x i8] } } %305, i64 %18, 1
  %307 = insertvalue { i64, i64, { i128, [64 x i8] } } %306, { i128, [64 x i8] } %298, 2
  ret { i64, i64, { i128, [64 x i8] } } %307
}

define private { i64, i64, { i128, [64 x i8] } } @f104(i64 %0, i64 %1, { i128, i128 } %2, { i128, i128 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call fastcc { i64, i64, { i128, [64 x i8] } } @"impl$f104"(i64 %0, i64 %1, { i128, i128 } %2, { i128, i128 } %3, { ptr, i32, i32, i32 } %4)
  %7 = extractvalue { i64, i64, { i128, [64 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i128, [64 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i128, [64 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i128, [64 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i128, [64 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i128, [64 x i8] } } %11, { i128, [64 x i8] } %9, 2
  ret { i64, i64, { i128, [64 x i8] } } %12
}

define void @_mlir_ciface_f104(ptr %0, i64 %1, i64 %2, { i128, i128 } %3, { i128, i128 } %4, { ptr, i32, i32, i32 } %5) {
  %7 = call { i64, i64, { i128, [64 x i8] } } @f104(i64 %1, i64 %2, { i128, i128 } %3, { i128, i128 } %4, { ptr, i32, i32, i32 } %5)
  store { i64, i64, { i128, [64 x i8] } } %7, ptr %0, align 16
  ret void
}

define private void @"drop$117"(ptr %0) {
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$117"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 1)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 1, i1 false)
  %3 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %4 = insertvalue { ptr, ptr } %3, ptr %2, 1
  ret { ptr, ptr } %4
}

define private fastcc { i64, i64, { i128, [112 x i8] } } @"impl$f105"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { { ptr, i32, i32, i32 }, i252, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i128, [112 x i8] }, i64 1, align 16
  %11 = alloca { i128, [112 x i8] }, i64 1, align 16
  %12 = alloca { i128, [112 x i8] }, i64 1, align 16
  br label %13

13:                                               ; preds = %169, %4
  %14 = phi i64 [ %171, %169 ], [ %0, %4 ]
  %15 = phi i64 [ %172, %169 ], [ %1, %4 ]
  %16 = phi { { ptr, i32, i32, i32 } } [ %170, %169 ], [ %2, %4 ]
  %17 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %178, %169 ], [ %3, %4 ]
  %18 = add i64 %14, 1
  %19 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %20 = call ptr %19()
  %21 = load i64, ptr %20, align 8
  %22 = mul i64 %21, 4490
  %23 = icmp uge i64 %15, %22
  %24 = call i64 @llvm.usub.sat.i64(i64 %15, i64 %22)
  br i1 %23, label %25, label %217

25:                                               ; preds = %13
  %26 = phi { { ptr, i32, i32, i32 } } [ %16, %13 ]
  %27 = extractvalue { { ptr, i32, i32, i32 } } %26, 0
  %28 = extractvalue { ptr, i32, i32, i32 } %27, 1
  %29 = extractvalue { ptr, i32, i32, i32 } %27, 2
  %30 = sub i32 %29, %28
  %31 = icmp uge i32 %30, 1
  br i1 %31, label %32, label %196

32:                                               ; preds = %25
  %33 = extractvalue { ptr, i32, i32, i32 } %27, 0
  %34 = load ptr, ptr %33, align 8
  %35 = sub i32 %29, 1
  %36 = insertvalue { ptr, i32, i32, i32 } %27, i32 %35, 2
  %37 = zext i32 %35 to i64
  %38 = getelementptr inbounds i8, ptr %34, i64 %37
  %39 = call ptr @realloc(ptr null, i64 1)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %38, i64 1, i1 false)
  %40 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %17, 0
  %41 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %17, 1
  %42 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %17, 2
  %43 = load i8, ptr %39, align 1
  call void @free(ptr %39)
  %44 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %36, 0
  %45 = icmp eq i32 %42, 0
  br i1 %45, label %46, label %54

46:                                               ; preds = %32
  %47 = phi i64 [ %24, %32 ]
  %48 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %49 = call ptr %48()
  %50 = load i64, ptr %49, align 8
  %51 = mul i64 %50, 1790
  %52 = call i64 @llvm.uadd.sat.i64(i64 %47, i64 %51)
  %53 = zext i8 %43 to i252
  br label %169

54:                                               ; preds = %32
  %55 = phi i8 [ %43, %32 ]
  %56 = zext i252 %41 to i512
  %57 = mul i512 %56, 256
  %58 = urem i512 %57, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %59 = icmp uge i512 %57, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %60 = select i1 %59, i512 %58, i512 %57
  %61 = trunc i512 %60 to i252
  %62 = zext i252 %61 to i256
  %63 = zext i8 %55 to i256
  %64 = add i256 %62, %63
  %65 = sub i256 %64, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %66 = icmp uge i256 %64, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %67 = select i1 %66, i256 %65, i256 %64
  %68 = trunc i256 %67 to i252
  %69 = icmp eq i32 %42, 30
  br i1 %69, label %96, label %70

70:                                               ; preds = %54
  %71 = phi i32 [ %42, %54 ]
  %72 = icmp eq i32 %71, -1
  br i1 %72, label %73, label %88

73:                                               ; preds = %70
  %74 = phi { { ptr, i32, i32, i32 } } [ %44, %70 ]
  call void @"drop$214"({ { ptr, i32, i32, i32 } } %74)
  call void @"drop$42"({ ptr, i32, i32, i32 } %40)
  %75 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f83"()
  %76 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %75, 0
  %77 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %76, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %77, ptr %12, align 8
  %78 = load { i128, [112 x i8] }, ptr %12, align 16
  %79 = extractvalue { ptr, ptr, i64 } %8, 1
  %80 = load i64, ptr %79, align 8
  %81 = icmp eq i64 %80, 0
  %82 = sub i64 %80, 1
  %83 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %82, ptr %83, align 8
  br i1 %81, label %84, label %183

84:                                               ; preds = %73
  %85 = insertvalue { i64, i64, { i128, [112 x i8] } } undef, i64 %18, 0
  %86 = insertvalue { i64, i64, { i128, [112 x i8] } } %85, i64 %24, 1
  %87 = insertvalue { i64, i64, { i128, [112 x i8] } } %86, { i128, [112 x i8] } %78, 2
  ret { i64, i64, { i128, [112 x i8] } } %87

88:                                               ; preds = %70
  %89 = phi i64 [ %24, %70 ]
  %90 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %91 = call ptr %90()
  %92 = load i64, ptr %91, align 8
  %93 = mul i64 %92, 1230
  %94 = call i64 @llvm.uadd.sat.i64(i64 %89, i64 %93)
  %95 = add i32 %71, 1
  br label %169

96:                                               ; preds = %54
  %97 = phi i64 [ %18, %54 ]
  %98 = phi i252 [ %68, %54 ]
  %99 = add i64 %97, 3
  %100 = icmp ule i252 %98, 452312848583266388373324160190187140051835877600158453279131187530910662655
  br i1 %100, label %101, label %106

101:                                              ; preds = %96
  %102 = trunc i252 %98 to i248
  %103 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %104 = call ptr %103()
  %105 = call i64 @llvm.uadd.sat.i64(i64 %24, i64 0)
  br label %113

106:                                              ; preds = %96
  %107 = phi i64 [ %24, %96 ]
  %108 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %109 = call ptr %108()
  %110 = load i64, ptr %109, align 8
  %111 = mul i64 %110, 10
  %112 = call i64 @llvm.uadd.sat.i64(i64 %107, i64 %111)
  br label %113

113:                                              ; preds = %101, %106
  %114 = phi { ptr, i32, i32, i32 } [ %40, %106 ], [ %40, %101 ]
  %115 = phi { { ptr, i32, i32, i32 } } [ %44, %106 ], [ %44, %101 ]
  %116 = phi i64 [ %99, %106 ], [ %99, %101 ]
  %117 = phi i64 [ %112, %106 ], [ %105, %101 ]
  %118 = phi i248 [ 88068479653790488123916992367510505285, %106 ], [ %102, %101 ]
  %119 = extractvalue { ptr, i32, i32, i32 } %114, 3
  %120 = icmp eq i32 %119, 0
  br i1 %120, label %121, label %135

121:                                              ; preds = %113
  %122 = shl i32 %119, 1
  %123 = call i32 @llvm.umin.i32(i32 %122, i32 1024)
  %124 = add i32 %123, %119
  %125 = call i32 @llvm.umax.i32(i32 %124, i32 8)
  %126 = zext i32 %125 to i64
  %127 = mul i64 %126, 32
  %128 = add i64 %127, 16
  %129 = call ptr @realloc(ptr null, i64 %128)
  store i32 1, ptr %129, align 4
  %130 = getelementptr inbounds i8, ptr %129, i32 4
  store i32 0, ptr %130, align 4
  %131 = getelementptr inbounds i8, ptr %129, i32 16
  %132 = call ptr @realloc(ptr null, i64 8)
  store ptr %131, ptr %132, align 8
  %133 = insertvalue { ptr, i32, i32, i32 } %114, ptr %132, 0
  %134 = insertvalue { ptr, i32, i32, i32 } %133, i32 %125, 3
  br label %156

135:                                              ; preds = %113
  %136 = extractvalue { ptr, i32, i32, i32 } %114, 2
  %137 = icmp ult i32 %136, %119
  br i1 %137, label %138, label %139

138:                                              ; preds = %135
  br label %153

139:                                              ; preds = %135
  %140 = shl i32 %119, 1
  %141 = call i32 @llvm.umin.i32(i32 %140, i32 1024)
  %142 = add i32 %141, %119
  %143 = call i32 @llvm.umax.i32(i32 %142, i32 8)
  %144 = zext i32 %143 to i64
  %145 = mul i64 %144, 32
  %146 = add i64 %145, 16
  %147 = extractvalue { ptr, i32, i32, i32 } %114, 0
  %148 = load ptr, ptr %147, align 8
  %149 = getelementptr inbounds i8, ptr %148, i32 -16
  %150 = call ptr @realloc(ptr %149, i64 %146)
  %151 = getelementptr inbounds i8, ptr %150, i32 16
  store ptr %151, ptr %147, align 8
  %152 = insertvalue { ptr, i32, i32, i32 } %114, i32 %143, 3
  br label %153

153:                                              ; preds = %138, %139
  %154 = phi { ptr, i32, i32, i32 } [ %152, %139 ], [ %114, %138 ]
  br label %155

155:                                              ; preds = %153
  br label %156

156:                                              ; preds = %121, %155
  %157 = phi { ptr, i32, i32, i32 } [ %154, %155 ], [ %134, %121 ]
  br label %158

158:                                              ; preds = %156
  %159 = extractvalue { ptr, i32, i32, i32 } %157, 0
  %160 = load ptr, ptr %159, align 8
  %161 = extractvalue { ptr, i32, i32, i32 } %157, 2
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 32
  %164 = getelementptr inbounds i8, ptr %160, i64 %163
  store i248 %118, ptr %164, align 16
  %165 = extractvalue { ptr, i32, i32, i32 } %157, 2
  %166 = add i32 %165, 1
  %167 = insertvalue { ptr, i32, i32, i32 } %157, i32 %166, 2
  %168 = getelementptr inbounds i8, ptr %160, i32 -12
  store i32 %166, ptr %168, align 4
  br label %169

169:                                              ; preds = %46, %158, %88
  %170 = phi { { ptr, i32, i32, i32 } } [ %115, %158 ], [ %44, %88 ], [ %44, %46 ]
  %171 = phi i64 [ %116, %158 ], [ %18, %88 ], [ %18, %46 ]
  %172 = phi i64 [ %117, %158 ], [ %94, %88 ], [ %52, %46 ]
  %173 = phi { ptr, i32, i32, i32 } [ %167, %158 ], [ %40, %88 ], [ %40, %46 ]
  %174 = phi i252 [ 0, %158 ], [ %68, %88 ], [ %53, %46 ]
  %175 = phi i32 [ 0, %158 ], [ %95, %88 ], [ 1, %46 ]
  %176 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %173, 0
  %177 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %176, i252 %174, 1
  %178 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %177, i32 %175, 2
  %179 = extractvalue { ptr, ptr, i64 } %8, 1
  %180 = load i64, ptr %179, align 8
  %181 = add i64 %180, 1
  %182 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %181, ptr %182, align 8
  br label %13

183:                                              ; preds = %183, %73, %196, %217
  %184 = phi i64 [ %18, %217 ], [ %18, %196 ], [ %184, %183 ], [ %18, %73 ]
  %185 = phi i64 [ %15, %217 ], [ %202, %196 ], [ %185, %183 ], [ %24, %73 ]
  %186 = phi { i128, [112 x i8] } [ %222, %217 ], [ %207, %196 ], [ %186, %183 ], [ %78, %73 ]
  %187 = extractvalue { ptr, ptr, i64 } %8, 1
  %188 = load i64, ptr %187, align 8
  %189 = icmp eq i64 %188, 0
  %190 = sub i64 %188, 1
  %191 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %190, ptr %191, align 8
  br i1 %189, label %192, label %183

192:                                              ; preds = %183
  %193 = insertvalue { i64, i64, { i128, [112 x i8] } } undef, i64 %184, 0
  %194 = insertvalue { i64, i64, { i128, [112 x i8] } } %193, i64 %185, 1
  %195 = insertvalue { i64, i64, { i128, [112 x i8] } } %194, { i128, [112 x i8] } %186, 2
  ret { i64, i64, { i128, [112 x i8] } } %195

196:                                              ; preds = %25
  %197 = phi i64 [ %24, %25 ]
  %198 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %199 = call ptr %198()
  %200 = load i64, ptr %199, align 8
  %201 = mul i64 %200, 5190
  %202 = call i64 @llvm.uadd.sat.i64(i64 %197, i64 %201)
  %203 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %27, 0
  %204 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %203, 0
  %205 = insertvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %204, { { ptr, i32, i32, i32 }, i252, i32 } %17, 1
  %206 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } undef }, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } %205, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 }, i252, i32 }, {} } } %206, ptr %11, align 16
  %207 = load { i128, [112 x i8] }, ptr %11, align 16
  %208 = extractvalue { ptr, ptr, i64 } %8, 1
  %209 = load i64, ptr %208, align 8
  %210 = icmp eq i64 %209, 0
  %211 = sub i64 %209, 1
  %212 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %211, ptr %212, align 8
  br i1 %210, label %213, label %183

213:                                              ; preds = %196
  %214 = insertvalue { i64, i64, { i128, [112 x i8] } } undef, i64 %18, 0
  %215 = insertvalue { i64, i64, { i128, [112 x i8] } } %214, i64 %202, 1
  %216 = insertvalue { i64, i64, { i128, [112 x i8] } } %215, { i128, [112 x i8] } %207, 2
  ret { i64, i64, { i128, [112 x i8] } } %216

217:                                              ; preds = %13
  %218 = phi { { ptr, i32, i32, i32 }, i252, i32 } [ %17, %13 ]
  call void @"drop$66"({ { ptr, i32, i32, i32 }, i252, i32 } %218)
  call void @"drop$214"({ { ptr, i32, i32, i32 } } %16)
  %219 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %220 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %219, 0
  %221 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %220, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %221, ptr %10, align 8
  %222 = load { i128, [112 x i8] }, ptr %10, align 16
  %223 = extractvalue { ptr, ptr, i64 } %8, 1
  %224 = load i64, ptr %223, align 8
  %225 = icmp eq i64 %224, 0
  %226 = sub i64 %224, 1
  %227 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %226, ptr %227, align 8
  br i1 %225, label %228, label %183

228:                                              ; preds = %217
  %229 = insertvalue { i64, i64, { i128, [112 x i8] } } undef, i64 %18, 0
  %230 = insertvalue { i64, i64, { i128, [112 x i8] } } %229, i64 %15, 1
  %231 = insertvalue { i64, i64, { i128, [112 x i8] } } %230, { i128, [112 x i8] } %222, 2
  ret { i64, i64, { i128, [112 x i8] } } %231
}

define private { i64, i64, { i128, [112 x i8] } } @f105(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { { ptr, i32, i32, i32 }, i252, i32 } %3) {
  %5 = call fastcc { i64, i64, { i128, [112 x i8] } } @"impl$f105"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { { ptr, i32, i32, i32 }, i252, i32 } %3)
  %6 = extractvalue { i64, i64, { i128, [112 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i128, [112 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i128, [112 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i128, [112 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i128, [112 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i128, [112 x i8] } } %10, { i128, [112 x i8] } %8, 2
  ret { i64, i64, { i128, [112 x i8] } } %11
}

define void @_mlir_ciface_f105(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4) {
  %6 = call { i64, i64, { i128, [112 x i8] } } @f105(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { { ptr, i32, i32, i32 }, i252, i32 } %4)
  store { i64, i64, { i128, [112 x i8] } } %6, ptr %0, align 16
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f106"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 8570164797203042506019982424912417129509686)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f106() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f106"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f106(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f106()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f107"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 573087285299505011920718992710461799)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f107() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f107"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f107(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f107()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f108"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = alloca i64, i64 1, align 8
  %7 = insertvalue { ptr, ptr, i64 } undef, ptr %6, 0
  %8 = insertvalue { ptr, ptr, i64 } %7, ptr %6, 1
  %9 = insertvalue { ptr, ptr, i64 } %8, i64 0, 2
  %10 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 0, ptr %10, align 8
  %11 = alloca { i64, [56 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [56 x i8] }, i64 1, align 8
  %14 = alloca { i32, [8 x i8] }, i64 1, align 4
  %15 = alloca { i16, [8 x i8] }, i64 1, align 2
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [56 x i8] }, i64 1, align 8
  br label %18

18:                                               ; preds = %176, %5
  %19 = phi i64 [ %116, %176 ], [ %0, %5 ]
  %20 = phi i64 [ %133, %176 ], [ %1, %5 ]
  %21 = phi { { ptr, i32, i32, i32 } } [ %117, %176 ], [ %2, %5 ]
  %22 = phi { ptr, i32, i32, i32 } [ %185, %176 ], [ %3, %5 ]
  %23 = phi i252 [ %192, %176 ], [ %4, %5 ]
  %24 = add i64 %19, 1
  %25 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %26 = call ptr %25()
  %27 = load i64, ptr %26, align 8
  %28 = mul i64 %27, 17060
  %29 = icmp uge i64 %20, %28
  %30 = call i64 @llvm.usub.sat.i64(i64 %20, i64 %28)
  br i1 %29, label %31, label %254

31:                                               ; preds = %18
  %32 = phi i252 [ %23, %18 ]
  %33 = icmp eq i252 %32, 0
  br i1 %33, label %34, label %56

34:                                               ; preds = %31
  %35 = phi i64 [ %30, %31 ]
  %36 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %37 = call ptr %36()
  %38 = load i64, ptr %37, align 8
  %39 = mul i64 %38, 17960
  %40 = call i64 @llvm.uadd.sat.i64(i64 %35, i64 %39)
  %41 = insertvalue { i1, { ptr, i32, i32, i32 } } { i1 false, { ptr, i32, i32, i32 } undef }, { ptr, i32, i32, i32 } %22, 1
  store { i1, { ptr, i32, i32, i32 } } %41, ptr %16, align 8
  %42 = load { i64, [24 x i8] }, ptr %16, align 8
  %43 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %21, 0
  %44 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %43, { i64, [24 x i8] } %42, 1
  %45 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %44, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %45, ptr %17, align 8
  %46 = load { i64, [56 x i8] }, ptr %17, align 8
  %47 = extractvalue { ptr, ptr, i64 } %9, 1
  %48 = load i64, ptr %47, align 8
  %49 = icmp eq i64 %48, 0
  %50 = sub i64 %48, 1
  %51 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %50, ptr %51, align 8
  br i1 %49, label %52, label %203

52:                                               ; preds = %34
  %53 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %24, 0
  %54 = insertvalue { i64, i64, { i64, [56 x i8] } } %53, i64 %40, 1
  %55 = insertvalue { i64, i64, { i64, [56 x i8] } } %54, { i64, [56 x i8] } %46, 2
  ret { i64, i64, { i64, [56 x i8] } } %55

56:                                               ; preds = %31
  %57 = phi { { ptr, i32, i32, i32 } } [ %21, %31 ]
  %58 = extractvalue { { ptr, i32, i32, i32 } } %57, 0
  %59 = extractvalue { ptr, i32, i32, i32 } %58, 1
  %60 = extractvalue { ptr, i32, i32, i32 } %58, 2
  %61 = sub i32 %60, %59
  %62 = icmp uge i32 %61, 1
  br i1 %62, label %63, label %228

63:                                               ; preds = %56
  %64 = extractvalue { ptr, i32, i32, i32 } %58, 0
  %65 = load ptr, ptr %64, align 8
  %66 = zext i32 %59 to i64
  %67 = mul i64 %66, 32
  %68 = getelementptr inbounds i8, ptr %65, i64 %67
  %69 = add i32 %59, 1
  %70 = insertvalue { ptr, i32, i32, i32 } %58, i32 %69, 1
  %71 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %71, ptr %68, i64 32, i1 false)
  %72 = load i252, ptr %71, align 16
  call void @free(ptr %71)
  %73 = icmp eq i252 %72, 0
  br i1 %73, label %74, label %79

74:                                               ; preds = %63
  %75 = phi i64 [ %30, %63 ]
  %76 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %77 = call ptr %76()
  %78 = call i64 @llvm.uadd.sat.i64(i64 %75, i64 0)
  br label %97

79:                                               ; preds = %63
  %80 = phi i252 [ %72, %63 ]
  %81 = phi i252 [ 1, %63 ]
  %82 = zext i252 %80 to i256
  %83 = zext i252 %81 to i256
  %84 = sub i256 %82, %83
  %85 = add i256 %84, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %86 = icmp ult i256 %82, %83
  %87 = select i1 %86, i256 %85, i256 %84
  %88 = trunc i256 %87 to i252
  %89 = icmp eq i252 %88, 0
  br i1 %89, label %90, label %221

90:                                               ; preds = %79
  %91 = phi i64 [ %30, %79 ]
  %92 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %93 = call ptr %92()
  %94 = load i64, ptr %93, align 8
  %95 = mul i64 %94, 10
  %96 = call i64 @llvm.uadd.sat.i64(i64 %91, i64 %95)
  br label %97

97:                                               ; preds = %74, %90
  %98 = phi { ptr, i32, i32, i32 } [ %22, %90 ], [ %22, %74 ]
  %99 = phi i252 [ %32, %90 ], [ %32, %74 ]
  %100 = phi i64 [ %24, %90 ], [ %24, %74 ]
  %101 = phi { ptr, i32, i32, i32 } [ %70, %90 ], [ %70, %74 ]
  %102 = phi i64 [ %96, %90 ], [ %78, %74 ]
  %103 = phi { i1, [0 x i8] } [ { i1 true, [0 x i8] undef }, %90 ], [ { i1 false, [0 x i8] undef }, %74 ]
  %104 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %101, 0
  %105 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f124"(i64 %100, { { ptr, i32, i32, i32 } } %104)
  %106 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %105, 0
  %107 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %105, 1
  %108 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %105, 2
  store { i32, [8 x i8] } %108, ptr %14, align 4
  %109 = load i1, ptr %14, align 1
  switch i1 %109, label %110 [
    i1 false, label %112
    i1 true, label %120
  ]

110:                                              ; preds = %97
  br i1 false, label %111, label %269

111:                                              ; preds = %110
  unreachable

112:                                              ; preds = %97
  %113 = load { i1, { i32, [4 x i8] } }, ptr %14, align 4
  %114 = extractvalue { i1, { i32, [4 x i8] } } %113, 1
  %115 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } @"impl$f125"(i64 %106, { { ptr, i32, i32, i32 } } %107)
  %116 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %115, 0
  %117 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %115, 1
  %118 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %115, 2
  store { i16, [8 x i8] } %118, ptr %15, align 2
  %119 = load i1, ptr %15, align 1
  switch i1 %119, label %126 [
    i1 false, label %128
    i1 true, label %197
  ]

120:                                              ; preds = %97
  call void @"drop$37"({ ptr, i32, i32, i32 } %98)
  %121 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %122 = call ptr %121()
  %123 = load i64, ptr %122, align 8
  %124 = mul i64 %123, 12440
  %125 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 %124)
  br label %216

126:                                              ; preds = %112
  br i1 false, label %127, label %270

127:                                              ; preds = %126
  unreachable

128:                                              ; preds = %112
  %129 = load { i1, { i16, [6 x i8] } }, ptr %15, align 2
  %130 = extractvalue { i1, { i16, [6 x i8] } } %129, 1
  %131 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %132 = call ptr %131()
  %133 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 0)
  %134 = insertvalue { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } undef, { i1, [0 x i8] } %103, 0
  %135 = insertvalue { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %134, { i32, [4 x i8] } %114, 1
  %136 = insertvalue { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %135, { i16, [6 x i8] } %130, 2
  %137 = extractvalue { ptr, i32, i32, i32 } %98, 3
  %138 = icmp eq i32 %137, 0
  br i1 %138, label %139, label %153

139:                                              ; preds = %128
  %140 = shl i32 %137, 1
  %141 = call i32 @llvm.umin.i32(i32 %140, i32 1024)
  %142 = add i32 %141, %137
  %143 = call i32 @llvm.umax.i32(i32 %142, i32 8)
  %144 = zext i32 %143 to i64
  %145 = mul i64 %144, 20
  %146 = add i64 %145, 8
  %147 = call ptr @realloc(ptr null, i64 %146)
  store i32 1, ptr %147, align 4
  %148 = getelementptr inbounds i8, ptr %147, i32 4
  store i32 0, ptr %148, align 4
  %149 = getelementptr inbounds i8, ptr %147, i32 8
  %150 = call ptr @realloc(ptr null, i64 8)
  store ptr %149, ptr %150, align 8
  %151 = insertvalue { ptr, i32, i32, i32 } %98, ptr %150, 0
  %152 = insertvalue { ptr, i32, i32, i32 } %151, i32 %143, 3
  br label %174

153:                                              ; preds = %128
  %154 = extractvalue { ptr, i32, i32, i32 } %98, 2
  %155 = icmp ult i32 %154, %137
  br i1 %155, label %156, label %157

156:                                              ; preds = %153
  br label %171

157:                                              ; preds = %153
  %158 = shl i32 %137, 1
  %159 = call i32 @llvm.umin.i32(i32 %158, i32 1024)
  %160 = add i32 %159, %137
  %161 = call i32 @llvm.umax.i32(i32 %160, i32 8)
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 20
  %164 = add i64 %163, 8
  %165 = extractvalue { ptr, i32, i32, i32 } %98, 0
  %166 = load ptr, ptr %165, align 8
  %167 = getelementptr inbounds i8, ptr %166, i32 -8
  %168 = call ptr @realloc(ptr %167, i64 %164)
  %169 = getelementptr inbounds i8, ptr %168, i32 8
  store ptr %169, ptr %165, align 8
  %170 = insertvalue { ptr, i32, i32, i32 } %98, i32 %161, 3
  br label %171

171:                                              ; preds = %156, %157
  %172 = phi { ptr, i32, i32, i32 } [ %170, %157 ], [ %98, %156 ]
  br label %173

173:                                              ; preds = %171
  br label %174

174:                                              ; preds = %139, %173
  %175 = phi { ptr, i32, i32, i32 } [ %172, %173 ], [ %152, %139 ]
  br label %176

176:                                              ; preds = %174
  %177 = extractvalue { ptr, i32, i32, i32 } %175, 0
  %178 = load ptr, ptr %177, align 8
  %179 = extractvalue { ptr, i32, i32, i32 } %175, 2
  %180 = zext i32 %179 to i64
  %181 = mul i64 %180, 20
  %182 = getelementptr inbounds i8, ptr %178, i64 %181
  store { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %136, ptr %182, align 4
  %183 = extractvalue { ptr, i32, i32, i32 } %175, 2
  %184 = add i32 %183, 1
  %185 = insertvalue { ptr, i32, i32, i32 } %175, i32 %184, 2
  %186 = getelementptr inbounds i8, ptr %178, i32 -4
  store i32 %184, ptr %186, align 4
  %187 = zext i252 %99 to i256
  %188 = sub i256 %187, 1
  %189 = add i256 %187, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %190 = icmp ult i256 %187, 1
  %191 = select i1 %190, i256 %189, i256 %188
  %192 = trunc i256 %191 to i252
  %193 = extractvalue { ptr, ptr, i64 } %9, 1
  %194 = load i64, ptr %193, align 8
  %195 = add i64 %194, 1
  %196 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %195, ptr %196, align 8
  br label %18

197:                                              ; preds = %112
  call void @"drop$37"({ ptr, i32, i32, i32 } %98)
  %198 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %199 = call ptr %198()
  %200 = load i64, ptr %199, align 8
  %201 = mul i64 %200, 2870
  %202 = call i64 @llvm.uadd.sat.i64(i64 %102, i64 %201)
  br label %216

203:                                              ; preds = %203, %34, %235, %254
  %204 = phi i64 [ %24, %254 ], [ %236, %235 ], [ %204, %203 ], [ %24, %34 ]
  %205 = phi i64 [ %20, %254 ], [ %237, %235 ], [ %205, %203 ], [ %40, %34 ]
  %206 = phi { i64, [56 x i8] } [ %259, %254 ], [ %244, %235 ], [ %206, %203 ], [ %46, %34 ]
  %207 = extractvalue { ptr, ptr, i64 } %9, 1
  %208 = load i64, ptr %207, align 8
  %209 = icmp eq i64 %208, 0
  %210 = sub i64 %208, 1
  %211 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %210, ptr %211, align 8
  br i1 %209, label %212, label %203

212:                                              ; preds = %203
  %213 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %204, 0
  %214 = insertvalue { i64, i64, { i64, [56 x i8] } } %213, i64 %205, 1
  %215 = insertvalue { i64, i64, { i64, [56 x i8] } } %214, { i64, [56 x i8] } %206, 2
  ret { i64, i64, { i64, [56 x i8] } } %215

216:                                              ; preds = %197, %120
  %217 = phi i64 [ %116, %197 ], [ %106, %120 ]
  %218 = phi i64 [ %202, %197 ], [ %125, %120 ]
  %219 = phi { { ptr, i32, i32, i32 } } [ %117, %197 ], [ %107, %120 ]
  %220 = extractvalue { { ptr, i32, i32, i32 } } %219, 0
  br label %235

221:                                              ; preds = %79
  %222 = phi { ptr, i32, i32, i32 } [ %22, %79 ]
  call void @"drop$37"({ ptr, i32, i32, i32 } %222)
  %223 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %224 = call ptr %223()
  %225 = load i64, ptr %224, align 8
  %226 = mul i64 %225, 16560
  %227 = call i64 @llvm.uadd.sat.i64(i64 %30, i64 %226)
  br label %235

228:                                              ; preds = %56
  %229 = phi { ptr, i32, i32, i32 } [ %22, %56 ]
  call void @"drop$37"({ ptr, i32, i32, i32 } %229)
  %230 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %231 = call ptr %230()
  %232 = load i64, ptr %231, align 8
  %233 = mul i64 %232, 16840
  %234 = call i64 @llvm.uadd.sat.i64(i64 %30, i64 %233)
  br label %235

235:                                              ; preds = %216, %221, %228
  %236 = phi i64 [ %24, %228 ], [ %24, %221 ], [ %217, %216 ]
  %237 = phi i64 [ %234, %228 ], [ %227, %221 ], [ %218, %216 ]
  %238 = phi { ptr, i32, i32, i32 } [ %58, %228 ], [ %70, %221 ], [ %220, %216 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %12, align 1
  %239 = load { i64, [24 x i8] }, ptr %12, align 8
  %240 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %238, 0
  %241 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef, { { ptr, i32, i32, i32 } } %240, 0
  %242 = insertvalue { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %241, { i64, [24 x i8] } %239, 1
  %243 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } { i1 false, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } undef }, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } %242, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { i64, [24 x i8] } } } %243, ptr %13, align 8
  %244 = load { i64, [56 x i8] }, ptr %13, align 8
  %245 = extractvalue { ptr, ptr, i64 } %9, 1
  %246 = load i64, ptr %245, align 8
  %247 = icmp eq i64 %246, 0
  %248 = sub i64 %246, 1
  %249 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %248, ptr %249, align 8
  br i1 %247, label %250, label %203

250:                                              ; preds = %235
  %251 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %236, 0
  %252 = insertvalue { i64, i64, { i64, [56 x i8] } } %251, i64 %237, 1
  %253 = insertvalue { i64, i64, { i64, [56 x i8] } } %252, { i64, [56 x i8] } %244, 2
  ret { i64, i64, { i64, [56 x i8] } } %253

254:                                              ; preds = %18
  %255 = phi { ptr, i32, i32, i32 } [ %22, %18 ]
  call void @"drop$37"({ ptr, i32, i32, i32 } %255)
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %21)
  %256 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %257 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %256, 0
  %258 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %257, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %258, ptr %11, align 8
  %259 = load { i64, [56 x i8] }, ptr %11, align 8
  %260 = extractvalue { ptr, ptr, i64 } %9, 1
  %261 = load i64, ptr %260, align 8
  %262 = icmp eq i64 %261, 0
  %263 = sub i64 %261, 1
  %264 = extractvalue { ptr, ptr, i64 } %9, 1
  store i64 %263, ptr %264, align 8
  br i1 %262, label %265, label %203

265:                                              ; preds = %254
  %266 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %24, 0
  %267 = insertvalue { i64, i64, { i64, [56 x i8] } } %266, i64 %20, 1
  %268 = insertvalue { i64, i64, { i64, [56 x i8] } } %267, { i64, [56 x i8] } %259, 2
  ret { i64, i64, { i64, [56 x i8] } } %268

269:                                              ; preds = %110
  call void @puts(ptr @assert_msg_168)
  call void @abort()
  unreachable

270:                                              ; preds = %126
  call void @puts(ptr @assert_msg_169)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [56 x i8] } } @f108(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4) {
  %6 = call fastcc { i64, i64, { i64, [56 x i8] } } @"impl$f108"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3, i252 %4)
  %7 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, { i64, [56 x i8] } } %6, 2
  %10 = insertvalue { i64, i64, { i64, [56 x i8] } } undef, i64 %7, 0
  %11 = insertvalue { i64, i64, { i64, [56 x i8] } } %10, i64 %8, 1
  %12 = insertvalue { i64, i64, { i64, [56 x i8] } } %11, { i64, [56 x i8] } %9, 2
  ret { i64, i64, { i64, [56 x i8] } } %12
}

define void @_mlir_ciface_f108(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5) {
  %7 = call { i64, i64, { i64, [56 x i8] } } @f108(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4, i252 %5)
  store { i64, i64, { i64, [56 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f109"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 608642104203229548495787928534675319)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f109() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f109"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f109(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f109()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f110"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 139861644157973526622261446548040478583)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f110() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f110"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f110(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f110()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f111"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 546334547492084087938116166309670775)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f111() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f111"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f111(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f111()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f112"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 155775200859838811096160292336445452151)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f112() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f112"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f112(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f112()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f113"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 35795063018498839831738724970515344945015)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f113() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f113"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f113(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f113()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f114"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 139824464916011093092299301806806953847)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f114() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f114"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f114(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f114()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { ptr, i32, i32, i32 } } @"impl$f115"(ptr %0, { ptr, i32, i32, i32 } %1) {
  %3 = alloca { i16, [6 x i8] }, i64 1, align 2
  %4 = load { i16, [6 x i8] }, ptr %0, align 2
  store { i16, [6 x i8] } %4, ptr %3, align 2
  %5 = load i6, ptr %3, align 1
  switch i6 %5, label %6 [
    i6 0, label %5171
    i6 1, label %8
    i6 2, label %117
    i6 3, label %221
    i6 4, label %325
    i6 5, label %434
    i6 6, label %543
    i6 7, label %652
    i6 8, label %761
    i6 9, label %870
    i6 10, label %979
    i6 11, label %1088
    i6 12, label %1197
    i6 13, label %1306
    i6 14, label %1415
    i6 15, label %1524
    i6 16, label %1802
    i6 17, label %2080
    i6 18, label %2302
    i6 19, label %2411
    i6 20, label %2520
    i6 21, label %2629
    i6 22, label %2738
    i6 23, label %2847
    i6 24, label %2956
    i6 25, label %3065
    i6 26, label %3174
    i6 27, label %3283
    i6 28, label %3392
    i6 29, label %3501
    i6 30, label %3779
    i6 31, label %4057
    i6 -32, label %4279
    i6 -31, label %4436
    i6 -30, label %4540
    i6 -29, label %4644
    i6 -28, label %4748
    i6 -27, label %4857
    i6 -26, label %4961
    i6 -25, label %5065
  ]

6:                                                ; preds = %2
  br i1 false, label %7, label %5386

7:                                                ; preds = %6
  unreachable

8:                                                ; preds = %2
  %9 = load { i6, i16 }, ptr %3, align 2
  %10 = extractvalue { i6, i16 } %9, 1
  %11 = icmp slt i16 %10, 0
  %12 = zext i16 %10 to i252
  %13 = call i16 @llvm.abs.i16(i16 %10, i1 false)
  %14 = zext i16 %13 to i252
  %15 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %14
  %16 = select i1 %11, i252 %15, i252 %12
  %17 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %33

19:                                               ; preds = %8
  %20 = shl i32 %17, 1
  %21 = call i32 @llvm.umin.i32(i32 %20, i32 1024)
  %22 = add i32 %21, %17
  %23 = call i32 @llvm.umax.i32(i32 %22, i32 8)
  %24 = zext i32 %23 to i64
  %25 = mul i64 %24, 32
  %26 = add i64 %25, 16
  %27 = call ptr @realloc(ptr null, i64 %26)
  store i32 1, ptr %27, align 4
  %28 = getelementptr inbounds i8, ptr %27, i32 4
  store i32 0, ptr %28, align 4
  %29 = getelementptr inbounds i8, ptr %27, i32 16
  %30 = call ptr @realloc(ptr null, i64 8)
  store ptr %29, ptr %30, align 8
  %31 = insertvalue { ptr, i32, i32, i32 } %1, ptr %30, 0
  %32 = insertvalue { ptr, i32, i32, i32 } %31, i32 %23, 3
  br label %54

33:                                               ; preds = %8
  %34 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %35 = icmp ult i32 %34, %17
  br i1 %35, label %36, label %37

36:                                               ; preds = %33
  br label %51

37:                                               ; preds = %33
  %38 = shl i32 %17, 1
  %39 = call i32 @llvm.umin.i32(i32 %38, i32 1024)
  %40 = add i32 %39, %17
  %41 = call i32 @llvm.umax.i32(i32 %40, i32 8)
  %42 = zext i32 %41 to i64
  %43 = mul i64 %42, 32
  %44 = add i64 %43, 16
  %45 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %46 = load ptr, ptr %45, align 8
  %47 = getelementptr inbounds i8, ptr %46, i32 -16
  %48 = call ptr @realloc(ptr %47, i64 %44)
  %49 = getelementptr inbounds i8, ptr %48, i32 16
  store ptr %49, ptr %45, align 8
  %50 = insertvalue { ptr, i32, i32, i32 } %1, i32 %41, 3
  br label %51

51:                                               ; preds = %36, %37
  %52 = phi { ptr, i32, i32, i32 } [ %50, %37 ], [ %1, %36 ]
  br label %53

53:                                               ; preds = %51
  br label %54

54:                                               ; preds = %19, %53
  %55 = phi { ptr, i32, i32, i32 } [ %52, %53 ], [ %32, %19 ]
  br label %56

56:                                               ; preds = %54
  %57 = extractvalue { ptr, i32, i32, i32 } %55, 0
  %58 = load ptr, ptr %57, align 8
  %59 = extractvalue { ptr, i32, i32, i32 } %55, 2
  %60 = zext i32 %59 to i64
  %61 = mul i64 %60, 32
  %62 = getelementptr inbounds i8, ptr %58, i64 %61
  store i252 1, ptr %62, align 16
  %63 = extractvalue { ptr, i32, i32, i32 } %55, 2
  %64 = add i32 %63, 1
  %65 = insertvalue { ptr, i32, i32, i32 } %55, i32 %64, 2
  %66 = getelementptr inbounds i8, ptr %58, i32 -12
  store i32 %64, ptr %66, align 4
  %67 = extractvalue { ptr, i32, i32, i32 } %55, 3
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %69, label %83

69:                                               ; preds = %56
  %70 = shl i32 %67, 1
  %71 = call i32 @llvm.umin.i32(i32 %70, i32 1024)
  %72 = add i32 %71, %67
  %73 = call i32 @llvm.umax.i32(i32 %72, i32 8)
  %74 = zext i32 %73 to i64
  %75 = mul i64 %74, 32
  %76 = add i64 %75, 16
  %77 = call ptr @realloc(ptr null, i64 %76)
  store i32 1, ptr %77, align 4
  %78 = getelementptr inbounds i8, ptr %77, i32 4
  store i32 0, ptr %78, align 4
  %79 = getelementptr inbounds i8, ptr %77, i32 16
  %80 = call ptr @realloc(ptr null, i64 8)
  store ptr %79, ptr %80, align 8
  %81 = insertvalue { ptr, i32, i32, i32 } %65, ptr %80, 0
  %82 = insertvalue { ptr, i32, i32, i32 } %81, i32 %73, 3
  br label %103

83:                                               ; preds = %56
  %84 = icmp ult i32 %64, %67
  br i1 %84, label %85, label %86

85:                                               ; preds = %83
  br label %100

86:                                               ; preds = %83
  %87 = shl i32 %67, 1
  %88 = call i32 @llvm.umin.i32(i32 %87, i32 1024)
  %89 = add i32 %88, %67
  %90 = call i32 @llvm.umax.i32(i32 %89, i32 8)
  %91 = zext i32 %90 to i64
  %92 = mul i64 %91, 32
  %93 = add i64 %92, 16
  %94 = extractvalue { ptr, i32, i32, i32 } %55, 0
  %95 = load ptr, ptr %94, align 8
  %96 = getelementptr inbounds i8, ptr %95, i32 -16
  %97 = call ptr @realloc(ptr %96, i64 %93)
  %98 = getelementptr inbounds i8, ptr %97, i32 16
  store ptr %98, ptr %94, align 8
  %99 = insertvalue { ptr, i32, i32, i32 } %65, i32 %90, 3
  br label %100

100:                                              ; preds = %85, %86
  %101 = phi { ptr, i32, i32, i32 } [ %99, %86 ], [ %65, %85 ]
  br label %102

102:                                              ; preds = %100
  br label %103

103:                                              ; preds = %69, %102
  %104 = phi { ptr, i32, i32, i32 } [ %101, %102 ], [ %82, %69 ]
  br label %105

105:                                              ; preds = %103
  %106 = extractvalue { ptr, i32, i32, i32 } %104, 0
  %107 = load ptr, ptr %106, align 8
  %108 = extractvalue { ptr, i32, i32, i32 } %104, 2
  %109 = zext i32 %108 to i64
  %110 = mul i64 %109, 32
  %111 = getelementptr inbounds i8, ptr %107, i64 %110
  store i252 %16, ptr %111, align 16
  %112 = extractvalue { ptr, i32, i32, i32 } %104, 2
  %113 = add i32 %112, 1
  %114 = insertvalue { ptr, i32, i32, i32 } %104, i32 %113, 2
  %115 = getelementptr inbounds i8, ptr %107, i32 -12
  store i32 %113, ptr %115, align 4
  %116 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %114, 0
  ret { { ptr, i32, i32, i32 } } %116

117:                                              ; preds = %2
  %118 = load { i6, i8 }, ptr %3, align 1
  %119 = extractvalue { i6, i8 } %118, 1
  %120 = zext i8 %119 to i252
  %121 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %122 = icmp eq i32 %121, 0
  br i1 %122, label %123, label %137

123:                                              ; preds = %117
  %124 = shl i32 %121, 1
  %125 = call i32 @llvm.umin.i32(i32 %124, i32 1024)
  %126 = add i32 %125, %121
  %127 = call i32 @llvm.umax.i32(i32 %126, i32 8)
  %128 = zext i32 %127 to i64
  %129 = mul i64 %128, 32
  %130 = add i64 %129, 16
  %131 = call ptr @realloc(ptr null, i64 %130)
  store i32 1, ptr %131, align 4
  %132 = getelementptr inbounds i8, ptr %131, i32 4
  store i32 0, ptr %132, align 4
  %133 = getelementptr inbounds i8, ptr %131, i32 16
  %134 = call ptr @realloc(ptr null, i64 8)
  store ptr %133, ptr %134, align 8
  %135 = insertvalue { ptr, i32, i32, i32 } %1, ptr %134, 0
  %136 = insertvalue { ptr, i32, i32, i32 } %135, i32 %127, 3
  br label %158

137:                                              ; preds = %117
  %138 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %139 = icmp ult i32 %138, %121
  br i1 %139, label %140, label %141

140:                                              ; preds = %137
  br label %155

141:                                              ; preds = %137
  %142 = shl i32 %121, 1
  %143 = call i32 @llvm.umin.i32(i32 %142, i32 1024)
  %144 = add i32 %143, %121
  %145 = call i32 @llvm.umax.i32(i32 %144, i32 8)
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 32
  %148 = add i64 %147, 16
  %149 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %150 = load ptr, ptr %149, align 8
  %151 = getelementptr inbounds i8, ptr %150, i32 -16
  %152 = call ptr @realloc(ptr %151, i64 %148)
  %153 = getelementptr inbounds i8, ptr %152, i32 16
  store ptr %153, ptr %149, align 8
  %154 = insertvalue { ptr, i32, i32, i32 } %1, i32 %145, 3
  br label %155

155:                                              ; preds = %140, %141
  %156 = phi { ptr, i32, i32, i32 } [ %154, %141 ], [ %1, %140 ]
  br label %157

157:                                              ; preds = %155
  br label %158

158:                                              ; preds = %123, %157
  %159 = phi { ptr, i32, i32, i32 } [ %156, %157 ], [ %136, %123 ]
  br label %160

160:                                              ; preds = %158
  %161 = extractvalue { ptr, i32, i32, i32 } %159, 0
  %162 = load ptr, ptr %161, align 8
  %163 = extractvalue { ptr, i32, i32, i32 } %159, 2
  %164 = zext i32 %163 to i64
  %165 = mul i64 %164, 32
  %166 = getelementptr inbounds i8, ptr %162, i64 %165
  store i252 2, ptr %166, align 16
  %167 = extractvalue { ptr, i32, i32, i32 } %159, 2
  %168 = add i32 %167, 1
  %169 = insertvalue { ptr, i32, i32, i32 } %159, i32 %168, 2
  %170 = getelementptr inbounds i8, ptr %162, i32 -12
  store i32 %168, ptr %170, align 4
  %171 = extractvalue { ptr, i32, i32, i32 } %159, 3
  %172 = icmp eq i32 %171, 0
  br i1 %172, label %173, label %187

173:                                              ; preds = %160
  %174 = shl i32 %171, 1
  %175 = call i32 @llvm.umin.i32(i32 %174, i32 1024)
  %176 = add i32 %175, %171
  %177 = call i32 @llvm.umax.i32(i32 %176, i32 8)
  %178 = zext i32 %177 to i64
  %179 = mul i64 %178, 32
  %180 = add i64 %179, 16
  %181 = call ptr @realloc(ptr null, i64 %180)
  store i32 1, ptr %181, align 4
  %182 = getelementptr inbounds i8, ptr %181, i32 4
  store i32 0, ptr %182, align 4
  %183 = getelementptr inbounds i8, ptr %181, i32 16
  %184 = call ptr @realloc(ptr null, i64 8)
  store ptr %183, ptr %184, align 8
  %185 = insertvalue { ptr, i32, i32, i32 } %169, ptr %184, 0
  %186 = insertvalue { ptr, i32, i32, i32 } %185, i32 %177, 3
  br label %207

187:                                              ; preds = %160
  %188 = icmp ult i32 %168, %171
  br i1 %188, label %189, label %190

189:                                              ; preds = %187
  br label %204

190:                                              ; preds = %187
  %191 = shl i32 %171, 1
  %192 = call i32 @llvm.umin.i32(i32 %191, i32 1024)
  %193 = add i32 %192, %171
  %194 = call i32 @llvm.umax.i32(i32 %193, i32 8)
  %195 = zext i32 %194 to i64
  %196 = mul i64 %195, 32
  %197 = add i64 %196, 16
  %198 = extractvalue { ptr, i32, i32, i32 } %159, 0
  %199 = load ptr, ptr %198, align 8
  %200 = getelementptr inbounds i8, ptr %199, i32 -16
  %201 = call ptr @realloc(ptr %200, i64 %197)
  %202 = getelementptr inbounds i8, ptr %201, i32 16
  store ptr %202, ptr %198, align 8
  %203 = insertvalue { ptr, i32, i32, i32 } %169, i32 %194, 3
  br label %204

204:                                              ; preds = %189, %190
  %205 = phi { ptr, i32, i32, i32 } [ %203, %190 ], [ %169, %189 ]
  br label %206

206:                                              ; preds = %204
  br label %207

207:                                              ; preds = %173, %206
  %208 = phi { ptr, i32, i32, i32 } [ %205, %206 ], [ %186, %173 ]
  br label %209

209:                                              ; preds = %207
  %210 = extractvalue { ptr, i32, i32, i32 } %208, 0
  %211 = load ptr, ptr %210, align 8
  %212 = extractvalue { ptr, i32, i32, i32 } %208, 2
  %213 = zext i32 %212 to i64
  %214 = mul i64 %213, 32
  %215 = getelementptr inbounds i8, ptr %211, i64 %214
  store i252 %120, ptr %215, align 16
  %216 = extractvalue { ptr, i32, i32, i32 } %208, 2
  %217 = add i32 %216, 1
  %218 = insertvalue { ptr, i32, i32, i32 } %208, i32 %217, 2
  %219 = getelementptr inbounds i8, ptr %211, i32 -12
  store i32 %217, ptr %219, align 4
  %220 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %218, 0
  ret { { ptr, i32, i32, i32 } } %220

221:                                              ; preds = %2
  %222 = load { i6, i8 }, ptr %3, align 1
  %223 = extractvalue { i6, i8 } %222, 1
  %224 = zext i8 %223 to i252
  %225 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %226 = icmp eq i32 %225, 0
  br i1 %226, label %227, label %241

227:                                              ; preds = %221
  %228 = shl i32 %225, 1
  %229 = call i32 @llvm.umin.i32(i32 %228, i32 1024)
  %230 = add i32 %229, %225
  %231 = call i32 @llvm.umax.i32(i32 %230, i32 8)
  %232 = zext i32 %231 to i64
  %233 = mul i64 %232, 32
  %234 = add i64 %233, 16
  %235 = call ptr @realloc(ptr null, i64 %234)
  store i32 1, ptr %235, align 4
  %236 = getelementptr inbounds i8, ptr %235, i32 4
  store i32 0, ptr %236, align 4
  %237 = getelementptr inbounds i8, ptr %235, i32 16
  %238 = call ptr @realloc(ptr null, i64 8)
  store ptr %237, ptr %238, align 8
  %239 = insertvalue { ptr, i32, i32, i32 } %1, ptr %238, 0
  %240 = insertvalue { ptr, i32, i32, i32 } %239, i32 %231, 3
  br label %262

241:                                              ; preds = %221
  %242 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %243 = icmp ult i32 %242, %225
  br i1 %243, label %244, label %245

244:                                              ; preds = %241
  br label %259

245:                                              ; preds = %241
  %246 = shl i32 %225, 1
  %247 = call i32 @llvm.umin.i32(i32 %246, i32 1024)
  %248 = add i32 %247, %225
  %249 = call i32 @llvm.umax.i32(i32 %248, i32 8)
  %250 = zext i32 %249 to i64
  %251 = mul i64 %250, 32
  %252 = add i64 %251, 16
  %253 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %254 = load ptr, ptr %253, align 8
  %255 = getelementptr inbounds i8, ptr %254, i32 -16
  %256 = call ptr @realloc(ptr %255, i64 %252)
  %257 = getelementptr inbounds i8, ptr %256, i32 16
  store ptr %257, ptr %253, align 8
  %258 = insertvalue { ptr, i32, i32, i32 } %1, i32 %249, 3
  br label %259

259:                                              ; preds = %244, %245
  %260 = phi { ptr, i32, i32, i32 } [ %258, %245 ], [ %1, %244 ]
  br label %261

261:                                              ; preds = %259
  br label %262

262:                                              ; preds = %227, %261
  %263 = phi { ptr, i32, i32, i32 } [ %260, %261 ], [ %240, %227 ]
  br label %264

264:                                              ; preds = %262
  %265 = extractvalue { ptr, i32, i32, i32 } %263, 0
  %266 = load ptr, ptr %265, align 8
  %267 = extractvalue { ptr, i32, i32, i32 } %263, 2
  %268 = zext i32 %267 to i64
  %269 = mul i64 %268, 32
  %270 = getelementptr inbounds i8, ptr %266, i64 %269
  store i252 3, ptr %270, align 16
  %271 = extractvalue { ptr, i32, i32, i32 } %263, 2
  %272 = add i32 %271, 1
  %273 = insertvalue { ptr, i32, i32, i32 } %263, i32 %272, 2
  %274 = getelementptr inbounds i8, ptr %266, i32 -12
  store i32 %272, ptr %274, align 4
  %275 = extractvalue { ptr, i32, i32, i32 } %263, 3
  %276 = icmp eq i32 %275, 0
  br i1 %276, label %277, label %291

277:                                              ; preds = %264
  %278 = shl i32 %275, 1
  %279 = call i32 @llvm.umin.i32(i32 %278, i32 1024)
  %280 = add i32 %279, %275
  %281 = call i32 @llvm.umax.i32(i32 %280, i32 8)
  %282 = zext i32 %281 to i64
  %283 = mul i64 %282, 32
  %284 = add i64 %283, 16
  %285 = call ptr @realloc(ptr null, i64 %284)
  store i32 1, ptr %285, align 4
  %286 = getelementptr inbounds i8, ptr %285, i32 4
  store i32 0, ptr %286, align 4
  %287 = getelementptr inbounds i8, ptr %285, i32 16
  %288 = call ptr @realloc(ptr null, i64 8)
  store ptr %287, ptr %288, align 8
  %289 = insertvalue { ptr, i32, i32, i32 } %273, ptr %288, 0
  %290 = insertvalue { ptr, i32, i32, i32 } %289, i32 %281, 3
  br label %311

291:                                              ; preds = %264
  %292 = icmp ult i32 %272, %275
  br i1 %292, label %293, label %294

293:                                              ; preds = %291
  br label %308

294:                                              ; preds = %291
  %295 = shl i32 %275, 1
  %296 = call i32 @llvm.umin.i32(i32 %295, i32 1024)
  %297 = add i32 %296, %275
  %298 = call i32 @llvm.umax.i32(i32 %297, i32 8)
  %299 = zext i32 %298 to i64
  %300 = mul i64 %299, 32
  %301 = add i64 %300, 16
  %302 = extractvalue { ptr, i32, i32, i32 } %263, 0
  %303 = load ptr, ptr %302, align 8
  %304 = getelementptr inbounds i8, ptr %303, i32 -16
  %305 = call ptr @realloc(ptr %304, i64 %301)
  %306 = getelementptr inbounds i8, ptr %305, i32 16
  store ptr %306, ptr %302, align 8
  %307 = insertvalue { ptr, i32, i32, i32 } %273, i32 %298, 3
  br label %308

308:                                              ; preds = %293, %294
  %309 = phi { ptr, i32, i32, i32 } [ %307, %294 ], [ %273, %293 ]
  br label %310

310:                                              ; preds = %308
  br label %311

311:                                              ; preds = %277, %310
  %312 = phi { ptr, i32, i32, i32 } [ %309, %310 ], [ %290, %277 ]
  br label %313

313:                                              ; preds = %311
  %314 = extractvalue { ptr, i32, i32, i32 } %312, 0
  %315 = load ptr, ptr %314, align 8
  %316 = extractvalue { ptr, i32, i32, i32 } %312, 2
  %317 = zext i32 %316 to i64
  %318 = mul i64 %317, 32
  %319 = getelementptr inbounds i8, ptr %315, i64 %318
  store i252 %224, ptr %319, align 16
  %320 = extractvalue { ptr, i32, i32, i32 } %312, 2
  %321 = add i32 %320, 1
  %322 = insertvalue { ptr, i32, i32, i32 } %312, i32 %321, 2
  %323 = getelementptr inbounds i8, ptr %315, i32 -12
  store i32 %321, ptr %323, align 4
  %324 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %322, 0
  ret { { ptr, i32, i32, i32 } } %324

325:                                              ; preds = %2
  %326 = load { i6, i8 }, ptr %3, align 1
  %327 = extractvalue { i6, i8 } %326, 1
  %328 = icmp slt i8 %327, 0
  %329 = zext i8 %327 to i252
  %330 = call i8 @llvm.abs.i8(i8 %327, i1 false)
  %331 = zext i8 %330 to i252
  %332 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %331
  %333 = select i1 %328, i252 %332, i252 %329
  %334 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %335 = icmp eq i32 %334, 0
  br i1 %335, label %336, label %350

336:                                              ; preds = %325
  %337 = shl i32 %334, 1
  %338 = call i32 @llvm.umin.i32(i32 %337, i32 1024)
  %339 = add i32 %338, %334
  %340 = call i32 @llvm.umax.i32(i32 %339, i32 8)
  %341 = zext i32 %340 to i64
  %342 = mul i64 %341, 32
  %343 = add i64 %342, 16
  %344 = call ptr @realloc(ptr null, i64 %343)
  store i32 1, ptr %344, align 4
  %345 = getelementptr inbounds i8, ptr %344, i32 4
  store i32 0, ptr %345, align 4
  %346 = getelementptr inbounds i8, ptr %344, i32 16
  %347 = call ptr @realloc(ptr null, i64 8)
  store ptr %346, ptr %347, align 8
  %348 = insertvalue { ptr, i32, i32, i32 } %1, ptr %347, 0
  %349 = insertvalue { ptr, i32, i32, i32 } %348, i32 %340, 3
  br label %371

350:                                              ; preds = %325
  %351 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %352 = icmp ult i32 %351, %334
  br i1 %352, label %353, label %354

353:                                              ; preds = %350
  br label %368

354:                                              ; preds = %350
  %355 = shl i32 %334, 1
  %356 = call i32 @llvm.umin.i32(i32 %355, i32 1024)
  %357 = add i32 %356, %334
  %358 = call i32 @llvm.umax.i32(i32 %357, i32 8)
  %359 = zext i32 %358 to i64
  %360 = mul i64 %359, 32
  %361 = add i64 %360, 16
  %362 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %363 = load ptr, ptr %362, align 8
  %364 = getelementptr inbounds i8, ptr %363, i32 -16
  %365 = call ptr @realloc(ptr %364, i64 %361)
  %366 = getelementptr inbounds i8, ptr %365, i32 16
  store ptr %366, ptr %362, align 8
  %367 = insertvalue { ptr, i32, i32, i32 } %1, i32 %358, 3
  br label %368

368:                                              ; preds = %353, %354
  %369 = phi { ptr, i32, i32, i32 } [ %367, %354 ], [ %1, %353 ]
  br label %370

370:                                              ; preds = %368
  br label %371

371:                                              ; preds = %336, %370
  %372 = phi { ptr, i32, i32, i32 } [ %369, %370 ], [ %349, %336 ]
  br label %373

373:                                              ; preds = %371
  %374 = extractvalue { ptr, i32, i32, i32 } %372, 0
  %375 = load ptr, ptr %374, align 8
  %376 = extractvalue { ptr, i32, i32, i32 } %372, 2
  %377 = zext i32 %376 to i64
  %378 = mul i64 %377, 32
  %379 = getelementptr inbounds i8, ptr %375, i64 %378
  store i252 4, ptr %379, align 16
  %380 = extractvalue { ptr, i32, i32, i32 } %372, 2
  %381 = add i32 %380, 1
  %382 = insertvalue { ptr, i32, i32, i32 } %372, i32 %381, 2
  %383 = getelementptr inbounds i8, ptr %375, i32 -12
  store i32 %381, ptr %383, align 4
  %384 = extractvalue { ptr, i32, i32, i32 } %372, 3
  %385 = icmp eq i32 %384, 0
  br i1 %385, label %386, label %400

386:                                              ; preds = %373
  %387 = shl i32 %384, 1
  %388 = call i32 @llvm.umin.i32(i32 %387, i32 1024)
  %389 = add i32 %388, %384
  %390 = call i32 @llvm.umax.i32(i32 %389, i32 8)
  %391 = zext i32 %390 to i64
  %392 = mul i64 %391, 32
  %393 = add i64 %392, 16
  %394 = call ptr @realloc(ptr null, i64 %393)
  store i32 1, ptr %394, align 4
  %395 = getelementptr inbounds i8, ptr %394, i32 4
  store i32 0, ptr %395, align 4
  %396 = getelementptr inbounds i8, ptr %394, i32 16
  %397 = call ptr @realloc(ptr null, i64 8)
  store ptr %396, ptr %397, align 8
  %398 = insertvalue { ptr, i32, i32, i32 } %382, ptr %397, 0
  %399 = insertvalue { ptr, i32, i32, i32 } %398, i32 %390, 3
  br label %420

400:                                              ; preds = %373
  %401 = icmp ult i32 %381, %384
  br i1 %401, label %402, label %403

402:                                              ; preds = %400
  br label %417

403:                                              ; preds = %400
  %404 = shl i32 %384, 1
  %405 = call i32 @llvm.umin.i32(i32 %404, i32 1024)
  %406 = add i32 %405, %384
  %407 = call i32 @llvm.umax.i32(i32 %406, i32 8)
  %408 = zext i32 %407 to i64
  %409 = mul i64 %408, 32
  %410 = add i64 %409, 16
  %411 = extractvalue { ptr, i32, i32, i32 } %372, 0
  %412 = load ptr, ptr %411, align 8
  %413 = getelementptr inbounds i8, ptr %412, i32 -16
  %414 = call ptr @realloc(ptr %413, i64 %410)
  %415 = getelementptr inbounds i8, ptr %414, i32 16
  store ptr %415, ptr %411, align 8
  %416 = insertvalue { ptr, i32, i32, i32 } %382, i32 %407, 3
  br label %417

417:                                              ; preds = %402, %403
  %418 = phi { ptr, i32, i32, i32 } [ %416, %403 ], [ %382, %402 ]
  br label %419

419:                                              ; preds = %417
  br label %420

420:                                              ; preds = %386, %419
  %421 = phi { ptr, i32, i32, i32 } [ %418, %419 ], [ %399, %386 ]
  br label %422

422:                                              ; preds = %420
  %423 = extractvalue { ptr, i32, i32, i32 } %421, 0
  %424 = load ptr, ptr %423, align 8
  %425 = extractvalue { ptr, i32, i32, i32 } %421, 2
  %426 = zext i32 %425 to i64
  %427 = mul i64 %426, 32
  %428 = getelementptr inbounds i8, ptr %424, i64 %427
  store i252 %333, ptr %428, align 16
  %429 = extractvalue { ptr, i32, i32, i32 } %421, 2
  %430 = add i32 %429, 1
  %431 = insertvalue { ptr, i32, i32, i32 } %421, i32 %430, 2
  %432 = getelementptr inbounds i8, ptr %424, i32 -12
  store i32 %430, ptr %432, align 4
  %433 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %431, 0
  ret { { ptr, i32, i32, i32 } } %433

434:                                              ; preds = %2
  %435 = load { i6, i8 }, ptr %3, align 1
  %436 = extractvalue { i6, i8 } %435, 1
  %437 = icmp slt i8 %436, 0
  %438 = zext i8 %436 to i252
  %439 = call i8 @llvm.abs.i8(i8 %436, i1 false)
  %440 = zext i8 %439 to i252
  %441 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %440
  %442 = select i1 %437, i252 %441, i252 %438
  %443 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %444 = icmp eq i32 %443, 0
  br i1 %444, label %445, label %459

445:                                              ; preds = %434
  %446 = shl i32 %443, 1
  %447 = call i32 @llvm.umin.i32(i32 %446, i32 1024)
  %448 = add i32 %447, %443
  %449 = call i32 @llvm.umax.i32(i32 %448, i32 8)
  %450 = zext i32 %449 to i64
  %451 = mul i64 %450, 32
  %452 = add i64 %451, 16
  %453 = call ptr @realloc(ptr null, i64 %452)
  store i32 1, ptr %453, align 4
  %454 = getelementptr inbounds i8, ptr %453, i32 4
  store i32 0, ptr %454, align 4
  %455 = getelementptr inbounds i8, ptr %453, i32 16
  %456 = call ptr @realloc(ptr null, i64 8)
  store ptr %455, ptr %456, align 8
  %457 = insertvalue { ptr, i32, i32, i32 } %1, ptr %456, 0
  %458 = insertvalue { ptr, i32, i32, i32 } %457, i32 %449, 3
  br label %480

459:                                              ; preds = %434
  %460 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %461 = icmp ult i32 %460, %443
  br i1 %461, label %462, label %463

462:                                              ; preds = %459
  br label %477

463:                                              ; preds = %459
  %464 = shl i32 %443, 1
  %465 = call i32 @llvm.umin.i32(i32 %464, i32 1024)
  %466 = add i32 %465, %443
  %467 = call i32 @llvm.umax.i32(i32 %466, i32 8)
  %468 = zext i32 %467 to i64
  %469 = mul i64 %468, 32
  %470 = add i64 %469, 16
  %471 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %472 = load ptr, ptr %471, align 8
  %473 = getelementptr inbounds i8, ptr %472, i32 -16
  %474 = call ptr @realloc(ptr %473, i64 %470)
  %475 = getelementptr inbounds i8, ptr %474, i32 16
  store ptr %475, ptr %471, align 8
  %476 = insertvalue { ptr, i32, i32, i32 } %1, i32 %467, 3
  br label %477

477:                                              ; preds = %462, %463
  %478 = phi { ptr, i32, i32, i32 } [ %476, %463 ], [ %1, %462 ]
  br label %479

479:                                              ; preds = %477
  br label %480

480:                                              ; preds = %445, %479
  %481 = phi { ptr, i32, i32, i32 } [ %478, %479 ], [ %458, %445 ]
  br label %482

482:                                              ; preds = %480
  %483 = extractvalue { ptr, i32, i32, i32 } %481, 0
  %484 = load ptr, ptr %483, align 8
  %485 = extractvalue { ptr, i32, i32, i32 } %481, 2
  %486 = zext i32 %485 to i64
  %487 = mul i64 %486, 32
  %488 = getelementptr inbounds i8, ptr %484, i64 %487
  store i252 5, ptr %488, align 16
  %489 = extractvalue { ptr, i32, i32, i32 } %481, 2
  %490 = add i32 %489, 1
  %491 = insertvalue { ptr, i32, i32, i32 } %481, i32 %490, 2
  %492 = getelementptr inbounds i8, ptr %484, i32 -12
  store i32 %490, ptr %492, align 4
  %493 = extractvalue { ptr, i32, i32, i32 } %481, 3
  %494 = icmp eq i32 %493, 0
  br i1 %494, label %495, label %509

495:                                              ; preds = %482
  %496 = shl i32 %493, 1
  %497 = call i32 @llvm.umin.i32(i32 %496, i32 1024)
  %498 = add i32 %497, %493
  %499 = call i32 @llvm.umax.i32(i32 %498, i32 8)
  %500 = zext i32 %499 to i64
  %501 = mul i64 %500, 32
  %502 = add i64 %501, 16
  %503 = call ptr @realloc(ptr null, i64 %502)
  store i32 1, ptr %503, align 4
  %504 = getelementptr inbounds i8, ptr %503, i32 4
  store i32 0, ptr %504, align 4
  %505 = getelementptr inbounds i8, ptr %503, i32 16
  %506 = call ptr @realloc(ptr null, i64 8)
  store ptr %505, ptr %506, align 8
  %507 = insertvalue { ptr, i32, i32, i32 } %491, ptr %506, 0
  %508 = insertvalue { ptr, i32, i32, i32 } %507, i32 %499, 3
  br label %529

509:                                              ; preds = %482
  %510 = icmp ult i32 %490, %493
  br i1 %510, label %511, label %512

511:                                              ; preds = %509
  br label %526

512:                                              ; preds = %509
  %513 = shl i32 %493, 1
  %514 = call i32 @llvm.umin.i32(i32 %513, i32 1024)
  %515 = add i32 %514, %493
  %516 = call i32 @llvm.umax.i32(i32 %515, i32 8)
  %517 = zext i32 %516 to i64
  %518 = mul i64 %517, 32
  %519 = add i64 %518, 16
  %520 = extractvalue { ptr, i32, i32, i32 } %481, 0
  %521 = load ptr, ptr %520, align 8
  %522 = getelementptr inbounds i8, ptr %521, i32 -16
  %523 = call ptr @realloc(ptr %522, i64 %519)
  %524 = getelementptr inbounds i8, ptr %523, i32 16
  store ptr %524, ptr %520, align 8
  %525 = insertvalue { ptr, i32, i32, i32 } %491, i32 %516, 3
  br label %526

526:                                              ; preds = %511, %512
  %527 = phi { ptr, i32, i32, i32 } [ %525, %512 ], [ %491, %511 ]
  br label %528

528:                                              ; preds = %526
  br label %529

529:                                              ; preds = %495, %528
  %530 = phi { ptr, i32, i32, i32 } [ %527, %528 ], [ %508, %495 ]
  br label %531

531:                                              ; preds = %529
  %532 = extractvalue { ptr, i32, i32, i32 } %530, 0
  %533 = load ptr, ptr %532, align 8
  %534 = extractvalue { ptr, i32, i32, i32 } %530, 2
  %535 = zext i32 %534 to i64
  %536 = mul i64 %535, 32
  %537 = getelementptr inbounds i8, ptr %533, i64 %536
  store i252 %442, ptr %537, align 16
  %538 = extractvalue { ptr, i32, i32, i32 } %530, 2
  %539 = add i32 %538, 1
  %540 = insertvalue { ptr, i32, i32, i32 } %530, i32 %539, 2
  %541 = getelementptr inbounds i8, ptr %533, i32 -12
  store i32 %539, ptr %541, align 4
  %542 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %540, 0
  ret { { ptr, i32, i32, i32 } } %542

543:                                              ; preds = %2
  %544 = load { i6, i8 }, ptr %3, align 1
  %545 = extractvalue { i6, i8 } %544, 1
  %546 = icmp slt i8 %545, 0
  %547 = zext i8 %545 to i252
  %548 = call i8 @llvm.abs.i8(i8 %545, i1 false)
  %549 = zext i8 %548 to i252
  %550 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %549
  %551 = select i1 %546, i252 %550, i252 %547
  %552 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %553 = icmp eq i32 %552, 0
  br i1 %553, label %554, label %568

554:                                              ; preds = %543
  %555 = shl i32 %552, 1
  %556 = call i32 @llvm.umin.i32(i32 %555, i32 1024)
  %557 = add i32 %556, %552
  %558 = call i32 @llvm.umax.i32(i32 %557, i32 8)
  %559 = zext i32 %558 to i64
  %560 = mul i64 %559, 32
  %561 = add i64 %560, 16
  %562 = call ptr @realloc(ptr null, i64 %561)
  store i32 1, ptr %562, align 4
  %563 = getelementptr inbounds i8, ptr %562, i32 4
  store i32 0, ptr %563, align 4
  %564 = getelementptr inbounds i8, ptr %562, i32 16
  %565 = call ptr @realloc(ptr null, i64 8)
  store ptr %564, ptr %565, align 8
  %566 = insertvalue { ptr, i32, i32, i32 } %1, ptr %565, 0
  %567 = insertvalue { ptr, i32, i32, i32 } %566, i32 %558, 3
  br label %589

568:                                              ; preds = %543
  %569 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %570 = icmp ult i32 %569, %552
  br i1 %570, label %571, label %572

571:                                              ; preds = %568
  br label %586

572:                                              ; preds = %568
  %573 = shl i32 %552, 1
  %574 = call i32 @llvm.umin.i32(i32 %573, i32 1024)
  %575 = add i32 %574, %552
  %576 = call i32 @llvm.umax.i32(i32 %575, i32 8)
  %577 = zext i32 %576 to i64
  %578 = mul i64 %577, 32
  %579 = add i64 %578, 16
  %580 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %581 = load ptr, ptr %580, align 8
  %582 = getelementptr inbounds i8, ptr %581, i32 -16
  %583 = call ptr @realloc(ptr %582, i64 %579)
  %584 = getelementptr inbounds i8, ptr %583, i32 16
  store ptr %584, ptr %580, align 8
  %585 = insertvalue { ptr, i32, i32, i32 } %1, i32 %576, 3
  br label %586

586:                                              ; preds = %571, %572
  %587 = phi { ptr, i32, i32, i32 } [ %585, %572 ], [ %1, %571 ]
  br label %588

588:                                              ; preds = %586
  br label %589

589:                                              ; preds = %554, %588
  %590 = phi { ptr, i32, i32, i32 } [ %587, %588 ], [ %567, %554 ]
  br label %591

591:                                              ; preds = %589
  %592 = extractvalue { ptr, i32, i32, i32 } %590, 0
  %593 = load ptr, ptr %592, align 8
  %594 = extractvalue { ptr, i32, i32, i32 } %590, 2
  %595 = zext i32 %594 to i64
  %596 = mul i64 %595, 32
  %597 = getelementptr inbounds i8, ptr %593, i64 %596
  store i252 6, ptr %597, align 16
  %598 = extractvalue { ptr, i32, i32, i32 } %590, 2
  %599 = add i32 %598, 1
  %600 = insertvalue { ptr, i32, i32, i32 } %590, i32 %599, 2
  %601 = getelementptr inbounds i8, ptr %593, i32 -12
  store i32 %599, ptr %601, align 4
  %602 = extractvalue { ptr, i32, i32, i32 } %590, 3
  %603 = icmp eq i32 %602, 0
  br i1 %603, label %604, label %618

604:                                              ; preds = %591
  %605 = shl i32 %602, 1
  %606 = call i32 @llvm.umin.i32(i32 %605, i32 1024)
  %607 = add i32 %606, %602
  %608 = call i32 @llvm.umax.i32(i32 %607, i32 8)
  %609 = zext i32 %608 to i64
  %610 = mul i64 %609, 32
  %611 = add i64 %610, 16
  %612 = call ptr @realloc(ptr null, i64 %611)
  store i32 1, ptr %612, align 4
  %613 = getelementptr inbounds i8, ptr %612, i32 4
  store i32 0, ptr %613, align 4
  %614 = getelementptr inbounds i8, ptr %612, i32 16
  %615 = call ptr @realloc(ptr null, i64 8)
  store ptr %614, ptr %615, align 8
  %616 = insertvalue { ptr, i32, i32, i32 } %600, ptr %615, 0
  %617 = insertvalue { ptr, i32, i32, i32 } %616, i32 %608, 3
  br label %638

618:                                              ; preds = %591
  %619 = icmp ult i32 %599, %602
  br i1 %619, label %620, label %621

620:                                              ; preds = %618
  br label %635

621:                                              ; preds = %618
  %622 = shl i32 %602, 1
  %623 = call i32 @llvm.umin.i32(i32 %622, i32 1024)
  %624 = add i32 %623, %602
  %625 = call i32 @llvm.umax.i32(i32 %624, i32 8)
  %626 = zext i32 %625 to i64
  %627 = mul i64 %626, 32
  %628 = add i64 %627, 16
  %629 = extractvalue { ptr, i32, i32, i32 } %590, 0
  %630 = load ptr, ptr %629, align 8
  %631 = getelementptr inbounds i8, ptr %630, i32 -16
  %632 = call ptr @realloc(ptr %631, i64 %628)
  %633 = getelementptr inbounds i8, ptr %632, i32 16
  store ptr %633, ptr %629, align 8
  %634 = insertvalue { ptr, i32, i32, i32 } %600, i32 %625, 3
  br label %635

635:                                              ; preds = %620, %621
  %636 = phi { ptr, i32, i32, i32 } [ %634, %621 ], [ %600, %620 ]
  br label %637

637:                                              ; preds = %635
  br label %638

638:                                              ; preds = %604, %637
  %639 = phi { ptr, i32, i32, i32 } [ %636, %637 ], [ %617, %604 ]
  br label %640

640:                                              ; preds = %638
  %641 = extractvalue { ptr, i32, i32, i32 } %639, 0
  %642 = load ptr, ptr %641, align 8
  %643 = extractvalue { ptr, i32, i32, i32 } %639, 2
  %644 = zext i32 %643 to i64
  %645 = mul i64 %644, 32
  %646 = getelementptr inbounds i8, ptr %642, i64 %645
  store i252 %551, ptr %646, align 16
  %647 = extractvalue { ptr, i32, i32, i32 } %639, 2
  %648 = add i32 %647, 1
  %649 = insertvalue { ptr, i32, i32, i32 } %639, i32 %648, 2
  %650 = getelementptr inbounds i8, ptr %642, i32 -12
  store i32 %648, ptr %650, align 4
  %651 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %649, 0
  ret { { ptr, i32, i32, i32 } } %651

652:                                              ; preds = %2
  %653 = load { i6, i8 }, ptr %3, align 1
  %654 = extractvalue { i6, i8 } %653, 1
  %655 = icmp slt i8 %654, 0
  %656 = zext i8 %654 to i252
  %657 = call i8 @llvm.abs.i8(i8 %654, i1 false)
  %658 = zext i8 %657 to i252
  %659 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %658
  %660 = select i1 %655, i252 %659, i252 %656
  %661 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %662 = icmp eq i32 %661, 0
  br i1 %662, label %663, label %677

663:                                              ; preds = %652
  %664 = shl i32 %661, 1
  %665 = call i32 @llvm.umin.i32(i32 %664, i32 1024)
  %666 = add i32 %665, %661
  %667 = call i32 @llvm.umax.i32(i32 %666, i32 8)
  %668 = zext i32 %667 to i64
  %669 = mul i64 %668, 32
  %670 = add i64 %669, 16
  %671 = call ptr @realloc(ptr null, i64 %670)
  store i32 1, ptr %671, align 4
  %672 = getelementptr inbounds i8, ptr %671, i32 4
  store i32 0, ptr %672, align 4
  %673 = getelementptr inbounds i8, ptr %671, i32 16
  %674 = call ptr @realloc(ptr null, i64 8)
  store ptr %673, ptr %674, align 8
  %675 = insertvalue { ptr, i32, i32, i32 } %1, ptr %674, 0
  %676 = insertvalue { ptr, i32, i32, i32 } %675, i32 %667, 3
  br label %698

677:                                              ; preds = %652
  %678 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %679 = icmp ult i32 %678, %661
  br i1 %679, label %680, label %681

680:                                              ; preds = %677
  br label %695

681:                                              ; preds = %677
  %682 = shl i32 %661, 1
  %683 = call i32 @llvm.umin.i32(i32 %682, i32 1024)
  %684 = add i32 %683, %661
  %685 = call i32 @llvm.umax.i32(i32 %684, i32 8)
  %686 = zext i32 %685 to i64
  %687 = mul i64 %686, 32
  %688 = add i64 %687, 16
  %689 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %690 = load ptr, ptr %689, align 8
  %691 = getelementptr inbounds i8, ptr %690, i32 -16
  %692 = call ptr @realloc(ptr %691, i64 %688)
  %693 = getelementptr inbounds i8, ptr %692, i32 16
  store ptr %693, ptr %689, align 8
  %694 = insertvalue { ptr, i32, i32, i32 } %1, i32 %685, 3
  br label %695

695:                                              ; preds = %680, %681
  %696 = phi { ptr, i32, i32, i32 } [ %694, %681 ], [ %1, %680 ]
  br label %697

697:                                              ; preds = %695
  br label %698

698:                                              ; preds = %663, %697
  %699 = phi { ptr, i32, i32, i32 } [ %696, %697 ], [ %676, %663 ]
  br label %700

700:                                              ; preds = %698
  %701 = extractvalue { ptr, i32, i32, i32 } %699, 0
  %702 = load ptr, ptr %701, align 8
  %703 = extractvalue { ptr, i32, i32, i32 } %699, 2
  %704 = zext i32 %703 to i64
  %705 = mul i64 %704, 32
  %706 = getelementptr inbounds i8, ptr %702, i64 %705
  store i252 7, ptr %706, align 16
  %707 = extractvalue { ptr, i32, i32, i32 } %699, 2
  %708 = add i32 %707, 1
  %709 = insertvalue { ptr, i32, i32, i32 } %699, i32 %708, 2
  %710 = getelementptr inbounds i8, ptr %702, i32 -12
  store i32 %708, ptr %710, align 4
  %711 = extractvalue { ptr, i32, i32, i32 } %699, 3
  %712 = icmp eq i32 %711, 0
  br i1 %712, label %713, label %727

713:                                              ; preds = %700
  %714 = shl i32 %711, 1
  %715 = call i32 @llvm.umin.i32(i32 %714, i32 1024)
  %716 = add i32 %715, %711
  %717 = call i32 @llvm.umax.i32(i32 %716, i32 8)
  %718 = zext i32 %717 to i64
  %719 = mul i64 %718, 32
  %720 = add i64 %719, 16
  %721 = call ptr @realloc(ptr null, i64 %720)
  store i32 1, ptr %721, align 4
  %722 = getelementptr inbounds i8, ptr %721, i32 4
  store i32 0, ptr %722, align 4
  %723 = getelementptr inbounds i8, ptr %721, i32 16
  %724 = call ptr @realloc(ptr null, i64 8)
  store ptr %723, ptr %724, align 8
  %725 = insertvalue { ptr, i32, i32, i32 } %709, ptr %724, 0
  %726 = insertvalue { ptr, i32, i32, i32 } %725, i32 %717, 3
  br label %747

727:                                              ; preds = %700
  %728 = icmp ult i32 %708, %711
  br i1 %728, label %729, label %730

729:                                              ; preds = %727
  br label %744

730:                                              ; preds = %727
  %731 = shl i32 %711, 1
  %732 = call i32 @llvm.umin.i32(i32 %731, i32 1024)
  %733 = add i32 %732, %711
  %734 = call i32 @llvm.umax.i32(i32 %733, i32 8)
  %735 = zext i32 %734 to i64
  %736 = mul i64 %735, 32
  %737 = add i64 %736, 16
  %738 = extractvalue { ptr, i32, i32, i32 } %699, 0
  %739 = load ptr, ptr %738, align 8
  %740 = getelementptr inbounds i8, ptr %739, i32 -16
  %741 = call ptr @realloc(ptr %740, i64 %737)
  %742 = getelementptr inbounds i8, ptr %741, i32 16
  store ptr %742, ptr %738, align 8
  %743 = insertvalue { ptr, i32, i32, i32 } %709, i32 %734, 3
  br label %744

744:                                              ; preds = %729, %730
  %745 = phi { ptr, i32, i32, i32 } [ %743, %730 ], [ %709, %729 ]
  br label %746

746:                                              ; preds = %744
  br label %747

747:                                              ; preds = %713, %746
  %748 = phi { ptr, i32, i32, i32 } [ %745, %746 ], [ %726, %713 ]
  br label %749

749:                                              ; preds = %747
  %750 = extractvalue { ptr, i32, i32, i32 } %748, 0
  %751 = load ptr, ptr %750, align 8
  %752 = extractvalue { ptr, i32, i32, i32 } %748, 2
  %753 = zext i32 %752 to i64
  %754 = mul i64 %753, 32
  %755 = getelementptr inbounds i8, ptr %751, i64 %754
  store i252 %660, ptr %755, align 16
  %756 = extractvalue { ptr, i32, i32, i32 } %748, 2
  %757 = add i32 %756, 1
  %758 = insertvalue { ptr, i32, i32, i32 } %748, i32 %757, 2
  %759 = getelementptr inbounds i8, ptr %751, i32 -12
  store i32 %757, ptr %759, align 4
  %760 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %758, 0
  ret { { ptr, i32, i32, i32 } } %760

761:                                              ; preds = %2
  %762 = load { i6, i8 }, ptr %3, align 1
  %763 = extractvalue { i6, i8 } %762, 1
  %764 = icmp slt i8 %763, 0
  %765 = zext i8 %763 to i252
  %766 = call i8 @llvm.abs.i8(i8 %763, i1 false)
  %767 = zext i8 %766 to i252
  %768 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %767
  %769 = select i1 %764, i252 %768, i252 %765
  %770 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %771 = icmp eq i32 %770, 0
  br i1 %771, label %772, label %786

772:                                              ; preds = %761
  %773 = shl i32 %770, 1
  %774 = call i32 @llvm.umin.i32(i32 %773, i32 1024)
  %775 = add i32 %774, %770
  %776 = call i32 @llvm.umax.i32(i32 %775, i32 8)
  %777 = zext i32 %776 to i64
  %778 = mul i64 %777, 32
  %779 = add i64 %778, 16
  %780 = call ptr @realloc(ptr null, i64 %779)
  store i32 1, ptr %780, align 4
  %781 = getelementptr inbounds i8, ptr %780, i32 4
  store i32 0, ptr %781, align 4
  %782 = getelementptr inbounds i8, ptr %780, i32 16
  %783 = call ptr @realloc(ptr null, i64 8)
  store ptr %782, ptr %783, align 8
  %784 = insertvalue { ptr, i32, i32, i32 } %1, ptr %783, 0
  %785 = insertvalue { ptr, i32, i32, i32 } %784, i32 %776, 3
  br label %807

786:                                              ; preds = %761
  %787 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %788 = icmp ult i32 %787, %770
  br i1 %788, label %789, label %790

789:                                              ; preds = %786
  br label %804

790:                                              ; preds = %786
  %791 = shl i32 %770, 1
  %792 = call i32 @llvm.umin.i32(i32 %791, i32 1024)
  %793 = add i32 %792, %770
  %794 = call i32 @llvm.umax.i32(i32 %793, i32 8)
  %795 = zext i32 %794 to i64
  %796 = mul i64 %795, 32
  %797 = add i64 %796, 16
  %798 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %799 = load ptr, ptr %798, align 8
  %800 = getelementptr inbounds i8, ptr %799, i32 -16
  %801 = call ptr @realloc(ptr %800, i64 %797)
  %802 = getelementptr inbounds i8, ptr %801, i32 16
  store ptr %802, ptr %798, align 8
  %803 = insertvalue { ptr, i32, i32, i32 } %1, i32 %794, 3
  br label %804

804:                                              ; preds = %789, %790
  %805 = phi { ptr, i32, i32, i32 } [ %803, %790 ], [ %1, %789 ]
  br label %806

806:                                              ; preds = %804
  br label %807

807:                                              ; preds = %772, %806
  %808 = phi { ptr, i32, i32, i32 } [ %805, %806 ], [ %785, %772 ]
  br label %809

809:                                              ; preds = %807
  %810 = extractvalue { ptr, i32, i32, i32 } %808, 0
  %811 = load ptr, ptr %810, align 8
  %812 = extractvalue { ptr, i32, i32, i32 } %808, 2
  %813 = zext i32 %812 to i64
  %814 = mul i64 %813, 32
  %815 = getelementptr inbounds i8, ptr %811, i64 %814
  store i252 8, ptr %815, align 16
  %816 = extractvalue { ptr, i32, i32, i32 } %808, 2
  %817 = add i32 %816, 1
  %818 = insertvalue { ptr, i32, i32, i32 } %808, i32 %817, 2
  %819 = getelementptr inbounds i8, ptr %811, i32 -12
  store i32 %817, ptr %819, align 4
  %820 = extractvalue { ptr, i32, i32, i32 } %808, 3
  %821 = icmp eq i32 %820, 0
  br i1 %821, label %822, label %836

822:                                              ; preds = %809
  %823 = shl i32 %820, 1
  %824 = call i32 @llvm.umin.i32(i32 %823, i32 1024)
  %825 = add i32 %824, %820
  %826 = call i32 @llvm.umax.i32(i32 %825, i32 8)
  %827 = zext i32 %826 to i64
  %828 = mul i64 %827, 32
  %829 = add i64 %828, 16
  %830 = call ptr @realloc(ptr null, i64 %829)
  store i32 1, ptr %830, align 4
  %831 = getelementptr inbounds i8, ptr %830, i32 4
  store i32 0, ptr %831, align 4
  %832 = getelementptr inbounds i8, ptr %830, i32 16
  %833 = call ptr @realloc(ptr null, i64 8)
  store ptr %832, ptr %833, align 8
  %834 = insertvalue { ptr, i32, i32, i32 } %818, ptr %833, 0
  %835 = insertvalue { ptr, i32, i32, i32 } %834, i32 %826, 3
  br label %856

836:                                              ; preds = %809
  %837 = icmp ult i32 %817, %820
  br i1 %837, label %838, label %839

838:                                              ; preds = %836
  br label %853

839:                                              ; preds = %836
  %840 = shl i32 %820, 1
  %841 = call i32 @llvm.umin.i32(i32 %840, i32 1024)
  %842 = add i32 %841, %820
  %843 = call i32 @llvm.umax.i32(i32 %842, i32 8)
  %844 = zext i32 %843 to i64
  %845 = mul i64 %844, 32
  %846 = add i64 %845, 16
  %847 = extractvalue { ptr, i32, i32, i32 } %808, 0
  %848 = load ptr, ptr %847, align 8
  %849 = getelementptr inbounds i8, ptr %848, i32 -16
  %850 = call ptr @realloc(ptr %849, i64 %846)
  %851 = getelementptr inbounds i8, ptr %850, i32 16
  store ptr %851, ptr %847, align 8
  %852 = insertvalue { ptr, i32, i32, i32 } %818, i32 %843, 3
  br label %853

853:                                              ; preds = %838, %839
  %854 = phi { ptr, i32, i32, i32 } [ %852, %839 ], [ %818, %838 ]
  br label %855

855:                                              ; preds = %853
  br label %856

856:                                              ; preds = %822, %855
  %857 = phi { ptr, i32, i32, i32 } [ %854, %855 ], [ %835, %822 ]
  br label %858

858:                                              ; preds = %856
  %859 = extractvalue { ptr, i32, i32, i32 } %857, 0
  %860 = load ptr, ptr %859, align 8
  %861 = extractvalue { ptr, i32, i32, i32 } %857, 2
  %862 = zext i32 %861 to i64
  %863 = mul i64 %862, 32
  %864 = getelementptr inbounds i8, ptr %860, i64 %863
  store i252 %769, ptr %864, align 16
  %865 = extractvalue { ptr, i32, i32, i32 } %857, 2
  %866 = add i32 %865, 1
  %867 = insertvalue { ptr, i32, i32, i32 } %857, i32 %866, 2
  %868 = getelementptr inbounds i8, ptr %860, i32 -12
  store i32 %866, ptr %868, align 4
  %869 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %867, 0
  ret { { ptr, i32, i32, i32 } } %869

870:                                              ; preds = %2
  %871 = load { i6, i8 }, ptr %3, align 1
  %872 = extractvalue { i6, i8 } %871, 1
  %873 = icmp slt i8 %872, 0
  %874 = zext i8 %872 to i252
  %875 = call i8 @llvm.abs.i8(i8 %872, i1 false)
  %876 = zext i8 %875 to i252
  %877 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %876
  %878 = select i1 %873, i252 %877, i252 %874
  %879 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %880 = icmp eq i32 %879, 0
  br i1 %880, label %881, label %895

881:                                              ; preds = %870
  %882 = shl i32 %879, 1
  %883 = call i32 @llvm.umin.i32(i32 %882, i32 1024)
  %884 = add i32 %883, %879
  %885 = call i32 @llvm.umax.i32(i32 %884, i32 8)
  %886 = zext i32 %885 to i64
  %887 = mul i64 %886, 32
  %888 = add i64 %887, 16
  %889 = call ptr @realloc(ptr null, i64 %888)
  store i32 1, ptr %889, align 4
  %890 = getelementptr inbounds i8, ptr %889, i32 4
  store i32 0, ptr %890, align 4
  %891 = getelementptr inbounds i8, ptr %889, i32 16
  %892 = call ptr @realloc(ptr null, i64 8)
  store ptr %891, ptr %892, align 8
  %893 = insertvalue { ptr, i32, i32, i32 } %1, ptr %892, 0
  %894 = insertvalue { ptr, i32, i32, i32 } %893, i32 %885, 3
  br label %916

895:                                              ; preds = %870
  %896 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %897 = icmp ult i32 %896, %879
  br i1 %897, label %898, label %899

898:                                              ; preds = %895
  br label %913

899:                                              ; preds = %895
  %900 = shl i32 %879, 1
  %901 = call i32 @llvm.umin.i32(i32 %900, i32 1024)
  %902 = add i32 %901, %879
  %903 = call i32 @llvm.umax.i32(i32 %902, i32 8)
  %904 = zext i32 %903 to i64
  %905 = mul i64 %904, 32
  %906 = add i64 %905, 16
  %907 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %908 = load ptr, ptr %907, align 8
  %909 = getelementptr inbounds i8, ptr %908, i32 -16
  %910 = call ptr @realloc(ptr %909, i64 %906)
  %911 = getelementptr inbounds i8, ptr %910, i32 16
  store ptr %911, ptr %907, align 8
  %912 = insertvalue { ptr, i32, i32, i32 } %1, i32 %903, 3
  br label %913

913:                                              ; preds = %898, %899
  %914 = phi { ptr, i32, i32, i32 } [ %912, %899 ], [ %1, %898 ]
  br label %915

915:                                              ; preds = %913
  br label %916

916:                                              ; preds = %881, %915
  %917 = phi { ptr, i32, i32, i32 } [ %914, %915 ], [ %894, %881 ]
  br label %918

918:                                              ; preds = %916
  %919 = extractvalue { ptr, i32, i32, i32 } %917, 0
  %920 = load ptr, ptr %919, align 8
  %921 = extractvalue { ptr, i32, i32, i32 } %917, 2
  %922 = zext i32 %921 to i64
  %923 = mul i64 %922, 32
  %924 = getelementptr inbounds i8, ptr %920, i64 %923
  store i252 9, ptr %924, align 16
  %925 = extractvalue { ptr, i32, i32, i32 } %917, 2
  %926 = add i32 %925, 1
  %927 = insertvalue { ptr, i32, i32, i32 } %917, i32 %926, 2
  %928 = getelementptr inbounds i8, ptr %920, i32 -12
  store i32 %926, ptr %928, align 4
  %929 = extractvalue { ptr, i32, i32, i32 } %917, 3
  %930 = icmp eq i32 %929, 0
  br i1 %930, label %931, label %945

931:                                              ; preds = %918
  %932 = shl i32 %929, 1
  %933 = call i32 @llvm.umin.i32(i32 %932, i32 1024)
  %934 = add i32 %933, %929
  %935 = call i32 @llvm.umax.i32(i32 %934, i32 8)
  %936 = zext i32 %935 to i64
  %937 = mul i64 %936, 32
  %938 = add i64 %937, 16
  %939 = call ptr @realloc(ptr null, i64 %938)
  store i32 1, ptr %939, align 4
  %940 = getelementptr inbounds i8, ptr %939, i32 4
  store i32 0, ptr %940, align 4
  %941 = getelementptr inbounds i8, ptr %939, i32 16
  %942 = call ptr @realloc(ptr null, i64 8)
  store ptr %941, ptr %942, align 8
  %943 = insertvalue { ptr, i32, i32, i32 } %927, ptr %942, 0
  %944 = insertvalue { ptr, i32, i32, i32 } %943, i32 %935, 3
  br label %965

945:                                              ; preds = %918
  %946 = icmp ult i32 %926, %929
  br i1 %946, label %947, label %948

947:                                              ; preds = %945
  br label %962

948:                                              ; preds = %945
  %949 = shl i32 %929, 1
  %950 = call i32 @llvm.umin.i32(i32 %949, i32 1024)
  %951 = add i32 %950, %929
  %952 = call i32 @llvm.umax.i32(i32 %951, i32 8)
  %953 = zext i32 %952 to i64
  %954 = mul i64 %953, 32
  %955 = add i64 %954, 16
  %956 = extractvalue { ptr, i32, i32, i32 } %917, 0
  %957 = load ptr, ptr %956, align 8
  %958 = getelementptr inbounds i8, ptr %957, i32 -16
  %959 = call ptr @realloc(ptr %958, i64 %955)
  %960 = getelementptr inbounds i8, ptr %959, i32 16
  store ptr %960, ptr %956, align 8
  %961 = insertvalue { ptr, i32, i32, i32 } %927, i32 %952, 3
  br label %962

962:                                              ; preds = %947, %948
  %963 = phi { ptr, i32, i32, i32 } [ %961, %948 ], [ %927, %947 ]
  br label %964

964:                                              ; preds = %962
  br label %965

965:                                              ; preds = %931, %964
  %966 = phi { ptr, i32, i32, i32 } [ %963, %964 ], [ %944, %931 ]
  br label %967

967:                                              ; preds = %965
  %968 = extractvalue { ptr, i32, i32, i32 } %966, 0
  %969 = load ptr, ptr %968, align 8
  %970 = extractvalue { ptr, i32, i32, i32 } %966, 2
  %971 = zext i32 %970 to i64
  %972 = mul i64 %971, 32
  %973 = getelementptr inbounds i8, ptr %969, i64 %972
  store i252 %878, ptr %973, align 16
  %974 = extractvalue { ptr, i32, i32, i32 } %966, 2
  %975 = add i32 %974, 1
  %976 = insertvalue { ptr, i32, i32, i32 } %966, i32 %975, 2
  %977 = getelementptr inbounds i8, ptr %969, i32 -12
  store i32 %975, ptr %977, align 4
  %978 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %976, 0
  ret { { ptr, i32, i32, i32 } } %978

979:                                              ; preds = %2
  %980 = load { i6, i8 }, ptr %3, align 1
  %981 = extractvalue { i6, i8 } %980, 1
  %982 = icmp slt i8 %981, 0
  %983 = zext i8 %981 to i252
  %984 = call i8 @llvm.abs.i8(i8 %981, i1 false)
  %985 = zext i8 %984 to i252
  %986 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %985
  %987 = select i1 %982, i252 %986, i252 %983
  %988 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %989 = icmp eq i32 %988, 0
  br i1 %989, label %990, label %1004

990:                                              ; preds = %979
  %991 = shl i32 %988, 1
  %992 = call i32 @llvm.umin.i32(i32 %991, i32 1024)
  %993 = add i32 %992, %988
  %994 = call i32 @llvm.umax.i32(i32 %993, i32 8)
  %995 = zext i32 %994 to i64
  %996 = mul i64 %995, 32
  %997 = add i64 %996, 16
  %998 = call ptr @realloc(ptr null, i64 %997)
  store i32 1, ptr %998, align 4
  %999 = getelementptr inbounds i8, ptr %998, i32 4
  store i32 0, ptr %999, align 4
  %1000 = getelementptr inbounds i8, ptr %998, i32 16
  %1001 = call ptr @realloc(ptr null, i64 8)
  store ptr %1000, ptr %1001, align 8
  %1002 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1001, 0
  %1003 = insertvalue { ptr, i32, i32, i32 } %1002, i32 %994, 3
  br label %1025

1004:                                             ; preds = %979
  %1005 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1006 = icmp ult i32 %1005, %988
  br i1 %1006, label %1007, label %1008

1007:                                             ; preds = %1004
  br label %1022

1008:                                             ; preds = %1004
  %1009 = shl i32 %988, 1
  %1010 = call i32 @llvm.umin.i32(i32 %1009, i32 1024)
  %1011 = add i32 %1010, %988
  %1012 = call i32 @llvm.umax.i32(i32 %1011, i32 8)
  %1013 = zext i32 %1012 to i64
  %1014 = mul i64 %1013, 32
  %1015 = add i64 %1014, 16
  %1016 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1017 = load ptr, ptr %1016, align 8
  %1018 = getelementptr inbounds i8, ptr %1017, i32 -16
  %1019 = call ptr @realloc(ptr %1018, i64 %1015)
  %1020 = getelementptr inbounds i8, ptr %1019, i32 16
  store ptr %1020, ptr %1016, align 8
  %1021 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1012, 3
  br label %1022

1022:                                             ; preds = %1007, %1008
  %1023 = phi { ptr, i32, i32, i32 } [ %1021, %1008 ], [ %1, %1007 ]
  br label %1024

1024:                                             ; preds = %1022
  br label %1025

1025:                                             ; preds = %990, %1024
  %1026 = phi { ptr, i32, i32, i32 } [ %1023, %1024 ], [ %1003, %990 ]
  br label %1027

1027:                                             ; preds = %1025
  %1028 = extractvalue { ptr, i32, i32, i32 } %1026, 0
  %1029 = load ptr, ptr %1028, align 8
  %1030 = extractvalue { ptr, i32, i32, i32 } %1026, 2
  %1031 = zext i32 %1030 to i64
  %1032 = mul i64 %1031, 32
  %1033 = getelementptr inbounds i8, ptr %1029, i64 %1032
  store i252 10, ptr %1033, align 16
  %1034 = extractvalue { ptr, i32, i32, i32 } %1026, 2
  %1035 = add i32 %1034, 1
  %1036 = insertvalue { ptr, i32, i32, i32 } %1026, i32 %1035, 2
  %1037 = getelementptr inbounds i8, ptr %1029, i32 -12
  store i32 %1035, ptr %1037, align 4
  %1038 = extractvalue { ptr, i32, i32, i32 } %1026, 3
  %1039 = icmp eq i32 %1038, 0
  br i1 %1039, label %1040, label %1054

1040:                                             ; preds = %1027
  %1041 = shl i32 %1038, 1
  %1042 = call i32 @llvm.umin.i32(i32 %1041, i32 1024)
  %1043 = add i32 %1042, %1038
  %1044 = call i32 @llvm.umax.i32(i32 %1043, i32 8)
  %1045 = zext i32 %1044 to i64
  %1046 = mul i64 %1045, 32
  %1047 = add i64 %1046, 16
  %1048 = call ptr @realloc(ptr null, i64 %1047)
  store i32 1, ptr %1048, align 4
  %1049 = getelementptr inbounds i8, ptr %1048, i32 4
  store i32 0, ptr %1049, align 4
  %1050 = getelementptr inbounds i8, ptr %1048, i32 16
  %1051 = call ptr @realloc(ptr null, i64 8)
  store ptr %1050, ptr %1051, align 8
  %1052 = insertvalue { ptr, i32, i32, i32 } %1036, ptr %1051, 0
  %1053 = insertvalue { ptr, i32, i32, i32 } %1052, i32 %1044, 3
  br label %1074

1054:                                             ; preds = %1027
  %1055 = icmp ult i32 %1035, %1038
  br i1 %1055, label %1056, label %1057

1056:                                             ; preds = %1054
  br label %1071

1057:                                             ; preds = %1054
  %1058 = shl i32 %1038, 1
  %1059 = call i32 @llvm.umin.i32(i32 %1058, i32 1024)
  %1060 = add i32 %1059, %1038
  %1061 = call i32 @llvm.umax.i32(i32 %1060, i32 8)
  %1062 = zext i32 %1061 to i64
  %1063 = mul i64 %1062, 32
  %1064 = add i64 %1063, 16
  %1065 = extractvalue { ptr, i32, i32, i32 } %1026, 0
  %1066 = load ptr, ptr %1065, align 8
  %1067 = getelementptr inbounds i8, ptr %1066, i32 -16
  %1068 = call ptr @realloc(ptr %1067, i64 %1064)
  %1069 = getelementptr inbounds i8, ptr %1068, i32 16
  store ptr %1069, ptr %1065, align 8
  %1070 = insertvalue { ptr, i32, i32, i32 } %1036, i32 %1061, 3
  br label %1071

1071:                                             ; preds = %1056, %1057
  %1072 = phi { ptr, i32, i32, i32 } [ %1070, %1057 ], [ %1036, %1056 ]
  br label %1073

1073:                                             ; preds = %1071
  br label %1074

1074:                                             ; preds = %1040, %1073
  %1075 = phi { ptr, i32, i32, i32 } [ %1072, %1073 ], [ %1053, %1040 ]
  br label %1076

1076:                                             ; preds = %1074
  %1077 = extractvalue { ptr, i32, i32, i32 } %1075, 0
  %1078 = load ptr, ptr %1077, align 8
  %1079 = extractvalue { ptr, i32, i32, i32 } %1075, 2
  %1080 = zext i32 %1079 to i64
  %1081 = mul i64 %1080, 32
  %1082 = getelementptr inbounds i8, ptr %1078, i64 %1081
  store i252 %987, ptr %1082, align 16
  %1083 = extractvalue { ptr, i32, i32, i32 } %1075, 2
  %1084 = add i32 %1083, 1
  %1085 = insertvalue { ptr, i32, i32, i32 } %1075, i32 %1084, 2
  %1086 = getelementptr inbounds i8, ptr %1078, i32 -12
  store i32 %1084, ptr %1086, align 4
  %1087 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1085, 0
  ret { { ptr, i32, i32, i32 } } %1087

1088:                                             ; preds = %2
  %1089 = load { i6, i8 }, ptr %3, align 1
  %1090 = extractvalue { i6, i8 } %1089, 1
  %1091 = icmp slt i8 %1090, 0
  %1092 = zext i8 %1090 to i252
  %1093 = call i8 @llvm.abs.i8(i8 %1090, i1 false)
  %1094 = zext i8 %1093 to i252
  %1095 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1094
  %1096 = select i1 %1091, i252 %1095, i252 %1092
  %1097 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %1098 = icmp eq i32 %1097, 0
  br i1 %1098, label %1099, label %1113

1099:                                             ; preds = %1088
  %1100 = shl i32 %1097, 1
  %1101 = call i32 @llvm.umin.i32(i32 %1100, i32 1024)
  %1102 = add i32 %1101, %1097
  %1103 = call i32 @llvm.umax.i32(i32 %1102, i32 8)
  %1104 = zext i32 %1103 to i64
  %1105 = mul i64 %1104, 32
  %1106 = add i64 %1105, 16
  %1107 = call ptr @realloc(ptr null, i64 %1106)
  store i32 1, ptr %1107, align 4
  %1108 = getelementptr inbounds i8, ptr %1107, i32 4
  store i32 0, ptr %1108, align 4
  %1109 = getelementptr inbounds i8, ptr %1107, i32 16
  %1110 = call ptr @realloc(ptr null, i64 8)
  store ptr %1109, ptr %1110, align 8
  %1111 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1110, 0
  %1112 = insertvalue { ptr, i32, i32, i32 } %1111, i32 %1103, 3
  br label %1134

1113:                                             ; preds = %1088
  %1114 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1115 = icmp ult i32 %1114, %1097
  br i1 %1115, label %1116, label %1117

1116:                                             ; preds = %1113
  br label %1131

1117:                                             ; preds = %1113
  %1118 = shl i32 %1097, 1
  %1119 = call i32 @llvm.umin.i32(i32 %1118, i32 1024)
  %1120 = add i32 %1119, %1097
  %1121 = call i32 @llvm.umax.i32(i32 %1120, i32 8)
  %1122 = zext i32 %1121 to i64
  %1123 = mul i64 %1122, 32
  %1124 = add i64 %1123, 16
  %1125 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1126 = load ptr, ptr %1125, align 8
  %1127 = getelementptr inbounds i8, ptr %1126, i32 -16
  %1128 = call ptr @realloc(ptr %1127, i64 %1124)
  %1129 = getelementptr inbounds i8, ptr %1128, i32 16
  store ptr %1129, ptr %1125, align 8
  %1130 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1121, 3
  br label %1131

1131:                                             ; preds = %1116, %1117
  %1132 = phi { ptr, i32, i32, i32 } [ %1130, %1117 ], [ %1, %1116 ]
  br label %1133

1133:                                             ; preds = %1131
  br label %1134

1134:                                             ; preds = %1099, %1133
  %1135 = phi { ptr, i32, i32, i32 } [ %1132, %1133 ], [ %1112, %1099 ]
  br label %1136

1136:                                             ; preds = %1134
  %1137 = extractvalue { ptr, i32, i32, i32 } %1135, 0
  %1138 = load ptr, ptr %1137, align 8
  %1139 = extractvalue { ptr, i32, i32, i32 } %1135, 2
  %1140 = zext i32 %1139 to i64
  %1141 = mul i64 %1140, 32
  %1142 = getelementptr inbounds i8, ptr %1138, i64 %1141
  store i252 11, ptr %1142, align 16
  %1143 = extractvalue { ptr, i32, i32, i32 } %1135, 2
  %1144 = add i32 %1143, 1
  %1145 = insertvalue { ptr, i32, i32, i32 } %1135, i32 %1144, 2
  %1146 = getelementptr inbounds i8, ptr %1138, i32 -12
  store i32 %1144, ptr %1146, align 4
  %1147 = extractvalue { ptr, i32, i32, i32 } %1135, 3
  %1148 = icmp eq i32 %1147, 0
  br i1 %1148, label %1149, label %1163

1149:                                             ; preds = %1136
  %1150 = shl i32 %1147, 1
  %1151 = call i32 @llvm.umin.i32(i32 %1150, i32 1024)
  %1152 = add i32 %1151, %1147
  %1153 = call i32 @llvm.umax.i32(i32 %1152, i32 8)
  %1154 = zext i32 %1153 to i64
  %1155 = mul i64 %1154, 32
  %1156 = add i64 %1155, 16
  %1157 = call ptr @realloc(ptr null, i64 %1156)
  store i32 1, ptr %1157, align 4
  %1158 = getelementptr inbounds i8, ptr %1157, i32 4
  store i32 0, ptr %1158, align 4
  %1159 = getelementptr inbounds i8, ptr %1157, i32 16
  %1160 = call ptr @realloc(ptr null, i64 8)
  store ptr %1159, ptr %1160, align 8
  %1161 = insertvalue { ptr, i32, i32, i32 } %1145, ptr %1160, 0
  %1162 = insertvalue { ptr, i32, i32, i32 } %1161, i32 %1153, 3
  br label %1183

1163:                                             ; preds = %1136
  %1164 = icmp ult i32 %1144, %1147
  br i1 %1164, label %1165, label %1166

1165:                                             ; preds = %1163
  br label %1180

1166:                                             ; preds = %1163
  %1167 = shl i32 %1147, 1
  %1168 = call i32 @llvm.umin.i32(i32 %1167, i32 1024)
  %1169 = add i32 %1168, %1147
  %1170 = call i32 @llvm.umax.i32(i32 %1169, i32 8)
  %1171 = zext i32 %1170 to i64
  %1172 = mul i64 %1171, 32
  %1173 = add i64 %1172, 16
  %1174 = extractvalue { ptr, i32, i32, i32 } %1135, 0
  %1175 = load ptr, ptr %1174, align 8
  %1176 = getelementptr inbounds i8, ptr %1175, i32 -16
  %1177 = call ptr @realloc(ptr %1176, i64 %1173)
  %1178 = getelementptr inbounds i8, ptr %1177, i32 16
  store ptr %1178, ptr %1174, align 8
  %1179 = insertvalue { ptr, i32, i32, i32 } %1145, i32 %1170, 3
  br label %1180

1180:                                             ; preds = %1165, %1166
  %1181 = phi { ptr, i32, i32, i32 } [ %1179, %1166 ], [ %1145, %1165 ]
  br label %1182

1182:                                             ; preds = %1180
  br label %1183

1183:                                             ; preds = %1149, %1182
  %1184 = phi { ptr, i32, i32, i32 } [ %1181, %1182 ], [ %1162, %1149 ]
  br label %1185

1185:                                             ; preds = %1183
  %1186 = extractvalue { ptr, i32, i32, i32 } %1184, 0
  %1187 = load ptr, ptr %1186, align 8
  %1188 = extractvalue { ptr, i32, i32, i32 } %1184, 2
  %1189 = zext i32 %1188 to i64
  %1190 = mul i64 %1189, 32
  %1191 = getelementptr inbounds i8, ptr %1187, i64 %1190
  store i252 %1096, ptr %1191, align 16
  %1192 = extractvalue { ptr, i32, i32, i32 } %1184, 2
  %1193 = add i32 %1192, 1
  %1194 = insertvalue { ptr, i32, i32, i32 } %1184, i32 %1193, 2
  %1195 = getelementptr inbounds i8, ptr %1187, i32 -12
  store i32 %1193, ptr %1195, align 4
  %1196 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1194, 0
  ret { { ptr, i32, i32, i32 } } %1196

1197:                                             ; preds = %2
  %1198 = load { i6, i16 }, ptr %3, align 2
  %1199 = extractvalue { i6, i16 } %1198, 1
  %1200 = icmp slt i16 %1199, 0
  %1201 = zext i16 %1199 to i252
  %1202 = call i16 @llvm.abs.i16(i16 %1199, i1 false)
  %1203 = zext i16 %1202 to i252
  %1204 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1203
  %1205 = select i1 %1200, i252 %1204, i252 %1201
  %1206 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %1207 = icmp eq i32 %1206, 0
  br i1 %1207, label %1208, label %1222

1208:                                             ; preds = %1197
  %1209 = shl i32 %1206, 1
  %1210 = call i32 @llvm.umin.i32(i32 %1209, i32 1024)
  %1211 = add i32 %1210, %1206
  %1212 = call i32 @llvm.umax.i32(i32 %1211, i32 8)
  %1213 = zext i32 %1212 to i64
  %1214 = mul i64 %1213, 32
  %1215 = add i64 %1214, 16
  %1216 = call ptr @realloc(ptr null, i64 %1215)
  store i32 1, ptr %1216, align 4
  %1217 = getelementptr inbounds i8, ptr %1216, i32 4
  store i32 0, ptr %1217, align 4
  %1218 = getelementptr inbounds i8, ptr %1216, i32 16
  %1219 = call ptr @realloc(ptr null, i64 8)
  store ptr %1218, ptr %1219, align 8
  %1220 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1219, 0
  %1221 = insertvalue { ptr, i32, i32, i32 } %1220, i32 %1212, 3
  br label %1243

1222:                                             ; preds = %1197
  %1223 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1224 = icmp ult i32 %1223, %1206
  br i1 %1224, label %1225, label %1226

1225:                                             ; preds = %1222
  br label %1240

1226:                                             ; preds = %1222
  %1227 = shl i32 %1206, 1
  %1228 = call i32 @llvm.umin.i32(i32 %1227, i32 1024)
  %1229 = add i32 %1228, %1206
  %1230 = call i32 @llvm.umax.i32(i32 %1229, i32 8)
  %1231 = zext i32 %1230 to i64
  %1232 = mul i64 %1231, 32
  %1233 = add i64 %1232, 16
  %1234 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1235 = load ptr, ptr %1234, align 8
  %1236 = getelementptr inbounds i8, ptr %1235, i32 -16
  %1237 = call ptr @realloc(ptr %1236, i64 %1233)
  %1238 = getelementptr inbounds i8, ptr %1237, i32 16
  store ptr %1238, ptr %1234, align 8
  %1239 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1230, 3
  br label %1240

1240:                                             ; preds = %1225, %1226
  %1241 = phi { ptr, i32, i32, i32 } [ %1239, %1226 ], [ %1, %1225 ]
  br label %1242

1242:                                             ; preds = %1240
  br label %1243

1243:                                             ; preds = %1208, %1242
  %1244 = phi { ptr, i32, i32, i32 } [ %1241, %1242 ], [ %1221, %1208 ]
  br label %1245

1245:                                             ; preds = %1243
  %1246 = extractvalue { ptr, i32, i32, i32 } %1244, 0
  %1247 = load ptr, ptr %1246, align 8
  %1248 = extractvalue { ptr, i32, i32, i32 } %1244, 2
  %1249 = zext i32 %1248 to i64
  %1250 = mul i64 %1249, 32
  %1251 = getelementptr inbounds i8, ptr %1247, i64 %1250
  store i252 12, ptr %1251, align 16
  %1252 = extractvalue { ptr, i32, i32, i32 } %1244, 2
  %1253 = add i32 %1252, 1
  %1254 = insertvalue { ptr, i32, i32, i32 } %1244, i32 %1253, 2
  %1255 = getelementptr inbounds i8, ptr %1247, i32 -12
  store i32 %1253, ptr %1255, align 4
  %1256 = extractvalue { ptr, i32, i32, i32 } %1244, 3
  %1257 = icmp eq i32 %1256, 0
  br i1 %1257, label %1258, label %1272

1258:                                             ; preds = %1245
  %1259 = shl i32 %1256, 1
  %1260 = call i32 @llvm.umin.i32(i32 %1259, i32 1024)
  %1261 = add i32 %1260, %1256
  %1262 = call i32 @llvm.umax.i32(i32 %1261, i32 8)
  %1263 = zext i32 %1262 to i64
  %1264 = mul i64 %1263, 32
  %1265 = add i64 %1264, 16
  %1266 = call ptr @realloc(ptr null, i64 %1265)
  store i32 1, ptr %1266, align 4
  %1267 = getelementptr inbounds i8, ptr %1266, i32 4
  store i32 0, ptr %1267, align 4
  %1268 = getelementptr inbounds i8, ptr %1266, i32 16
  %1269 = call ptr @realloc(ptr null, i64 8)
  store ptr %1268, ptr %1269, align 8
  %1270 = insertvalue { ptr, i32, i32, i32 } %1254, ptr %1269, 0
  %1271 = insertvalue { ptr, i32, i32, i32 } %1270, i32 %1262, 3
  br label %1292

1272:                                             ; preds = %1245
  %1273 = icmp ult i32 %1253, %1256
  br i1 %1273, label %1274, label %1275

1274:                                             ; preds = %1272
  br label %1289

1275:                                             ; preds = %1272
  %1276 = shl i32 %1256, 1
  %1277 = call i32 @llvm.umin.i32(i32 %1276, i32 1024)
  %1278 = add i32 %1277, %1256
  %1279 = call i32 @llvm.umax.i32(i32 %1278, i32 8)
  %1280 = zext i32 %1279 to i64
  %1281 = mul i64 %1280, 32
  %1282 = add i64 %1281, 16
  %1283 = extractvalue { ptr, i32, i32, i32 } %1244, 0
  %1284 = load ptr, ptr %1283, align 8
  %1285 = getelementptr inbounds i8, ptr %1284, i32 -16
  %1286 = call ptr @realloc(ptr %1285, i64 %1282)
  %1287 = getelementptr inbounds i8, ptr %1286, i32 16
  store ptr %1287, ptr %1283, align 8
  %1288 = insertvalue { ptr, i32, i32, i32 } %1254, i32 %1279, 3
  br label %1289

1289:                                             ; preds = %1274, %1275
  %1290 = phi { ptr, i32, i32, i32 } [ %1288, %1275 ], [ %1254, %1274 ]
  br label %1291

1291:                                             ; preds = %1289
  br label %1292

1292:                                             ; preds = %1258, %1291
  %1293 = phi { ptr, i32, i32, i32 } [ %1290, %1291 ], [ %1271, %1258 ]
  br label %1294

1294:                                             ; preds = %1292
  %1295 = extractvalue { ptr, i32, i32, i32 } %1293, 0
  %1296 = load ptr, ptr %1295, align 8
  %1297 = extractvalue { ptr, i32, i32, i32 } %1293, 2
  %1298 = zext i32 %1297 to i64
  %1299 = mul i64 %1298, 32
  %1300 = getelementptr inbounds i8, ptr %1296, i64 %1299
  store i252 %1205, ptr %1300, align 16
  %1301 = extractvalue { ptr, i32, i32, i32 } %1293, 2
  %1302 = add i32 %1301, 1
  %1303 = insertvalue { ptr, i32, i32, i32 } %1293, i32 %1302, 2
  %1304 = getelementptr inbounds i8, ptr %1296, i32 -12
  store i32 %1302, ptr %1304, align 4
  %1305 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1303, 0
  ret { { ptr, i32, i32, i32 } } %1305

1306:                                             ; preds = %2
  %1307 = load { i6, i16 }, ptr %3, align 2
  %1308 = extractvalue { i6, i16 } %1307, 1
  %1309 = icmp slt i16 %1308, 0
  %1310 = zext i16 %1308 to i252
  %1311 = call i16 @llvm.abs.i16(i16 %1308, i1 false)
  %1312 = zext i16 %1311 to i252
  %1313 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1312
  %1314 = select i1 %1309, i252 %1313, i252 %1310
  %1315 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %1316 = icmp eq i32 %1315, 0
  br i1 %1316, label %1317, label %1331

1317:                                             ; preds = %1306
  %1318 = shl i32 %1315, 1
  %1319 = call i32 @llvm.umin.i32(i32 %1318, i32 1024)
  %1320 = add i32 %1319, %1315
  %1321 = call i32 @llvm.umax.i32(i32 %1320, i32 8)
  %1322 = zext i32 %1321 to i64
  %1323 = mul i64 %1322, 32
  %1324 = add i64 %1323, 16
  %1325 = call ptr @realloc(ptr null, i64 %1324)
  store i32 1, ptr %1325, align 4
  %1326 = getelementptr inbounds i8, ptr %1325, i32 4
  store i32 0, ptr %1326, align 4
  %1327 = getelementptr inbounds i8, ptr %1325, i32 16
  %1328 = call ptr @realloc(ptr null, i64 8)
  store ptr %1327, ptr %1328, align 8
  %1329 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1328, 0
  %1330 = insertvalue { ptr, i32, i32, i32 } %1329, i32 %1321, 3
  br label %1352

1331:                                             ; preds = %1306
  %1332 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1333 = icmp ult i32 %1332, %1315
  br i1 %1333, label %1334, label %1335

1334:                                             ; preds = %1331
  br label %1349

1335:                                             ; preds = %1331
  %1336 = shl i32 %1315, 1
  %1337 = call i32 @llvm.umin.i32(i32 %1336, i32 1024)
  %1338 = add i32 %1337, %1315
  %1339 = call i32 @llvm.umax.i32(i32 %1338, i32 8)
  %1340 = zext i32 %1339 to i64
  %1341 = mul i64 %1340, 32
  %1342 = add i64 %1341, 16
  %1343 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1344 = load ptr, ptr %1343, align 8
  %1345 = getelementptr inbounds i8, ptr %1344, i32 -16
  %1346 = call ptr @realloc(ptr %1345, i64 %1342)
  %1347 = getelementptr inbounds i8, ptr %1346, i32 16
  store ptr %1347, ptr %1343, align 8
  %1348 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1339, 3
  br label %1349

1349:                                             ; preds = %1334, %1335
  %1350 = phi { ptr, i32, i32, i32 } [ %1348, %1335 ], [ %1, %1334 ]
  br label %1351

1351:                                             ; preds = %1349
  br label %1352

1352:                                             ; preds = %1317, %1351
  %1353 = phi { ptr, i32, i32, i32 } [ %1350, %1351 ], [ %1330, %1317 ]
  br label %1354

1354:                                             ; preds = %1352
  %1355 = extractvalue { ptr, i32, i32, i32 } %1353, 0
  %1356 = load ptr, ptr %1355, align 8
  %1357 = extractvalue { ptr, i32, i32, i32 } %1353, 2
  %1358 = zext i32 %1357 to i64
  %1359 = mul i64 %1358, 32
  %1360 = getelementptr inbounds i8, ptr %1356, i64 %1359
  store i252 13, ptr %1360, align 16
  %1361 = extractvalue { ptr, i32, i32, i32 } %1353, 2
  %1362 = add i32 %1361, 1
  %1363 = insertvalue { ptr, i32, i32, i32 } %1353, i32 %1362, 2
  %1364 = getelementptr inbounds i8, ptr %1356, i32 -12
  store i32 %1362, ptr %1364, align 4
  %1365 = extractvalue { ptr, i32, i32, i32 } %1353, 3
  %1366 = icmp eq i32 %1365, 0
  br i1 %1366, label %1367, label %1381

1367:                                             ; preds = %1354
  %1368 = shl i32 %1365, 1
  %1369 = call i32 @llvm.umin.i32(i32 %1368, i32 1024)
  %1370 = add i32 %1369, %1365
  %1371 = call i32 @llvm.umax.i32(i32 %1370, i32 8)
  %1372 = zext i32 %1371 to i64
  %1373 = mul i64 %1372, 32
  %1374 = add i64 %1373, 16
  %1375 = call ptr @realloc(ptr null, i64 %1374)
  store i32 1, ptr %1375, align 4
  %1376 = getelementptr inbounds i8, ptr %1375, i32 4
  store i32 0, ptr %1376, align 4
  %1377 = getelementptr inbounds i8, ptr %1375, i32 16
  %1378 = call ptr @realloc(ptr null, i64 8)
  store ptr %1377, ptr %1378, align 8
  %1379 = insertvalue { ptr, i32, i32, i32 } %1363, ptr %1378, 0
  %1380 = insertvalue { ptr, i32, i32, i32 } %1379, i32 %1371, 3
  br label %1401

1381:                                             ; preds = %1354
  %1382 = icmp ult i32 %1362, %1365
  br i1 %1382, label %1383, label %1384

1383:                                             ; preds = %1381
  br label %1398

1384:                                             ; preds = %1381
  %1385 = shl i32 %1365, 1
  %1386 = call i32 @llvm.umin.i32(i32 %1385, i32 1024)
  %1387 = add i32 %1386, %1365
  %1388 = call i32 @llvm.umax.i32(i32 %1387, i32 8)
  %1389 = zext i32 %1388 to i64
  %1390 = mul i64 %1389, 32
  %1391 = add i64 %1390, 16
  %1392 = extractvalue { ptr, i32, i32, i32 } %1353, 0
  %1393 = load ptr, ptr %1392, align 8
  %1394 = getelementptr inbounds i8, ptr %1393, i32 -16
  %1395 = call ptr @realloc(ptr %1394, i64 %1391)
  %1396 = getelementptr inbounds i8, ptr %1395, i32 16
  store ptr %1396, ptr %1392, align 8
  %1397 = insertvalue { ptr, i32, i32, i32 } %1363, i32 %1388, 3
  br label %1398

1398:                                             ; preds = %1383, %1384
  %1399 = phi { ptr, i32, i32, i32 } [ %1397, %1384 ], [ %1363, %1383 ]
  br label %1400

1400:                                             ; preds = %1398
  br label %1401

1401:                                             ; preds = %1367, %1400
  %1402 = phi { ptr, i32, i32, i32 } [ %1399, %1400 ], [ %1380, %1367 ]
  br label %1403

1403:                                             ; preds = %1401
  %1404 = extractvalue { ptr, i32, i32, i32 } %1402, 0
  %1405 = load ptr, ptr %1404, align 8
  %1406 = extractvalue { ptr, i32, i32, i32 } %1402, 2
  %1407 = zext i32 %1406 to i64
  %1408 = mul i64 %1407, 32
  %1409 = getelementptr inbounds i8, ptr %1405, i64 %1408
  store i252 %1314, ptr %1409, align 16
  %1410 = extractvalue { ptr, i32, i32, i32 } %1402, 2
  %1411 = add i32 %1410, 1
  %1412 = insertvalue { ptr, i32, i32, i32 } %1402, i32 %1411, 2
  %1413 = getelementptr inbounds i8, ptr %1405, i32 -12
  store i32 %1411, ptr %1413, align 4
  %1414 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1412, 0
  ret { { ptr, i32, i32, i32 } } %1414

1415:                                             ; preds = %2
  %1416 = load { i6, i16 }, ptr %3, align 2
  %1417 = extractvalue { i6, i16 } %1416, 1
  %1418 = icmp slt i16 %1417, 0
  %1419 = zext i16 %1417 to i252
  %1420 = call i16 @llvm.abs.i16(i16 %1417, i1 false)
  %1421 = zext i16 %1420 to i252
  %1422 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1421
  %1423 = select i1 %1418, i252 %1422, i252 %1419
  %1424 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %1425 = icmp eq i32 %1424, 0
  br i1 %1425, label %1426, label %1440

1426:                                             ; preds = %1415
  %1427 = shl i32 %1424, 1
  %1428 = call i32 @llvm.umin.i32(i32 %1427, i32 1024)
  %1429 = add i32 %1428, %1424
  %1430 = call i32 @llvm.umax.i32(i32 %1429, i32 8)
  %1431 = zext i32 %1430 to i64
  %1432 = mul i64 %1431, 32
  %1433 = add i64 %1432, 16
  %1434 = call ptr @realloc(ptr null, i64 %1433)
  store i32 1, ptr %1434, align 4
  %1435 = getelementptr inbounds i8, ptr %1434, i32 4
  store i32 0, ptr %1435, align 4
  %1436 = getelementptr inbounds i8, ptr %1434, i32 16
  %1437 = call ptr @realloc(ptr null, i64 8)
  store ptr %1436, ptr %1437, align 8
  %1438 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1437, 0
  %1439 = insertvalue { ptr, i32, i32, i32 } %1438, i32 %1430, 3
  br label %1461

1440:                                             ; preds = %1415
  %1441 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1442 = icmp ult i32 %1441, %1424
  br i1 %1442, label %1443, label %1444

1443:                                             ; preds = %1440
  br label %1458

1444:                                             ; preds = %1440
  %1445 = shl i32 %1424, 1
  %1446 = call i32 @llvm.umin.i32(i32 %1445, i32 1024)
  %1447 = add i32 %1446, %1424
  %1448 = call i32 @llvm.umax.i32(i32 %1447, i32 8)
  %1449 = zext i32 %1448 to i64
  %1450 = mul i64 %1449, 32
  %1451 = add i64 %1450, 16
  %1452 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1453 = load ptr, ptr %1452, align 8
  %1454 = getelementptr inbounds i8, ptr %1453, i32 -16
  %1455 = call ptr @realloc(ptr %1454, i64 %1451)
  %1456 = getelementptr inbounds i8, ptr %1455, i32 16
  store ptr %1456, ptr %1452, align 8
  %1457 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1448, 3
  br label %1458

1458:                                             ; preds = %1443, %1444
  %1459 = phi { ptr, i32, i32, i32 } [ %1457, %1444 ], [ %1, %1443 ]
  br label %1460

1460:                                             ; preds = %1458
  br label %1461

1461:                                             ; preds = %1426, %1460
  %1462 = phi { ptr, i32, i32, i32 } [ %1459, %1460 ], [ %1439, %1426 ]
  br label %1463

1463:                                             ; preds = %1461
  %1464 = extractvalue { ptr, i32, i32, i32 } %1462, 0
  %1465 = load ptr, ptr %1464, align 8
  %1466 = extractvalue { ptr, i32, i32, i32 } %1462, 2
  %1467 = zext i32 %1466 to i64
  %1468 = mul i64 %1467, 32
  %1469 = getelementptr inbounds i8, ptr %1465, i64 %1468
  store i252 14, ptr %1469, align 16
  %1470 = extractvalue { ptr, i32, i32, i32 } %1462, 2
  %1471 = add i32 %1470, 1
  %1472 = insertvalue { ptr, i32, i32, i32 } %1462, i32 %1471, 2
  %1473 = getelementptr inbounds i8, ptr %1465, i32 -12
  store i32 %1471, ptr %1473, align 4
  %1474 = extractvalue { ptr, i32, i32, i32 } %1462, 3
  %1475 = icmp eq i32 %1474, 0
  br i1 %1475, label %1476, label %1490

1476:                                             ; preds = %1463
  %1477 = shl i32 %1474, 1
  %1478 = call i32 @llvm.umin.i32(i32 %1477, i32 1024)
  %1479 = add i32 %1478, %1474
  %1480 = call i32 @llvm.umax.i32(i32 %1479, i32 8)
  %1481 = zext i32 %1480 to i64
  %1482 = mul i64 %1481, 32
  %1483 = add i64 %1482, 16
  %1484 = call ptr @realloc(ptr null, i64 %1483)
  store i32 1, ptr %1484, align 4
  %1485 = getelementptr inbounds i8, ptr %1484, i32 4
  store i32 0, ptr %1485, align 4
  %1486 = getelementptr inbounds i8, ptr %1484, i32 16
  %1487 = call ptr @realloc(ptr null, i64 8)
  store ptr %1486, ptr %1487, align 8
  %1488 = insertvalue { ptr, i32, i32, i32 } %1472, ptr %1487, 0
  %1489 = insertvalue { ptr, i32, i32, i32 } %1488, i32 %1480, 3
  br label %1510

1490:                                             ; preds = %1463
  %1491 = icmp ult i32 %1471, %1474
  br i1 %1491, label %1492, label %1493

1492:                                             ; preds = %1490
  br label %1507

1493:                                             ; preds = %1490
  %1494 = shl i32 %1474, 1
  %1495 = call i32 @llvm.umin.i32(i32 %1494, i32 1024)
  %1496 = add i32 %1495, %1474
  %1497 = call i32 @llvm.umax.i32(i32 %1496, i32 8)
  %1498 = zext i32 %1497 to i64
  %1499 = mul i64 %1498, 32
  %1500 = add i64 %1499, 16
  %1501 = extractvalue { ptr, i32, i32, i32 } %1462, 0
  %1502 = load ptr, ptr %1501, align 8
  %1503 = getelementptr inbounds i8, ptr %1502, i32 -16
  %1504 = call ptr @realloc(ptr %1503, i64 %1500)
  %1505 = getelementptr inbounds i8, ptr %1504, i32 16
  store ptr %1505, ptr %1501, align 8
  %1506 = insertvalue { ptr, i32, i32, i32 } %1472, i32 %1497, 3
  br label %1507

1507:                                             ; preds = %1492, %1493
  %1508 = phi { ptr, i32, i32, i32 } [ %1506, %1493 ], [ %1472, %1492 ]
  br label %1509

1509:                                             ; preds = %1507
  br label %1510

1510:                                             ; preds = %1476, %1509
  %1511 = phi { ptr, i32, i32, i32 } [ %1508, %1509 ], [ %1489, %1476 ]
  br label %1512

1512:                                             ; preds = %1510
  %1513 = extractvalue { ptr, i32, i32, i32 } %1511, 0
  %1514 = load ptr, ptr %1513, align 8
  %1515 = extractvalue { ptr, i32, i32, i32 } %1511, 2
  %1516 = zext i32 %1515 to i64
  %1517 = mul i64 %1516, 32
  %1518 = getelementptr inbounds i8, ptr %1514, i64 %1517
  store i252 %1423, ptr %1518, align 16
  %1519 = extractvalue { ptr, i32, i32, i32 } %1511, 2
  %1520 = add i32 %1519, 1
  %1521 = insertvalue { ptr, i32, i32, i32 } %1511, i32 %1520, 2
  %1522 = getelementptr inbounds i8, ptr %1514, i32 -12
  store i32 %1520, ptr %1522, align 4
  %1523 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1521, 0
  ret { { ptr, i32, i32, i32 } } %1523

1524:                                             ; preds = %2
  %1525 = load { i6, { i8, i8, i8, i8 } }, ptr %3, align 1
  %1526 = extractvalue { i6, { i8, i8, i8, i8 } } %1525, 1
  %1527 = extractvalue { i8, i8, i8, i8 } %1526, 0
  %1528 = icmp slt i8 %1527, 0
  %1529 = zext i8 %1527 to i252
  %1530 = call i8 @llvm.abs.i8(i8 %1527, i1 false)
  %1531 = zext i8 %1530 to i252
  %1532 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1531
  %1533 = select i1 %1528, i252 %1532, i252 %1529
  %1534 = extractvalue { i8, i8, i8, i8 } %1526, 1
  %1535 = icmp slt i8 %1534, 0
  %1536 = zext i8 %1534 to i252
  %1537 = call i8 @llvm.abs.i8(i8 %1534, i1 false)
  %1538 = zext i8 %1537 to i252
  %1539 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1538
  %1540 = select i1 %1535, i252 %1539, i252 %1536
  %1541 = extractvalue { i8, i8, i8, i8 } %1526, 2
  %1542 = icmp slt i8 %1541, 0
  %1543 = zext i8 %1541 to i252
  %1544 = call i8 @llvm.abs.i8(i8 %1541, i1 false)
  %1545 = zext i8 %1544 to i252
  %1546 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1545
  %1547 = select i1 %1542, i252 %1546, i252 %1543
  %1548 = extractvalue { i8, i8, i8, i8 } %1526, 3
  %1549 = icmp slt i8 %1548, 0
  %1550 = zext i8 %1548 to i252
  %1551 = call i8 @llvm.abs.i8(i8 %1548, i1 false)
  %1552 = zext i8 %1551 to i252
  %1553 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1552
  %1554 = select i1 %1549, i252 %1553, i252 %1550
  %1555 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %1556 = icmp eq i32 %1555, 0
  br i1 %1556, label %1557, label %1571

1557:                                             ; preds = %1524
  %1558 = shl i32 %1555, 1
  %1559 = call i32 @llvm.umin.i32(i32 %1558, i32 1024)
  %1560 = add i32 %1559, %1555
  %1561 = call i32 @llvm.umax.i32(i32 %1560, i32 8)
  %1562 = zext i32 %1561 to i64
  %1563 = mul i64 %1562, 32
  %1564 = add i64 %1563, 16
  %1565 = call ptr @realloc(ptr null, i64 %1564)
  store i32 1, ptr %1565, align 4
  %1566 = getelementptr inbounds i8, ptr %1565, i32 4
  store i32 0, ptr %1566, align 4
  %1567 = getelementptr inbounds i8, ptr %1565, i32 16
  %1568 = call ptr @realloc(ptr null, i64 8)
  store ptr %1567, ptr %1568, align 8
  %1569 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1568, 0
  %1570 = insertvalue { ptr, i32, i32, i32 } %1569, i32 %1561, 3
  br label %1592

1571:                                             ; preds = %1524
  %1572 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1573 = icmp ult i32 %1572, %1555
  br i1 %1573, label %1574, label %1575

1574:                                             ; preds = %1571
  br label %1589

1575:                                             ; preds = %1571
  %1576 = shl i32 %1555, 1
  %1577 = call i32 @llvm.umin.i32(i32 %1576, i32 1024)
  %1578 = add i32 %1577, %1555
  %1579 = call i32 @llvm.umax.i32(i32 %1578, i32 8)
  %1580 = zext i32 %1579 to i64
  %1581 = mul i64 %1580, 32
  %1582 = add i64 %1581, 16
  %1583 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1584 = load ptr, ptr %1583, align 8
  %1585 = getelementptr inbounds i8, ptr %1584, i32 -16
  %1586 = call ptr @realloc(ptr %1585, i64 %1582)
  %1587 = getelementptr inbounds i8, ptr %1586, i32 16
  store ptr %1587, ptr %1583, align 8
  %1588 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1579, 3
  br label %1589

1589:                                             ; preds = %1574, %1575
  %1590 = phi { ptr, i32, i32, i32 } [ %1588, %1575 ], [ %1, %1574 ]
  br label %1591

1591:                                             ; preds = %1589
  br label %1592

1592:                                             ; preds = %1557, %1591
  %1593 = phi { ptr, i32, i32, i32 } [ %1590, %1591 ], [ %1570, %1557 ]
  br label %1594

1594:                                             ; preds = %1592
  %1595 = extractvalue { ptr, i32, i32, i32 } %1593, 0
  %1596 = load ptr, ptr %1595, align 8
  %1597 = extractvalue { ptr, i32, i32, i32 } %1593, 2
  %1598 = zext i32 %1597 to i64
  %1599 = mul i64 %1598, 32
  %1600 = getelementptr inbounds i8, ptr %1596, i64 %1599
  store i252 15, ptr %1600, align 16
  %1601 = extractvalue { ptr, i32, i32, i32 } %1593, 2
  %1602 = add i32 %1601, 1
  %1603 = insertvalue { ptr, i32, i32, i32 } %1593, i32 %1602, 2
  %1604 = getelementptr inbounds i8, ptr %1596, i32 -12
  store i32 %1602, ptr %1604, align 4
  %1605 = extractvalue { ptr, i32, i32, i32 } %1593, 3
  %1606 = icmp eq i32 %1605, 0
  br i1 %1606, label %1607, label %1621

1607:                                             ; preds = %1594
  %1608 = shl i32 %1605, 1
  %1609 = call i32 @llvm.umin.i32(i32 %1608, i32 1024)
  %1610 = add i32 %1609, %1605
  %1611 = call i32 @llvm.umax.i32(i32 %1610, i32 8)
  %1612 = zext i32 %1611 to i64
  %1613 = mul i64 %1612, 32
  %1614 = add i64 %1613, 16
  %1615 = call ptr @realloc(ptr null, i64 %1614)
  store i32 1, ptr %1615, align 4
  %1616 = getelementptr inbounds i8, ptr %1615, i32 4
  store i32 0, ptr %1616, align 4
  %1617 = getelementptr inbounds i8, ptr %1615, i32 16
  %1618 = call ptr @realloc(ptr null, i64 8)
  store ptr %1617, ptr %1618, align 8
  %1619 = insertvalue { ptr, i32, i32, i32 } %1603, ptr %1618, 0
  %1620 = insertvalue { ptr, i32, i32, i32 } %1619, i32 %1611, 3
  br label %1641

1621:                                             ; preds = %1594
  %1622 = icmp ult i32 %1602, %1605
  br i1 %1622, label %1623, label %1624

1623:                                             ; preds = %1621
  br label %1638

1624:                                             ; preds = %1621
  %1625 = shl i32 %1605, 1
  %1626 = call i32 @llvm.umin.i32(i32 %1625, i32 1024)
  %1627 = add i32 %1626, %1605
  %1628 = call i32 @llvm.umax.i32(i32 %1627, i32 8)
  %1629 = zext i32 %1628 to i64
  %1630 = mul i64 %1629, 32
  %1631 = add i64 %1630, 16
  %1632 = extractvalue { ptr, i32, i32, i32 } %1593, 0
  %1633 = load ptr, ptr %1632, align 8
  %1634 = getelementptr inbounds i8, ptr %1633, i32 -16
  %1635 = call ptr @realloc(ptr %1634, i64 %1631)
  %1636 = getelementptr inbounds i8, ptr %1635, i32 16
  store ptr %1636, ptr %1632, align 8
  %1637 = insertvalue { ptr, i32, i32, i32 } %1603, i32 %1628, 3
  br label %1638

1638:                                             ; preds = %1623, %1624
  %1639 = phi { ptr, i32, i32, i32 } [ %1637, %1624 ], [ %1603, %1623 ]
  br label %1640

1640:                                             ; preds = %1638
  br label %1641

1641:                                             ; preds = %1607, %1640
  %1642 = phi { ptr, i32, i32, i32 } [ %1639, %1640 ], [ %1620, %1607 ]
  br label %1643

1643:                                             ; preds = %1641
  %1644 = extractvalue { ptr, i32, i32, i32 } %1642, 0
  %1645 = load ptr, ptr %1644, align 8
  %1646 = extractvalue { ptr, i32, i32, i32 } %1642, 2
  %1647 = zext i32 %1646 to i64
  %1648 = mul i64 %1647, 32
  %1649 = getelementptr inbounds i8, ptr %1645, i64 %1648
  store i252 %1533, ptr %1649, align 16
  %1650 = extractvalue { ptr, i32, i32, i32 } %1642, 2
  %1651 = add i32 %1650, 1
  %1652 = insertvalue { ptr, i32, i32, i32 } %1642, i32 %1651, 2
  %1653 = getelementptr inbounds i8, ptr %1645, i32 -12
  store i32 %1651, ptr %1653, align 4
  %1654 = extractvalue { ptr, i32, i32, i32 } %1642, 3
  %1655 = icmp eq i32 %1654, 0
  br i1 %1655, label %1656, label %1670

1656:                                             ; preds = %1643
  %1657 = shl i32 %1654, 1
  %1658 = call i32 @llvm.umin.i32(i32 %1657, i32 1024)
  %1659 = add i32 %1658, %1654
  %1660 = call i32 @llvm.umax.i32(i32 %1659, i32 8)
  %1661 = zext i32 %1660 to i64
  %1662 = mul i64 %1661, 32
  %1663 = add i64 %1662, 16
  %1664 = call ptr @realloc(ptr null, i64 %1663)
  store i32 1, ptr %1664, align 4
  %1665 = getelementptr inbounds i8, ptr %1664, i32 4
  store i32 0, ptr %1665, align 4
  %1666 = getelementptr inbounds i8, ptr %1664, i32 16
  %1667 = call ptr @realloc(ptr null, i64 8)
  store ptr %1666, ptr %1667, align 8
  %1668 = insertvalue { ptr, i32, i32, i32 } %1652, ptr %1667, 0
  %1669 = insertvalue { ptr, i32, i32, i32 } %1668, i32 %1660, 3
  br label %1690

1670:                                             ; preds = %1643
  %1671 = icmp ult i32 %1651, %1654
  br i1 %1671, label %1672, label %1673

1672:                                             ; preds = %1670
  br label %1687

1673:                                             ; preds = %1670
  %1674 = shl i32 %1654, 1
  %1675 = call i32 @llvm.umin.i32(i32 %1674, i32 1024)
  %1676 = add i32 %1675, %1654
  %1677 = call i32 @llvm.umax.i32(i32 %1676, i32 8)
  %1678 = zext i32 %1677 to i64
  %1679 = mul i64 %1678, 32
  %1680 = add i64 %1679, 16
  %1681 = extractvalue { ptr, i32, i32, i32 } %1642, 0
  %1682 = load ptr, ptr %1681, align 8
  %1683 = getelementptr inbounds i8, ptr %1682, i32 -16
  %1684 = call ptr @realloc(ptr %1683, i64 %1680)
  %1685 = getelementptr inbounds i8, ptr %1684, i32 16
  store ptr %1685, ptr %1681, align 8
  %1686 = insertvalue { ptr, i32, i32, i32 } %1652, i32 %1677, 3
  br label %1687

1687:                                             ; preds = %1672, %1673
  %1688 = phi { ptr, i32, i32, i32 } [ %1686, %1673 ], [ %1652, %1672 ]
  br label %1689

1689:                                             ; preds = %1687
  br label %1690

1690:                                             ; preds = %1656, %1689
  %1691 = phi { ptr, i32, i32, i32 } [ %1688, %1689 ], [ %1669, %1656 ]
  br label %1692

1692:                                             ; preds = %1690
  %1693 = extractvalue { ptr, i32, i32, i32 } %1691, 0
  %1694 = load ptr, ptr %1693, align 8
  %1695 = extractvalue { ptr, i32, i32, i32 } %1691, 2
  %1696 = zext i32 %1695 to i64
  %1697 = mul i64 %1696, 32
  %1698 = getelementptr inbounds i8, ptr %1694, i64 %1697
  store i252 %1540, ptr %1698, align 16
  %1699 = extractvalue { ptr, i32, i32, i32 } %1691, 2
  %1700 = add i32 %1699, 1
  %1701 = insertvalue { ptr, i32, i32, i32 } %1691, i32 %1700, 2
  %1702 = getelementptr inbounds i8, ptr %1694, i32 -12
  store i32 %1700, ptr %1702, align 4
  %1703 = extractvalue { ptr, i32, i32, i32 } %1691, 3
  %1704 = icmp eq i32 %1703, 0
  br i1 %1704, label %1705, label %1719

1705:                                             ; preds = %1692
  %1706 = shl i32 %1703, 1
  %1707 = call i32 @llvm.umin.i32(i32 %1706, i32 1024)
  %1708 = add i32 %1707, %1703
  %1709 = call i32 @llvm.umax.i32(i32 %1708, i32 8)
  %1710 = zext i32 %1709 to i64
  %1711 = mul i64 %1710, 32
  %1712 = add i64 %1711, 16
  %1713 = call ptr @realloc(ptr null, i64 %1712)
  store i32 1, ptr %1713, align 4
  %1714 = getelementptr inbounds i8, ptr %1713, i32 4
  store i32 0, ptr %1714, align 4
  %1715 = getelementptr inbounds i8, ptr %1713, i32 16
  %1716 = call ptr @realloc(ptr null, i64 8)
  store ptr %1715, ptr %1716, align 8
  %1717 = insertvalue { ptr, i32, i32, i32 } %1701, ptr %1716, 0
  %1718 = insertvalue { ptr, i32, i32, i32 } %1717, i32 %1709, 3
  br label %1739

1719:                                             ; preds = %1692
  %1720 = icmp ult i32 %1700, %1703
  br i1 %1720, label %1721, label %1722

1721:                                             ; preds = %1719
  br label %1736

1722:                                             ; preds = %1719
  %1723 = shl i32 %1703, 1
  %1724 = call i32 @llvm.umin.i32(i32 %1723, i32 1024)
  %1725 = add i32 %1724, %1703
  %1726 = call i32 @llvm.umax.i32(i32 %1725, i32 8)
  %1727 = zext i32 %1726 to i64
  %1728 = mul i64 %1727, 32
  %1729 = add i64 %1728, 16
  %1730 = extractvalue { ptr, i32, i32, i32 } %1691, 0
  %1731 = load ptr, ptr %1730, align 8
  %1732 = getelementptr inbounds i8, ptr %1731, i32 -16
  %1733 = call ptr @realloc(ptr %1732, i64 %1729)
  %1734 = getelementptr inbounds i8, ptr %1733, i32 16
  store ptr %1734, ptr %1730, align 8
  %1735 = insertvalue { ptr, i32, i32, i32 } %1701, i32 %1726, 3
  br label %1736

1736:                                             ; preds = %1721, %1722
  %1737 = phi { ptr, i32, i32, i32 } [ %1735, %1722 ], [ %1701, %1721 ]
  br label %1738

1738:                                             ; preds = %1736
  br label %1739

1739:                                             ; preds = %1705, %1738
  %1740 = phi { ptr, i32, i32, i32 } [ %1737, %1738 ], [ %1718, %1705 ]
  br label %1741

1741:                                             ; preds = %1739
  %1742 = extractvalue { ptr, i32, i32, i32 } %1740, 0
  %1743 = load ptr, ptr %1742, align 8
  %1744 = extractvalue { ptr, i32, i32, i32 } %1740, 2
  %1745 = zext i32 %1744 to i64
  %1746 = mul i64 %1745, 32
  %1747 = getelementptr inbounds i8, ptr %1743, i64 %1746
  store i252 %1547, ptr %1747, align 16
  %1748 = extractvalue { ptr, i32, i32, i32 } %1740, 2
  %1749 = add i32 %1748, 1
  %1750 = insertvalue { ptr, i32, i32, i32 } %1740, i32 %1749, 2
  %1751 = getelementptr inbounds i8, ptr %1743, i32 -12
  store i32 %1749, ptr %1751, align 4
  %1752 = extractvalue { ptr, i32, i32, i32 } %1740, 3
  %1753 = icmp eq i32 %1752, 0
  br i1 %1753, label %1754, label %1768

1754:                                             ; preds = %1741
  %1755 = shl i32 %1752, 1
  %1756 = call i32 @llvm.umin.i32(i32 %1755, i32 1024)
  %1757 = add i32 %1756, %1752
  %1758 = call i32 @llvm.umax.i32(i32 %1757, i32 8)
  %1759 = zext i32 %1758 to i64
  %1760 = mul i64 %1759, 32
  %1761 = add i64 %1760, 16
  %1762 = call ptr @realloc(ptr null, i64 %1761)
  store i32 1, ptr %1762, align 4
  %1763 = getelementptr inbounds i8, ptr %1762, i32 4
  store i32 0, ptr %1763, align 4
  %1764 = getelementptr inbounds i8, ptr %1762, i32 16
  %1765 = call ptr @realloc(ptr null, i64 8)
  store ptr %1764, ptr %1765, align 8
  %1766 = insertvalue { ptr, i32, i32, i32 } %1750, ptr %1765, 0
  %1767 = insertvalue { ptr, i32, i32, i32 } %1766, i32 %1758, 3
  br label %1788

1768:                                             ; preds = %1741
  %1769 = icmp ult i32 %1749, %1752
  br i1 %1769, label %1770, label %1771

1770:                                             ; preds = %1768
  br label %1785

1771:                                             ; preds = %1768
  %1772 = shl i32 %1752, 1
  %1773 = call i32 @llvm.umin.i32(i32 %1772, i32 1024)
  %1774 = add i32 %1773, %1752
  %1775 = call i32 @llvm.umax.i32(i32 %1774, i32 8)
  %1776 = zext i32 %1775 to i64
  %1777 = mul i64 %1776, 32
  %1778 = add i64 %1777, 16
  %1779 = extractvalue { ptr, i32, i32, i32 } %1740, 0
  %1780 = load ptr, ptr %1779, align 8
  %1781 = getelementptr inbounds i8, ptr %1780, i32 -16
  %1782 = call ptr @realloc(ptr %1781, i64 %1778)
  %1783 = getelementptr inbounds i8, ptr %1782, i32 16
  store ptr %1783, ptr %1779, align 8
  %1784 = insertvalue { ptr, i32, i32, i32 } %1750, i32 %1775, 3
  br label %1785

1785:                                             ; preds = %1770, %1771
  %1786 = phi { ptr, i32, i32, i32 } [ %1784, %1771 ], [ %1750, %1770 ]
  br label %1787

1787:                                             ; preds = %1785
  br label %1788

1788:                                             ; preds = %1754, %1787
  %1789 = phi { ptr, i32, i32, i32 } [ %1786, %1787 ], [ %1767, %1754 ]
  br label %1790

1790:                                             ; preds = %1788
  %1791 = extractvalue { ptr, i32, i32, i32 } %1789, 0
  %1792 = load ptr, ptr %1791, align 8
  %1793 = extractvalue { ptr, i32, i32, i32 } %1789, 2
  %1794 = zext i32 %1793 to i64
  %1795 = mul i64 %1794, 32
  %1796 = getelementptr inbounds i8, ptr %1792, i64 %1795
  store i252 %1554, ptr %1796, align 16
  %1797 = extractvalue { ptr, i32, i32, i32 } %1789, 2
  %1798 = add i32 %1797, 1
  %1799 = insertvalue { ptr, i32, i32, i32 } %1789, i32 %1798, 2
  %1800 = getelementptr inbounds i8, ptr %1792, i32 -12
  store i32 %1798, ptr %1800, align 4
  %1801 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1799, 0
  ret { { ptr, i32, i32, i32 } } %1801

1802:                                             ; preds = %2
  %1803 = load { i6, { i8, i8, i8, i8 } }, ptr %3, align 1
  %1804 = extractvalue { i6, { i8, i8, i8, i8 } } %1803, 1
  %1805 = extractvalue { i8, i8, i8, i8 } %1804, 0
  %1806 = icmp slt i8 %1805, 0
  %1807 = zext i8 %1805 to i252
  %1808 = call i8 @llvm.abs.i8(i8 %1805, i1 false)
  %1809 = zext i8 %1808 to i252
  %1810 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1809
  %1811 = select i1 %1806, i252 %1810, i252 %1807
  %1812 = extractvalue { i8, i8, i8, i8 } %1804, 1
  %1813 = icmp slt i8 %1812, 0
  %1814 = zext i8 %1812 to i252
  %1815 = call i8 @llvm.abs.i8(i8 %1812, i1 false)
  %1816 = zext i8 %1815 to i252
  %1817 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1816
  %1818 = select i1 %1813, i252 %1817, i252 %1814
  %1819 = extractvalue { i8, i8, i8, i8 } %1804, 2
  %1820 = icmp slt i8 %1819, 0
  %1821 = zext i8 %1819 to i252
  %1822 = call i8 @llvm.abs.i8(i8 %1819, i1 false)
  %1823 = zext i8 %1822 to i252
  %1824 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1823
  %1825 = select i1 %1820, i252 %1824, i252 %1821
  %1826 = extractvalue { i8, i8, i8, i8 } %1804, 3
  %1827 = icmp slt i8 %1826, 0
  %1828 = zext i8 %1826 to i252
  %1829 = call i8 @llvm.abs.i8(i8 %1826, i1 false)
  %1830 = zext i8 %1829 to i252
  %1831 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %1830
  %1832 = select i1 %1827, i252 %1831, i252 %1828
  %1833 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %1834 = icmp eq i32 %1833, 0
  br i1 %1834, label %1835, label %1849

1835:                                             ; preds = %1802
  %1836 = shl i32 %1833, 1
  %1837 = call i32 @llvm.umin.i32(i32 %1836, i32 1024)
  %1838 = add i32 %1837, %1833
  %1839 = call i32 @llvm.umax.i32(i32 %1838, i32 8)
  %1840 = zext i32 %1839 to i64
  %1841 = mul i64 %1840, 32
  %1842 = add i64 %1841, 16
  %1843 = call ptr @realloc(ptr null, i64 %1842)
  store i32 1, ptr %1843, align 4
  %1844 = getelementptr inbounds i8, ptr %1843, i32 4
  store i32 0, ptr %1844, align 4
  %1845 = getelementptr inbounds i8, ptr %1843, i32 16
  %1846 = call ptr @realloc(ptr null, i64 8)
  store ptr %1845, ptr %1846, align 8
  %1847 = insertvalue { ptr, i32, i32, i32 } %1, ptr %1846, 0
  %1848 = insertvalue { ptr, i32, i32, i32 } %1847, i32 %1839, 3
  br label %1870

1849:                                             ; preds = %1802
  %1850 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %1851 = icmp ult i32 %1850, %1833
  br i1 %1851, label %1852, label %1853

1852:                                             ; preds = %1849
  br label %1867

1853:                                             ; preds = %1849
  %1854 = shl i32 %1833, 1
  %1855 = call i32 @llvm.umin.i32(i32 %1854, i32 1024)
  %1856 = add i32 %1855, %1833
  %1857 = call i32 @llvm.umax.i32(i32 %1856, i32 8)
  %1858 = zext i32 %1857 to i64
  %1859 = mul i64 %1858, 32
  %1860 = add i64 %1859, 16
  %1861 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %1862 = load ptr, ptr %1861, align 8
  %1863 = getelementptr inbounds i8, ptr %1862, i32 -16
  %1864 = call ptr @realloc(ptr %1863, i64 %1860)
  %1865 = getelementptr inbounds i8, ptr %1864, i32 16
  store ptr %1865, ptr %1861, align 8
  %1866 = insertvalue { ptr, i32, i32, i32 } %1, i32 %1857, 3
  br label %1867

1867:                                             ; preds = %1852, %1853
  %1868 = phi { ptr, i32, i32, i32 } [ %1866, %1853 ], [ %1, %1852 ]
  br label %1869

1869:                                             ; preds = %1867
  br label %1870

1870:                                             ; preds = %1835, %1869
  %1871 = phi { ptr, i32, i32, i32 } [ %1868, %1869 ], [ %1848, %1835 ]
  br label %1872

1872:                                             ; preds = %1870
  %1873 = extractvalue { ptr, i32, i32, i32 } %1871, 0
  %1874 = load ptr, ptr %1873, align 8
  %1875 = extractvalue { ptr, i32, i32, i32 } %1871, 2
  %1876 = zext i32 %1875 to i64
  %1877 = mul i64 %1876, 32
  %1878 = getelementptr inbounds i8, ptr %1874, i64 %1877
  store i252 16, ptr %1878, align 16
  %1879 = extractvalue { ptr, i32, i32, i32 } %1871, 2
  %1880 = add i32 %1879, 1
  %1881 = insertvalue { ptr, i32, i32, i32 } %1871, i32 %1880, 2
  %1882 = getelementptr inbounds i8, ptr %1874, i32 -12
  store i32 %1880, ptr %1882, align 4
  %1883 = extractvalue { ptr, i32, i32, i32 } %1871, 3
  %1884 = icmp eq i32 %1883, 0
  br i1 %1884, label %1885, label %1899

1885:                                             ; preds = %1872
  %1886 = shl i32 %1883, 1
  %1887 = call i32 @llvm.umin.i32(i32 %1886, i32 1024)
  %1888 = add i32 %1887, %1883
  %1889 = call i32 @llvm.umax.i32(i32 %1888, i32 8)
  %1890 = zext i32 %1889 to i64
  %1891 = mul i64 %1890, 32
  %1892 = add i64 %1891, 16
  %1893 = call ptr @realloc(ptr null, i64 %1892)
  store i32 1, ptr %1893, align 4
  %1894 = getelementptr inbounds i8, ptr %1893, i32 4
  store i32 0, ptr %1894, align 4
  %1895 = getelementptr inbounds i8, ptr %1893, i32 16
  %1896 = call ptr @realloc(ptr null, i64 8)
  store ptr %1895, ptr %1896, align 8
  %1897 = insertvalue { ptr, i32, i32, i32 } %1881, ptr %1896, 0
  %1898 = insertvalue { ptr, i32, i32, i32 } %1897, i32 %1889, 3
  br label %1919

1899:                                             ; preds = %1872
  %1900 = icmp ult i32 %1880, %1883
  br i1 %1900, label %1901, label %1902

1901:                                             ; preds = %1899
  br label %1916

1902:                                             ; preds = %1899
  %1903 = shl i32 %1883, 1
  %1904 = call i32 @llvm.umin.i32(i32 %1903, i32 1024)
  %1905 = add i32 %1904, %1883
  %1906 = call i32 @llvm.umax.i32(i32 %1905, i32 8)
  %1907 = zext i32 %1906 to i64
  %1908 = mul i64 %1907, 32
  %1909 = add i64 %1908, 16
  %1910 = extractvalue { ptr, i32, i32, i32 } %1871, 0
  %1911 = load ptr, ptr %1910, align 8
  %1912 = getelementptr inbounds i8, ptr %1911, i32 -16
  %1913 = call ptr @realloc(ptr %1912, i64 %1909)
  %1914 = getelementptr inbounds i8, ptr %1913, i32 16
  store ptr %1914, ptr %1910, align 8
  %1915 = insertvalue { ptr, i32, i32, i32 } %1881, i32 %1906, 3
  br label %1916

1916:                                             ; preds = %1901, %1902
  %1917 = phi { ptr, i32, i32, i32 } [ %1915, %1902 ], [ %1881, %1901 ]
  br label %1918

1918:                                             ; preds = %1916
  br label %1919

1919:                                             ; preds = %1885, %1918
  %1920 = phi { ptr, i32, i32, i32 } [ %1917, %1918 ], [ %1898, %1885 ]
  br label %1921

1921:                                             ; preds = %1919
  %1922 = extractvalue { ptr, i32, i32, i32 } %1920, 0
  %1923 = load ptr, ptr %1922, align 8
  %1924 = extractvalue { ptr, i32, i32, i32 } %1920, 2
  %1925 = zext i32 %1924 to i64
  %1926 = mul i64 %1925, 32
  %1927 = getelementptr inbounds i8, ptr %1923, i64 %1926
  store i252 %1811, ptr %1927, align 16
  %1928 = extractvalue { ptr, i32, i32, i32 } %1920, 2
  %1929 = add i32 %1928, 1
  %1930 = insertvalue { ptr, i32, i32, i32 } %1920, i32 %1929, 2
  %1931 = getelementptr inbounds i8, ptr %1923, i32 -12
  store i32 %1929, ptr %1931, align 4
  %1932 = extractvalue { ptr, i32, i32, i32 } %1920, 3
  %1933 = icmp eq i32 %1932, 0
  br i1 %1933, label %1934, label %1948

1934:                                             ; preds = %1921
  %1935 = shl i32 %1932, 1
  %1936 = call i32 @llvm.umin.i32(i32 %1935, i32 1024)
  %1937 = add i32 %1936, %1932
  %1938 = call i32 @llvm.umax.i32(i32 %1937, i32 8)
  %1939 = zext i32 %1938 to i64
  %1940 = mul i64 %1939, 32
  %1941 = add i64 %1940, 16
  %1942 = call ptr @realloc(ptr null, i64 %1941)
  store i32 1, ptr %1942, align 4
  %1943 = getelementptr inbounds i8, ptr %1942, i32 4
  store i32 0, ptr %1943, align 4
  %1944 = getelementptr inbounds i8, ptr %1942, i32 16
  %1945 = call ptr @realloc(ptr null, i64 8)
  store ptr %1944, ptr %1945, align 8
  %1946 = insertvalue { ptr, i32, i32, i32 } %1930, ptr %1945, 0
  %1947 = insertvalue { ptr, i32, i32, i32 } %1946, i32 %1938, 3
  br label %1968

1948:                                             ; preds = %1921
  %1949 = icmp ult i32 %1929, %1932
  br i1 %1949, label %1950, label %1951

1950:                                             ; preds = %1948
  br label %1965

1951:                                             ; preds = %1948
  %1952 = shl i32 %1932, 1
  %1953 = call i32 @llvm.umin.i32(i32 %1952, i32 1024)
  %1954 = add i32 %1953, %1932
  %1955 = call i32 @llvm.umax.i32(i32 %1954, i32 8)
  %1956 = zext i32 %1955 to i64
  %1957 = mul i64 %1956, 32
  %1958 = add i64 %1957, 16
  %1959 = extractvalue { ptr, i32, i32, i32 } %1920, 0
  %1960 = load ptr, ptr %1959, align 8
  %1961 = getelementptr inbounds i8, ptr %1960, i32 -16
  %1962 = call ptr @realloc(ptr %1961, i64 %1958)
  %1963 = getelementptr inbounds i8, ptr %1962, i32 16
  store ptr %1963, ptr %1959, align 8
  %1964 = insertvalue { ptr, i32, i32, i32 } %1930, i32 %1955, 3
  br label %1965

1965:                                             ; preds = %1950, %1951
  %1966 = phi { ptr, i32, i32, i32 } [ %1964, %1951 ], [ %1930, %1950 ]
  br label %1967

1967:                                             ; preds = %1965
  br label %1968

1968:                                             ; preds = %1934, %1967
  %1969 = phi { ptr, i32, i32, i32 } [ %1966, %1967 ], [ %1947, %1934 ]
  br label %1970

1970:                                             ; preds = %1968
  %1971 = extractvalue { ptr, i32, i32, i32 } %1969, 0
  %1972 = load ptr, ptr %1971, align 8
  %1973 = extractvalue { ptr, i32, i32, i32 } %1969, 2
  %1974 = zext i32 %1973 to i64
  %1975 = mul i64 %1974, 32
  %1976 = getelementptr inbounds i8, ptr %1972, i64 %1975
  store i252 %1818, ptr %1976, align 16
  %1977 = extractvalue { ptr, i32, i32, i32 } %1969, 2
  %1978 = add i32 %1977, 1
  %1979 = insertvalue { ptr, i32, i32, i32 } %1969, i32 %1978, 2
  %1980 = getelementptr inbounds i8, ptr %1972, i32 -12
  store i32 %1978, ptr %1980, align 4
  %1981 = extractvalue { ptr, i32, i32, i32 } %1969, 3
  %1982 = icmp eq i32 %1981, 0
  br i1 %1982, label %1983, label %1997

1983:                                             ; preds = %1970
  %1984 = shl i32 %1981, 1
  %1985 = call i32 @llvm.umin.i32(i32 %1984, i32 1024)
  %1986 = add i32 %1985, %1981
  %1987 = call i32 @llvm.umax.i32(i32 %1986, i32 8)
  %1988 = zext i32 %1987 to i64
  %1989 = mul i64 %1988, 32
  %1990 = add i64 %1989, 16
  %1991 = call ptr @realloc(ptr null, i64 %1990)
  store i32 1, ptr %1991, align 4
  %1992 = getelementptr inbounds i8, ptr %1991, i32 4
  store i32 0, ptr %1992, align 4
  %1993 = getelementptr inbounds i8, ptr %1991, i32 16
  %1994 = call ptr @realloc(ptr null, i64 8)
  store ptr %1993, ptr %1994, align 8
  %1995 = insertvalue { ptr, i32, i32, i32 } %1979, ptr %1994, 0
  %1996 = insertvalue { ptr, i32, i32, i32 } %1995, i32 %1987, 3
  br label %2017

1997:                                             ; preds = %1970
  %1998 = icmp ult i32 %1978, %1981
  br i1 %1998, label %1999, label %2000

1999:                                             ; preds = %1997
  br label %2014

2000:                                             ; preds = %1997
  %2001 = shl i32 %1981, 1
  %2002 = call i32 @llvm.umin.i32(i32 %2001, i32 1024)
  %2003 = add i32 %2002, %1981
  %2004 = call i32 @llvm.umax.i32(i32 %2003, i32 8)
  %2005 = zext i32 %2004 to i64
  %2006 = mul i64 %2005, 32
  %2007 = add i64 %2006, 16
  %2008 = extractvalue { ptr, i32, i32, i32 } %1969, 0
  %2009 = load ptr, ptr %2008, align 8
  %2010 = getelementptr inbounds i8, ptr %2009, i32 -16
  %2011 = call ptr @realloc(ptr %2010, i64 %2007)
  %2012 = getelementptr inbounds i8, ptr %2011, i32 16
  store ptr %2012, ptr %2008, align 8
  %2013 = insertvalue { ptr, i32, i32, i32 } %1979, i32 %2004, 3
  br label %2014

2014:                                             ; preds = %1999, %2000
  %2015 = phi { ptr, i32, i32, i32 } [ %2013, %2000 ], [ %1979, %1999 ]
  br label %2016

2016:                                             ; preds = %2014
  br label %2017

2017:                                             ; preds = %1983, %2016
  %2018 = phi { ptr, i32, i32, i32 } [ %2015, %2016 ], [ %1996, %1983 ]
  br label %2019

2019:                                             ; preds = %2017
  %2020 = extractvalue { ptr, i32, i32, i32 } %2018, 0
  %2021 = load ptr, ptr %2020, align 8
  %2022 = extractvalue { ptr, i32, i32, i32 } %2018, 2
  %2023 = zext i32 %2022 to i64
  %2024 = mul i64 %2023, 32
  %2025 = getelementptr inbounds i8, ptr %2021, i64 %2024
  store i252 %1825, ptr %2025, align 16
  %2026 = extractvalue { ptr, i32, i32, i32 } %2018, 2
  %2027 = add i32 %2026, 1
  %2028 = insertvalue { ptr, i32, i32, i32 } %2018, i32 %2027, 2
  %2029 = getelementptr inbounds i8, ptr %2021, i32 -12
  store i32 %2027, ptr %2029, align 4
  %2030 = extractvalue { ptr, i32, i32, i32 } %2018, 3
  %2031 = icmp eq i32 %2030, 0
  br i1 %2031, label %2032, label %2046

2032:                                             ; preds = %2019
  %2033 = shl i32 %2030, 1
  %2034 = call i32 @llvm.umin.i32(i32 %2033, i32 1024)
  %2035 = add i32 %2034, %2030
  %2036 = call i32 @llvm.umax.i32(i32 %2035, i32 8)
  %2037 = zext i32 %2036 to i64
  %2038 = mul i64 %2037, 32
  %2039 = add i64 %2038, 16
  %2040 = call ptr @realloc(ptr null, i64 %2039)
  store i32 1, ptr %2040, align 4
  %2041 = getelementptr inbounds i8, ptr %2040, i32 4
  store i32 0, ptr %2041, align 4
  %2042 = getelementptr inbounds i8, ptr %2040, i32 16
  %2043 = call ptr @realloc(ptr null, i64 8)
  store ptr %2042, ptr %2043, align 8
  %2044 = insertvalue { ptr, i32, i32, i32 } %2028, ptr %2043, 0
  %2045 = insertvalue { ptr, i32, i32, i32 } %2044, i32 %2036, 3
  br label %2066

2046:                                             ; preds = %2019
  %2047 = icmp ult i32 %2027, %2030
  br i1 %2047, label %2048, label %2049

2048:                                             ; preds = %2046
  br label %2063

2049:                                             ; preds = %2046
  %2050 = shl i32 %2030, 1
  %2051 = call i32 @llvm.umin.i32(i32 %2050, i32 1024)
  %2052 = add i32 %2051, %2030
  %2053 = call i32 @llvm.umax.i32(i32 %2052, i32 8)
  %2054 = zext i32 %2053 to i64
  %2055 = mul i64 %2054, 32
  %2056 = add i64 %2055, 16
  %2057 = extractvalue { ptr, i32, i32, i32 } %2018, 0
  %2058 = load ptr, ptr %2057, align 8
  %2059 = getelementptr inbounds i8, ptr %2058, i32 -16
  %2060 = call ptr @realloc(ptr %2059, i64 %2056)
  %2061 = getelementptr inbounds i8, ptr %2060, i32 16
  store ptr %2061, ptr %2057, align 8
  %2062 = insertvalue { ptr, i32, i32, i32 } %2028, i32 %2053, 3
  br label %2063

2063:                                             ; preds = %2048, %2049
  %2064 = phi { ptr, i32, i32, i32 } [ %2062, %2049 ], [ %2028, %2048 ]
  br label %2065

2065:                                             ; preds = %2063
  br label %2066

2066:                                             ; preds = %2032, %2065
  %2067 = phi { ptr, i32, i32, i32 } [ %2064, %2065 ], [ %2045, %2032 ]
  br label %2068

2068:                                             ; preds = %2066
  %2069 = extractvalue { ptr, i32, i32, i32 } %2067, 0
  %2070 = load ptr, ptr %2069, align 8
  %2071 = extractvalue { ptr, i32, i32, i32 } %2067, 2
  %2072 = zext i32 %2071 to i64
  %2073 = mul i64 %2072, 32
  %2074 = getelementptr inbounds i8, ptr %2070, i64 %2073
  store i252 %1832, ptr %2074, align 16
  %2075 = extractvalue { ptr, i32, i32, i32 } %2067, 2
  %2076 = add i32 %2075, 1
  %2077 = insertvalue { ptr, i32, i32, i32 } %2067, i32 %2076, 2
  %2078 = getelementptr inbounds i8, ptr %2070, i32 -12
  store i32 %2076, ptr %2078, align 4
  %2079 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2077, 0
  ret { { ptr, i32, i32, i32 } } %2079

2080:                                             ; preds = %2
  %2081 = load { i6, { i16, i16, i16 } }, ptr %3, align 2
  %2082 = extractvalue { i6, { i16, i16, i16 } } %2081, 1
  %2083 = extractvalue { i16, i16, i16 } %2082, 0
  %2084 = icmp slt i16 %2083, 0
  %2085 = zext i16 %2083 to i252
  %2086 = call i16 @llvm.abs.i16(i16 %2083, i1 false)
  %2087 = zext i16 %2086 to i252
  %2088 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2087
  %2089 = select i1 %2084, i252 %2088, i252 %2085
  %2090 = extractvalue { i16, i16, i16 } %2082, 1
  %2091 = icmp slt i16 %2090, 0
  %2092 = zext i16 %2090 to i252
  %2093 = call i16 @llvm.abs.i16(i16 %2090, i1 false)
  %2094 = zext i16 %2093 to i252
  %2095 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2094
  %2096 = select i1 %2091, i252 %2095, i252 %2092
  %2097 = extractvalue { i16, i16, i16 } %2082, 2
  %2098 = icmp slt i16 %2097, 0
  %2099 = zext i16 %2097 to i252
  %2100 = call i16 @llvm.abs.i16(i16 %2097, i1 false)
  %2101 = zext i16 %2100 to i252
  %2102 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2101
  %2103 = select i1 %2098, i252 %2102, i252 %2099
  %2104 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2105 = icmp eq i32 %2104, 0
  br i1 %2105, label %2106, label %2120

2106:                                             ; preds = %2080
  %2107 = shl i32 %2104, 1
  %2108 = call i32 @llvm.umin.i32(i32 %2107, i32 1024)
  %2109 = add i32 %2108, %2104
  %2110 = call i32 @llvm.umax.i32(i32 %2109, i32 8)
  %2111 = zext i32 %2110 to i64
  %2112 = mul i64 %2111, 32
  %2113 = add i64 %2112, 16
  %2114 = call ptr @realloc(ptr null, i64 %2113)
  store i32 1, ptr %2114, align 4
  %2115 = getelementptr inbounds i8, ptr %2114, i32 4
  store i32 0, ptr %2115, align 4
  %2116 = getelementptr inbounds i8, ptr %2114, i32 16
  %2117 = call ptr @realloc(ptr null, i64 8)
  store ptr %2116, ptr %2117, align 8
  %2118 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2117, 0
  %2119 = insertvalue { ptr, i32, i32, i32 } %2118, i32 %2110, 3
  br label %2141

2120:                                             ; preds = %2080
  %2121 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2122 = icmp ult i32 %2121, %2104
  br i1 %2122, label %2123, label %2124

2123:                                             ; preds = %2120
  br label %2138

2124:                                             ; preds = %2120
  %2125 = shl i32 %2104, 1
  %2126 = call i32 @llvm.umin.i32(i32 %2125, i32 1024)
  %2127 = add i32 %2126, %2104
  %2128 = call i32 @llvm.umax.i32(i32 %2127, i32 8)
  %2129 = zext i32 %2128 to i64
  %2130 = mul i64 %2129, 32
  %2131 = add i64 %2130, 16
  %2132 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2133 = load ptr, ptr %2132, align 8
  %2134 = getelementptr inbounds i8, ptr %2133, i32 -16
  %2135 = call ptr @realloc(ptr %2134, i64 %2131)
  %2136 = getelementptr inbounds i8, ptr %2135, i32 16
  store ptr %2136, ptr %2132, align 8
  %2137 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2128, 3
  br label %2138

2138:                                             ; preds = %2123, %2124
  %2139 = phi { ptr, i32, i32, i32 } [ %2137, %2124 ], [ %1, %2123 ]
  br label %2140

2140:                                             ; preds = %2138
  br label %2141

2141:                                             ; preds = %2106, %2140
  %2142 = phi { ptr, i32, i32, i32 } [ %2139, %2140 ], [ %2119, %2106 ]
  br label %2143

2143:                                             ; preds = %2141
  %2144 = extractvalue { ptr, i32, i32, i32 } %2142, 0
  %2145 = load ptr, ptr %2144, align 8
  %2146 = extractvalue { ptr, i32, i32, i32 } %2142, 2
  %2147 = zext i32 %2146 to i64
  %2148 = mul i64 %2147, 32
  %2149 = getelementptr inbounds i8, ptr %2145, i64 %2148
  store i252 17, ptr %2149, align 16
  %2150 = extractvalue { ptr, i32, i32, i32 } %2142, 2
  %2151 = add i32 %2150, 1
  %2152 = insertvalue { ptr, i32, i32, i32 } %2142, i32 %2151, 2
  %2153 = getelementptr inbounds i8, ptr %2145, i32 -12
  store i32 %2151, ptr %2153, align 4
  %2154 = extractvalue { ptr, i32, i32, i32 } %2142, 3
  %2155 = icmp eq i32 %2154, 0
  br i1 %2155, label %2156, label %2170

2156:                                             ; preds = %2143
  %2157 = shl i32 %2154, 1
  %2158 = call i32 @llvm.umin.i32(i32 %2157, i32 1024)
  %2159 = add i32 %2158, %2154
  %2160 = call i32 @llvm.umax.i32(i32 %2159, i32 8)
  %2161 = zext i32 %2160 to i64
  %2162 = mul i64 %2161, 32
  %2163 = add i64 %2162, 16
  %2164 = call ptr @realloc(ptr null, i64 %2163)
  store i32 1, ptr %2164, align 4
  %2165 = getelementptr inbounds i8, ptr %2164, i32 4
  store i32 0, ptr %2165, align 4
  %2166 = getelementptr inbounds i8, ptr %2164, i32 16
  %2167 = call ptr @realloc(ptr null, i64 8)
  store ptr %2166, ptr %2167, align 8
  %2168 = insertvalue { ptr, i32, i32, i32 } %2152, ptr %2167, 0
  %2169 = insertvalue { ptr, i32, i32, i32 } %2168, i32 %2160, 3
  br label %2190

2170:                                             ; preds = %2143
  %2171 = icmp ult i32 %2151, %2154
  br i1 %2171, label %2172, label %2173

2172:                                             ; preds = %2170
  br label %2187

2173:                                             ; preds = %2170
  %2174 = shl i32 %2154, 1
  %2175 = call i32 @llvm.umin.i32(i32 %2174, i32 1024)
  %2176 = add i32 %2175, %2154
  %2177 = call i32 @llvm.umax.i32(i32 %2176, i32 8)
  %2178 = zext i32 %2177 to i64
  %2179 = mul i64 %2178, 32
  %2180 = add i64 %2179, 16
  %2181 = extractvalue { ptr, i32, i32, i32 } %2142, 0
  %2182 = load ptr, ptr %2181, align 8
  %2183 = getelementptr inbounds i8, ptr %2182, i32 -16
  %2184 = call ptr @realloc(ptr %2183, i64 %2180)
  %2185 = getelementptr inbounds i8, ptr %2184, i32 16
  store ptr %2185, ptr %2181, align 8
  %2186 = insertvalue { ptr, i32, i32, i32 } %2152, i32 %2177, 3
  br label %2187

2187:                                             ; preds = %2172, %2173
  %2188 = phi { ptr, i32, i32, i32 } [ %2186, %2173 ], [ %2152, %2172 ]
  br label %2189

2189:                                             ; preds = %2187
  br label %2190

2190:                                             ; preds = %2156, %2189
  %2191 = phi { ptr, i32, i32, i32 } [ %2188, %2189 ], [ %2169, %2156 ]
  br label %2192

2192:                                             ; preds = %2190
  %2193 = extractvalue { ptr, i32, i32, i32 } %2191, 0
  %2194 = load ptr, ptr %2193, align 8
  %2195 = extractvalue { ptr, i32, i32, i32 } %2191, 2
  %2196 = zext i32 %2195 to i64
  %2197 = mul i64 %2196, 32
  %2198 = getelementptr inbounds i8, ptr %2194, i64 %2197
  store i252 %2089, ptr %2198, align 16
  %2199 = extractvalue { ptr, i32, i32, i32 } %2191, 2
  %2200 = add i32 %2199, 1
  %2201 = insertvalue { ptr, i32, i32, i32 } %2191, i32 %2200, 2
  %2202 = getelementptr inbounds i8, ptr %2194, i32 -12
  store i32 %2200, ptr %2202, align 4
  %2203 = extractvalue { ptr, i32, i32, i32 } %2191, 3
  %2204 = icmp eq i32 %2203, 0
  br i1 %2204, label %2205, label %2219

2205:                                             ; preds = %2192
  %2206 = shl i32 %2203, 1
  %2207 = call i32 @llvm.umin.i32(i32 %2206, i32 1024)
  %2208 = add i32 %2207, %2203
  %2209 = call i32 @llvm.umax.i32(i32 %2208, i32 8)
  %2210 = zext i32 %2209 to i64
  %2211 = mul i64 %2210, 32
  %2212 = add i64 %2211, 16
  %2213 = call ptr @realloc(ptr null, i64 %2212)
  store i32 1, ptr %2213, align 4
  %2214 = getelementptr inbounds i8, ptr %2213, i32 4
  store i32 0, ptr %2214, align 4
  %2215 = getelementptr inbounds i8, ptr %2213, i32 16
  %2216 = call ptr @realloc(ptr null, i64 8)
  store ptr %2215, ptr %2216, align 8
  %2217 = insertvalue { ptr, i32, i32, i32 } %2201, ptr %2216, 0
  %2218 = insertvalue { ptr, i32, i32, i32 } %2217, i32 %2209, 3
  br label %2239

2219:                                             ; preds = %2192
  %2220 = icmp ult i32 %2200, %2203
  br i1 %2220, label %2221, label %2222

2221:                                             ; preds = %2219
  br label %2236

2222:                                             ; preds = %2219
  %2223 = shl i32 %2203, 1
  %2224 = call i32 @llvm.umin.i32(i32 %2223, i32 1024)
  %2225 = add i32 %2224, %2203
  %2226 = call i32 @llvm.umax.i32(i32 %2225, i32 8)
  %2227 = zext i32 %2226 to i64
  %2228 = mul i64 %2227, 32
  %2229 = add i64 %2228, 16
  %2230 = extractvalue { ptr, i32, i32, i32 } %2191, 0
  %2231 = load ptr, ptr %2230, align 8
  %2232 = getelementptr inbounds i8, ptr %2231, i32 -16
  %2233 = call ptr @realloc(ptr %2232, i64 %2229)
  %2234 = getelementptr inbounds i8, ptr %2233, i32 16
  store ptr %2234, ptr %2230, align 8
  %2235 = insertvalue { ptr, i32, i32, i32 } %2201, i32 %2226, 3
  br label %2236

2236:                                             ; preds = %2221, %2222
  %2237 = phi { ptr, i32, i32, i32 } [ %2235, %2222 ], [ %2201, %2221 ]
  br label %2238

2238:                                             ; preds = %2236
  br label %2239

2239:                                             ; preds = %2205, %2238
  %2240 = phi { ptr, i32, i32, i32 } [ %2237, %2238 ], [ %2218, %2205 ]
  br label %2241

2241:                                             ; preds = %2239
  %2242 = extractvalue { ptr, i32, i32, i32 } %2240, 0
  %2243 = load ptr, ptr %2242, align 8
  %2244 = extractvalue { ptr, i32, i32, i32 } %2240, 2
  %2245 = zext i32 %2244 to i64
  %2246 = mul i64 %2245, 32
  %2247 = getelementptr inbounds i8, ptr %2243, i64 %2246
  store i252 %2096, ptr %2247, align 16
  %2248 = extractvalue { ptr, i32, i32, i32 } %2240, 2
  %2249 = add i32 %2248, 1
  %2250 = insertvalue { ptr, i32, i32, i32 } %2240, i32 %2249, 2
  %2251 = getelementptr inbounds i8, ptr %2243, i32 -12
  store i32 %2249, ptr %2251, align 4
  %2252 = extractvalue { ptr, i32, i32, i32 } %2240, 3
  %2253 = icmp eq i32 %2252, 0
  br i1 %2253, label %2254, label %2268

2254:                                             ; preds = %2241
  %2255 = shl i32 %2252, 1
  %2256 = call i32 @llvm.umin.i32(i32 %2255, i32 1024)
  %2257 = add i32 %2256, %2252
  %2258 = call i32 @llvm.umax.i32(i32 %2257, i32 8)
  %2259 = zext i32 %2258 to i64
  %2260 = mul i64 %2259, 32
  %2261 = add i64 %2260, 16
  %2262 = call ptr @realloc(ptr null, i64 %2261)
  store i32 1, ptr %2262, align 4
  %2263 = getelementptr inbounds i8, ptr %2262, i32 4
  store i32 0, ptr %2263, align 4
  %2264 = getelementptr inbounds i8, ptr %2262, i32 16
  %2265 = call ptr @realloc(ptr null, i64 8)
  store ptr %2264, ptr %2265, align 8
  %2266 = insertvalue { ptr, i32, i32, i32 } %2250, ptr %2265, 0
  %2267 = insertvalue { ptr, i32, i32, i32 } %2266, i32 %2258, 3
  br label %2288

2268:                                             ; preds = %2241
  %2269 = icmp ult i32 %2249, %2252
  br i1 %2269, label %2270, label %2271

2270:                                             ; preds = %2268
  br label %2285

2271:                                             ; preds = %2268
  %2272 = shl i32 %2252, 1
  %2273 = call i32 @llvm.umin.i32(i32 %2272, i32 1024)
  %2274 = add i32 %2273, %2252
  %2275 = call i32 @llvm.umax.i32(i32 %2274, i32 8)
  %2276 = zext i32 %2275 to i64
  %2277 = mul i64 %2276, 32
  %2278 = add i64 %2277, 16
  %2279 = extractvalue { ptr, i32, i32, i32 } %2240, 0
  %2280 = load ptr, ptr %2279, align 8
  %2281 = getelementptr inbounds i8, ptr %2280, i32 -16
  %2282 = call ptr @realloc(ptr %2281, i64 %2278)
  %2283 = getelementptr inbounds i8, ptr %2282, i32 16
  store ptr %2283, ptr %2279, align 8
  %2284 = insertvalue { ptr, i32, i32, i32 } %2250, i32 %2275, 3
  br label %2285

2285:                                             ; preds = %2270, %2271
  %2286 = phi { ptr, i32, i32, i32 } [ %2284, %2271 ], [ %2250, %2270 ]
  br label %2287

2287:                                             ; preds = %2285
  br label %2288

2288:                                             ; preds = %2254, %2287
  %2289 = phi { ptr, i32, i32, i32 } [ %2286, %2287 ], [ %2267, %2254 ]
  br label %2290

2290:                                             ; preds = %2288
  %2291 = extractvalue { ptr, i32, i32, i32 } %2289, 0
  %2292 = load ptr, ptr %2291, align 8
  %2293 = extractvalue { ptr, i32, i32, i32 } %2289, 2
  %2294 = zext i32 %2293 to i64
  %2295 = mul i64 %2294, 32
  %2296 = getelementptr inbounds i8, ptr %2292, i64 %2295
  store i252 %2103, ptr %2296, align 16
  %2297 = extractvalue { ptr, i32, i32, i32 } %2289, 2
  %2298 = add i32 %2297, 1
  %2299 = insertvalue { ptr, i32, i32, i32 } %2289, i32 %2298, 2
  %2300 = getelementptr inbounds i8, ptr %2292, i32 -12
  store i32 %2298, ptr %2300, align 4
  %2301 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2299, 0
  ret { { ptr, i32, i32, i32 } } %2301

2302:                                             ; preds = %2
  %2303 = load { i6, i8 }, ptr %3, align 1
  %2304 = extractvalue { i6, i8 } %2303, 1
  %2305 = icmp slt i8 %2304, 0
  %2306 = zext i8 %2304 to i252
  %2307 = call i8 @llvm.abs.i8(i8 %2304, i1 false)
  %2308 = zext i8 %2307 to i252
  %2309 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2308
  %2310 = select i1 %2305, i252 %2309, i252 %2306
  %2311 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2312 = icmp eq i32 %2311, 0
  br i1 %2312, label %2313, label %2327

2313:                                             ; preds = %2302
  %2314 = shl i32 %2311, 1
  %2315 = call i32 @llvm.umin.i32(i32 %2314, i32 1024)
  %2316 = add i32 %2315, %2311
  %2317 = call i32 @llvm.umax.i32(i32 %2316, i32 8)
  %2318 = zext i32 %2317 to i64
  %2319 = mul i64 %2318, 32
  %2320 = add i64 %2319, 16
  %2321 = call ptr @realloc(ptr null, i64 %2320)
  store i32 1, ptr %2321, align 4
  %2322 = getelementptr inbounds i8, ptr %2321, i32 4
  store i32 0, ptr %2322, align 4
  %2323 = getelementptr inbounds i8, ptr %2321, i32 16
  %2324 = call ptr @realloc(ptr null, i64 8)
  store ptr %2323, ptr %2324, align 8
  %2325 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2324, 0
  %2326 = insertvalue { ptr, i32, i32, i32 } %2325, i32 %2317, 3
  br label %2348

2327:                                             ; preds = %2302
  %2328 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2329 = icmp ult i32 %2328, %2311
  br i1 %2329, label %2330, label %2331

2330:                                             ; preds = %2327
  br label %2345

2331:                                             ; preds = %2327
  %2332 = shl i32 %2311, 1
  %2333 = call i32 @llvm.umin.i32(i32 %2332, i32 1024)
  %2334 = add i32 %2333, %2311
  %2335 = call i32 @llvm.umax.i32(i32 %2334, i32 8)
  %2336 = zext i32 %2335 to i64
  %2337 = mul i64 %2336, 32
  %2338 = add i64 %2337, 16
  %2339 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2340 = load ptr, ptr %2339, align 8
  %2341 = getelementptr inbounds i8, ptr %2340, i32 -16
  %2342 = call ptr @realloc(ptr %2341, i64 %2338)
  %2343 = getelementptr inbounds i8, ptr %2342, i32 16
  store ptr %2343, ptr %2339, align 8
  %2344 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2335, 3
  br label %2345

2345:                                             ; preds = %2330, %2331
  %2346 = phi { ptr, i32, i32, i32 } [ %2344, %2331 ], [ %1, %2330 ]
  br label %2347

2347:                                             ; preds = %2345
  br label %2348

2348:                                             ; preds = %2313, %2347
  %2349 = phi { ptr, i32, i32, i32 } [ %2346, %2347 ], [ %2326, %2313 ]
  br label %2350

2350:                                             ; preds = %2348
  %2351 = extractvalue { ptr, i32, i32, i32 } %2349, 0
  %2352 = load ptr, ptr %2351, align 8
  %2353 = extractvalue { ptr, i32, i32, i32 } %2349, 2
  %2354 = zext i32 %2353 to i64
  %2355 = mul i64 %2354, 32
  %2356 = getelementptr inbounds i8, ptr %2352, i64 %2355
  store i252 18, ptr %2356, align 16
  %2357 = extractvalue { ptr, i32, i32, i32 } %2349, 2
  %2358 = add i32 %2357, 1
  %2359 = insertvalue { ptr, i32, i32, i32 } %2349, i32 %2358, 2
  %2360 = getelementptr inbounds i8, ptr %2352, i32 -12
  store i32 %2358, ptr %2360, align 4
  %2361 = extractvalue { ptr, i32, i32, i32 } %2349, 3
  %2362 = icmp eq i32 %2361, 0
  br i1 %2362, label %2363, label %2377

2363:                                             ; preds = %2350
  %2364 = shl i32 %2361, 1
  %2365 = call i32 @llvm.umin.i32(i32 %2364, i32 1024)
  %2366 = add i32 %2365, %2361
  %2367 = call i32 @llvm.umax.i32(i32 %2366, i32 8)
  %2368 = zext i32 %2367 to i64
  %2369 = mul i64 %2368, 32
  %2370 = add i64 %2369, 16
  %2371 = call ptr @realloc(ptr null, i64 %2370)
  store i32 1, ptr %2371, align 4
  %2372 = getelementptr inbounds i8, ptr %2371, i32 4
  store i32 0, ptr %2372, align 4
  %2373 = getelementptr inbounds i8, ptr %2371, i32 16
  %2374 = call ptr @realloc(ptr null, i64 8)
  store ptr %2373, ptr %2374, align 8
  %2375 = insertvalue { ptr, i32, i32, i32 } %2359, ptr %2374, 0
  %2376 = insertvalue { ptr, i32, i32, i32 } %2375, i32 %2367, 3
  br label %2397

2377:                                             ; preds = %2350
  %2378 = icmp ult i32 %2358, %2361
  br i1 %2378, label %2379, label %2380

2379:                                             ; preds = %2377
  br label %2394

2380:                                             ; preds = %2377
  %2381 = shl i32 %2361, 1
  %2382 = call i32 @llvm.umin.i32(i32 %2381, i32 1024)
  %2383 = add i32 %2382, %2361
  %2384 = call i32 @llvm.umax.i32(i32 %2383, i32 8)
  %2385 = zext i32 %2384 to i64
  %2386 = mul i64 %2385, 32
  %2387 = add i64 %2386, 16
  %2388 = extractvalue { ptr, i32, i32, i32 } %2349, 0
  %2389 = load ptr, ptr %2388, align 8
  %2390 = getelementptr inbounds i8, ptr %2389, i32 -16
  %2391 = call ptr @realloc(ptr %2390, i64 %2387)
  %2392 = getelementptr inbounds i8, ptr %2391, i32 16
  store ptr %2392, ptr %2388, align 8
  %2393 = insertvalue { ptr, i32, i32, i32 } %2359, i32 %2384, 3
  br label %2394

2394:                                             ; preds = %2379, %2380
  %2395 = phi { ptr, i32, i32, i32 } [ %2393, %2380 ], [ %2359, %2379 ]
  br label %2396

2396:                                             ; preds = %2394
  br label %2397

2397:                                             ; preds = %2363, %2396
  %2398 = phi { ptr, i32, i32, i32 } [ %2395, %2396 ], [ %2376, %2363 ]
  br label %2399

2399:                                             ; preds = %2397
  %2400 = extractvalue { ptr, i32, i32, i32 } %2398, 0
  %2401 = load ptr, ptr %2400, align 8
  %2402 = extractvalue { ptr, i32, i32, i32 } %2398, 2
  %2403 = zext i32 %2402 to i64
  %2404 = mul i64 %2403, 32
  %2405 = getelementptr inbounds i8, ptr %2401, i64 %2404
  store i252 %2310, ptr %2405, align 16
  %2406 = extractvalue { ptr, i32, i32, i32 } %2398, 2
  %2407 = add i32 %2406, 1
  %2408 = insertvalue { ptr, i32, i32, i32 } %2398, i32 %2407, 2
  %2409 = getelementptr inbounds i8, ptr %2401, i32 -12
  store i32 %2407, ptr %2409, align 4
  %2410 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2408, 0
  ret { { ptr, i32, i32, i32 } } %2410

2411:                                             ; preds = %2
  %2412 = load { i6, i8 }, ptr %3, align 1
  %2413 = extractvalue { i6, i8 } %2412, 1
  %2414 = icmp slt i8 %2413, 0
  %2415 = zext i8 %2413 to i252
  %2416 = call i8 @llvm.abs.i8(i8 %2413, i1 false)
  %2417 = zext i8 %2416 to i252
  %2418 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2417
  %2419 = select i1 %2414, i252 %2418, i252 %2415
  %2420 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2421 = icmp eq i32 %2420, 0
  br i1 %2421, label %2422, label %2436

2422:                                             ; preds = %2411
  %2423 = shl i32 %2420, 1
  %2424 = call i32 @llvm.umin.i32(i32 %2423, i32 1024)
  %2425 = add i32 %2424, %2420
  %2426 = call i32 @llvm.umax.i32(i32 %2425, i32 8)
  %2427 = zext i32 %2426 to i64
  %2428 = mul i64 %2427, 32
  %2429 = add i64 %2428, 16
  %2430 = call ptr @realloc(ptr null, i64 %2429)
  store i32 1, ptr %2430, align 4
  %2431 = getelementptr inbounds i8, ptr %2430, i32 4
  store i32 0, ptr %2431, align 4
  %2432 = getelementptr inbounds i8, ptr %2430, i32 16
  %2433 = call ptr @realloc(ptr null, i64 8)
  store ptr %2432, ptr %2433, align 8
  %2434 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2433, 0
  %2435 = insertvalue { ptr, i32, i32, i32 } %2434, i32 %2426, 3
  br label %2457

2436:                                             ; preds = %2411
  %2437 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2438 = icmp ult i32 %2437, %2420
  br i1 %2438, label %2439, label %2440

2439:                                             ; preds = %2436
  br label %2454

2440:                                             ; preds = %2436
  %2441 = shl i32 %2420, 1
  %2442 = call i32 @llvm.umin.i32(i32 %2441, i32 1024)
  %2443 = add i32 %2442, %2420
  %2444 = call i32 @llvm.umax.i32(i32 %2443, i32 8)
  %2445 = zext i32 %2444 to i64
  %2446 = mul i64 %2445, 32
  %2447 = add i64 %2446, 16
  %2448 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2449 = load ptr, ptr %2448, align 8
  %2450 = getelementptr inbounds i8, ptr %2449, i32 -16
  %2451 = call ptr @realloc(ptr %2450, i64 %2447)
  %2452 = getelementptr inbounds i8, ptr %2451, i32 16
  store ptr %2452, ptr %2448, align 8
  %2453 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2444, 3
  br label %2454

2454:                                             ; preds = %2439, %2440
  %2455 = phi { ptr, i32, i32, i32 } [ %2453, %2440 ], [ %1, %2439 ]
  br label %2456

2456:                                             ; preds = %2454
  br label %2457

2457:                                             ; preds = %2422, %2456
  %2458 = phi { ptr, i32, i32, i32 } [ %2455, %2456 ], [ %2435, %2422 ]
  br label %2459

2459:                                             ; preds = %2457
  %2460 = extractvalue { ptr, i32, i32, i32 } %2458, 0
  %2461 = load ptr, ptr %2460, align 8
  %2462 = extractvalue { ptr, i32, i32, i32 } %2458, 2
  %2463 = zext i32 %2462 to i64
  %2464 = mul i64 %2463, 32
  %2465 = getelementptr inbounds i8, ptr %2461, i64 %2464
  store i252 19, ptr %2465, align 16
  %2466 = extractvalue { ptr, i32, i32, i32 } %2458, 2
  %2467 = add i32 %2466, 1
  %2468 = insertvalue { ptr, i32, i32, i32 } %2458, i32 %2467, 2
  %2469 = getelementptr inbounds i8, ptr %2461, i32 -12
  store i32 %2467, ptr %2469, align 4
  %2470 = extractvalue { ptr, i32, i32, i32 } %2458, 3
  %2471 = icmp eq i32 %2470, 0
  br i1 %2471, label %2472, label %2486

2472:                                             ; preds = %2459
  %2473 = shl i32 %2470, 1
  %2474 = call i32 @llvm.umin.i32(i32 %2473, i32 1024)
  %2475 = add i32 %2474, %2470
  %2476 = call i32 @llvm.umax.i32(i32 %2475, i32 8)
  %2477 = zext i32 %2476 to i64
  %2478 = mul i64 %2477, 32
  %2479 = add i64 %2478, 16
  %2480 = call ptr @realloc(ptr null, i64 %2479)
  store i32 1, ptr %2480, align 4
  %2481 = getelementptr inbounds i8, ptr %2480, i32 4
  store i32 0, ptr %2481, align 4
  %2482 = getelementptr inbounds i8, ptr %2480, i32 16
  %2483 = call ptr @realloc(ptr null, i64 8)
  store ptr %2482, ptr %2483, align 8
  %2484 = insertvalue { ptr, i32, i32, i32 } %2468, ptr %2483, 0
  %2485 = insertvalue { ptr, i32, i32, i32 } %2484, i32 %2476, 3
  br label %2506

2486:                                             ; preds = %2459
  %2487 = icmp ult i32 %2467, %2470
  br i1 %2487, label %2488, label %2489

2488:                                             ; preds = %2486
  br label %2503

2489:                                             ; preds = %2486
  %2490 = shl i32 %2470, 1
  %2491 = call i32 @llvm.umin.i32(i32 %2490, i32 1024)
  %2492 = add i32 %2491, %2470
  %2493 = call i32 @llvm.umax.i32(i32 %2492, i32 8)
  %2494 = zext i32 %2493 to i64
  %2495 = mul i64 %2494, 32
  %2496 = add i64 %2495, 16
  %2497 = extractvalue { ptr, i32, i32, i32 } %2458, 0
  %2498 = load ptr, ptr %2497, align 8
  %2499 = getelementptr inbounds i8, ptr %2498, i32 -16
  %2500 = call ptr @realloc(ptr %2499, i64 %2496)
  %2501 = getelementptr inbounds i8, ptr %2500, i32 16
  store ptr %2501, ptr %2497, align 8
  %2502 = insertvalue { ptr, i32, i32, i32 } %2468, i32 %2493, 3
  br label %2503

2503:                                             ; preds = %2488, %2489
  %2504 = phi { ptr, i32, i32, i32 } [ %2502, %2489 ], [ %2468, %2488 ]
  br label %2505

2505:                                             ; preds = %2503
  br label %2506

2506:                                             ; preds = %2472, %2505
  %2507 = phi { ptr, i32, i32, i32 } [ %2504, %2505 ], [ %2485, %2472 ]
  br label %2508

2508:                                             ; preds = %2506
  %2509 = extractvalue { ptr, i32, i32, i32 } %2507, 0
  %2510 = load ptr, ptr %2509, align 8
  %2511 = extractvalue { ptr, i32, i32, i32 } %2507, 2
  %2512 = zext i32 %2511 to i64
  %2513 = mul i64 %2512, 32
  %2514 = getelementptr inbounds i8, ptr %2510, i64 %2513
  store i252 %2419, ptr %2514, align 16
  %2515 = extractvalue { ptr, i32, i32, i32 } %2507, 2
  %2516 = add i32 %2515, 1
  %2517 = insertvalue { ptr, i32, i32, i32 } %2507, i32 %2516, 2
  %2518 = getelementptr inbounds i8, ptr %2510, i32 -12
  store i32 %2516, ptr %2518, align 4
  %2519 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2517, 0
  ret { { ptr, i32, i32, i32 } } %2519

2520:                                             ; preds = %2
  %2521 = load { i6, i8 }, ptr %3, align 1
  %2522 = extractvalue { i6, i8 } %2521, 1
  %2523 = icmp slt i8 %2522, 0
  %2524 = zext i8 %2522 to i252
  %2525 = call i8 @llvm.abs.i8(i8 %2522, i1 false)
  %2526 = zext i8 %2525 to i252
  %2527 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2526
  %2528 = select i1 %2523, i252 %2527, i252 %2524
  %2529 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2530 = icmp eq i32 %2529, 0
  br i1 %2530, label %2531, label %2545

2531:                                             ; preds = %2520
  %2532 = shl i32 %2529, 1
  %2533 = call i32 @llvm.umin.i32(i32 %2532, i32 1024)
  %2534 = add i32 %2533, %2529
  %2535 = call i32 @llvm.umax.i32(i32 %2534, i32 8)
  %2536 = zext i32 %2535 to i64
  %2537 = mul i64 %2536, 32
  %2538 = add i64 %2537, 16
  %2539 = call ptr @realloc(ptr null, i64 %2538)
  store i32 1, ptr %2539, align 4
  %2540 = getelementptr inbounds i8, ptr %2539, i32 4
  store i32 0, ptr %2540, align 4
  %2541 = getelementptr inbounds i8, ptr %2539, i32 16
  %2542 = call ptr @realloc(ptr null, i64 8)
  store ptr %2541, ptr %2542, align 8
  %2543 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2542, 0
  %2544 = insertvalue { ptr, i32, i32, i32 } %2543, i32 %2535, 3
  br label %2566

2545:                                             ; preds = %2520
  %2546 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2547 = icmp ult i32 %2546, %2529
  br i1 %2547, label %2548, label %2549

2548:                                             ; preds = %2545
  br label %2563

2549:                                             ; preds = %2545
  %2550 = shl i32 %2529, 1
  %2551 = call i32 @llvm.umin.i32(i32 %2550, i32 1024)
  %2552 = add i32 %2551, %2529
  %2553 = call i32 @llvm.umax.i32(i32 %2552, i32 8)
  %2554 = zext i32 %2553 to i64
  %2555 = mul i64 %2554, 32
  %2556 = add i64 %2555, 16
  %2557 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2558 = load ptr, ptr %2557, align 8
  %2559 = getelementptr inbounds i8, ptr %2558, i32 -16
  %2560 = call ptr @realloc(ptr %2559, i64 %2556)
  %2561 = getelementptr inbounds i8, ptr %2560, i32 16
  store ptr %2561, ptr %2557, align 8
  %2562 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2553, 3
  br label %2563

2563:                                             ; preds = %2548, %2549
  %2564 = phi { ptr, i32, i32, i32 } [ %2562, %2549 ], [ %1, %2548 ]
  br label %2565

2565:                                             ; preds = %2563
  br label %2566

2566:                                             ; preds = %2531, %2565
  %2567 = phi { ptr, i32, i32, i32 } [ %2564, %2565 ], [ %2544, %2531 ]
  br label %2568

2568:                                             ; preds = %2566
  %2569 = extractvalue { ptr, i32, i32, i32 } %2567, 0
  %2570 = load ptr, ptr %2569, align 8
  %2571 = extractvalue { ptr, i32, i32, i32 } %2567, 2
  %2572 = zext i32 %2571 to i64
  %2573 = mul i64 %2572, 32
  %2574 = getelementptr inbounds i8, ptr %2570, i64 %2573
  store i252 20, ptr %2574, align 16
  %2575 = extractvalue { ptr, i32, i32, i32 } %2567, 2
  %2576 = add i32 %2575, 1
  %2577 = insertvalue { ptr, i32, i32, i32 } %2567, i32 %2576, 2
  %2578 = getelementptr inbounds i8, ptr %2570, i32 -12
  store i32 %2576, ptr %2578, align 4
  %2579 = extractvalue { ptr, i32, i32, i32 } %2567, 3
  %2580 = icmp eq i32 %2579, 0
  br i1 %2580, label %2581, label %2595

2581:                                             ; preds = %2568
  %2582 = shl i32 %2579, 1
  %2583 = call i32 @llvm.umin.i32(i32 %2582, i32 1024)
  %2584 = add i32 %2583, %2579
  %2585 = call i32 @llvm.umax.i32(i32 %2584, i32 8)
  %2586 = zext i32 %2585 to i64
  %2587 = mul i64 %2586, 32
  %2588 = add i64 %2587, 16
  %2589 = call ptr @realloc(ptr null, i64 %2588)
  store i32 1, ptr %2589, align 4
  %2590 = getelementptr inbounds i8, ptr %2589, i32 4
  store i32 0, ptr %2590, align 4
  %2591 = getelementptr inbounds i8, ptr %2589, i32 16
  %2592 = call ptr @realloc(ptr null, i64 8)
  store ptr %2591, ptr %2592, align 8
  %2593 = insertvalue { ptr, i32, i32, i32 } %2577, ptr %2592, 0
  %2594 = insertvalue { ptr, i32, i32, i32 } %2593, i32 %2585, 3
  br label %2615

2595:                                             ; preds = %2568
  %2596 = icmp ult i32 %2576, %2579
  br i1 %2596, label %2597, label %2598

2597:                                             ; preds = %2595
  br label %2612

2598:                                             ; preds = %2595
  %2599 = shl i32 %2579, 1
  %2600 = call i32 @llvm.umin.i32(i32 %2599, i32 1024)
  %2601 = add i32 %2600, %2579
  %2602 = call i32 @llvm.umax.i32(i32 %2601, i32 8)
  %2603 = zext i32 %2602 to i64
  %2604 = mul i64 %2603, 32
  %2605 = add i64 %2604, 16
  %2606 = extractvalue { ptr, i32, i32, i32 } %2567, 0
  %2607 = load ptr, ptr %2606, align 8
  %2608 = getelementptr inbounds i8, ptr %2607, i32 -16
  %2609 = call ptr @realloc(ptr %2608, i64 %2605)
  %2610 = getelementptr inbounds i8, ptr %2609, i32 16
  store ptr %2610, ptr %2606, align 8
  %2611 = insertvalue { ptr, i32, i32, i32 } %2577, i32 %2602, 3
  br label %2612

2612:                                             ; preds = %2597, %2598
  %2613 = phi { ptr, i32, i32, i32 } [ %2611, %2598 ], [ %2577, %2597 ]
  br label %2614

2614:                                             ; preds = %2612
  br label %2615

2615:                                             ; preds = %2581, %2614
  %2616 = phi { ptr, i32, i32, i32 } [ %2613, %2614 ], [ %2594, %2581 ]
  br label %2617

2617:                                             ; preds = %2615
  %2618 = extractvalue { ptr, i32, i32, i32 } %2616, 0
  %2619 = load ptr, ptr %2618, align 8
  %2620 = extractvalue { ptr, i32, i32, i32 } %2616, 2
  %2621 = zext i32 %2620 to i64
  %2622 = mul i64 %2621, 32
  %2623 = getelementptr inbounds i8, ptr %2619, i64 %2622
  store i252 %2528, ptr %2623, align 16
  %2624 = extractvalue { ptr, i32, i32, i32 } %2616, 2
  %2625 = add i32 %2624, 1
  %2626 = insertvalue { ptr, i32, i32, i32 } %2616, i32 %2625, 2
  %2627 = getelementptr inbounds i8, ptr %2619, i32 -12
  store i32 %2625, ptr %2627, align 4
  %2628 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2626, 0
  ret { { ptr, i32, i32, i32 } } %2628

2629:                                             ; preds = %2
  %2630 = load { i6, i8 }, ptr %3, align 1
  %2631 = extractvalue { i6, i8 } %2630, 1
  %2632 = icmp slt i8 %2631, 0
  %2633 = zext i8 %2631 to i252
  %2634 = call i8 @llvm.abs.i8(i8 %2631, i1 false)
  %2635 = zext i8 %2634 to i252
  %2636 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2635
  %2637 = select i1 %2632, i252 %2636, i252 %2633
  %2638 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2639 = icmp eq i32 %2638, 0
  br i1 %2639, label %2640, label %2654

2640:                                             ; preds = %2629
  %2641 = shl i32 %2638, 1
  %2642 = call i32 @llvm.umin.i32(i32 %2641, i32 1024)
  %2643 = add i32 %2642, %2638
  %2644 = call i32 @llvm.umax.i32(i32 %2643, i32 8)
  %2645 = zext i32 %2644 to i64
  %2646 = mul i64 %2645, 32
  %2647 = add i64 %2646, 16
  %2648 = call ptr @realloc(ptr null, i64 %2647)
  store i32 1, ptr %2648, align 4
  %2649 = getelementptr inbounds i8, ptr %2648, i32 4
  store i32 0, ptr %2649, align 4
  %2650 = getelementptr inbounds i8, ptr %2648, i32 16
  %2651 = call ptr @realloc(ptr null, i64 8)
  store ptr %2650, ptr %2651, align 8
  %2652 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2651, 0
  %2653 = insertvalue { ptr, i32, i32, i32 } %2652, i32 %2644, 3
  br label %2675

2654:                                             ; preds = %2629
  %2655 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2656 = icmp ult i32 %2655, %2638
  br i1 %2656, label %2657, label %2658

2657:                                             ; preds = %2654
  br label %2672

2658:                                             ; preds = %2654
  %2659 = shl i32 %2638, 1
  %2660 = call i32 @llvm.umin.i32(i32 %2659, i32 1024)
  %2661 = add i32 %2660, %2638
  %2662 = call i32 @llvm.umax.i32(i32 %2661, i32 8)
  %2663 = zext i32 %2662 to i64
  %2664 = mul i64 %2663, 32
  %2665 = add i64 %2664, 16
  %2666 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2667 = load ptr, ptr %2666, align 8
  %2668 = getelementptr inbounds i8, ptr %2667, i32 -16
  %2669 = call ptr @realloc(ptr %2668, i64 %2665)
  %2670 = getelementptr inbounds i8, ptr %2669, i32 16
  store ptr %2670, ptr %2666, align 8
  %2671 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2662, 3
  br label %2672

2672:                                             ; preds = %2657, %2658
  %2673 = phi { ptr, i32, i32, i32 } [ %2671, %2658 ], [ %1, %2657 ]
  br label %2674

2674:                                             ; preds = %2672
  br label %2675

2675:                                             ; preds = %2640, %2674
  %2676 = phi { ptr, i32, i32, i32 } [ %2673, %2674 ], [ %2653, %2640 ]
  br label %2677

2677:                                             ; preds = %2675
  %2678 = extractvalue { ptr, i32, i32, i32 } %2676, 0
  %2679 = load ptr, ptr %2678, align 8
  %2680 = extractvalue { ptr, i32, i32, i32 } %2676, 2
  %2681 = zext i32 %2680 to i64
  %2682 = mul i64 %2681, 32
  %2683 = getelementptr inbounds i8, ptr %2679, i64 %2682
  store i252 21, ptr %2683, align 16
  %2684 = extractvalue { ptr, i32, i32, i32 } %2676, 2
  %2685 = add i32 %2684, 1
  %2686 = insertvalue { ptr, i32, i32, i32 } %2676, i32 %2685, 2
  %2687 = getelementptr inbounds i8, ptr %2679, i32 -12
  store i32 %2685, ptr %2687, align 4
  %2688 = extractvalue { ptr, i32, i32, i32 } %2676, 3
  %2689 = icmp eq i32 %2688, 0
  br i1 %2689, label %2690, label %2704

2690:                                             ; preds = %2677
  %2691 = shl i32 %2688, 1
  %2692 = call i32 @llvm.umin.i32(i32 %2691, i32 1024)
  %2693 = add i32 %2692, %2688
  %2694 = call i32 @llvm.umax.i32(i32 %2693, i32 8)
  %2695 = zext i32 %2694 to i64
  %2696 = mul i64 %2695, 32
  %2697 = add i64 %2696, 16
  %2698 = call ptr @realloc(ptr null, i64 %2697)
  store i32 1, ptr %2698, align 4
  %2699 = getelementptr inbounds i8, ptr %2698, i32 4
  store i32 0, ptr %2699, align 4
  %2700 = getelementptr inbounds i8, ptr %2698, i32 16
  %2701 = call ptr @realloc(ptr null, i64 8)
  store ptr %2700, ptr %2701, align 8
  %2702 = insertvalue { ptr, i32, i32, i32 } %2686, ptr %2701, 0
  %2703 = insertvalue { ptr, i32, i32, i32 } %2702, i32 %2694, 3
  br label %2724

2704:                                             ; preds = %2677
  %2705 = icmp ult i32 %2685, %2688
  br i1 %2705, label %2706, label %2707

2706:                                             ; preds = %2704
  br label %2721

2707:                                             ; preds = %2704
  %2708 = shl i32 %2688, 1
  %2709 = call i32 @llvm.umin.i32(i32 %2708, i32 1024)
  %2710 = add i32 %2709, %2688
  %2711 = call i32 @llvm.umax.i32(i32 %2710, i32 8)
  %2712 = zext i32 %2711 to i64
  %2713 = mul i64 %2712, 32
  %2714 = add i64 %2713, 16
  %2715 = extractvalue { ptr, i32, i32, i32 } %2676, 0
  %2716 = load ptr, ptr %2715, align 8
  %2717 = getelementptr inbounds i8, ptr %2716, i32 -16
  %2718 = call ptr @realloc(ptr %2717, i64 %2714)
  %2719 = getelementptr inbounds i8, ptr %2718, i32 16
  store ptr %2719, ptr %2715, align 8
  %2720 = insertvalue { ptr, i32, i32, i32 } %2686, i32 %2711, 3
  br label %2721

2721:                                             ; preds = %2706, %2707
  %2722 = phi { ptr, i32, i32, i32 } [ %2720, %2707 ], [ %2686, %2706 ]
  br label %2723

2723:                                             ; preds = %2721
  br label %2724

2724:                                             ; preds = %2690, %2723
  %2725 = phi { ptr, i32, i32, i32 } [ %2722, %2723 ], [ %2703, %2690 ]
  br label %2726

2726:                                             ; preds = %2724
  %2727 = extractvalue { ptr, i32, i32, i32 } %2725, 0
  %2728 = load ptr, ptr %2727, align 8
  %2729 = extractvalue { ptr, i32, i32, i32 } %2725, 2
  %2730 = zext i32 %2729 to i64
  %2731 = mul i64 %2730, 32
  %2732 = getelementptr inbounds i8, ptr %2728, i64 %2731
  store i252 %2637, ptr %2732, align 16
  %2733 = extractvalue { ptr, i32, i32, i32 } %2725, 2
  %2734 = add i32 %2733, 1
  %2735 = insertvalue { ptr, i32, i32, i32 } %2725, i32 %2734, 2
  %2736 = getelementptr inbounds i8, ptr %2728, i32 -12
  store i32 %2734, ptr %2736, align 4
  %2737 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2735, 0
  ret { { ptr, i32, i32, i32 } } %2737

2738:                                             ; preds = %2
  %2739 = load { i6, i8 }, ptr %3, align 1
  %2740 = extractvalue { i6, i8 } %2739, 1
  %2741 = icmp slt i8 %2740, 0
  %2742 = zext i8 %2740 to i252
  %2743 = call i8 @llvm.abs.i8(i8 %2740, i1 false)
  %2744 = zext i8 %2743 to i252
  %2745 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2744
  %2746 = select i1 %2741, i252 %2745, i252 %2742
  %2747 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2748 = icmp eq i32 %2747, 0
  br i1 %2748, label %2749, label %2763

2749:                                             ; preds = %2738
  %2750 = shl i32 %2747, 1
  %2751 = call i32 @llvm.umin.i32(i32 %2750, i32 1024)
  %2752 = add i32 %2751, %2747
  %2753 = call i32 @llvm.umax.i32(i32 %2752, i32 8)
  %2754 = zext i32 %2753 to i64
  %2755 = mul i64 %2754, 32
  %2756 = add i64 %2755, 16
  %2757 = call ptr @realloc(ptr null, i64 %2756)
  store i32 1, ptr %2757, align 4
  %2758 = getelementptr inbounds i8, ptr %2757, i32 4
  store i32 0, ptr %2758, align 4
  %2759 = getelementptr inbounds i8, ptr %2757, i32 16
  %2760 = call ptr @realloc(ptr null, i64 8)
  store ptr %2759, ptr %2760, align 8
  %2761 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2760, 0
  %2762 = insertvalue { ptr, i32, i32, i32 } %2761, i32 %2753, 3
  br label %2784

2763:                                             ; preds = %2738
  %2764 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2765 = icmp ult i32 %2764, %2747
  br i1 %2765, label %2766, label %2767

2766:                                             ; preds = %2763
  br label %2781

2767:                                             ; preds = %2763
  %2768 = shl i32 %2747, 1
  %2769 = call i32 @llvm.umin.i32(i32 %2768, i32 1024)
  %2770 = add i32 %2769, %2747
  %2771 = call i32 @llvm.umax.i32(i32 %2770, i32 8)
  %2772 = zext i32 %2771 to i64
  %2773 = mul i64 %2772, 32
  %2774 = add i64 %2773, 16
  %2775 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2776 = load ptr, ptr %2775, align 8
  %2777 = getelementptr inbounds i8, ptr %2776, i32 -16
  %2778 = call ptr @realloc(ptr %2777, i64 %2774)
  %2779 = getelementptr inbounds i8, ptr %2778, i32 16
  store ptr %2779, ptr %2775, align 8
  %2780 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2771, 3
  br label %2781

2781:                                             ; preds = %2766, %2767
  %2782 = phi { ptr, i32, i32, i32 } [ %2780, %2767 ], [ %1, %2766 ]
  br label %2783

2783:                                             ; preds = %2781
  br label %2784

2784:                                             ; preds = %2749, %2783
  %2785 = phi { ptr, i32, i32, i32 } [ %2782, %2783 ], [ %2762, %2749 ]
  br label %2786

2786:                                             ; preds = %2784
  %2787 = extractvalue { ptr, i32, i32, i32 } %2785, 0
  %2788 = load ptr, ptr %2787, align 8
  %2789 = extractvalue { ptr, i32, i32, i32 } %2785, 2
  %2790 = zext i32 %2789 to i64
  %2791 = mul i64 %2790, 32
  %2792 = getelementptr inbounds i8, ptr %2788, i64 %2791
  store i252 22, ptr %2792, align 16
  %2793 = extractvalue { ptr, i32, i32, i32 } %2785, 2
  %2794 = add i32 %2793, 1
  %2795 = insertvalue { ptr, i32, i32, i32 } %2785, i32 %2794, 2
  %2796 = getelementptr inbounds i8, ptr %2788, i32 -12
  store i32 %2794, ptr %2796, align 4
  %2797 = extractvalue { ptr, i32, i32, i32 } %2785, 3
  %2798 = icmp eq i32 %2797, 0
  br i1 %2798, label %2799, label %2813

2799:                                             ; preds = %2786
  %2800 = shl i32 %2797, 1
  %2801 = call i32 @llvm.umin.i32(i32 %2800, i32 1024)
  %2802 = add i32 %2801, %2797
  %2803 = call i32 @llvm.umax.i32(i32 %2802, i32 8)
  %2804 = zext i32 %2803 to i64
  %2805 = mul i64 %2804, 32
  %2806 = add i64 %2805, 16
  %2807 = call ptr @realloc(ptr null, i64 %2806)
  store i32 1, ptr %2807, align 4
  %2808 = getelementptr inbounds i8, ptr %2807, i32 4
  store i32 0, ptr %2808, align 4
  %2809 = getelementptr inbounds i8, ptr %2807, i32 16
  %2810 = call ptr @realloc(ptr null, i64 8)
  store ptr %2809, ptr %2810, align 8
  %2811 = insertvalue { ptr, i32, i32, i32 } %2795, ptr %2810, 0
  %2812 = insertvalue { ptr, i32, i32, i32 } %2811, i32 %2803, 3
  br label %2833

2813:                                             ; preds = %2786
  %2814 = icmp ult i32 %2794, %2797
  br i1 %2814, label %2815, label %2816

2815:                                             ; preds = %2813
  br label %2830

2816:                                             ; preds = %2813
  %2817 = shl i32 %2797, 1
  %2818 = call i32 @llvm.umin.i32(i32 %2817, i32 1024)
  %2819 = add i32 %2818, %2797
  %2820 = call i32 @llvm.umax.i32(i32 %2819, i32 8)
  %2821 = zext i32 %2820 to i64
  %2822 = mul i64 %2821, 32
  %2823 = add i64 %2822, 16
  %2824 = extractvalue { ptr, i32, i32, i32 } %2785, 0
  %2825 = load ptr, ptr %2824, align 8
  %2826 = getelementptr inbounds i8, ptr %2825, i32 -16
  %2827 = call ptr @realloc(ptr %2826, i64 %2823)
  %2828 = getelementptr inbounds i8, ptr %2827, i32 16
  store ptr %2828, ptr %2824, align 8
  %2829 = insertvalue { ptr, i32, i32, i32 } %2795, i32 %2820, 3
  br label %2830

2830:                                             ; preds = %2815, %2816
  %2831 = phi { ptr, i32, i32, i32 } [ %2829, %2816 ], [ %2795, %2815 ]
  br label %2832

2832:                                             ; preds = %2830
  br label %2833

2833:                                             ; preds = %2799, %2832
  %2834 = phi { ptr, i32, i32, i32 } [ %2831, %2832 ], [ %2812, %2799 ]
  br label %2835

2835:                                             ; preds = %2833
  %2836 = extractvalue { ptr, i32, i32, i32 } %2834, 0
  %2837 = load ptr, ptr %2836, align 8
  %2838 = extractvalue { ptr, i32, i32, i32 } %2834, 2
  %2839 = zext i32 %2838 to i64
  %2840 = mul i64 %2839, 32
  %2841 = getelementptr inbounds i8, ptr %2837, i64 %2840
  store i252 %2746, ptr %2841, align 16
  %2842 = extractvalue { ptr, i32, i32, i32 } %2834, 2
  %2843 = add i32 %2842, 1
  %2844 = insertvalue { ptr, i32, i32, i32 } %2834, i32 %2843, 2
  %2845 = getelementptr inbounds i8, ptr %2837, i32 -12
  store i32 %2843, ptr %2845, align 4
  %2846 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2844, 0
  ret { { ptr, i32, i32, i32 } } %2846

2847:                                             ; preds = %2
  %2848 = load { i6, i8 }, ptr %3, align 1
  %2849 = extractvalue { i6, i8 } %2848, 1
  %2850 = icmp slt i8 %2849, 0
  %2851 = zext i8 %2849 to i252
  %2852 = call i8 @llvm.abs.i8(i8 %2849, i1 false)
  %2853 = zext i8 %2852 to i252
  %2854 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2853
  %2855 = select i1 %2850, i252 %2854, i252 %2851
  %2856 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2857 = icmp eq i32 %2856, 0
  br i1 %2857, label %2858, label %2872

2858:                                             ; preds = %2847
  %2859 = shl i32 %2856, 1
  %2860 = call i32 @llvm.umin.i32(i32 %2859, i32 1024)
  %2861 = add i32 %2860, %2856
  %2862 = call i32 @llvm.umax.i32(i32 %2861, i32 8)
  %2863 = zext i32 %2862 to i64
  %2864 = mul i64 %2863, 32
  %2865 = add i64 %2864, 16
  %2866 = call ptr @realloc(ptr null, i64 %2865)
  store i32 1, ptr %2866, align 4
  %2867 = getelementptr inbounds i8, ptr %2866, i32 4
  store i32 0, ptr %2867, align 4
  %2868 = getelementptr inbounds i8, ptr %2866, i32 16
  %2869 = call ptr @realloc(ptr null, i64 8)
  store ptr %2868, ptr %2869, align 8
  %2870 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2869, 0
  %2871 = insertvalue { ptr, i32, i32, i32 } %2870, i32 %2862, 3
  br label %2893

2872:                                             ; preds = %2847
  %2873 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2874 = icmp ult i32 %2873, %2856
  br i1 %2874, label %2875, label %2876

2875:                                             ; preds = %2872
  br label %2890

2876:                                             ; preds = %2872
  %2877 = shl i32 %2856, 1
  %2878 = call i32 @llvm.umin.i32(i32 %2877, i32 1024)
  %2879 = add i32 %2878, %2856
  %2880 = call i32 @llvm.umax.i32(i32 %2879, i32 8)
  %2881 = zext i32 %2880 to i64
  %2882 = mul i64 %2881, 32
  %2883 = add i64 %2882, 16
  %2884 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2885 = load ptr, ptr %2884, align 8
  %2886 = getelementptr inbounds i8, ptr %2885, i32 -16
  %2887 = call ptr @realloc(ptr %2886, i64 %2883)
  %2888 = getelementptr inbounds i8, ptr %2887, i32 16
  store ptr %2888, ptr %2884, align 8
  %2889 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2880, 3
  br label %2890

2890:                                             ; preds = %2875, %2876
  %2891 = phi { ptr, i32, i32, i32 } [ %2889, %2876 ], [ %1, %2875 ]
  br label %2892

2892:                                             ; preds = %2890
  br label %2893

2893:                                             ; preds = %2858, %2892
  %2894 = phi { ptr, i32, i32, i32 } [ %2891, %2892 ], [ %2871, %2858 ]
  br label %2895

2895:                                             ; preds = %2893
  %2896 = extractvalue { ptr, i32, i32, i32 } %2894, 0
  %2897 = load ptr, ptr %2896, align 8
  %2898 = extractvalue { ptr, i32, i32, i32 } %2894, 2
  %2899 = zext i32 %2898 to i64
  %2900 = mul i64 %2899, 32
  %2901 = getelementptr inbounds i8, ptr %2897, i64 %2900
  store i252 23, ptr %2901, align 16
  %2902 = extractvalue { ptr, i32, i32, i32 } %2894, 2
  %2903 = add i32 %2902, 1
  %2904 = insertvalue { ptr, i32, i32, i32 } %2894, i32 %2903, 2
  %2905 = getelementptr inbounds i8, ptr %2897, i32 -12
  store i32 %2903, ptr %2905, align 4
  %2906 = extractvalue { ptr, i32, i32, i32 } %2894, 3
  %2907 = icmp eq i32 %2906, 0
  br i1 %2907, label %2908, label %2922

2908:                                             ; preds = %2895
  %2909 = shl i32 %2906, 1
  %2910 = call i32 @llvm.umin.i32(i32 %2909, i32 1024)
  %2911 = add i32 %2910, %2906
  %2912 = call i32 @llvm.umax.i32(i32 %2911, i32 8)
  %2913 = zext i32 %2912 to i64
  %2914 = mul i64 %2913, 32
  %2915 = add i64 %2914, 16
  %2916 = call ptr @realloc(ptr null, i64 %2915)
  store i32 1, ptr %2916, align 4
  %2917 = getelementptr inbounds i8, ptr %2916, i32 4
  store i32 0, ptr %2917, align 4
  %2918 = getelementptr inbounds i8, ptr %2916, i32 16
  %2919 = call ptr @realloc(ptr null, i64 8)
  store ptr %2918, ptr %2919, align 8
  %2920 = insertvalue { ptr, i32, i32, i32 } %2904, ptr %2919, 0
  %2921 = insertvalue { ptr, i32, i32, i32 } %2920, i32 %2912, 3
  br label %2942

2922:                                             ; preds = %2895
  %2923 = icmp ult i32 %2903, %2906
  br i1 %2923, label %2924, label %2925

2924:                                             ; preds = %2922
  br label %2939

2925:                                             ; preds = %2922
  %2926 = shl i32 %2906, 1
  %2927 = call i32 @llvm.umin.i32(i32 %2926, i32 1024)
  %2928 = add i32 %2927, %2906
  %2929 = call i32 @llvm.umax.i32(i32 %2928, i32 8)
  %2930 = zext i32 %2929 to i64
  %2931 = mul i64 %2930, 32
  %2932 = add i64 %2931, 16
  %2933 = extractvalue { ptr, i32, i32, i32 } %2894, 0
  %2934 = load ptr, ptr %2933, align 8
  %2935 = getelementptr inbounds i8, ptr %2934, i32 -16
  %2936 = call ptr @realloc(ptr %2935, i64 %2932)
  %2937 = getelementptr inbounds i8, ptr %2936, i32 16
  store ptr %2937, ptr %2933, align 8
  %2938 = insertvalue { ptr, i32, i32, i32 } %2904, i32 %2929, 3
  br label %2939

2939:                                             ; preds = %2924, %2925
  %2940 = phi { ptr, i32, i32, i32 } [ %2938, %2925 ], [ %2904, %2924 ]
  br label %2941

2941:                                             ; preds = %2939
  br label %2942

2942:                                             ; preds = %2908, %2941
  %2943 = phi { ptr, i32, i32, i32 } [ %2940, %2941 ], [ %2921, %2908 ]
  br label %2944

2944:                                             ; preds = %2942
  %2945 = extractvalue { ptr, i32, i32, i32 } %2943, 0
  %2946 = load ptr, ptr %2945, align 8
  %2947 = extractvalue { ptr, i32, i32, i32 } %2943, 2
  %2948 = zext i32 %2947 to i64
  %2949 = mul i64 %2948, 32
  %2950 = getelementptr inbounds i8, ptr %2946, i64 %2949
  store i252 %2855, ptr %2950, align 16
  %2951 = extractvalue { ptr, i32, i32, i32 } %2943, 2
  %2952 = add i32 %2951, 1
  %2953 = insertvalue { ptr, i32, i32, i32 } %2943, i32 %2952, 2
  %2954 = getelementptr inbounds i8, ptr %2946, i32 -12
  store i32 %2952, ptr %2954, align 4
  %2955 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %2953, 0
  ret { { ptr, i32, i32, i32 } } %2955

2956:                                             ; preds = %2
  %2957 = load { i6, i8 }, ptr %3, align 1
  %2958 = extractvalue { i6, i8 } %2957, 1
  %2959 = icmp slt i8 %2958, 0
  %2960 = zext i8 %2958 to i252
  %2961 = call i8 @llvm.abs.i8(i8 %2958, i1 false)
  %2962 = zext i8 %2961 to i252
  %2963 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %2962
  %2964 = select i1 %2959, i252 %2963, i252 %2960
  %2965 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %2966 = icmp eq i32 %2965, 0
  br i1 %2966, label %2967, label %2981

2967:                                             ; preds = %2956
  %2968 = shl i32 %2965, 1
  %2969 = call i32 @llvm.umin.i32(i32 %2968, i32 1024)
  %2970 = add i32 %2969, %2965
  %2971 = call i32 @llvm.umax.i32(i32 %2970, i32 8)
  %2972 = zext i32 %2971 to i64
  %2973 = mul i64 %2972, 32
  %2974 = add i64 %2973, 16
  %2975 = call ptr @realloc(ptr null, i64 %2974)
  store i32 1, ptr %2975, align 4
  %2976 = getelementptr inbounds i8, ptr %2975, i32 4
  store i32 0, ptr %2976, align 4
  %2977 = getelementptr inbounds i8, ptr %2975, i32 16
  %2978 = call ptr @realloc(ptr null, i64 8)
  store ptr %2977, ptr %2978, align 8
  %2979 = insertvalue { ptr, i32, i32, i32 } %1, ptr %2978, 0
  %2980 = insertvalue { ptr, i32, i32, i32 } %2979, i32 %2971, 3
  br label %3002

2981:                                             ; preds = %2956
  %2982 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %2983 = icmp ult i32 %2982, %2965
  br i1 %2983, label %2984, label %2985

2984:                                             ; preds = %2981
  br label %2999

2985:                                             ; preds = %2981
  %2986 = shl i32 %2965, 1
  %2987 = call i32 @llvm.umin.i32(i32 %2986, i32 1024)
  %2988 = add i32 %2987, %2965
  %2989 = call i32 @llvm.umax.i32(i32 %2988, i32 8)
  %2990 = zext i32 %2989 to i64
  %2991 = mul i64 %2990, 32
  %2992 = add i64 %2991, 16
  %2993 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %2994 = load ptr, ptr %2993, align 8
  %2995 = getelementptr inbounds i8, ptr %2994, i32 -16
  %2996 = call ptr @realloc(ptr %2995, i64 %2992)
  %2997 = getelementptr inbounds i8, ptr %2996, i32 16
  store ptr %2997, ptr %2993, align 8
  %2998 = insertvalue { ptr, i32, i32, i32 } %1, i32 %2989, 3
  br label %2999

2999:                                             ; preds = %2984, %2985
  %3000 = phi { ptr, i32, i32, i32 } [ %2998, %2985 ], [ %1, %2984 ]
  br label %3001

3001:                                             ; preds = %2999
  br label %3002

3002:                                             ; preds = %2967, %3001
  %3003 = phi { ptr, i32, i32, i32 } [ %3000, %3001 ], [ %2980, %2967 ]
  br label %3004

3004:                                             ; preds = %3002
  %3005 = extractvalue { ptr, i32, i32, i32 } %3003, 0
  %3006 = load ptr, ptr %3005, align 8
  %3007 = extractvalue { ptr, i32, i32, i32 } %3003, 2
  %3008 = zext i32 %3007 to i64
  %3009 = mul i64 %3008, 32
  %3010 = getelementptr inbounds i8, ptr %3006, i64 %3009
  store i252 24, ptr %3010, align 16
  %3011 = extractvalue { ptr, i32, i32, i32 } %3003, 2
  %3012 = add i32 %3011, 1
  %3013 = insertvalue { ptr, i32, i32, i32 } %3003, i32 %3012, 2
  %3014 = getelementptr inbounds i8, ptr %3006, i32 -12
  store i32 %3012, ptr %3014, align 4
  %3015 = extractvalue { ptr, i32, i32, i32 } %3003, 3
  %3016 = icmp eq i32 %3015, 0
  br i1 %3016, label %3017, label %3031

3017:                                             ; preds = %3004
  %3018 = shl i32 %3015, 1
  %3019 = call i32 @llvm.umin.i32(i32 %3018, i32 1024)
  %3020 = add i32 %3019, %3015
  %3021 = call i32 @llvm.umax.i32(i32 %3020, i32 8)
  %3022 = zext i32 %3021 to i64
  %3023 = mul i64 %3022, 32
  %3024 = add i64 %3023, 16
  %3025 = call ptr @realloc(ptr null, i64 %3024)
  store i32 1, ptr %3025, align 4
  %3026 = getelementptr inbounds i8, ptr %3025, i32 4
  store i32 0, ptr %3026, align 4
  %3027 = getelementptr inbounds i8, ptr %3025, i32 16
  %3028 = call ptr @realloc(ptr null, i64 8)
  store ptr %3027, ptr %3028, align 8
  %3029 = insertvalue { ptr, i32, i32, i32 } %3013, ptr %3028, 0
  %3030 = insertvalue { ptr, i32, i32, i32 } %3029, i32 %3021, 3
  br label %3051

3031:                                             ; preds = %3004
  %3032 = icmp ult i32 %3012, %3015
  br i1 %3032, label %3033, label %3034

3033:                                             ; preds = %3031
  br label %3048

3034:                                             ; preds = %3031
  %3035 = shl i32 %3015, 1
  %3036 = call i32 @llvm.umin.i32(i32 %3035, i32 1024)
  %3037 = add i32 %3036, %3015
  %3038 = call i32 @llvm.umax.i32(i32 %3037, i32 8)
  %3039 = zext i32 %3038 to i64
  %3040 = mul i64 %3039, 32
  %3041 = add i64 %3040, 16
  %3042 = extractvalue { ptr, i32, i32, i32 } %3003, 0
  %3043 = load ptr, ptr %3042, align 8
  %3044 = getelementptr inbounds i8, ptr %3043, i32 -16
  %3045 = call ptr @realloc(ptr %3044, i64 %3041)
  %3046 = getelementptr inbounds i8, ptr %3045, i32 16
  store ptr %3046, ptr %3042, align 8
  %3047 = insertvalue { ptr, i32, i32, i32 } %3013, i32 %3038, 3
  br label %3048

3048:                                             ; preds = %3033, %3034
  %3049 = phi { ptr, i32, i32, i32 } [ %3047, %3034 ], [ %3013, %3033 ]
  br label %3050

3050:                                             ; preds = %3048
  br label %3051

3051:                                             ; preds = %3017, %3050
  %3052 = phi { ptr, i32, i32, i32 } [ %3049, %3050 ], [ %3030, %3017 ]
  br label %3053

3053:                                             ; preds = %3051
  %3054 = extractvalue { ptr, i32, i32, i32 } %3052, 0
  %3055 = load ptr, ptr %3054, align 8
  %3056 = extractvalue { ptr, i32, i32, i32 } %3052, 2
  %3057 = zext i32 %3056 to i64
  %3058 = mul i64 %3057, 32
  %3059 = getelementptr inbounds i8, ptr %3055, i64 %3058
  store i252 %2964, ptr %3059, align 16
  %3060 = extractvalue { ptr, i32, i32, i32 } %3052, 2
  %3061 = add i32 %3060, 1
  %3062 = insertvalue { ptr, i32, i32, i32 } %3052, i32 %3061, 2
  %3063 = getelementptr inbounds i8, ptr %3055, i32 -12
  store i32 %3061, ptr %3063, align 4
  %3064 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3062, 0
  ret { { ptr, i32, i32, i32 } } %3064

3065:                                             ; preds = %2
  %3066 = load { i6, i8 }, ptr %3, align 1
  %3067 = extractvalue { i6, i8 } %3066, 1
  %3068 = icmp slt i8 %3067, 0
  %3069 = zext i8 %3067 to i252
  %3070 = call i8 @llvm.abs.i8(i8 %3067, i1 false)
  %3071 = zext i8 %3070 to i252
  %3072 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3071
  %3073 = select i1 %3068, i252 %3072, i252 %3069
  %3074 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %3075 = icmp eq i32 %3074, 0
  br i1 %3075, label %3076, label %3090

3076:                                             ; preds = %3065
  %3077 = shl i32 %3074, 1
  %3078 = call i32 @llvm.umin.i32(i32 %3077, i32 1024)
  %3079 = add i32 %3078, %3074
  %3080 = call i32 @llvm.umax.i32(i32 %3079, i32 8)
  %3081 = zext i32 %3080 to i64
  %3082 = mul i64 %3081, 32
  %3083 = add i64 %3082, 16
  %3084 = call ptr @realloc(ptr null, i64 %3083)
  store i32 1, ptr %3084, align 4
  %3085 = getelementptr inbounds i8, ptr %3084, i32 4
  store i32 0, ptr %3085, align 4
  %3086 = getelementptr inbounds i8, ptr %3084, i32 16
  %3087 = call ptr @realloc(ptr null, i64 8)
  store ptr %3086, ptr %3087, align 8
  %3088 = insertvalue { ptr, i32, i32, i32 } %1, ptr %3087, 0
  %3089 = insertvalue { ptr, i32, i32, i32 } %3088, i32 %3080, 3
  br label %3111

3090:                                             ; preds = %3065
  %3091 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %3092 = icmp ult i32 %3091, %3074
  br i1 %3092, label %3093, label %3094

3093:                                             ; preds = %3090
  br label %3108

3094:                                             ; preds = %3090
  %3095 = shl i32 %3074, 1
  %3096 = call i32 @llvm.umin.i32(i32 %3095, i32 1024)
  %3097 = add i32 %3096, %3074
  %3098 = call i32 @llvm.umax.i32(i32 %3097, i32 8)
  %3099 = zext i32 %3098 to i64
  %3100 = mul i64 %3099, 32
  %3101 = add i64 %3100, 16
  %3102 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %3103 = load ptr, ptr %3102, align 8
  %3104 = getelementptr inbounds i8, ptr %3103, i32 -16
  %3105 = call ptr @realloc(ptr %3104, i64 %3101)
  %3106 = getelementptr inbounds i8, ptr %3105, i32 16
  store ptr %3106, ptr %3102, align 8
  %3107 = insertvalue { ptr, i32, i32, i32 } %1, i32 %3098, 3
  br label %3108

3108:                                             ; preds = %3093, %3094
  %3109 = phi { ptr, i32, i32, i32 } [ %3107, %3094 ], [ %1, %3093 ]
  br label %3110

3110:                                             ; preds = %3108
  br label %3111

3111:                                             ; preds = %3076, %3110
  %3112 = phi { ptr, i32, i32, i32 } [ %3109, %3110 ], [ %3089, %3076 ]
  br label %3113

3113:                                             ; preds = %3111
  %3114 = extractvalue { ptr, i32, i32, i32 } %3112, 0
  %3115 = load ptr, ptr %3114, align 8
  %3116 = extractvalue { ptr, i32, i32, i32 } %3112, 2
  %3117 = zext i32 %3116 to i64
  %3118 = mul i64 %3117, 32
  %3119 = getelementptr inbounds i8, ptr %3115, i64 %3118
  store i252 25, ptr %3119, align 16
  %3120 = extractvalue { ptr, i32, i32, i32 } %3112, 2
  %3121 = add i32 %3120, 1
  %3122 = insertvalue { ptr, i32, i32, i32 } %3112, i32 %3121, 2
  %3123 = getelementptr inbounds i8, ptr %3115, i32 -12
  store i32 %3121, ptr %3123, align 4
  %3124 = extractvalue { ptr, i32, i32, i32 } %3112, 3
  %3125 = icmp eq i32 %3124, 0
  br i1 %3125, label %3126, label %3140

3126:                                             ; preds = %3113
  %3127 = shl i32 %3124, 1
  %3128 = call i32 @llvm.umin.i32(i32 %3127, i32 1024)
  %3129 = add i32 %3128, %3124
  %3130 = call i32 @llvm.umax.i32(i32 %3129, i32 8)
  %3131 = zext i32 %3130 to i64
  %3132 = mul i64 %3131, 32
  %3133 = add i64 %3132, 16
  %3134 = call ptr @realloc(ptr null, i64 %3133)
  store i32 1, ptr %3134, align 4
  %3135 = getelementptr inbounds i8, ptr %3134, i32 4
  store i32 0, ptr %3135, align 4
  %3136 = getelementptr inbounds i8, ptr %3134, i32 16
  %3137 = call ptr @realloc(ptr null, i64 8)
  store ptr %3136, ptr %3137, align 8
  %3138 = insertvalue { ptr, i32, i32, i32 } %3122, ptr %3137, 0
  %3139 = insertvalue { ptr, i32, i32, i32 } %3138, i32 %3130, 3
  br label %3160

3140:                                             ; preds = %3113
  %3141 = icmp ult i32 %3121, %3124
  br i1 %3141, label %3142, label %3143

3142:                                             ; preds = %3140
  br label %3157

3143:                                             ; preds = %3140
  %3144 = shl i32 %3124, 1
  %3145 = call i32 @llvm.umin.i32(i32 %3144, i32 1024)
  %3146 = add i32 %3145, %3124
  %3147 = call i32 @llvm.umax.i32(i32 %3146, i32 8)
  %3148 = zext i32 %3147 to i64
  %3149 = mul i64 %3148, 32
  %3150 = add i64 %3149, 16
  %3151 = extractvalue { ptr, i32, i32, i32 } %3112, 0
  %3152 = load ptr, ptr %3151, align 8
  %3153 = getelementptr inbounds i8, ptr %3152, i32 -16
  %3154 = call ptr @realloc(ptr %3153, i64 %3150)
  %3155 = getelementptr inbounds i8, ptr %3154, i32 16
  store ptr %3155, ptr %3151, align 8
  %3156 = insertvalue { ptr, i32, i32, i32 } %3122, i32 %3147, 3
  br label %3157

3157:                                             ; preds = %3142, %3143
  %3158 = phi { ptr, i32, i32, i32 } [ %3156, %3143 ], [ %3122, %3142 ]
  br label %3159

3159:                                             ; preds = %3157
  br label %3160

3160:                                             ; preds = %3126, %3159
  %3161 = phi { ptr, i32, i32, i32 } [ %3158, %3159 ], [ %3139, %3126 ]
  br label %3162

3162:                                             ; preds = %3160
  %3163 = extractvalue { ptr, i32, i32, i32 } %3161, 0
  %3164 = load ptr, ptr %3163, align 8
  %3165 = extractvalue { ptr, i32, i32, i32 } %3161, 2
  %3166 = zext i32 %3165 to i64
  %3167 = mul i64 %3166, 32
  %3168 = getelementptr inbounds i8, ptr %3164, i64 %3167
  store i252 %3073, ptr %3168, align 16
  %3169 = extractvalue { ptr, i32, i32, i32 } %3161, 2
  %3170 = add i32 %3169, 1
  %3171 = insertvalue { ptr, i32, i32, i32 } %3161, i32 %3170, 2
  %3172 = getelementptr inbounds i8, ptr %3164, i32 -12
  store i32 %3170, ptr %3172, align 4
  %3173 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3171, 0
  ret { { ptr, i32, i32, i32 } } %3173

3174:                                             ; preds = %2
  %3175 = load { i6, i16 }, ptr %3, align 2
  %3176 = extractvalue { i6, i16 } %3175, 1
  %3177 = icmp slt i16 %3176, 0
  %3178 = zext i16 %3176 to i252
  %3179 = call i16 @llvm.abs.i16(i16 %3176, i1 false)
  %3180 = zext i16 %3179 to i252
  %3181 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3180
  %3182 = select i1 %3177, i252 %3181, i252 %3178
  %3183 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %3184 = icmp eq i32 %3183, 0
  br i1 %3184, label %3185, label %3199

3185:                                             ; preds = %3174
  %3186 = shl i32 %3183, 1
  %3187 = call i32 @llvm.umin.i32(i32 %3186, i32 1024)
  %3188 = add i32 %3187, %3183
  %3189 = call i32 @llvm.umax.i32(i32 %3188, i32 8)
  %3190 = zext i32 %3189 to i64
  %3191 = mul i64 %3190, 32
  %3192 = add i64 %3191, 16
  %3193 = call ptr @realloc(ptr null, i64 %3192)
  store i32 1, ptr %3193, align 4
  %3194 = getelementptr inbounds i8, ptr %3193, i32 4
  store i32 0, ptr %3194, align 4
  %3195 = getelementptr inbounds i8, ptr %3193, i32 16
  %3196 = call ptr @realloc(ptr null, i64 8)
  store ptr %3195, ptr %3196, align 8
  %3197 = insertvalue { ptr, i32, i32, i32 } %1, ptr %3196, 0
  %3198 = insertvalue { ptr, i32, i32, i32 } %3197, i32 %3189, 3
  br label %3220

3199:                                             ; preds = %3174
  %3200 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %3201 = icmp ult i32 %3200, %3183
  br i1 %3201, label %3202, label %3203

3202:                                             ; preds = %3199
  br label %3217

3203:                                             ; preds = %3199
  %3204 = shl i32 %3183, 1
  %3205 = call i32 @llvm.umin.i32(i32 %3204, i32 1024)
  %3206 = add i32 %3205, %3183
  %3207 = call i32 @llvm.umax.i32(i32 %3206, i32 8)
  %3208 = zext i32 %3207 to i64
  %3209 = mul i64 %3208, 32
  %3210 = add i64 %3209, 16
  %3211 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %3212 = load ptr, ptr %3211, align 8
  %3213 = getelementptr inbounds i8, ptr %3212, i32 -16
  %3214 = call ptr @realloc(ptr %3213, i64 %3210)
  %3215 = getelementptr inbounds i8, ptr %3214, i32 16
  store ptr %3215, ptr %3211, align 8
  %3216 = insertvalue { ptr, i32, i32, i32 } %1, i32 %3207, 3
  br label %3217

3217:                                             ; preds = %3202, %3203
  %3218 = phi { ptr, i32, i32, i32 } [ %3216, %3203 ], [ %1, %3202 ]
  br label %3219

3219:                                             ; preds = %3217
  br label %3220

3220:                                             ; preds = %3185, %3219
  %3221 = phi { ptr, i32, i32, i32 } [ %3218, %3219 ], [ %3198, %3185 ]
  br label %3222

3222:                                             ; preds = %3220
  %3223 = extractvalue { ptr, i32, i32, i32 } %3221, 0
  %3224 = load ptr, ptr %3223, align 8
  %3225 = extractvalue { ptr, i32, i32, i32 } %3221, 2
  %3226 = zext i32 %3225 to i64
  %3227 = mul i64 %3226, 32
  %3228 = getelementptr inbounds i8, ptr %3224, i64 %3227
  store i252 26, ptr %3228, align 16
  %3229 = extractvalue { ptr, i32, i32, i32 } %3221, 2
  %3230 = add i32 %3229, 1
  %3231 = insertvalue { ptr, i32, i32, i32 } %3221, i32 %3230, 2
  %3232 = getelementptr inbounds i8, ptr %3224, i32 -12
  store i32 %3230, ptr %3232, align 4
  %3233 = extractvalue { ptr, i32, i32, i32 } %3221, 3
  %3234 = icmp eq i32 %3233, 0
  br i1 %3234, label %3235, label %3249

3235:                                             ; preds = %3222
  %3236 = shl i32 %3233, 1
  %3237 = call i32 @llvm.umin.i32(i32 %3236, i32 1024)
  %3238 = add i32 %3237, %3233
  %3239 = call i32 @llvm.umax.i32(i32 %3238, i32 8)
  %3240 = zext i32 %3239 to i64
  %3241 = mul i64 %3240, 32
  %3242 = add i64 %3241, 16
  %3243 = call ptr @realloc(ptr null, i64 %3242)
  store i32 1, ptr %3243, align 4
  %3244 = getelementptr inbounds i8, ptr %3243, i32 4
  store i32 0, ptr %3244, align 4
  %3245 = getelementptr inbounds i8, ptr %3243, i32 16
  %3246 = call ptr @realloc(ptr null, i64 8)
  store ptr %3245, ptr %3246, align 8
  %3247 = insertvalue { ptr, i32, i32, i32 } %3231, ptr %3246, 0
  %3248 = insertvalue { ptr, i32, i32, i32 } %3247, i32 %3239, 3
  br label %3269

3249:                                             ; preds = %3222
  %3250 = icmp ult i32 %3230, %3233
  br i1 %3250, label %3251, label %3252

3251:                                             ; preds = %3249
  br label %3266

3252:                                             ; preds = %3249
  %3253 = shl i32 %3233, 1
  %3254 = call i32 @llvm.umin.i32(i32 %3253, i32 1024)
  %3255 = add i32 %3254, %3233
  %3256 = call i32 @llvm.umax.i32(i32 %3255, i32 8)
  %3257 = zext i32 %3256 to i64
  %3258 = mul i64 %3257, 32
  %3259 = add i64 %3258, 16
  %3260 = extractvalue { ptr, i32, i32, i32 } %3221, 0
  %3261 = load ptr, ptr %3260, align 8
  %3262 = getelementptr inbounds i8, ptr %3261, i32 -16
  %3263 = call ptr @realloc(ptr %3262, i64 %3259)
  %3264 = getelementptr inbounds i8, ptr %3263, i32 16
  store ptr %3264, ptr %3260, align 8
  %3265 = insertvalue { ptr, i32, i32, i32 } %3231, i32 %3256, 3
  br label %3266

3266:                                             ; preds = %3251, %3252
  %3267 = phi { ptr, i32, i32, i32 } [ %3265, %3252 ], [ %3231, %3251 ]
  br label %3268

3268:                                             ; preds = %3266
  br label %3269

3269:                                             ; preds = %3235, %3268
  %3270 = phi { ptr, i32, i32, i32 } [ %3267, %3268 ], [ %3248, %3235 ]
  br label %3271

3271:                                             ; preds = %3269
  %3272 = extractvalue { ptr, i32, i32, i32 } %3270, 0
  %3273 = load ptr, ptr %3272, align 8
  %3274 = extractvalue { ptr, i32, i32, i32 } %3270, 2
  %3275 = zext i32 %3274 to i64
  %3276 = mul i64 %3275, 32
  %3277 = getelementptr inbounds i8, ptr %3273, i64 %3276
  store i252 %3182, ptr %3277, align 16
  %3278 = extractvalue { ptr, i32, i32, i32 } %3270, 2
  %3279 = add i32 %3278, 1
  %3280 = insertvalue { ptr, i32, i32, i32 } %3270, i32 %3279, 2
  %3281 = getelementptr inbounds i8, ptr %3273, i32 -12
  store i32 %3279, ptr %3281, align 4
  %3282 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3280, 0
  ret { { ptr, i32, i32, i32 } } %3282

3283:                                             ; preds = %2
  %3284 = load { i6, i16 }, ptr %3, align 2
  %3285 = extractvalue { i6, i16 } %3284, 1
  %3286 = icmp slt i16 %3285, 0
  %3287 = zext i16 %3285 to i252
  %3288 = call i16 @llvm.abs.i16(i16 %3285, i1 false)
  %3289 = zext i16 %3288 to i252
  %3290 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3289
  %3291 = select i1 %3286, i252 %3290, i252 %3287
  %3292 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %3293 = icmp eq i32 %3292, 0
  br i1 %3293, label %3294, label %3308

3294:                                             ; preds = %3283
  %3295 = shl i32 %3292, 1
  %3296 = call i32 @llvm.umin.i32(i32 %3295, i32 1024)
  %3297 = add i32 %3296, %3292
  %3298 = call i32 @llvm.umax.i32(i32 %3297, i32 8)
  %3299 = zext i32 %3298 to i64
  %3300 = mul i64 %3299, 32
  %3301 = add i64 %3300, 16
  %3302 = call ptr @realloc(ptr null, i64 %3301)
  store i32 1, ptr %3302, align 4
  %3303 = getelementptr inbounds i8, ptr %3302, i32 4
  store i32 0, ptr %3303, align 4
  %3304 = getelementptr inbounds i8, ptr %3302, i32 16
  %3305 = call ptr @realloc(ptr null, i64 8)
  store ptr %3304, ptr %3305, align 8
  %3306 = insertvalue { ptr, i32, i32, i32 } %1, ptr %3305, 0
  %3307 = insertvalue { ptr, i32, i32, i32 } %3306, i32 %3298, 3
  br label %3329

3308:                                             ; preds = %3283
  %3309 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %3310 = icmp ult i32 %3309, %3292
  br i1 %3310, label %3311, label %3312

3311:                                             ; preds = %3308
  br label %3326

3312:                                             ; preds = %3308
  %3313 = shl i32 %3292, 1
  %3314 = call i32 @llvm.umin.i32(i32 %3313, i32 1024)
  %3315 = add i32 %3314, %3292
  %3316 = call i32 @llvm.umax.i32(i32 %3315, i32 8)
  %3317 = zext i32 %3316 to i64
  %3318 = mul i64 %3317, 32
  %3319 = add i64 %3318, 16
  %3320 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %3321 = load ptr, ptr %3320, align 8
  %3322 = getelementptr inbounds i8, ptr %3321, i32 -16
  %3323 = call ptr @realloc(ptr %3322, i64 %3319)
  %3324 = getelementptr inbounds i8, ptr %3323, i32 16
  store ptr %3324, ptr %3320, align 8
  %3325 = insertvalue { ptr, i32, i32, i32 } %1, i32 %3316, 3
  br label %3326

3326:                                             ; preds = %3311, %3312
  %3327 = phi { ptr, i32, i32, i32 } [ %3325, %3312 ], [ %1, %3311 ]
  br label %3328

3328:                                             ; preds = %3326
  br label %3329

3329:                                             ; preds = %3294, %3328
  %3330 = phi { ptr, i32, i32, i32 } [ %3327, %3328 ], [ %3307, %3294 ]
  br label %3331

3331:                                             ; preds = %3329
  %3332 = extractvalue { ptr, i32, i32, i32 } %3330, 0
  %3333 = load ptr, ptr %3332, align 8
  %3334 = extractvalue { ptr, i32, i32, i32 } %3330, 2
  %3335 = zext i32 %3334 to i64
  %3336 = mul i64 %3335, 32
  %3337 = getelementptr inbounds i8, ptr %3333, i64 %3336
  store i252 27, ptr %3337, align 16
  %3338 = extractvalue { ptr, i32, i32, i32 } %3330, 2
  %3339 = add i32 %3338, 1
  %3340 = insertvalue { ptr, i32, i32, i32 } %3330, i32 %3339, 2
  %3341 = getelementptr inbounds i8, ptr %3333, i32 -12
  store i32 %3339, ptr %3341, align 4
  %3342 = extractvalue { ptr, i32, i32, i32 } %3330, 3
  %3343 = icmp eq i32 %3342, 0
  br i1 %3343, label %3344, label %3358

3344:                                             ; preds = %3331
  %3345 = shl i32 %3342, 1
  %3346 = call i32 @llvm.umin.i32(i32 %3345, i32 1024)
  %3347 = add i32 %3346, %3342
  %3348 = call i32 @llvm.umax.i32(i32 %3347, i32 8)
  %3349 = zext i32 %3348 to i64
  %3350 = mul i64 %3349, 32
  %3351 = add i64 %3350, 16
  %3352 = call ptr @realloc(ptr null, i64 %3351)
  store i32 1, ptr %3352, align 4
  %3353 = getelementptr inbounds i8, ptr %3352, i32 4
  store i32 0, ptr %3353, align 4
  %3354 = getelementptr inbounds i8, ptr %3352, i32 16
  %3355 = call ptr @realloc(ptr null, i64 8)
  store ptr %3354, ptr %3355, align 8
  %3356 = insertvalue { ptr, i32, i32, i32 } %3340, ptr %3355, 0
  %3357 = insertvalue { ptr, i32, i32, i32 } %3356, i32 %3348, 3
  br label %3378

3358:                                             ; preds = %3331
  %3359 = icmp ult i32 %3339, %3342
  br i1 %3359, label %3360, label %3361

3360:                                             ; preds = %3358
  br label %3375

3361:                                             ; preds = %3358
  %3362 = shl i32 %3342, 1
  %3363 = call i32 @llvm.umin.i32(i32 %3362, i32 1024)
  %3364 = add i32 %3363, %3342
  %3365 = call i32 @llvm.umax.i32(i32 %3364, i32 8)
  %3366 = zext i32 %3365 to i64
  %3367 = mul i64 %3366, 32
  %3368 = add i64 %3367, 16
  %3369 = extractvalue { ptr, i32, i32, i32 } %3330, 0
  %3370 = load ptr, ptr %3369, align 8
  %3371 = getelementptr inbounds i8, ptr %3370, i32 -16
  %3372 = call ptr @realloc(ptr %3371, i64 %3368)
  %3373 = getelementptr inbounds i8, ptr %3372, i32 16
  store ptr %3373, ptr %3369, align 8
  %3374 = insertvalue { ptr, i32, i32, i32 } %3340, i32 %3365, 3
  br label %3375

3375:                                             ; preds = %3360, %3361
  %3376 = phi { ptr, i32, i32, i32 } [ %3374, %3361 ], [ %3340, %3360 ]
  br label %3377

3377:                                             ; preds = %3375
  br label %3378

3378:                                             ; preds = %3344, %3377
  %3379 = phi { ptr, i32, i32, i32 } [ %3376, %3377 ], [ %3357, %3344 ]
  br label %3380

3380:                                             ; preds = %3378
  %3381 = extractvalue { ptr, i32, i32, i32 } %3379, 0
  %3382 = load ptr, ptr %3381, align 8
  %3383 = extractvalue { ptr, i32, i32, i32 } %3379, 2
  %3384 = zext i32 %3383 to i64
  %3385 = mul i64 %3384, 32
  %3386 = getelementptr inbounds i8, ptr %3382, i64 %3385
  store i252 %3291, ptr %3386, align 16
  %3387 = extractvalue { ptr, i32, i32, i32 } %3379, 2
  %3388 = add i32 %3387, 1
  %3389 = insertvalue { ptr, i32, i32, i32 } %3379, i32 %3388, 2
  %3390 = getelementptr inbounds i8, ptr %3382, i32 -12
  store i32 %3388, ptr %3390, align 4
  %3391 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3389, 0
  ret { { ptr, i32, i32, i32 } } %3391

3392:                                             ; preds = %2
  %3393 = load { i6, i16 }, ptr %3, align 2
  %3394 = extractvalue { i6, i16 } %3393, 1
  %3395 = icmp slt i16 %3394, 0
  %3396 = zext i16 %3394 to i252
  %3397 = call i16 @llvm.abs.i16(i16 %3394, i1 false)
  %3398 = zext i16 %3397 to i252
  %3399 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3398
  %3400 = select i1 %3395, i252 %3399, i252 %3396
  %3401 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %3402 = icmp eq i32 %3401, 0
  br i1 %3402, label %3403, label %3417

3403:                                             ; preds = %3392
  %3404 = shl i32 %3401, 1
  %3405 = call i32 @llvm.umin.i32(i32 %3404, i32 1024)
  %3406 = add i32 %3405, %3401
  %3407 = call i32 @llvm.umax.i32(i32 %3406, i32 8)
  %3408 = zext i32 %3407 to i64
  %3409 = mul i64 %3408, 32
  %3410 = add i64 %3409, 16
  %3411 = call ptr @realloc(ptr null, i64 %3410)
  store i32 1, ptr %3411, align 4
  %3412 = getelementptr inbounds i8, ptr %3411, i32 4
  store i32 0, ptr %3412, align 4
  %3413 = getelementptr inbounds i8, ptr %3411, i32 16
  %3414 = call ptr @realloc(ptr null, i64 8)
  store ptr %3413, ptr %3414, align 8
  %3415 = insertvalue { ptr, i32, i32, i32 } %1, ptr %3414, 0
  %3416 = insertvalue { ptr, i32, i32, i32 } %3415, i32 %3407, 3
  br label %3438

3417:                                             ; preds = %3392
  %3418 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %3419 = icmp ult i32 %3418, %3401
  br i1 %3419, label %3420, label %3421

3420:                                             ; preds = %3417
  br label %3435

3421:                                             ; preds = %3417
  %3422 = shl i32 %3401, 1
  %3423 = call i32 @llvm.umin.i32(i32 %3422, i32 1024)
  %3424 = add i32 %3423, %3401
  %3425 = call i32 @llvm.umax.i32(i32 %3424, i32 8)
  %3426 = zext i32 %3425 to i64
  %3427 = mul i64 %3426, 32
  %3428 = add i64 %3427, 16
  %3429 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %3430 = load ptr, ptr %3429, align 8
  %3431 = getelementptr inbounds i8, ptr %3430, i32 -16
  %3432 = call ptr @realloc(ptr %3431, i64 %3428)
  %3433 = getelementptr inbounds i8, ptr %3432, i32 16
  store ptr %3433, ptr %3429, align 8
  %3434 = insertvalue { ptr, i32, i32, i32 } %1, i32 %3425, 3
  br label %3435

3435:                                             ; preds = %3420, %3421
  %3436 = phi { ptr, i32, i32, i32 } [ %3434, %3421 ], [ %1, %3420 ]
  br label %3437

3437:                                             ; preds = %3435
  br label %3438

3438:                                             ; preds = %3403, %3437
  %3439 = phi { ptr, i32, i32, i32 } [ %3436, %3437 ], [ %3416, %3403 ]
  br label %3440

3440:                                             ; preds = %3438
  %3441 = extractvalue { ptr, i32, i32, i32 } %3439, 0
  %3442 = load ptr, ptr %3441, align 8
  %3443 = extractvalue { ptr, i32, i32, i32 } %3439, 2
  %3444 = zext i32 %3443 to i64
  %3445 = mul i64 %3444, 32
  %3446 = getelementptr inbounds i8, ptr %3442, i64 %3445
  store i252 28, ptr %3446, align 16
  %3447 = extractvalue { ptr, i32, i32, i32 } %3439, 2
  %3448 = add i32 %3447, 1
  %3449 = insertvalue { ptr, i32, i32, i32 } %3439, i32 %3448, 2
  %3450 = getelementptr inbounds i8, ptr %3442, i32 -12
  store i32 %3448, ptr %3450, align 4
  %3451 = extractvalue { ptr, i32, i32, i32 } %3439, 3
  %3452 = icmp eq i32 %3451, 0
  br i1 %3452, label %3453, label %3467

3453:                                             ; preds = %3440
  %3454 = shl i32 %3451, 1
  %3455 = call i32 @llvm.umin.i32(i32 %3454, i32 1024)
  %3456 = add i32 %3455, %3451
  %3457 = call i32 @llvm.umax.i32(i32 %3456, i32 8)
  %3458 = zext i32 %3457 to i64
  %3459 = mul i64 %3458, 32
  %3460 = add i64 %3459, 16
  %3461 = call ptr @realloc(ptr null, i64 %3460)
  store i32 1, ptr %3461, align 4
  %3462 = getelementptr inbounds i8, ptr %3461, i32 4
  store i32 0, ptr %3462, align 4
  %3463 = getelementptr inbounds i8, ptr %3461, i32 16
  %3464 = call ptr @realloc(ptr null, i64 8)
  store ptr %3463, ptr %3464, align 8
  %3465 = insertvalue { ptr, i32, i32, i32 } %3449, ptr %3464, 0
  %3466 = insertvalue { ptr, i32, i32, i32 } %3465, i32 %3457, 3
  br label %3487

3467:                                             ; preds = %3440
  %3468 = icmp ult i32 %3448, %3451
  br i1 %3468, label %3469, label %3470

3469:                                             ; preds = %3467
  br label %3484

3470:                                             ; preds = %3467
  %3471 = shl i32 %3451, 1
  %3472 = call i32 @llvm.umin.i32(i32 %3471, i32 1024)
  %3473 = add i32 %3472, %3451
  %3474 = call i32 @llvm.umax.i32(i32 %3473, i32 8)
  %3475 = zext i32 %3474 to i64
  %3476 = mul i64 %3475, 32
  %3477 = add i64 %3476, 16
  %3478 = extractvalue { ptr, i32, i32, i32 } %3439, 0
  %3479 = load ptr, ptr %3478, align 8
  %3480 = getelementptr inbounds i8, ptr %3479, i32 -16
  %3481 = call ptr @realloc(ptr %3480, i64 %3477)
  %3482 = getelementptr inbounds i8, ptr %3481, i32 16
  store ptr %3482, ptr %3478, align 8
  %3483 = insertvalue { ptr, i32, i32, i32 } %3449, i32 %3474, 3
  br label %3484

3484:                                             ; preds = %3469, %3470
  %3485 = phi { ptr, i32, i32, i32 } [ %3483, %3470 ], [ %3449, %3469 ]
  br label %3486

3486:                                             ; preds = %3484
  br label %3487

3487:                                             ; preds = %3453, %3486
  %3488 = phi { ptr, i32, i32, i32 } [ %3485, %3486 ], [ %3466, %3453 ]
  br label %3489

3489:                                             ; preds = %3487
  %3490 = extractvalue { ptr, i32, i32, i32 } %3488, 0
  %3491 = load ptr, ptr %3490, align 8
  %3492 = extractvalue { ptr, i32, i32, i32 } %3488, 2
  %3493 = zext i32 %3492 to i64
  %3494 = mul i64 %3493, 32
  %3495 = getelementptr inbounds i8, ptr %3491, i64 %3494
  store i252 %3400, ptr %3495, align 16
  %3496 = extractvalue { ptr, i32, i32, i32 } %3488, 2
  %3497 = add i32 %3496, 1
  %3498 = insertvalue { ptr, i32, i32, i32 } %3488, i32 %3497, 2
  %3499 = getelementptr inbounds i8, ptr %3491, i32 -12
  store i32 %3497, ptr %3499, align 4
  %3500 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3498, 0
  ret { { ptr, i32, i32, i32 } } %3500

3501:                                             ; preds = %2
  %3502 = load { i6, { i8, i8, i8, i8 } }, ptr %3, align 1
  %3503 = extractvalue { i6, { i8, i8, i8, i8 } } %3502, 1
  %3504 = extractvalue { i8, i8, i8, i8 } %3503, 0
  %3505 = icmp slt i8 %3504, 0
  %3506 = zext i8 %3504 to i252
  %3507 = call i8 @llvm.abs.i8(i8 %3504, i1 false)
  %3508 = zext i8 %3507 to i252
  %3509 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3508
  %3510 = select i1 %3505, i252 %3509, i252 %3506
  %3511 = extractvalue { i8, i8, i8, i8 } %3503, 1
  %3512 = icmp slt i8 %3511, 0
  %3513 = zext i8 %3511 to i252
  %3514 = call i8 @llvm.abs.i8(i8 %3511, i1 false)
  %3515 = zext i8 %3514 to i252
  %3516 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3515
  %3517 = select i1 %3512, i252 %3516, i252 %3513
  %3518 = extractvalue { i8, i8, i8, i8 } %3503, 2
  %3519 = icmp slt i8 %3518, 0
  %3520 = zext i8 %3518 to i252
  %3521 = call i8 @llvm.abs.i8(i8 %3518, i1 false)
  %3522 = zext i8 %3521 to i252
  %3523 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3522
  %3524 = select i1 %3519, i252 %3523, i252 %3520
  %3525 = extractvalue { i8, i8, i8, i8 } %3503, 3
  %3526 = icmp slt i8 %3525, 0
  %3527 = zext i8 %3525 to i252
  %3528 = call i8 @llvm.abs.i8(i8 %3525, i1 false)
  %3529 = zext i8 %3528 to i252
  %3530 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3529
  %3531 = select i1 %3526, i252 %3530, i252 %3527
  %3532 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %3533 = icmp eq i32 %3532, 0
  br i1 %3533, label %3534, label %3548

3534:                                             ; preds = %3501
  %3535 = shl i32 %3532, 1
  %3536 = call i32 @llvm.umin.i32(i32 %3535, i32 1024)
  %3537 = add i32 %3536, %3532
  %3538 = call i32 @llvm.umax.i32(i32 %3537, i32 8)
  %3539 = zext i32 %3538 to i64
  %3540 = mul i64 %3539, 32
  %3541 = add i64 %3540, 16
  %3542 = call ptr @realloc(ptr null, i64 %3541)
  store i32 1, ptr %3542, align 4
  %3543 = getelementptr inbounds i8, ptr %3542, i32 4
  store i32 0, ptr %3543, align 4
  %3544 = getelementptr inbounds i8, ptr %3542, i32 16
  %3545 = call ptr @realloc(ptr null, i64 8)
  store ptr %3544, ptr %3545, align 8
  %3546 = insertvalue { ptr, i32, i32, i32 } %1, ptr %3545, 0
  %3547 = insertvalue { ptr, i32, i32, i32 } %3546, i32 %3538, 3
  br label %3569

3548:                                             ; preds = %3501
  %3549 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %3550 = icmp ult i32 %3549, %3532
  br i1 %3550, label %3551, label %3552

3551:                                             ; preds = %3548
  br label %3566

3552:                                             ; preds = %3548
  %3553 = shl i32 %3532, 1
  %3554 = call i32 @llvm.umin.i32(i32 %3553, i32 1024)
  %3555 = add i32 %3554, %3532
  %3556 = call i32 @llvm.umax.i32(i32 %3555, i32 8)
  %3557 = zext i32 %3556 to i64
  %3558 = mul i64 %3557, 32
  %3559 = add i64 %3558, 16
  %3560 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %3561 = load ptr, ptr %3560, align 8
  %3562 = getelementptr inbounds i8, ptr %3561, i32 -16
  %3563 = call ptr @realloc(ptr %3562, i64 %3559)
  %3564 = getelementptr inbounds i8, ptr %3563, i32 16
  store ptr %3564, ptr %3560, align 8
  %3565 = insertvalue { ptr, i32, i32, i32 } %1, i32 %3556, 3
  br label %3566

3566:                                             ; preds = %3551, %3552
  %3567 = phi { ptr, i32, i32, i32 } [ %3565, %3552 ], [ %1, %3551 ]
  br label %3568

3568:                                             ; preds = %3566
  br label %3569

3569:                                             ; preds = %3534, %3568
  %3570 = phi { ptr, i32, i32, i32 } [ %3567, %3568 ], [ %3547, %3534 ]
  br label %3571

3571:                                             ; preds = %3569
  %3572 = extractvalue { ptr, i32, i32, i32 } %3570, 0
  %3573 = load ptr, ptr %3572, align 8
  %3574 = extractvalue { ptr, i32, i32, i32 } %3570, 2
  %3575 = zext i32 %3574 to i64
  %3576 = mul i64 %3575, 32
  %3577 = getelementptr inbounds i8, ptr %3573, i64 %3576
  store i252 29, ptr %3577, align 16
  %3578 = extractvalue { ptr, i32, i32, i32 } %3570, 2
  %3579 = add i32 %3578, 1
  %3580 = insertvalue { ptr, i32, i32, i32 } %3570, i32 %3579, 2
  %3581 = getelementptr inbounds i8, ptr %3573, i32 -12
  store i32 %3579, ptr %3581, align 4
  %3582 = extractvalue { ptr, i32, i32, i32 } %3570, 3
  %3583 = icmp eq i32 %3582, 0
  br i1 %3583, label %3584, label %3598

3584:                                             ; preds = %3571
  %3585 = shl i32 %3582, 1
  %3586 = call i32 @llvm.umin.i32(i32 %3585, i32 1024)
  %3587 = add i32 %3586, %3582
  %3588 = call i32 @llvm.umax.i32(i32 %3587, i32 8)
  %3589 = zext i32 %3588 to i64
  %3590 = mul i64 %3589, 32
  %3591 = add i64 %3590, 16
  %3592 = call ptr @realloc(ptr null, i64 %3591)
  store i32 1, ptr %3592, align 4
  %3593 = getelementptr inbounds i8, ptr %3592, i32 4
  store i32 0, ptr %3593, align 4
  %3594 = getelementptr inbounds i8, ptr %3592, i32 16
  %3595 = call ptr @realloc(ptr null, i64 8)
  store ptr %3594, ptr %3595, align 8
  %3596 = insertvalue { ptr, i32, i32, i32 } %3580, ptr %3595, 0
  %3597 = insertvalue { ptr, i32, i32, i32 } %3596, i32 %3588, 3
  br label %3618

3598:                                             ; preds = %3571
  %3599 = icmp ult i32 %3579, %3582
  br i1 %3599, label %3600, label %3601

3600:                                             ; preds = %3598
  br label %3615

3601:                                             ; preds = %3598
  %3602 = shl i32 %3582, 1
  %3603 = call i32 @llvm.umin.i32(i32 %3602, i32 1024)
  %3604 = add i32 %3603, %3582
  %3605 = call i32 @llvm.umax.i32(i32 %3604, i32 8)
  %3606 = zext i32 %3605 to i64
  %3607 = mul i64 %3606, 32
  %3608 = add i64 %3607, 16
  %3609 = extractvalue { ptr, i32, i32, i32 } %3570, 0
  %3610 = load ptr, ptr %3609, align 8
  %3611 = getelementptr inbounds i8, ptr %3610, i32 -16
  %3612 = call ptr @realloc(ptr %3611, i64 %3608)
  %3613 = getelementptr inbounds i8, ptr %3612, i32 16
  store ptr %3613, ptr %3609, align 8
  %3614 = insertvalue { ptr, i32, i32, i32 } %3580, i32 %3605, 3
  br label %3615

3615:                                             ; preds = %3600, %3601
  %3616 = phi { ptr, i32, i32, i32 } [ %3614, %3601 ], [ %3580, %3600 ]
  br label %3617

3617:                                             ; preds = %3615
  br label %3618

3618:                                             ; preds = %3584, %3617
  %3619 = phi { ptr, i32, i32, i32 } [ %3616, %3617 ], [ %3597, %3584 ]
  br label %3620

3620:                                             ; preds = %3618
  %3621 = extractvalue { ptr, i32, i32, i32 } %3619, 0
  %3622 = load ptr, ptr %3621, align 8
  %3623 = extractvalue { ptr, i32, i32, i32 } %3619, 2
  %3624 = zext i32 %3623 to i64
  %3625 = mul i64 %3624, 32
  %3626 = getelementptr inbounds i8, ptr %3622, i64 %3625
  store i252 %3510, ptr %3626, align 16
  %3627 = extractvalue { ptr, i32, i32, i32 } %3619, 2
  %3628 = add i32 %3627, 1
  %3629 = insertvalue { ptr, i32, i32, i32 } %3619, i32 %3628, 2
  %3630 = getelementptr inbounds i8, ptr %3622, i32 -12
  store i32 %3628, ptr %3630, align 4
  %3631 = extractvalue { ptr, i32, i32, i32 } %3619, 3
  %3632 = icmp eq i32 %3631, 0
  br i1 %3632, label %3633, label %3647

3633:                                             ; preds = %3620
  %3634 = shl i32 %3631, 1
  %3635 = call i32 @llvm.umin.i32(i32 %3634, i32 1024)
  %3636 = add i32 %3635, %3631
  %3637 = call i32 @llvm.umax.i32(i32 %3636, i32 8)
  %3638 = zext i32 %3637 to i64
  %3639 = mul i64 %3638, 32
  %3640 = add i64 %3639, 16
  %3641 = call ptr @realloc(ptr null, i64 %3640)
  store i32 1, ptr %3641, align 4
  %3642 = getelementptr inbounds i8, ptr %3641, i32 4
  store i32 0, ptr %3642, align 4
  %3643 = getelementptr inbounds i8, ptr %3641, i32 16
  %3644 = call ptr @realloc(ptr null, i64 8)
  store ptr %3643, ptr %3644, align 8
  %3645 = insertvalue { ptr, i32, i32, i32 } %3629, ptr %3644, 0
  %3646 = insertvalue { ptr, i32, i32, i32 } %3645, i32 %3637, 3
  br label %3667

3647:                                             ; preds = %3620
  %3648 = icmp ult i32 %3628, %3631
  br i1 %3648, label %3649, label %3650

3649:                                             ; preds = %3647
  br label %3664

3650:                                             ; preds = %3647
  %3651 = shl i32 %3631, 1
  %3652 = call i32 @llvm.umin.i32(i32 %3651, i32 1024)
  %3653 = add i32 %3652, %3631
  %3654 = call i32 @llvm.umax.i32(i32 %3653, i32 8)
  %3655 = zext i32 %3654 to i64
  %3656 = mul i64 %3655, 32
  %3657 = add i64 %3656, 16
  %3658 = extractvalue { ptr, i32, i32, i32 } %3619, 0
  %3659 = load ptr, ptr %3658, align 8
  %3660 = getelementptr inbounds i8, ptr %3659, i32 -16
  %3661 = call ptr @realloc(ptr %3660, i64 %3657)
  %3662 = getelementptr inbounds i8, ptr %3661, i32 16
  store ptr %3662, ptr %3658, align 8
  %3663 = insertvalue { ptr, i32, i32, i32 } %3629, i32 %3654, 3
  br label %3664

3664:                                             ; preds = %3649, %3650
  %3665 = phi { ptr, i32, i32, i32 } [ %3663, %3650 ], [ %3629, %3649 ]
  br label %3666

3666:                                             ; preds = %3664
  br label %3667

3667:                                             ; preds = %3633, %3666
  %3668 = phi { ptr, i32, i32, i32 } [ %3665, %3666 ], [ %3646, %3633 ]
  br label %3669

3669:                                             ; preds = %3667
  %3670 = extractvalue { ptr, i32, i32, i32 } %3668, 0
  %3671 = load ptr, ptr %3670, align 8
  %3672 = extractvalue { ptr, i32, i32, i32 } %3668, 2
  %3673 = zext i32 %3672 to i64
  %3674 = mul i64 %3673, 32
  %3675 = getelementptr inbounds i8, ptr %3671, i64 %3674
  store i252 %3517, ptr %3675, align 16
  %3676 = extractvalue { ptr, i32, i32, i32 } %3668, 2
  %3677 = add i32 %3676, 1
  %3678 = insertvalue { ptr, i32, i32, i32 } %3668, i32 %3677, 2
  %3679 = getelementptr inbounds i8, ptr %3671, i32 -12
  store i32 %3677, ptr %3679, align 4
  %3680 = extractvalue { ptr, i32, i32, i32 } %3668, 3
  %3681 = icmp eq i32 %3680, 0
  br i1 %3681, label %3682, label %3696

3682:                                             ; preds = %3669
  %3683 = shl i32 %3680, 1
  %3684 = call i32 @llvm.umin.i32(i32 %3683, i32 1024)
  %3685 = add i32 %3684, %3680
  %3686 = call i32 @llvm.umax.i32(i32 %3685, i32 8)
  %3687 = zext i32 %3686 to i64
  %3688 = mul i64 %3687, 32
  %3689 = add i64 %3688, 16
  %3690 = call ptr @realloc(ptr null, i64 %3689)
  store i32 1, ptr %3690, align 4
  %3691 = getelementptr inbounds i8, ptr %3690, i32 4
  store i32 0, ptr %3691, align 4
  %3692 = getelementptr inbounds i8, ptr %3690, i32 16
  %3693 = call ptr @realloc(ptr null, i64 8)
  store ptr %3692, ptr %3693, align 8
  %3694 = insertvalue { ptr, i32, i32, i32 } %3678, ptr %3693, 0
  %3695 = insertvalue { ptr, i32, i32, i32 } %3694, i32 %3686, 3
  br label %3716

3696:                                             ; preds = %3669
  %3697 = icmp ult i32 %3677, %3680
  br i1 %3697, label %3698, label %3699

3698:                                             ; preds = %3696
  br label %3713

3699:                                             ; preds = %3696
  %3700 = shl i32 %3680, 1
  %3701 = call i32 @llvm.umin.i32(i32 %3700, i32 1024)
  %3702 = add i32 %3701, %3680
  %3703 = call i32 @llvm.umax.i32(i32 %3702, i32 8)
  %3704 = zext i32 %3703 to i64
  %3705 = mul i64 %3704, 32
  %3706 = add i64 %3705, 16
  %3707 = extractvalue { ptr, i32, i32, i32 } %3668, 0
  %3708 = load ptr, ptr %3707, align 8
  %3709 = getelementptr inbounds i8, ptr %3708, i32 -16
  %3710 = call ptr @realloc(ptr %3709, i64 %3706)
  %3711 = getelementptr inbounds i8, ptr %3710, i32 16
  store ptr %3711, ptr %3707, align 8
  %3712 = insertvalue { ptr, i32, i32, i32 } %3678, i32 %3703, 3
  br label %3713

3713:                                             ; preds = %3698, %3699
  %3714 = phi { ptr, i32, i32, i32 } [ %3712, %3699 ], [ %3678, %3698 ]
  br label %3715

3715:                                             ; preds = %3713
  br label %3716

3716:                                             ; preds = %3682, %3715
  %3717 = phi { ptr, i32, i32, i32 } [ %3714, %3715 ], [ %3695, %3682 ]
  br label %3718

3718:                                             ; preds = %3716
  %3719 = extractvalue { ptr, i32, i32, i32 } %3717, 0
  %3720 = load ptr, ptr %3719, align 8
  %3721 = extractvalue { ptr, i32, i32, i32 } %3717, 2
  %3722 = zext i32 %3721 to i64
  %3723 = mul i64 %3722, 32
  %3724 = getelementptr inbounds i8, ptr %3720, i64 %3723
  store i252 %3524, ptr %3724, align 16
  %3725 = extractvalue { ptr, i32, i32, i32 } %3717, 2
  %3726 = add i32 %3725, 1
  %3727 = insertvalue { ptr, i32, i32, i32 } %3717, i32 %3726, 2
  %3728 = getelementptr inbounds i8, ptr %3720, i32 -12
  store i32 %3726, ptr %3728, align 4
  %3729 = extractvalue { ptr, i32, i32, i32 } %3717, 3
  %3730 = icmp eq i32 %3729, 0
  br i1 %3730, label %3731, label %3745

3731:                                             ; preds = %3718
  %3732 = shl i32 %3729, 1
  %3733 = call i32 @llvm.umin.i32(i32 %3732, i32 1024)
  %3734 = add i32 %3733, %3729
  %3735 = call i32 @llvm.umax.i32(i32 %3734, i32 8)
  %3736 = zext i32 %3735 to i64
  %3737 = mul i64 %3736, 32
  %3738 = add i64 %3737, 16
  %3739 = call ptr @realloc(ptr null, i64 %3738)
  store i32 1, ptr %3739, align 4
  %3740 = getelementptr inbounds i8, ptr %3739, i32 4
  store i32 0, ptr %3740, align 4
  %3741 = getelementptr inbounds i8, ptr %3739, i32 16
  %3742 = call ptr @realloc(ptr null, i64 8)
  store ptr %3741, ptr %3742, align 8
  %3743 = insertvalue { ptr, i32, i32, i32 } %3727, ptr %3742, 0
  %3744 = insertvalue { ptr, i32, i32, i32 } %3743, i32 %3735, 3
  br label %3765

3745:                                             ; preds = %3718
  %3746 = icmp ult i32 %3726, %3729
  br i1 %3746, label %3747, label %3748

3747:                                             ; preds = %3745
  br label %3762

3748:                                             ; preds = %3745
  %3749 = shl i32 %3729, 1
  %3750 = call i32 @llvm.umin.i32(i32 %3749, i32 1024)
  %3751 = add i32 %3750, %3729
  %3752 = call i32 @llvm.umax.i32(i32 %3751, i32 8)
  %3753 = zext i32 %3752 to i64
  %3754 = mul i64 %3753, 32
  %3755 = add i64 %3754, 16
  %3756 = extractvalue { ptr, i32, i32, i32 } %3717, 0
  %3757 = load ptr, ptr %3756, align 8
  %3758 = getelementptr inbounds i8, ptr %3757, i32 -16
  %3759 = call ptr @realloc(ptr %3758, i64 %3755)
  %3760 = getelementptr inbounds i8, ptr %3759, i32 16
  store ptr %3760, ptr %3756, align 8
  %3761 = insertvalue { ptr, i32, i32, i32 } %3727, i32 %3752, 3
  br label %3762

3762:                                             ; preds = %3747, %3748
  %3763 = phi { ptr, i32, i32, i32 } [ %3761, %3748 ], [ %3727, %3747 ]
  br label %3764

3764:                                             ; preds = %3762
  br label %3765

3765:                                             ; preds = %3731, %3764
  %3766 = phi { ptr, i32, i32, i32 } [ %3763, %3764 ], [ %3744, %3731 ]
  br label %3767

3767:                                             ; preds = %3765
  %3768 = extractvalue { ptr, i32, i32, i32 } %3766, 0
  %3769 = load ptr, ptr %3768, align 8
  %3770 = extractvalue { ptr, i32, i32, i32 } %3766, 2
  %3771 = zext i32 %3770 to i64
  %3772 = mul i64 %3771, 32
  %3773 = getelementptr inbounds i8, ptr %3769, i64 %3772
  store i252 %3531, ptr %3773, align 16
  %3774 = extractvalue { ptr, i32, i32, i32 } %3766, 2
  %3775 = add i32 %3774, 1
  %3776 = insertvalue { ptr, i32, i32, i32 } %3766, i32 %3775, 2
  %3777 = getelementptr inbounds i8, ptr %3769, i32 -12
  store i32 %3775, ptr %3777, align 4
  %3778 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %3776, 0
  ret { { ptr, i32, i32, i32 } } %3778

3779:                                             ; preds = %2
  %3780 = load { i6, { i8, i8, i8, i8 } }, ptr %3, align 1
  %3781 = extractvalue { i6, { i8, i8, i8, i8 } } %3780, 1
  %3782 = extractvalue { i8, i8, i8, i8 } %3781, 0
  %3783 = icmp slt i8 %3782, 0
  %3784 = zext i8 %3782 to i252
  %3785 = call i8 @llvm.abs.i8(i8 %3782, i1 false)
  %3786 = zext i8 %3785 to i252
  %3787 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3786
  %3788 = select i1 %3783, i252 %3787, i252 %3784
  %3789 = extractvalue { i8, i8, i8, i8 } %3781, 1
  %3790 = icmp slt i8 %3789, 0
  %3791 = zext i8 %3789 to i252
  %3792 = call i8 @llvm.abs.i8(i8 %3789, i1 false)
  %3793 = zext i8 %3792 to i252
  %3794 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3793
  %3795 = select i1 %3790, i252 %3794, i252 %3791
  %3796 = extractvalue { i8, i8, i8, i8 } %3781, 2
  %3797 = icmp slt i8 %3796, 0
  %3798 = zext i8 %3796 to i252
  %3799 = call i8 @llvm.abs.i8(i8 %3796, i1 false)
  %3800 = zext i8 %3799 to i252
  %3801 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3800
  %3802 = select i1 %3797, i252 %3801, i252 %3798
  %3803 = extractvalue { i8, i8, i8, i8 } %3781, 3
  %3804 = icmp slt i8 %3803, 0
  %3805 = zext i8 %3803 to i252
  %3806 = call i8 @llvm.abs.i8(i8 %3803, i1 false)
  %3807 = zext i8 %3806 to i252
  %3808 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %3807
  %3809 = select i1 %3804, i252 %3808, i252 %3805
  %3810 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %3811 = icmp eq i32 %3810, 0
  br i1 %3811, label %3812, label %3826

3812:                                             ; preds = %3779
  %3813 = shl i32 %3810, 1
  %3814 = call i32 @llvm.umin.i32(i32 %3813, i32 1024)
  %3815 = add i32 %3814, %3810
  %3816 = call i32 @llvm.umax.i32(i32 %3815, i32 8)
  %3817 = zext i32 %3816 to i64
  %3818 = mul i64 %3817, 32
  %3819 = add i64 %3818, 16
  %3820 = call ptr @realloc(ptr null, i64 %3819)
  store i32 1, ptr %3820, align 4
  %3821 = getelementptr inbounds i8, ptr %3820, i32 4
  store i32 0, ptr %3821, align 4
  %3822 = getelementptr inbounds i8, ptr %3820, i32 16
  %3823 = call ptr @realloc(ptr null, i64 8)
  store ptr %3822, ptr %3823, align 8
  %3824 = insertvalue { ptr, i32, i32, i32 } %1, ptr %3823, 0
  %3825 = insertvalue { ptr, i32, i32, i32 } %3824, i32 %3816, 3
  br label %3847

3826:                                             ; preds = %3779
  %3827 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %3828 = icmp ult i32 %3827, %3810
  br i1 %3828, label %3829, label %3830

3829:                                             ; preds = %3826
  br label %3844

3830:                                             ; preds = %3826
  %3831 = shl i32 %3810, 1
  %3832 = call i32 @llvm.umin.i32(i32 %3831, i32 1024)
  %3833 = add i32 %3832, %3810
  %3834 = call i32 @llvm.umax.i32(i32 %3833, i32 8)
  %3835 = zext i32 %3834 to i64
  %3836 = mul i64 %3835, 32
  %3837 = add i64 %3836, 16
  %3838 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %3839 = load ptr, ptr %3838, align 8
  %3840 = getelementptr inbounds i8, ptr %3839, i32 -16
  %3841 = call ptr @realloc(ptr %3840, i64 %3837)
  %3842 = getelementptr inbounds i8, ptr %3841, i32 16
  store ptr %3842, ptr %3838, align 8
  %3843 = insertvalue { ptr, i32, i32, i32 } %1, i32 %3834, 3
  br label %3844

3844:                                             ; preds = %3829, %3830
  %3845 = phi { ptr, i32, i32, i32 } [ %3843, %3830 ], [ %1, %3829 ]
  br label %3846

3846:                                             ; preds = %3844
  br label %3847

3847:                                             ; preds = %3812, %3846
  %3848 = phi { ptr, i32, i32, i32 } [ %3845, %3846 ], [ %3825, %3812 ]
  br label %3849

3849:                                             ; preds = %3847
  %3850 = extractvalue { ptr, i32, i32, i32 } %3848, 0
  %3851 = load ptr, ptr %3850, align 8
  %3852 = extractvalue { ptr, i32, i32, i32 } %3848, 2
  %3853 = zext i32 %3852 to i64
  %3854 = mul i64 %3853, 32
  %3855 = getelementptr inbounds i8, ptr %3851, i64 %3854
  store i252 30, ptr %3855, align 16
  %3856 = extractvalue { ptr, i32, i32, i32 } %3848, 2
  %3857 = add i32 %3856, 1
  %3858 = insertvalue { ptr, i32, i32, i32 } %3848, i32 %3857, 2
  %3859 = getelementptr inbounds i8, ptr %3851, i32 -12
  store i32 %3857, ptr %3859, align 4
  %3860 = extractvalue { ptr, i32, i32, i32 } %3848, 3
  %3861 = icmp eq i32 %3860, 0
  br i1 %3861, label %3862, label %3876

3862:                                             ; preds = %3849
  %3863 = shl i32 %3860, 1
  %3864 = call i32 @llvm.umin.i32(i32 %3863, i32 1024)
  %3865 = add i32 %3864, %3860
  %3866 = call i32 @llvm.umax.i32(i32 %3865, i32 8)
  %3867 = zext i32 %3866 to i64
  %3868 = mul i64 %3867, 32
  %3869 = add i64 %3868, 16
  %3870 = call ptr @realloc(ptr null, i64 %3869)
  store i32 1, ptr %3870, align 4
  %3871 = getelementptr inbounds i8, ptr %3870, i32 4
  store i32 0, ptr %3871, align 4
  %3872 = getelementptr inbounds i8, ptr %3870, i32 16
  %3873 = call ptr @realloc(ptr null, i64 8)
  store ptr %3872, ptr %3873, align 8
  %3874 = insertvalue { ptr, i32, i32, i32 } %3858, ptr %3873, 0
  %3875 = insertvalue { ptr, i32, i32, i32 } %3874, i32 %3866, 3
  br label %3896

3876:                                             ; preds = %3849
  %3877 = icmp ult i32 %3857, %3860
  br i1 %3877, label %3878, label %3879

3878:                                             ; preds = %3876
  br label %3893

3879:                                             ; preds = %3876
  %3880 = shl i32 %3860, 1
  %3881 = call i32 @llvm.umin.i32(i32 %3880, i32 1024)
  %3882 = add i32 %3881, %3860
  %3883 = call i32 @llvm.umax.i32(i32 %3882, i32 8)
  %3884 = zext i32 %3883 to i64
  %3885 = mul i64 %3884, 32
  %3886 = add i64 %3885, 16
  %3887 = extractvalue { ptr, i32, i32, i32 } %3848, 0
  %3888 = load ptr, ptr %3887, align 8
  %3889 = getelementptr inbounds i8, ptr %3888, i32 -16
  %3890 = call ptr @realloc(ptr %3889, i64 %3886)
  %3891 = getelementptr inbounds i8, ptr %3890, i32 16
  store ptr %3891, ptr %3887, align 8
  %3892 = insertvalue { ptr, i32, i32, i32 } %3858, i32 %3883, 3
  br label %3893

3893:                                             ; preds = %3878, %3879
  %3894 = phi { ptr, i32, i32, i32 } [ %3892, %3879 ], [ %3858, %3878 ]
  br label %3895

3895:                                             ; preds = %3893
  br label %3896

3896:                                             ; preds = %3862, %3895
  %3897 = phi { ptr, i32, i32, i32 } [ %3894, %3895 ], [ %3875, %3862 ]
  br label %3898

3898:                                             ; preds = %3896
  %3899 = extractvalue { ptr, i32, i32, i32 } %3897, 0
  %3900 = load ptr, ptr %3899, align 8
  %3901 = extractvalue { ptr, i32, i32, i32 } %3897, 2
  %3902 = zext i32 %3901 to i64
  %3903 = mul i64 %3902, 32
  %3904 = getelementptr inbounds i8, ptr %3900, i64 %3903
  store i252 %3788, ptr %3904, align 16
  %3905 = extractvalue { ptr, i32, i32, i32 } %3897, 2
  %3906 = add i32 %3905, 1
  %3907 = insertvalue { ptr, i32, i32, i32 } %3897, i32 %3906, 2
  %3908 = getelementptr inbounds i8, ptr %3900, i32 -12
  store i32 %3906, ptr %3908, align 4
  %3909 = extractvalue { ptr, i32, i32, i32 } %3897, 3
  %3910 = icmp eq i32 %3909, 0
  br i1 %3910, label %3911, label %3925

3911:                                             ; preds = %3898
  %3912 = shl i32 %3909, 1
  %3913 = call i32 @llvm.umin.i32(i32 %3912, i32 1024)
  %3914 = add i32 %3913, %3909
  %3915 = call i32 @llvm.umax.i32(i32 %3914, i32 8)
  %3916 = zext i32 %3915 to i64
  %3917 = mul i64 %3916, 32
  %3918 = add i64 %3917, 16
  %3919 = call ptr @realloc(ptr null, i64 %3918)
  store i32 1, ptr %3919, align 4
  %3920 = getelementptr inbounds i8, ptr %3919, i32 4
  store i32 0, ptr %3920, align 4
  %3921 = getelementptr inbounds i8, ptr %3919, i32 16
  %3922 = call ptr @realloc(ptr null, i64 8)
  store ptr %3921, ptr %3922, align 8
  %3923 = insertvalue { ptr, i32, i32, i32 } %3907, ptr %3922, 0
  %3924 = insertvalue { ptr, i32, i32, i32 } %3923, i32 %3915, 3
  br label %3945

3925:                                             ; preds = %3898
  %3926 = icmp ult i32 %3906, %3909
  br i1 %3926, label %3927, label %3928

3927:                                             ; preds = %3925
  br label %3942

3928:                                             ; preds = %3925
  %3929 = shl i32 %3909, 1
  %3930 = call i32 @llvm.umin.i32(i32 %3929, i32 1024)
  %3931 = add i32 %3930, %3909
  %3932 = call i32 @llvm.umax.i32(i32 %3931, i32 8)
  %3933 = zext i32 %3932 to i64
  %3934 = mul i64 %3933, 32
  %3935 = add i64 %3934, 16
  %3936 = extractvalue { ptr, i32, i32, i32 } %3897, 0
  %3937 = load ptr, ptr %3936, align 8
  %3938 = getelementptr inbounds i8, ptr %3937, i32 -16
  %3939 = call ptr @realloc(ptr %3938, i64 %3935)
  %3940 = getelementptr inbounds i8, ptr %3939, i32 16
  store ptr %3940, ptr %3936, align 8
  %3941 = insertvalue { ptr, i32, i32, i32 } %3907, i32 %3932, 3
  br label %3942

3942:                                             ; preds = %3927, %3928
  %3943 = phi { ptr, i32, i32, i32 } [ %3941, %3928 ], [ %3907, %3927 ]
  br label %3944

3944:                                             ; preds = %3942
  br label %3945

3945:                                             ; preds = %3911, %3944
  %3946 = phi { ptr, i32, i32, i32 } [ %3943, %3944 ], [ %3924, %3911 ]
  br label %3947

3947:                                             ; preds = %3945
  %3948 = extractvalue { ptr, i32, i32, i32 } %3946, 0
  %3949 = load ptr, ptr %3948, align 8
  %3950 = extractvalue { ptr, i32, i32, i32 } %3946, 2
  %3951 = zext i32 %3950 to i64
  %3952 = mul i64 %3951, 32
  %3953 = getelementptr inbounds i8, ptr %3949, i64 %3952
  store i252 %3795, ptr %3953, align 16
  %3954 = extractvalue { ptr, i32, i32, i32 } %3946, 2
  %3955 = add i32 %3954, 1
  %3956 = insertvalue { ptr, i32, i32, i32 } %3946, i32 %3955, 2
  %3957 = getelementptr inbounds i8, ptr %3949, i32 -12
  store i32 %3955, ptr %3957, align 4
  %3958 = extractvalue { ptr, i32, i32, i32 } %3946, 3
  %3959 = icmp eq i32 %3958, 0
  br i1 %3959, label %3960, label %3974

3960:                                             ; preds = %3947
  %3961 = shl i32 %3958, 1
  %3962 = call i32 @llvm.umin.i32(i32 %3961, i32 1024)
  %3963 = add i32 %3962, %3958
  %3964 = call i32 @llvm.umax.i32(i32 %3963, i32 8)
  %3965 = zext i32 %3964 to i64
  %3966 = mul i64 %3965, 32
  %3967 = add i64 %3966, 16
  %3968 = call ptr @realloc(ptr null, i64 %3967)
  store i32 1, ptr %3968, align 4
  %3969 = getelementptr inbounds i8, ptr %3968, i32 4
  store i32 0, ptr %3969, align 4
  %3970 = getelementptr inbounds i8, ptr %3968, i32 16
  %3971 = call ptr @realloc(ptr null, i64 8)
  store ptr %3970, ptr %3971, align 8
  %3972 = insertvalue { ptr, i32, i32, i32 } %3956, ptr %3971, 0
  %3973 = insertvalue { ptr, i32, i32, i32 } %3972, i32 %3964, 3
  br label %3994

3974:                                             ; preds = %3947
  %3975 = icmp ult i32 %3955, %3958
  br i1 %3975, label %3976, label %3977

3976:                                             ; preds = %3974
  br label %3991

3977:                                             ; preds = %3974
  %3978 = shl i32 %3958, 1
  %3979 = call i32 @llvm.umin.i32(i32 %3978, i32 1024)
  %3980 = add i32 %3979, %3958
  %3981 = call i32 @llvm.umax.i32(i32 %3980, i32 8)
  %3982 = zext i32 %3981 to i64
  %3983 = mul i64 %3982, 32
  %3984 = add i64 %3983, 16
  %3985 = extractvalue { ptr, i32, i32, i32 } %3946, 0
  %3986 = load ptr, ptr %3985, align 8
  %3987 = getelementptr inbounds i8, ptr %3986, i32 -16
  %3988 = call ptr @realloc(ptr %3987, i64 %3984)
  %3989 = getelementptr inbounds i8, ptr %3988, i32 16
  store ptr %3989, ptr %3985, align 8
  %3990 = insertvalue { ptr, i32, i32, i32 } %3956, i32 %3981, 3
  br label %3991

3991:                                             ; preds = %3976, %3977
  %3992 = phi { ptr, i32, i32, i32 } [ %3990, %3977 ], [ %3956, %3976 ]
  br label %3993

3993:                                             ; preds = %3991
  br label %3994

3994:                                             ; preds = %3960, %3993
  %3995 = phi { ptr, i32, i32, i32 } [ %3992, %3993 ], [ %3973, %3960 ]
  br label %3996

3996:                                             ; preds = %3994
  %3997 = extractvalue { ptr, i32, i32, i32 } %3995, 0
  %3998 = load ptr, ptr %3997, align 8
  %3999 = extractvalue { ptr, i32, i32, i32 } %3995, 2
  %4000 = zext i32 %3999 to i64
  %4001 = mul i64 %4000, 32
  %4002 = getelementptr inbounds i8, ptr %3998, i64 %4001
  store i252 %3802, ptr %4002, align 16
  %4003 = extractvalue { ptr, i32, i32, i32 } %3995, 2
  %4004 = add i32 %4003, 1
  %4005 = insertvalue { ptr, i32, i32, i32 } %3995, i32 %4004, 2
  %4006 = getelementptr inbounds i8, ptr %3998, i32 -12
  store i32 %4004, ptr %4006, align 4
  %4007 = extractvalue { ptr, i32, i32, i32 } %3995, 3
  %4008 = icmp eq i32 %4007, 0
  br i1 %4008, label %4009, label %4023

4009:                                             ; preds = %3996
  %4010 = shl i32 %4007, 1
  %4011 = call i32 @llvm.umin.i32(i32 %4010, i32 1024)
  %4012 = add i32 %4011, %4007
  %4013 = call i32 @llvm.umax.i32(i32 %4012, i32 8)
  %4014 = zext i32 %4013 to i64
  %4015 = mul i64 %4014, 32
  %4016 = add i64 %4015, 16
  %4017 = call ptr @realloc(ptr null, i64 %4016)
  store i32 1, ptr %4017, align 4
  %4018 = getelementptr inbounds i8, ptr %4017, i32 4
  store i32 0, ptr %4018, align 4
  %4019 = getelementptr inbounds i8, ptr %4017, i32 16
  %4020 = call ptr @realloc(ptr null, i64 8)
  store ptr %4019, ptr %4020, align 8
  %4021 = insertvalue { ptr, i32, i32, i32 } %4005, ptr %4020, 0
  %4022 = insertvalue { ptr, i32, i32, i32 } %4021, i32 %4013, 3
  br label %4043

4023:                                             ; preds = %3996
  %4024 = icmp ult i32 %4004, %4007
  br i1 %4024, label %4025, label %4026

4025:                                             ; preds = %4023
  br label %4040

4026:                                             ; preds = %4023
  %4027 = shl i32 %4007, 1
  %4028 = call i32 @llvm.umin.i32(i32 %4027, i32 1024)
  %4029 = add i32 %4028, %4007
  %4030 = call i32 @llvm.umax.i32(i32 %4029, i32 8)
  %4031 = zext i32 %4030 to i64
  %4032 = mul i64 %4031, 32
  %4033 = add i64 %4032, 16
  %4034 = extractvalue { ptr, i32, i32, i32 } %3995, 0
  %4035 = load ptr, ptr %4034, align 8
  %4036 = getelementptr inbounds i8, ptr %4035, i32 -16
  %4037 = call ptr @realloc(ptr %4036, i64 %4033)
  %4038 = getelementptr inbounds i8, ptr %4037, i32 16
  store ptr %4038, ptr %4034, align 8
  %4039 = insertvalue { ptr, i32, i32, i32 } %4005, i32 %4030, 3
  br label %4040

4040:                                             ; preds = %4025, %4026
  %4041 = phi { ptr, i32, i32, i32 } [ %4039, %4026 ], [ %4005, %4025 ]
  br label %4042

4042:                                             ; preds = %4040
  br label %4043

4043:                                             ; preds = %4009, %4042
  %4044 = phi { ptr, i32, i32, i32 } [ %4041, %4042 ], [ %4022, %4009 ]
  br label %4045

4045:                                             ; preds = %4043
  %4046 = extractvalue { ptr, i32, i32, i32 } %4044, 0
  %4047 = load ptr, ptr %4046, align 8
  %4048 = extractvalue { ptr, i32, i32, i32 } %4044, 2
  %4049 = zext i32 %4048 to i64
  %4050 = mul i64 %4049, 32
  %4051 = getelementptr inbounds i8, ptr %4047, i64 %4050
  store i252 %3809, ptr %4051, align 16
  %4052 = extractvalue { ptr, i32, i32, i32 } %4044, 2
  %4053 = add i32 %4052, 1
  %4054 = insertvalue { ptr, i32, i32, i32 } %4044, i32 %4053, 2
  %4055 = getelementptr inbounds i8, ptr %4047, i32 -12
  store i32 %4053, ptr %4055, align 4
  %4056 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4054, 0
  ret { { ptr, i32, i32, i32 } } %4056

4057:                                             ; preds = %2
  %4058 = load { i6, { i16, i16, i16 } }, ptr %3, align 2
  %4059 = extractvalue { i6, { i16, i16, i16 } } %4058, 1
  %4060 = extractvalue { i16, i16, i16 } %4059, 0
  %4061 = icmp slt i16 %4060, 0
  %4062 = zext i16 %4060 to i252
  %4063 = call i16 @llvm.abs.i16(i16 %4060, i1 false)
  %4064 = zext i16 %4063 to i252
  %4065 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %4064
  %4066 = select i1 %4061, i252 %4065, i252 %4062
  %4067 = extractvalue { i16, i16, i16 } %4059, 1
  %4068 = icmp slt i16 %4067, 0
  %4069 = zext i16 %4067 to i252
  %4070 = call i16 @llvm.abs.i16(i16 %4067, i1 false)
  %4071 = zext i16 %4070 to i252
  %4072 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %4071
  %4073 = select i1 %4068, i252 %4072, i252 %4069
  %4074 = extractvalue { i16, i16, i16 } %4059, 2
  %4075 = icmp slt i16 %4074, 0
  %4076 = zext i16 %4074 to i252
  %4077 = call i16 @llvm.abs.i16(i16 %4074, i1 false)
  %4078 = zext i16 %4077 to i252
  %4079 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %4078
  %4080 = select i1 %4075, i252 %4079, i252 %4076
  %4081 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4082 = icmp eq i32 %4081, 0
  br i1 %4082, label %4083, label %4097

4083:                                             ; preds = %4057
  %4084 = shl i32 %4081, 1
  %4085 = call i32 @llvm.umin.i32(i32 %4084, i32 1024)
  %4086 = add i32 %4085, %4081
  %4087 = call i32 @llvm.umax.i32(i32 %4086, i32 8)
  %4088 = zext i32 %4087 to i64
  %4089 = mul i64 %4088, 32
  %4090 = add i64 %4089, 16
  %4091 = call ptr @realloc(ptr null, i64 %4090)
  store i32 1, ptr %4091, align 4
  %4092 = getelementptr inbounds i8, ptr %4091, i32 4
  store i32 0, ptr %4092, align 4
  %4093 = getelementptr inbounds i8, ptr %4091, i32 16
  %4094 = call ptr @realloc(ptr null, i64 8)
  store ptr %4093, ptr %4094, align 8
  %4095 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4094, 0
  %4096 = insertvalue { ptr, i32, i32, i32 } %4095, i32 %4087, 3
  br label %4118

4097:                                             ; preds = %4057
  %4098 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4099 = icmp ult i32 %4098, %4081
  br i1 %4099, label %4100, label %4101

4100:                                             ; preds = %4097
  br label %4115

4101:                                             ; preds = %4097
  %4102 = shl i32 %4081, 1
  %4103 = call i32 @llvm.umin.i32(i32 %4102, i32 1024)
  %4104 = add i32 %4103, %4081
  %4105 = call i32 @llvm.umax.i32(i32 %4104, i32 8)
  %4106 = zext i32 %4105 to i64
  %4107 = mul i64 %4106, 32
  %4108 = add i64 %4107, 16
  %4109 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4110 = load ptr, ptr %4109, align 8
  %4111 = getelementptr inbounds i8, ptr %4110, i32 -16
  %4112 = call ptr @realloc(ptr %4111, i64 %4108)
  %4113 = getelementptr inbounds i8, ptr %4112, i32 16
  store ptr %4113, ptr %4109, align 8
  %4114 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4105, 3
  br label %4115

4115:                                             ; preds = %4100, %4101
  %4116 = phi { ptr, i32, i32, i32 } [ %4114, %4101 ], [ %1, %4100 ]
  br label %4117

4117:                                             ; preds = %4115
  br label %4118

4118:                                             ; preds = %4083, %4117
  %4119 = phi { ptr, i32, i32, i32 } [ %4116, %4117 ], [ %4096, %4083 ]
  br label %4120

4120:                                             ; preds = %4118
  %4121 = extractvalue { ptr, i32, i32, i32 } %4119, 0
  %4122 = load ptr, ptr %4121, align 8
  %4123 = extractvalue { ptr, i32, i32, i32 } %4119, 2
  %4124 = zext i32 %4123 to i64
  %4125 = mul i64 %4124, 32
  %4126 = getelementptr inbounds i8, ptr %4122, i64 %4125
  store i252 31, ptr %4126, align 16
  %4127 = extractvalue { ptr, i32, i32, i32 } %4119, 2
  %4128 = add i32 %4127, 1
  %4129 = insertvalue { ptr, i32, i32, i32 } %4119, i32 %4128, 2
  %4130 = getelementptr inbounds i8, ptr %4122, i32 -12
  store i32 %4128, ptr %4130, align 4
  %4131 = extractvalue { ptr, i32, i32, i32 } %4119, 3
  %4132 = icmp eq i32 %4131, 0
  br i1 %4132, label %4133, label %4147

4133:                                             ; preds = %4120
  %4134 = shl i32 %4131, 1
  %4135 = call i32 @llvm.umin.i32(i32 %4134, i32 1024)
  %4136 = add i32 %4135, %4131
  %4137 = call i32 @llvm.umax.i32(i32 %4136, i32 8)
  %4138 = zext i32 %4137 to i64
  %4139 = mul i64 %4138, 32
  %4140 = add i64 %4139, 16
  %4141 = call ptr @realloc(ptr null, i64 %4140)
  store i32 1, ptr %4141, align 4
  %4142 = getelementptr inbounds i8, ptr %4141, i32 4
  store i32 0, ptr %4142, align 4
  %4143 = getelementptr inbounds i8, ptr %4141, i32 16
  %4144 = call ptr @realloc(ptr null, i64 8)
  store ptr %4143, ptr %4144, align 8
  %4145 = insertvalue { ptr, i32, i32, i32 } %4129, ptr %4144, 0
  %4146 = insertvalue { ptr, i32, i32, i32 } %4145, i32 %4137, 3
  br label %4167

4147:                                             ; preds = %4120
  %4148 = icmp ult i32 %4128, %4131
  br i1 %4148, label %4149, label %4150

4149:                                             ; preds = %4147
  br label %4164

4150:                                             ; preds = %4147
  %4151 = shl i32 %4131, 1
  %4152 = call i32 @llvm.umin.i32(i32 %4151, i32 1024)
  %4153 = add i32 %4152, %4131
  %4154 = call i32 @llvm.umax.i32(i32 %4153, i32 8)
  %4155 = zext i32 %4154 to i64
  %4156 = mul i64 %4155, 32
  %4157 = add i64 %4156, 16
  %4158 = extractvalue { ptr, i32, i32, i32 } %4119, 0
  %4159 = load ptr, ptr %4158, align 8
  %4160 = getelementptr inbounds i8, ptr %4159, i32 -16
  %4161 = call ptr @realloc(ptr %4160, i64 %4157)
  %4162 = getelementptr inbounds i8, ptr %4161, i32 16
  store ptr %4162, ptr %4158, align 8
  %4163 = insertvalue { ptr, i32, i32, i32 } %4129, i32 %4154, 3
  br label %4164

4164:                                             ; preds = %4149, %4150
  %4165 = phi { ptr, i32, i32, i32 } [ %4163, %4150 ], [ %4129, %4149 ]
  br label %4166

4166:                                             ; preds = %4164
  br label %4167

4167:                                             ; preds = %4133, %4166
  %4168 = phi { ptr, i32, i32, i32 } [ %4165, %4166 ], [ %4146, %4133 ]
  br label %4169

4169:                                             ; preds = %4167
  %4170 = extractvalue { ptr, i32, i32, i32 } %4168, 0
  %4171 = load ptr, ptr %4170, align 8
  %4172 = extractvalue { ptr, i32, i32, i32 } %4168, 2
  %4173 = zext i32 %4172 to i64
  %4174 = mul i64 %4173, 32
  %4175 = getelementptr inbounds i8, ptr %4171, i64 %4174
  store i252 %4066, ptr %4175, align 16
  %4176 = extractvalue { ptr, i32, i32, i32 } %4168, 2
  %4177 = add i32 %4176, 1
  %4178 = insertvalue { ptr, i32, i32, i32 } %4168, i32 %4177, 2
  %4179 = getelementptr inbounds i8, ptr %4171, i32 -12
  store i32 %4177, ptr %4179, align 4
  %4180 = extractvalue { ptr, i32, i32, i32 } %4168, 3
  %4181 = icmp eq i32 %4180, 0
  br i1 %4181, label %4182, label %4196

4182:                                             ; preds = %4169
  %4183 = shl i32 %4180, 1
  %4184 = call i32 @llvm.umin.i32(i32 %4183, i32 1024)
  %4185 = add i32 %4184, %4180
  %4186 = call i32 @llvm.umax.i32(i32 %4185, i32 8)
  %4187 = zext i32 %4186 to i64
  %4188 = mul i64 %4187, 32
  %4189 = add i64 %4188, 16
  %4190 = call ptr @realloc(ptr null, i64 %4189)
  store i32 1, ptr %4190, align 4
  %4191 = getelementptr inbounds i8, ptr %4190, i32 4
  store i32 0, ptr %4191, align 4
  %4192 = getelementptr inbounds i8, ptr %4190, i32 16
  %4193 = call ptr @realloc(ptr null, i64 8)
  store ptr %4192, ptr %4193, align 8
  %4194 = insertvalue { ptr, i32, i32, i32 } %4178, ptr %4193, 0
  %4195 = insertvalue { ptr, i32, i32, i32 } %4194, i32 %4186, 3
  br label %4216

4196:                                             ; preds = %4169
  %4197 = icmp ult i32 %4177, %4180
  br i1 %4197, label %4198, label %4199

4198:                                             ; preds = %4196
  br label %4213

4199:                                             ; preds = %4196
  %4200 = shl i32 %4180, 1
  %4201 = call i32 @llvm.umin.i32(i32 %4200, i32 1024)
  %4202 = add i32 %4201, %4180
  %4203 = call i32 @llvm.umax.i32(i32 %4202, i32 8)
  %4204 = zext i32 %4203 to i64
  %4205 = mul i64 %4204, 32
  %4206 = add i64 %4205, 16
  %4207 = extractvalue { ptr, i32, i32, i32 } %4168, 0
  %4208 = load ptr, ptr %4207, align 8
  %4209 = getelementptr inbounds i8, ptr %4208, i32 -16
  %4210 = call ptr @realloc(ptr %4209, i64 %4206)
  %4211 = getelementptr inbounds i8, ptr %4210, i32 16
  store ptr %4211, ptr %4207, align 8
  %4212 = insertvalue { ptr, i32, i32, i32 } %4178, i32 %4203, 3
  br label %4213

4213:                                             ; preds = %4198, %4199
  %4214 = phi { ptr, i32, i32, i32 } [ %4212, %4199 ], [ %4178, %4198 ]
  br label %4215

4215:                                             ; preds = %4213
  br label %4216

4216:                                             ; preds = %4182, %4215
  %4217 = phi { ptr, i32, i32, i32 } [ %4214, %4215 ], [ %4195, %4182 ]
  br label %4218

4218:                                             ; preds = %4216
  %4219 = extractvalue { ptr, i32, i32, i32 } %4217, 0
  %4220 = load ptr, ptr %4219, align 8
  %4221 = extractvalue { ptr, i32, i32, i32 } %4217, 2
  %4222 = zext i32 %4221 to i64
  %4223 = mul i64 %4222, 32
  %4224 = getelementptr inbounds i8, ptr %4220, i64 %4223
  store i252 %4073, ptr %4224, align 16
  %4225 = extractvalue { ptr, i32, i32, i32 } %4217, 2
  %4226 = add i32 %4225, 1
  %4227 = insertvalue { ptr, i32, i32, i32 } %4217, i32 %4226, 2
  %4228 = getelementptr inbounds i8, ptr %4220, i32 -12
  store i32 %4226, ptr %4228, align 4
  %4229 = extractvalue { ptr, i32, i32, i32 } %4217, 3
  %4230 = icmp eq i32 %4229, 0
  br i1 %4230, label %4231, label %4245

4231:                                             ; preds = %4218
  %4232 = shl i32 %4229, 1
  %4233 = call i32 @llvm.umin.i32(i32 %4232, i32 1024)
  %4234 = add i32 %4233, %4229
  %4235 = call i32 @llvm.umax.i32(i32 %4234, i32 8)
  %4236 = zext i32 %4235 to i64
  %4237 = mul i64 %4236, 32
  %4238 = add i64 %4237, 16
  %4239 = call ptr @realloc(ptr null, i64 %4238)
  store i32 1, ptr %4239, align 4
  %4240 = getelementptr inbounds i8, ptr %4239, i32 4
  store i32 0, ptr %4240, align 4
  %4241 = getelementptr inbounds i8, ptr %4239, i32 16
  %4242 = call ptr @realloc(ptr null, i64 8)
  store ptr %4241, ptr %4242, align 8
  %4243 = insertvalue { ptr, i32, i32, i32 } %4227, ptr %4242, 0
  %4244 = insertvalue { ptr, i32, i32, i32 } %4243, i32 %4235, 3
  br label %4265

4245:                                             ; preds = %4218
  %4246 = icmp ult i32 %4226, %4229
  br i1 %4246, label %4247, label %4248

4247:                                             ; preds = %4245
  br label %4262

4248:                                             ; preds = %4245
  %4249 = shl i32 %4229, 1
  %4250 = call i32 @llvm.umin.i32(i32 %4249, i32 1024)
  %4251 = add i32 %4250, %4229
  %4252 = call i32 @llvm.umax.i32(i32 %4251, i32 8)
  %4253 = zext i32 %4252 to i64
  %4254 = mul i64 %4253, 32
  %4255 = add i64 %4254, 16
  %4256 = extractvalue { ptr, i32, i32, i32 } %4217, 0
  %4257 = load ptr, ptr %4256, align 8
  %4258 = getelementptr inbounds i8, ptr %4257, i32 -16
  %4259 = call ptr @realloc(ptr %4258, i64 %4255)
  %4260 = getelementptr inbounds i8, ptr %4259, i32 16
  store ptr %4260, ptr %4256, align 8
  %4261 = insertvalue { ptr, i32, i32, i32 } %4227, i32 %4252, 3
  br label %4262

4262:                                             ; preds = %4247, %4248
  %4263 = phi { ptr, i32, i32, i32 } [ %4261, %4248 ], [ %4227, %4247 ]
  br label %4264

4264:                                             ; preds = %4262
  br label %4265

4265:                                             ; preds = %4231, %4264
  %4266 = phi { ptr, i32, i32, i32 } [ %4263, %4264 ], [ %4244, %4231 ]
  br label %4267

4267:                                             ; preds = %4265
  %4268 = extractvalue { ptr, i32, i32, i32 } %4266, 0
  %4269 = load ptr, ptr %4268, align 8
  %4270 = extractvalue { ptr, i32, i32, i32 } %4266, 2
  %4271 = zext i32 %4270 to i64
  %4272 = mul i64 %4271, 32
  %4273 = getelementptr inbounds i8, ptr %4269, i64 %4272
  store i252 %4080, ptr %4273, align 16
  %4274 = extractvalue { ptr, i32, i32, i32 } %4266, 2
  %4275 = add i32 %4274, 1
  %4276 = insertvalue { ptr, i32, i32, i32 } %4266, i32 %4275, 2
  %4277 = getelementptr inbounds i8, ptr %4269, i32 -12
  store i32 %4275, ptr %4277, align 4
  %4278 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4276, 0
  ret { { ptr, i32, i32, i32 } } %4278

4279:                                             ; preds = %2
  %4280 = load { i6, { i8, i8, { i2, [0 x i8] } } }, ptr %3, align 1
  %4281 = extractvalue { i6, { i8, i8, { i2, [0 x i8] } } } %4280, 1
  %4282 = extractvalue { i8, i8, { i2, [0 x i8] } } %4281, 0
  %4283 = zext i8 %4282 to i252
  %4284 = extractvalue { i8, i8, { i2, [0 x i8] } } %4281, 1
  %4285 = zext i8 %4284 to i252
  %4286 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4287 = icmp eq i32 %4286, 0
  br i1 %4287, label %4288, label %4302

4288:                                             ; preds = %4279
  %4289 = shl i32 %4286, 1
  %4290 = call i32 @llvm.umin.i32(i32 %4289, i32 1024)
  %4291 = add i32 %4290, %4286
  %4292 = call i32 @llvm.umax.i32(i32 %4291, i32 8)
  %4293 = zext i32 %4292 to i64
  %4294 = mul i64 %4293, 32
  %4295 = add i64 %4294, 16
  %4296 = call ptr @realloc(ptr null, i64 %4295)
  store i32 1, ptr %4296, align 4
  %4297 = getelementptr inbounds i8, ptr %4296, i32 4
  store i32 0, ptr %4297, align 4
  %4298 = getelementptr inbounds i8, ptr %4296, i32 16
  %4299 = call ptr @realloc(ptr null, i64 8)
  store ptr %4298, ptr %4299, align 8
  %4300 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4299, 0
  %4301 = insertvalue { ptr, i32, i32, i32 } %4300, i32 %4292, 3
  br label %4323

4302:                                             ; preds = %4279
  %4303 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4304 = icmp ult i32 %4303, %4286
  br i1 %4304, label %4305, label %4306

4305:                                             ; preds = %4302
  br label %4320

4306:                                             ; preds = %4302
  %4307 = shl i32 %4286, 1
  %4308 = call i32 @llvm.umin.i32(i32 %4307, i32 1024)
  %4309 = add i32 %4308, %4286
  %4310 = call i32 @llvm.umax.i32(i32 %4309, i32 8)
  %4311 = zext i32 %4310 to i64
  %4312 = mul i64 %4311, 32
  %4313 = add i64 %4312, 16
  %4314 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4315 = load ptr, ptr %4314, align 8
  %4316 = getelementptr inbounds i8, ptr %4315, i32 -16
  %4317 = call ptr @realloc(ptr %4316, i64 %4313)
  %4318 = getelementptr inbounds i8, ptr %4317, i32 16
  store ptr %4318, ptr %4314, align 8
  %4319 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4310, 3
  br label %4320

4320:                                             ; preds = %4305, %4306
  %4321 = phi { ptr, i32, i32, i32 } [ %4319, %4306 ], [ %1, %4305 ]
  br label %4322

4322:                                             ; preds = %4320
  br label %4323

4323:                                             ; preds = %4288, %4322
  %4324 = phi { ptr, i32, i32, i32 } [ %4321, %4322 ], [ %4301, %4288 ]
  br label %4325

4325:                                             ; preds = %4323
  %4326 = extractvalue { ptr, i32, i32, i32 } %4324, 0
  %4327 = load ptr, ptr %4326, align 8
  %4328 = extractvalue { ptr, i32, i32, i32 } %4324, 2
  %4329 = zext i32 %4328 to i64
  %4330 = mul i64 %4329, 32
  %4331 = getelementptr inbounds i8, ptr %4327, i64 %4330
  store i252 32, ptr %4331, align 16
  %4332 = extractvalue { ptr, i32, i32, i32 } %4324, 2
  %4333 = add i32 %4332, 1
  %4334 = insertvalue { ptr, i32, i32, i32 } %4324, i32 %4333, 2
  %4335 = getelementptr inbounds i8, ptr %4327, i32 -12
  store i32 %4333, ptr %4335, align 4
  %4336 = extractvalue { ptr, i32, i32, i32 } %4324, 3
  %4337 = icmp eq i32 %4336, 0
  br i1 %4337, label %4338, label %4352

4338:                                             ; preds = %4325
  %4339 = shl i32 %4336, 1
  %4340 = call i32 @llvm.umin.i32(i32 %4339, i32 1024)
  %4341 = add i32 %4340, %4336
  %4342 = call i32 @llvm.umax.i32(i32 %4341, i32 8)
  %4343 = zext i32 %4342 to i64
  %4344 = mul i64 %4343, 32
  %4345 = add i64 %4344, 16
  %4346 = call ptr @realloc(ptr null, i64 %4345)
  store i32 1, ptr %4346, align 4
  %4347 = getelementptr inbounds i8, ptr %4346, i32 4
  store i32 0, ptr %4347, align 4
  %4348 = getelementptr inbounds i8, ptr %4346, i32 16
  %4349 = call ptr @realloc(ptr null, i64 8)
  store ptr %4348, ptr %4349, align 8
  %4350 = insertvalue { ptr, i32, i32, i32 } %4334, ptr %4349, 0
  %4351 = insertvalue { ptr, i32, i32, i32 } %4350, i32 %4342, 3
  br label %4372

4352:                                             ; preds = %4325
  %4353 = icmp ult i32 %4333, %4336
  br i1 %4353, label %4354, label %4355

4354:                                             ; preds = %4352
  br label %4369

4355:                                             ; preds = %4352
  %4356 = shl i32 %4336, 1
  %4357 = call i32 @llvm.umin.i32(i32 %4356, i32 1024)
  %4358 = add i32 %4357, %4336
  %4359 = call i32 @llvm.umax.i32(i32 %4358, i32 8)
  %4360 = zext i32 %4359 to i64
  %4361 = mul i64 %4360, 32
  %4362 = add i64 %4361, 16
  %4363 = extractvalue { ptr, i32, i32, i32 } %4324, 0
  %4364 = load ptr, ptr %4363, align 8
  %4365 = getelementptr inbounds i8, ptr %4364, i32 -16
  %4366 = call ptr @realloc(ptr %4365, i64 %4362)
  %4367 = getelementptr inbounds i8, ptr %4366, i32 16
  store ptr %4367, ptr %4363, align 8
  %4368 = insertvalue { ptr, i32, i32, i32 } %4334, i32 %4359, 3
  br label %4369

4369:                                             ; preds = %4354, %4355
  %4370 = phi { ptr, i32, i32, i32 } [ %4368, %4355 ], [ %4334, %4354 ]
  br label %4371

4371:                                             ; preds = %4369
  br label %4372

4372:                                             ; preds = %4338, %4371
  %4373 = phi { ptr, i32, i32, i32 } [ %4370, %4371 ], [ %4351, %4338 ]
  br label %4374

4374:                                             ; preds = %4372
  %4375 = extractvalue { ptr, i32, i32, i32 } %4373, 0
  %4376 = load ptr, ptr %4375, align 8
  %4377 = extractvalue { ptr, i32, i32, i32 } %4373, 2
  %4378 = zext i32 %4377 to i64
  %4379 = mul i64 %4378, 32
  %4380 = getelementptr inbounds i8, ptr %4376, i64 %4379
  store i252 %4283, ptr %4380, align 16
  %4381 = extractvalue { ptr, i32, i32, i32 } %4373, 2
  %4382 = add i32 %4381, 1
  %4383 = insertvalue { ptr, i32, i32, i32 } %4373, i32 %4382, 2
  %4384 = getelementptr inbounds i8, ptr %4376, i32 -12
  store i32 %4382, ptr %4384, align 4
  %4385 = extractvalue { ptr, i32, i32, i32 } %4373, 3
  %4386 = icmp eq i32 %4385, 0
  br i1 %4386, label %4387, label %4401

4387:                                             ; preds = %4374
  %4388 = shl i32 %4385, 1
  %4389 = call i32 @llvm.umin.i32(i32 %4388, i32 1024)
  %4390 = add i32 %4389, %4385
  %4391 = call i32 @llvm.umax.i32(i32 %4390, i32 8)
  %4392 = zext i32 %4391 to i64
  %4393 = mul i64 %4392, 32
  %4394 = add i64 %4393, 16
  %4395 = call ptr @realloc(ptr null, i64 %4394)
  store i32 1, ptr %4395, align 4
  %4396 = getelementptr inbounds i8, ptr %4395, i32 4
  store i32 0, ptr %4396, align 4
  %4397 = getelementptr inbounds i8, ptr %4395, i32 16
  %4398 = call ptr @realloc(ptr null, i64 8)
  store ptr %4397, ptr %4398, align 8
  %4399 = insertvalue { ptr, i32, i32, i32 } %4383, ptr %4398, 0
  %4400 = insertvalue { ptr, i32, i32, i32 } %4399, i32 %4391, 3
  br label %4421

4401:                                             ; preds = %4374
  %4402 = icmp ult i32 %4382, %4385
  br i1 %4402, label %4403, label %4404

4403:                                             ; preds = %4401
  br label %4418

4404:                                             ; preds = %4401
  %4405 = shl i32 %4385, 1
  %4406 = call i32 @llvm.umin.i32(i32 %4405, i32 1024)
  %4407 = add i32 %4406, %4385
  %4408 = call i32 @llvm.umax.i32(i32 %4407, i32 8)
  %4409 = zext i32 %4408 to i64
  %4410 = mul i64 %4409, 32
  %4411 = add i64 %4410, 16
  %4412 = extractvalue { ptr, i32, i32, i32 } %4373, 0
  %4413 = load ptr, ptr %4412, align 8
  %4414 = getelementptr inbounds i8, ptr %4413, i32 -16
  %4415 = call ptr @realloc(ptr %4414, i64 %4411)
  %4416 = getelementptr inbounds i8, ptr %4415, i32 16
  store ptr %4416, ptr %4412, align 8
  %4417 = insertvalue { ptr, i32, i32, i32 } %4383, i32 %4408, 3
  br label %4418

4418:                                             ; preds = %4403, %4404
  %4419 = phi { ptr, i32, i32, i32 } [ %4417, %4404 ], [ %4383, %4403 ]
  br label %4420

4420:                                             ; preds = %4418
  br label %4421

4421:                                             ; preds = %4387, %4420
  %4422 = phi { ptr, i32, i32, i32 } [ %4419, %4420 ], [ %4400, %4387 ]
  br label %4423

4423:                                             ; preds = %4421
  %4424 = extractvalue { ptr, i32, i32, i32 } %4422, 0
  %4425 = load ptr, ptr %4424, align 8
  %4426 = extractvalue { ptr, i32, i32, i32 } %4422, 2
  %4427 = zext i32 %4426 to i64
  %4428 = mul i64 %4427, 32
  %4429 = getelementptr inbounds i8, ptr %4425, i64 %4428
  store i252 %4285, ptr %4429, align 16
  %4430 = extractvalue { ptr, i32, i32, i32 } %4422, 2
  %4431 = add i32 %4430, 1
  %4432 = insertvalue { ptr, i32, i32, i32 } %4422, i32 %4431, 2
  %4433 = getelementptr inbounds i8, ptr %4425, i32 -12
  store i32 %4431, ptr %4433, align 4
  %4434 = extractvalue { i8, i8, { i2, [0 x i8] } } %4281, 2
  %4435 = extractvalue { i2, [0 x i8] } %4434, 0
  switch i2 %4435, label %5169 [
    i2 0, label %5171
    i2 1, label %5224
    i2 -2, label %5278
    i2 -1, label %5332
  ]

4436:                                             ; preds = %2
  %4437 = load { i6, i8 }, ptr %3, align 1
  %4438 = extractvalue { i6, i8 } %4437, 1
  %4439 = zext i8 %4438 to i252
  %4440 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4441 = icmp eq i32 %4440, 0
  br i1 %4441, label %4442, label %4456

4442:                                             ; preds = %4436
  %4443 = shl i32 %4440, 1
  %4444 = call i32 @llvm.umin.i32(i32 %4443, i32 1024)
  %4445 = add i32 %4444, %4440
  %4446 = call i32 @llvm.umax.i32(i32 %4445, i32 8)
  %4447 = zext i32 %4446 to i64
  %4448 = mul i64 %4447, 32
  %4449 = add i64 %4448, 16
  %4450 = call ptr @realloc(ptr null, i64 %4449)
  store i32 1, ptr %4450, align 4
  %4451 = getelementptr inbounds i8, ptr %4450, i32 4
  store i32 0, ptr %4451, align 4
  %4452 = getelementptr inbounds i8, ptr %4450, i32 16
  %4453 = call ptr @realloc(ptr null, i64 8)
  store ptr %4452, ptr %4453, align 8
  %4454 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4453, 0
  %4455 = insertvalue { ptr, i32, i32, i32 } %4454, i32 %4446, 3
  br label %4477

4456:                                             ; preds = %4436
  %4457 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4458 = icmp ult i32 %4457, %4440
  br i1 %4458, label %4459, label %4460

4459:                                             ; preds = %4456
  br label %4474

4460:                                             ; preds = %4456
  %4461 = shl i32 %4440, 1
  %4462 = call i32 @llvm.umin.i32(i32 %4461, i32 1024)
  %4463 = add i32 %4462, %4440
  %4464 = call i32 @llvm.umax.i32(i32 %4463, i32 8)
  %4465 = zext i32 %4464 to i64
  %4466 = mul i64 %4465, 32
  %4467 = add i64 %4466, 16
  %4468 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4469 = load ptr, ptr %4468, align 8
  %4470 = getelementptr inbounds i8, ptr %4469, i32 -16
  %4471 = call ptr @realloc(ptr %4470, i64 %4467)
  %4472 = getelementptr inbounds i8, ptr %4471, i32 16
  store ptr %4472, ptr %4468, align 8
  %4473 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4464, 3
  br label %4474

4474:                                             ; preds = %4459, %4460
  %4475 = phi { ptr, i32, i32, i32 } [ %4473, %4460 ], [ %1, %4459 ]
  br label %4476

4476:                                             ; preds = %4474
  br label %4477

4477:                                             ; preds = %4442, %4476
  %4478 = phi { ptr, i32, i32, i32 } [ %4475, %4476 ], [ %4455, %4442 ]
  br label %4479

4479:                                             ; preds = %4477
  %4480 = extractvalue { ptr, i32, i32, i32 } %4478, 0
  %4481 = load ptr, ptr %4480, align 8
  %4482 = extractvalue { ptr, i32, i32, i32 } %4478, 2
  %4483 = zext i32 %4482 to i64
  %4484 = mul i64 %4483, 32
  %4485 = getelementptr inbounds i8, ptr %4481, i64 %4484
  store i252 33, ptr %4485, align 16
  %4486 = extractvalue { ptr, i32, i32, i32 } %4478, 2
  %4487 = add i32 %4486, 1
  %4488 = insertvalue { ptr, i32, i32, i32 } %4478, i32 %4487, 2
  %4489 = getelementptr inbounds i8, ptr %4481, i32 -12
  store i32 %4487, ptr %4489, align 4
  %4490 = extractvalue { ptr, i32, i32, i32 } %4478, 3
  %4491 = icmp eq i32 %4490, 0
  br i1 %4491, label %4492, label %4506

4492:                                             ; preds = %4479
  %4493 = shl i32 %4490, 1
  %4494 = call i32 @llvm.umin.i32(i32 %4493, i32 1024)
  %4495 = add i32 %4494, %4490
  %4496 = call i32 @llvm.umax.i32(i32 %4495, i32 8)
  %4497 = zext i32 %4496 to i64
  %4498 = mul i64 %4497, 32
  %4499 = add i64 %4498, 16
  %4500 = call ptr @realloc(ptr null, i64 %4499)
  store i32 1, ptr %4500, align 4
  %4501 = getelementptr inbounds i8, ptr %4500, i32 4
  store i32 0, ptr %4501, align 4
  %4502 = getelementptr inbounds i8, ptr %4500, i32 16
  %4503 = call ptr @realloc(ptr null, i64 8)
  store ptr %4502, ptr %4503, align 8
  %4504 = insertvalue { ptr, i32, i32, i32 } %4488, ptr %4503, 0
  %4505 = insertvalue { ptr, i32, i32, i32 } %4504, i32 %4496, 3
  br label %4526

4506:                                             ; preds = %4479
  %4507 = icmp ult i32 %4487, %4490
  br i1 %4507, label %4508, label %4509

4508:                                             ; preds = %4506
  br label %4523

4509:                                             ; preds = %4506
  %4510 = shl i32 %4490, 1
  %4511 = call i32 @llvm.umin.i32(i32 %4510, i32 1024)
  %4512 = add i32 %4511, %4490
  %4513 = call i32 @llvm.umax.i32(i32 %4512, i32 8)
  %4514 = zext i32 %4513 to i64
  %4515 = mul i64 %4514, 32
  %4516 = add i64 %4515, 16
  %4517 = extractvalue { ptr, i32, i32, i32 } %4478, 0
  %4518 = load ptr, ptr %4517, align 8
  %4519 = getelementptr inbounds i8, ptr %4518, i32 -16
  %4520 = call ptr @realloc(ptr %4519, i64 %4516)
  %4521 = getelementptr inbounds i8, ptr %4520, i32 16
  store ptr %4521, ptr %4517, align 8
  %4522 = insertvalue { ptr, i32, i32, i32 } %4488, i32 %4513, 3
  br label %4523

4523:                                             ; preds = %4508, %4509
  %4524 = phi { ptr, i32, i32, i32 } [ %4522, %4509 ], [ %4488, %4508 ]
  br label %4525

4525:                                             ; preds = %4523
  br label %4526

4526:                                             ; preds = %4492, %4525
  %4527 = phi { ptr, i32, i32, i32 } [ %4524, %4525 ], [ %4505, %4492 ]
  br label %4528

4528:                                             ; preds = %4526
  %4529 = extractvalue { ptr, i32, i32, i32 } %4527, 0
  %4530 = load ptr, ptr %4529, align 8
  %4531 = extractvalue { ptr, i32, i32, i32 } %4527, 2
  %4532 = zext i32 %4531 to i64
  %4533 = mul i64 %4532, 32
  %4534 = getelementptr inbounds i8, ptr %4530, i64 %4533
  store i252 %4439, ptr %4534, align 16
  %4535 = extractvalue { ptr, i32, i32, i32 } %4527, 2
  %4536 = add i32 %4535, 1
  %4537 = insertvalue { ptr, i32, i32, i32 } %4527, i32 %4536, 2
  %4538 = getelementptr inbounds i8, ptr %4530, i32 -12
  store i32 %4536, ptr %4538, align 4
  %4539 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4537, 0
  ret { { ptr, i32, i32, i32 } } %4539

4540:                                             ; preds = %2
  %4541 = load { i6, i8 }, ptr %3, align 1
  %4542 = extractvalue { i6, i8 } %4541, 1
  %4543 = zext i8 %4542 to i252
  %4544 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4545 = icmp eq i32 %4544, 0
  br i1 %4545, label %4546, label %4560

4546:                                             ; preds = %4540
  %4547 = shl i32 %4544, 1
  %4548 = call i32 @llvm.umin.i32(i32 %4547, i32 1024)
  %4549 = add i32 %4548, %4544
  %4550 = call i32 @llvm.umax.i32(i32 %4549, i32 8)
  %4551 = zext i32 %4550 to i64
  %4552 = mul i64 %4551, 32
  %4553 = add i64 %4552, 16
  %4554 = call ptr @realloc(ptr null, i64 %4553)
  store i32 1, ptr %4554, align 4
  %4555 = getelementptr inbounds i8, ptr %4554, i32 4
  store i32 0, ptr %4555, align 4
  %4556 = getelementptr inbounds i8, ptr %4554, i32 16
  %4557 = call ptr @realloc(ptr null, i64 8)
  store ptr %4556, ptr %4557, align 8
  %4558 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4557, 0
  %4559 = insertvalue { ptr, i32, i32, i32 } %4558, i32 %4550, 3
  br label %4581

4560:                                             ; preds = %4540
  %4561 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4562 = icmp ult i32 %4561, %4544
  br i1 %4562, label %4563, label %4564

4563:                                             ; preds = %4560
  br label %4578

4564:                                             ; preds = %4560
  %4565 = shl i32 %4544, 1
  %4566 = call i32 @llvm.umin.i32(i32 %4565, i32 1024)
  %4567 = add i32 %4566, %4544
  %4568 = call i32 @llvm.umax.i32(i32 %4567, i32 8)
  %4569 = zext i32 %4568 to i64
  %4570 = mul i64 %4569, 32
  %4571 = add i64 %4570, 16
  %4572 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4573 = load ptr, ptr %4572, align 8
  %4574 = getelementptr inbounds i8, ptr %4573, i32 -16
  %4575 = call ptr @realloc(ptr %4574, i64 %4571)
  %4576 = getelementptr inbounds i8, ptr %4575, i32 16
  store ptr %4576, ptr %4572, align 8
  %4577 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4568, 3
  br label %4578

4578:                                             ; preds = %4563, %4564
  %4579 = phi { ptr, i32, i32, i32 } [ %4577, %4564 ], [ %1, %4563 ]
  br label %4580

4580:                                             ; preds = %4578
  br label %4581

4581:                                             ; preds = %4546, %4580
  %4582 = phi { ptr, i32, i32, i32 } [ %4579, %4580 ], [ %4559, %4546 ]
  br label %4583

4583:                                             ; preds = %4581
  %4584 = extractvalue { ptr, i32, i32, i32 } %4582, 0
  %4585 = load ptr, ptr %4584, align 8
  %4586 = extractvalue { ptr, i32, i32, i32 } %4582, 2
  %4587 = zext i32 %4586 to i64
  %4588 = mul i64 %4587, 32
  %4589 = getelementptr inbounds i8, ptr %4585, i64 %4588
  store i252 34, ptr %4589, align 16
  %4590 = extractvalue { ptr, i32, i32, i32 } %4582, 2
  %4591 = add i32 %4590, 1
  %4592 = insertvalue { ptr, i32, i32, i32 } %4582, i32 %4591, 2
  %4593 = getelementptr inbounds i8, ptr %4585, i32 -12
  store i32 %4591, ptr %4593, align 4
  %4594 = extractvalue { ptr, i32, i32, i32 } %4582, 3
  %4595 = icmp eq i32 %4594, 0
  br i1 %4595, label %4596, label %4610

4596:                                             ; preds = %4583
  %4597 = shl i32 %4594, 1
  %4598 = call i32 @llvm.umin.i32(i32 %4597, i32 1024)
  %4599 = add i32 %4598, %4594
  %4600 = call i32 @llvm.umax.i32(i32 %4599, i32 8)
  %4601 = zext i32 %4600 to i64
  %4602 = mul i64 %4601, 32
  %4603 = add i64 %4602, 16
  %4604 = call ptr @realloc(ptr null, i64 %4603)
  store i32 1, ptr %4604, align 4
  %4605 = getelementptr inbounds i8, ptr %4604, i32 4
  store i32 0, ptr %4605, align 4
  %4606 = getelementptr inbounds i8, ptr %4604, i32 16
  %4607 = call ptr @realloc(ptr null, i64 8)
  store ptr %4606, ptr %4607, align 8
  %4608 = insertvalue { ptr, i32, i32, i32 } %4592, ptr %4607, 0
  %4609 = insertvalue { ptr, i32, i32, i32 } %4608, i32 %4600, 3
  br label %4630

4610:                                             ; preds = %4583
  %4611 = icmp ult i32 %4591, %4594
  br i1 %4611, label %4612, label %4613

4612:                                             ; preds = %4610
  br label %4627

4613:                                             ; preds = %4610
  %4614 = shl i32 %4594, 1
  %4615 = call i32 @llvm.umin.i32(i32 %4614, i32 1024)
  %4616 = add i32 %4615, %4594
  %4617 = call i32 @llvm.umax.i32(i32 %4616, i32 8)
  %4618 = zext i32 %4617 to i64
  %4619 = mul i64 %4618, 32
  %4620 = add i64 %4619, 16
  %4621 = extractvalue { ptr, i32, i32, i32 } %4582, 0
  %4622 = load ptr, ptr %4621, align 8
  %4623 = getelementptr inbounds i8, ptr %4622, i32 -16
  %4624 = call ptr @realloc(ptr %4623, i64 %4620)
  %4625 = getelementptr inbounds i8, ptr %4624, i32 16
  store ptr %4625, ptr %4621, align 8
  %4626 = insertvalue { ptr, i32, i32, i32 } %4592, i32 %4617, 3
  br label %4627

4627:                                             ; preds = %4612, %4613
  %4628 = phi { ptr, i32, i32, i32 } [ %4626, %4613 ], [ %4592, %4612 ]
  br label %4629

4629:                                             ; preds = %4627
  br label %4630

4630:                                             ; preds = %4596, %4629
  %4631 = phi { ptr, i32, i32, i32 } [ %4628, %4629 ], [ %4609, %4596 ]
  br label %4632

4632:                                             ; preds = %4630
  %4633 = extractvalue { ptr, i32, i32, i32 } %4631, 0
  %4634 = load ptr, ptr %4633, align 8
  %4635 = extractvalue { ptr, i32, i32, i32 } %4631, 2
  %4636 = zext i32 %4635 to i64
  %4637 = mul i64 %4636, 32
  %4638 = getelementptr inbounds i8, ptr %4634, i64 %4637
  store i252 %4543, ptr %4638, align 16
  %4639 = extractvalue { ptr, i32, i32, i32 } %4631, 2
  %4640 = add i32 %4639, 1
  %4641 = insertvalue { ptr, i32, i32, i32 } %4631, i32 %4640, 2
  %4642 = getelementptr inbounds i8, ptr %4634, i32 -12
  store i32 %4640, ptr %4642, align 4
  %4643 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4641, 0
  ret { { ptr, i32, i32, i32 } } %4643

4644:                                             ; preds = %2
  %4645 = load { i6, i8 }, ptr %3, align 1
  %4646 = extractvalue { i6, i8 } %4645, 1
  %4647 = zext i8 %4646 to i252
  %4648 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4649 = icmp eq i32 %4648, 0
  br i1 %4649, label %4650, label %4664

4650:                                             ; preds = %4644
  %4651 = shl i32 %4648, 1
  %4652 = call i32 @llvm.umin.i32(i32 %4651, i32 1024)
  %4653 = add i32 %4652, %4648
  %4654 = call i32 @llvm.umax.i32(i32 %4653, i32 8)
  %4655 = zext i32 %4654 to i64
  %4656 = mul i64 %4655, 32
  %4657 = add i64 %4656, 16
  %4658 = call ptr @realloc(ptr null, i64 %4657)
  store i32 1, ptr %4658, align 4
  %4659 = getelementptr inbounds i8, ptr %4658, i32 4
  store i32 0, ptr %4659, align 4
  %4660 = getelementptr inbounds i8, ptr %4658, i32 16
  %4661 = call ptr @realloc(ptr null, i64 8)
  store ptr %4660, ptr %4661, align 8
  %4662 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4661, 0
  %4663 = insertvalue { ptr, i32, i32, i32 } %4662, i32 %4654, 3
  br label %4685

4664:                                             ; preds = %4644
  %4665 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4666 = icmp ult i32 %4665, %4648
  br i1 %4666, label %4667, label %4668

4667:                                             ; preds = %4664
  br label %4682

4668:                                             ; preds = %4664
  %4669 = shl i32 %4648, 1
  %4670 = call i32 @llvm.umin.i32(i32 %4669, i32 1024)
  %4671 = add i32 %4670, %4648
  %4672 = call i32 @llvm.umax.i32(i32 %4671, i32 8)
  %4673 = zext i32 %4672 to i64
  %4674 = mul i64 %4673, 32
  %4675 = add i64 %4674, 16
  %4676 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4677 = load ptr, ptr %4676, align 8
  %4678 = getelementptr inbounds i8, ptr %4677, i32 -16
  %4679 = call ptr @realloc(ptr %4678, i64 %4675)
  %4680 = getelementptr inbounds i8, ptr %4679, i32 16
  store ptr %4680, ptr %4676, align 8
  %4681 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4672, 3
  br label %4682

4682:                                             ; preds = %4667, %4668
  %4683 = phi { ptr, i32, i32, i32 } [ %4681, %4668 ], [ %1, %4667 ]
  br label %4684

4684:                                             ; preds = %4682
  br label %4685

4685:                                             ; preds = %4650, %4684
  %4686 = phi { ptr, i32, i32, i32 } [ %4683, %4684 ], [ %4663, %4650 ]
  br label %4687

4687:                                             ; preds = %4685
  %4688 = extractvalue { ptr, i32, i32, i32 } %4686, 0
  %4689 = load ptr, ptr %4688, align 8
  %4690 = extractvalue { ptr, i32, i32, i32 } %4686, 2
  %4691 = zext i32 %4690 to i64
  %4692 = mul i64 %4691, 32
  %4693 = getelementptr inbounds i8, ptr %4689, i64 %4692
  store i252 35, ptr %4693, align 16
  %4694 = extractvalue { ptr, i32, i32, i32 } %4686, 2
  %4695 = add i32 %4694, 1
  %4696 = insertvalue { ptr, i32, i32, i32 } %4686, i32 %4695, 2
  %4697 = getelementptr inbounds i8, ptr %4689, i32 -12
  store i32 %4695, ptr %4697, align 4
  %4698 = extractvalue { ptr, i32, i32, i32 } %4686, 3
  %4699 = icmp eq i32 %4698, 0
  br i1 %4699, label %4700, label %4714

4700:                                             ; preds = %4687
  %4701 = shl i32 %4698, 1
  %4702 = call i32 @llvm.umin.i32(i32 %4701, i32 1024)
  %4703 = add i32 %4702, %4698
  %4704 = call i32 @llvm.umax.i32(i32 %4703, i32 8)
  %4705 = zext i32 %4704 to i64
  %4706 = mul i64 %4705, 32
  %4707 = add i64 %4706, 16
  %4708 = call ptr @realloc(ptr null, i64 %4707)
  store i32 1, ptr %4708, align 4
  %4709 = getelementptr inbounds i8, ptr %4708, i32 4
  store i32 0, ptr %4709, align 4
  %4710 = getelementptr inbounds i8, ptr %4708, i32 16
  %4711 = call ptr @realloc(ptr null, i64 8)
  store ptr %4710, ptr %4711, align 8
  %4712 = insertvalue { ptr, i32, i32, i32 } %4696, ptr %4711, 0
  %4713 = insertvalue { ptr, i32, i32, i32 } %4712, i32 %4704, 3
  br label %4734

4714:                                             ; preds = %4687
  %4715 = icmp ult i32 %4695, %4698
  br i1 %4715, label %4716, label %4717

4716:                                             ; preds = %4714
  br label %4731

4717:                                             ; preds = %4714
  %4718 = shl i32 %4698, 1
  %4719 = call i32 @llvm.umin.i32(i32 %4718, i32 1024)
  %4720 = add i32 %4719, %4698
  %4721 = call i32 @llvm.umax.i32(i32 %4720, i32 8)
  %4722 = zext i32 %4721 to i64
  %4723 = mul i64 %4722, 32
  %4724 = add i64 %4723, 16
  %4725 = extractvalue { ptr, i32, i32, i32 } %4686, 0
  %4726 = load ptr, ptr %4725, align 8
  %4727 = getelementptr inbounds i8, ptr %4726, i32 -16
  %4728 = call ptr @realloc(ptr %4727, i64 %4724)
  %4729 = getelementptr inbounds i8, ptr %4728, i32 16
  store ptr %4729, ptr %4725, align 8
  %4730 = insertvalue { ptr, i32, i32, i32 } %4696, i32 %4721, 3
  br label %4731

4731:                                             ; preds = %4716, %4717
  %4732 = phi { ptr, i32, i32, i32 } [ %4730, %4717 ], [ %4696, %4716 ]
  br label %4733

4733:                                             ; preds = %4731
  br label %4734

4734:                                             ; preds = %4700, %4733
  %4735 = phi { ptr, i32, i32, i32 } [ %4732, %4733 ], [ %4713, %4700 ]
  br label %4736

4736:                                             ; preds = %4734
  %4737 = extractvalue { ptr, i32, i32, i32 } %4735, 0
  %4738 = load ptr, ptr %4737, align 8
  %4739 = extractvalue { ptr, i32, i32, i32 } %4735, 2
  %4740 = zext i32 %4739 to i64
  %4741 = mul i64 %4740, 32
  %4742 = getelementptr inbounds i8, ptr %4738, i64 %4741
  store i252 %4647, ptr %4742, align 16
  %4743 = extractvalue { ptr, i32, i32, i32 } %4735, 2
  %4744 = add i32 %4743, 1
  %4745 = insertvalue { ptr, i32, i32, i32 } %4735, i32 %4744, 2
  %4746 = getelementptr inbounds i8, ptr %4738, i32 -12
  store i32 %4744, ptr %4746, align 4
  %4747 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4745, 0
  ret { { ptr, i32, i32, i32 } } %4747

4748:                                             ; preds = %2
  %4749 = load { i6, i8 }, ptr %3, align 1
  %4750 = extractvalue { i6, i8 } %4749, 1
  %4751 = icmp slt i8 %4750, 0
  %4752 = zext i8 %4750 to i252
  %4753 = call i8 @llvm.abs.i8(i8 %4750, i1 false)
  %4754 = zext i8 %4753 to i252
  %4755 = sub i252 -3618502788666131000275863779947924135206266826270938552493006944358698582015, %4754
  %4756 = select i1 %4751, i252 %4755, i252 %4752
  %4757 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4758 = icmp eq i32 %4757, 0
  br i1 %4758, label %4759, label %4773

4759:                                             ; preds = %4748
  %4760 = shl i32 %4757, 1
  %4761 = call i32 @llvm.umin.i32(i32 %4760, i32 1024)
  %4762 = add i32 %4761, %4757
  %4763 = call i32 @llvm.umax.i32(i32 %4762, i32 8)
  %4764 = zext i32 %4763 to i64
  %4765 = mul i64 %4764, 32
  %4766 = add i64 %4765, 16
  %4767 = call ptr @realloc(ptr null, i64 %4766)
  store i32 1, ptr %4767, align 4
  %4768 = getelementptr inbounds i8, ptr %4767, i32 4
  store i32 0, ptr %4768, align 4
  %4769 = getelementptr inbounds i8, ptr %4767, i32 16
  %4770 = call ptr @realloc(ptr null, i64 8)
  store ptr %4769, ptr %4770, align 8
  %4771 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4770, 0
  %4772 = insertvalue { ptr, i32, i32, i32 } %4771, i32 %4763, 3
  br label %4794

4773:                                             ; preds = %4748
  %4774 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4775 = icmp ult i32 %4774, %4757
  br i1 %4775, label %4776, label %4777

4776:                                             ; preds = %4773
  br label %4791

4777:                                             ; preds = %4773
  %4778 = shl i32 %4757, 1
  %4779 = call i32 @llvm.umin.i32(i32 %4778, i32 1024)
  %4780 = add i32 %4779, %4757
  %4781 = call i32 @llvm.umax.i32(i32 %4780, i32 8)
  %4782 = zext i32 %4781 to i64
  %4783 = mul i64 %4782, 32
  %4784 = add i64 %4783, 16
  %4785 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4786 = load ptr, ptr %4785, align 8
  %4787 = getelementptr inbounds i8, ptr %4786, i32 -16
  %4788 = call ptr @realloc(ptr %4787, i64 %4784)
  %4789 = getelementptr inbounds i8, ptr %4788, i32 16
  store ptr %4789, ptr %4785, align 8
  %4790 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4781, 3
  br label %4791

4791:                                             ; preds = %4776, %4777
  %4792 = phi { ptr, i32, i32, i32 } [ %4790, %4777 ], [ %1, %4776 ]
  br label %4793

4793:                                             ; preds = %4791
  br label %4794

4794:                                             ; preds = %4759, %4793
  %4795 = phi { ptr, i32, i32, i32 } [ %4792, %4793 ], [ %4772, %4759 ]
  br label %4796

4796:                                             ; preds = %4794
  %4797 = extractvalue { ptr, i32, i32, i32 } %4795, 0
  %4798 = load ptr, ptr %4797, align 8
  %4799 = extractvalue { ptr, i32, i32, i32 } %4795, 2
  %4800 = zext i32 %4799 to i64
  %4801 = mul i64 %4800, 32
  %4802 = getelementptr inbounds i8, ptr %4798, i64 %4801
  store i252 36, ptr %4802, align 16
  %4803 = extractvalue { ptr, i32, i32, i32 } %4795, 2
  %4804 = add i32 %4803, 1
  %4805 = insertvalue { ptr, i32, i32, i32 } %4795, i32 %4804, 2
  %4806 = getelementptr inbounds i8, ptr %4798, i32 -12
  store i32 %4804, ptr %4806, align 4
  %4807 = extractvalue { ptr, i32, i32, i32 } %4795, 3
  %4808 = icmp eq i32 %4807, 0
  br i1 %4808, label %4809, label %4823

4809:                                             ; preds = %4796
  %4810 = shl i32 %4807, 1
  %4811 = call i32 @llvm.umin.i32(i32 %4810, i32 1024)
  %4812 = add i32 %4811, %4807
  %4813 = call i32 @llvm.umax.i32(i32 %4812, i32 8)
  %4814 = zext i32 %4813 to i64
  %4815 = mul i64 %4814, 32
  %4816 = add i64 %4815, 16
  %4817 = call ptr @realloc(ptr null, i64 %4816)
  store i32 1, ptr %4817, align 4
  %4818 = getelementptr inbounds i8, ptr %4817, i32 4
  store i32 0, ptr %4818, align 4
  %4819 = getelementptr inbounds i8, ptr %4817, i32 16
  %4820 = call ptr @realloc(ptr null, i64 8)
  store ptr %4819, ptr %4820, align 8
  %4821 = insertvalue { ptr, i32, i32, i32 } %4805, ptr %4820, 0
  %4822 = insertvalue { ptr, i32, i32, i32 } %4821, i32 %4813, 3
  br label %4843

4823:                                             ; preds = %4796
  %4824 = icmp ult i32 %4804, %4807
  br i1 %4824, label %4825, label %4826

4825:                                             ; preds = %4823
  br label %4840

4826:                                             ; preds = %4823
  %4827 = shl i32 %4807, 1
  %4828 = call i32 @llvm.umin.i32(i32 %4827, i32 1024)
  %4829 = add i32 %4828, %4807
  %4830 = call i32 @llvm.umax.i32(i32 %4829, i32 8)
  %4831 = zext i32 %4830 to i64
  %4832 = mul i64 %4831, 32
  %4833 = add i64 %4832, 16
  %4834 = extractvalue { ptr, i32, i32, i32 } %4795, 0
  %4835 = load ptr, ptr %4834, align 8
  %4836 = getelementptr inbounds i8, ptr %4835, i32 -16
  %4837 = call ptr @realloc(ptr %4836, i64 %4833)
  %4838 = getelementptr inbounds i8, ptr %4837, i32 16
  store ptr %4838, ptr %4834, align 8
  %4839 = insertvalue { ptr, i32, i32, i32 } %4805, i32 %4830, 3
  br label %4840

4840:                                             ; preds = %4825, %4826
  %4841 = phi { ptr, i32, i32, i32 } [ %4839, %4826 ], [ %4805, %4825 ]
  br label %4842

4842:                                             ; preds = %4840
  br label %4843

4843:                                             ; preds = %4809, %4842
  %4844 = phi { ptr, i32, i32, i32 } [ %4841, %4842 ], [ %4822, %4809 ]
  br label %4845

4845:                                             ; preds = %4843
  %4846 = extractvalue { ptr, i32, i32, i32 } %4844, 0
  %4847 = load ptr, ptr %4846, align 8
  %4848 = extractvalue { ptr, i32, i32, i32 } %4844, 2
  %4849 = zext i32 %4848 to i64
  %4850 = mul i64 %4849, 32
  %4851 = getelementptr inbounds i8, ptr %4847, i64 %4850
  store i252 %4756, ptr %4851, align 16
  %4852 = extractvalue { ptr, i32, i32, i32 } %4844, 2
  %4853 = add i32 %4852, 1
  %4854 = insertvalue { ptr, i32, i32, i32 } %4844, i32 %4853, 2
  %4855 = getelementptr inbounds i8, ptr %4847, i32 -12
  store i32 %4853, ptr %4855, align 4
  %4856 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4854, 0
  ret { { ptr, i32, i32, i32 } } %4856

4857:                                             ; preds = %2
  %4858 = load { i6, i8 }, ptr %3, align 1
  %4859 = extractvalue { i6, i8 } %4858, 1
  %4860 = zext i8 %4859 to i252
  %4861 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4862 = icmp eq i32 %4861, 0
  br i1 %4862, label %4863, label %4877

4863:                                             ; preds = %4857
  %4864 = shl i32 %4861, 1
  %4865 = call i32 @llvm.umin.i32(i32 %4864, i32 1024)
  %4866 = add i32 %4865, %4861
  %4867 = call i32 @llvm.umax.i32(i32 %4866, i32 8)
  %4868 = zext i32 %4867 to i64
  %4869 = mul i64 %4868, 32
  %4870 = add i64 %4869, 16
  %4871 = call ptr @realloc(ptr null, i64 %4870)
  store i32 1, ptr %4871, align 4
  %4872 = getelementptr inbounds i8, ptr %4871, i32 4
  store i32 0, ptr %4872, align 4
  %4873 = getelementptr inbounds i8, ptr %4871, i32 16
  %4874 = call ptr @realloc(ptr null, i64 8)
  store ptr %4873, ptr %4874, align 8
  %4875 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4874, 0
  %4876 = insertvalue { ptr, i32, i32, i32 } %4875, i32 %4867, 3
  br label %4898

4877:                                             ; preds = %4857
  %4878 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4879 = icmp ult i32 %4878, %4861
  br i1 %4879, label %4880, label %4881

4880:                                             ; preds = %4877
  br label %4895

4881:                                             ; preds = %4877
  %4882 = shl i32 %4861, 1
  %4883 = call i32 @llvm.umin.i32(i32 %4882, i32 1024)
  %4884 = add i32 %4883, %4861
  %4885 = call i32 @llvm.umax.i32(i32 %4884, i32 8)
  %4886 = zext i32 %4885 to i64
  %4887 = mul i64 %4886, 32
  %4888 = add i64 %4887, 16
  %4889 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4890 = load ptr, ptr %4889, align 8
  %4891 = getelementptr inbounds i8, ptr %4890, i32 -16
  %4892 = call ptr @realloc(ptr %4891, i64 %4888)
  %4893 = getelementptr inbounds i8, ptr %4892, i32 16
  store ptr %4893, ptr %4889, align 8
  %4894 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4885, 3
  br label %4895

4895:                                             ; preds = %4880, %4881
  %4896 = phi { ptr, i32, i32, i32 } [ %4894, %4881 ], [ %1, %4880 ]
  br label %4897

4897:                                             ; preds = %4895
  br label %4898

4898:                                             ; preds = %4863, %4897
  %4899 = phi { ptr, i32, i32, i32 } [ %4896, %4897 ], [ %4876, %4863 ]
  br label %4900

4900:                                             ; preds = %4898
  %4901 = extractvalue { ptr, i32, i32, i32 } %4899, 0
  %4902 = load ptr, ptr %4901, align 8
  %4903 = extractvalue { ptr, i32, i32, i32 } %4899, 2
  %4904 = zext i32 %4903 to i64
  %4905 = mul i64 %4904, 32
  %4906 = getelementptr inbounds i8, ptr %4902, i64 %4905
  store i252 37, ptr %4906, align 16
  %4907 = extractvalue { ptr, i32, i32, i32 } %4899, 2
  %4908 = add i32 %4907, 1
  %4909 = insertvalue { ptr, i32, i32, i32 } %4899, i32 %4908, 2
  %4910 = getelementptr inbounds i8, ptr %4902, i32 -12
  store i32 %4908, ptr %4910, align 4
  %4911 = extractvalue { ptr, i32, i32, i32 } %4899, 3
  %4912 = icmp eq i32 %4911, 0
  br i1 %4912, label %4913, label %4927

4913:                                             ; preds = %4900
  %4914 = shl i32 %4911, 1
  %4915 = call i32 @llvm.umin.i32(i32 %4914, i32 1024)
  %4916 = add i32 %4915, %4911
  %4917 = call i32 @llvm.umax.i32(i32 %4916, i32 8)
  %4918 = zext i32 %4917 to i64
  %4919 = mul i64 %4918, 32
  %4920 = add i64 %4919, 16
  %4921 = call ptr @realloc(ptr null, i64 %4920)
  store i32 1, ptr %4921, align 4
  %4922 = getelementptr inbounds i8, ptr %4921, i32 4
  store i32 0, ptr %4922, align 4
  %4923 = getelementptr inbounds i8, ptr %4921, i32 16
  %4924 = call ptr @realloc(ptr null, i64 8)
  store ptr %4923, ptr %4924, align 8
  %4925 = insertvalue { ptr, i32, i32, i32 } %4909, ptr %4924, 0
  %4926 = insertvalue { ptr, i32, i32, i32 } %4925, i32 %4917, 3
  br label %4947

4927:                                             ; preds = %4900
  %4928 = icmp ult i32 %4908, %4911
  br i1 %4928, label %4929, label %4930

4929:                                             ; preds = %4927
  br label %4944

4930:                                             ; preds = %4927
  %4931 = shl i32 %4911, 1
  %4932 = call i32 @llvm.umin.i32(i32 %4931, i32 1024)
  %4933 = add i32 %4932, %4911
  %4934 = call i32 @llvm.umax.i32(i32 %4933, i32 8)
  %4935 = zext i32 %4934 to i64
  %4936 = mul i64 %4935, 32
  %4937 = add i64 %4936, 16
  %4938 = extractvalue { ptr, i32, i32, i32 } %4899, 0
  %4939 = load ptr, ptr %4938, align 8
  %4940 = getelementptr inbounds i8, ptr %4939, i32 -16
  %4941 = call ptr @realloc(ptr %4940, i64 %4937)
  %4942 = getelementptr inbounds i8, ptr %4941, i32 16
  store ptr %4942, ptr %4938, align 8
  %4943 = insertvalue { ptr, i32, i32, i32 } %4909, i32 %4934, 3
  br label %4944

4944:                                             ; preds = %4929, %4930
  %4945 = phi { ptr, i32, i32, i32 } [ %4943, %4930 ], [ %4909, %4929 ]
  br label %4946

4946:                                             ; preds = %4944
  br label %4947

4947:                                             ; preds = %4913, %4946
  %4948 = phi { ptr, i32, i32, i32 } [ %4945, %4946 ], [ %4926, %4913 ]
  br label %4949

4949:                                             ; preds = %4947
  %4950 = extractvalue { ptr, i32, i32, i32 } %4948, 0
  %4951 = load ptr, ptr %4950, align 8
  %4952 = extractvalue { ptr, i32, i32, i32 } %4948, 2
  %4953 = zext i32 %4952 to i64
  %4954 = mul i64 %4953, 32
  %4955 = getelementptr inbounds i8, ptr %4951, i64 %4954
  store i252 %4860, ptr %4955, align 16
  %4956 = extractvalue { ptr, i32, i32, i32 } %4948, 2
  %4957 = add i32 %4956, 1
  %4958 = insertvalue { ptr, i32, i32, i32 } %4948, i32 %4957, 2
  %4959 = getelementptr inbounds i8, ptr %4951, i32 -12
  store i32 %4957, ptr %4959, align 4
  %4960 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %4958, 0
  ret { { ptr, i32, i32, i32 } } %4960

4961:                                             ; preds = %2
  %4962 = load { i6, i8 }, ptr %3, align 1
  %4963 = extractvalue { i6, i8 } %4962, 1
  %4964 = zext i8 %4963 to i252
  %4965 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %4966 = icmp eq i32 %4965, 0
  br i1 %4966, label %4967, label %4981

4967:                                             ; preds = %4961
  %4968 = shl i32 %4965, 1
  %4969 = call i32 @llvm.umin.i32(i32 %4968, i32 1024)
  %4970 = add i32 %4969, %4965
  %4971 = call i32 @llvm.umax.i32(i32 %4970, i32 8)
  %4972 = zext i32 %4971 to i64
  %4973 = mul i64 %4972, 32
  %4974 = add i64 %4973, 16
  %4975 = call ptr @realloc(ptr null, i64 %4974)
  store i32 1, ptr %4975, align 4
  %4976 = getelementptr inbounds i8, ptr %4975, i32 4
  store i32 0, ptr %4976, align 4
  %4977 = getelementptr inbounds i8, ptr %4975, i32 16
  %4978 = call ptr @realloc(ptr null, i64 8)
  store ptr %4977, ptr %4978, align 8
  %4979 = insertvalue { ptr, i32, i32, i32 } %1, ptr %4978, 0
  %4980 = insertvalue { ptr, i32, i32, i32 } %4979, i32 %4971, 3
  br label %5002

4981:                                             ; preds = %4961
  %4982 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %4983 = icmp ult i32 %4982, %4965
  br i1 %4983, label %4984, label %4985

4984:                                             ; preds = %4981
  br label %4999

4985:                                             ; preds = %4981
  %4986 = shl i32 %4965, 1
  %4987 = call i32 @llvm.umin.i32(i32 %4986, i32 1024)
  %4988 = add i32 %4987, %4965
  %4989 = call i32 @llvm.umax.i32(i32 %4988, i32 8)
  %4990 = zext i32 %4989 to i64
  %4991 = mul i64 %4990, 32
  %4992 = add i64 %4991, 16
  %4993 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %4994 = load ptr, ptr %4993, align 8
  %4995 = getelementptr inbounds i8, ptr %4994, i32 -16
  %4996 = call ptr @realloc(ptr %4995, i64 %4992)
  %4997 = getelementptr inbounds i8, ptr %4996, i32 16
  store ptr %4997, ptr %4993, align 8
  %4998 = insertvalue { ptr, i32, i32, i32 } %1, i32 %4989, 3
  br label %4999

4999:                                             ; preds = %4984, %4985
  %5000 = phi { ptr, i32, i32, i32 } [ %4998, %4985 ], [ %1, %4984 ]
  br label %5001

5001:                                             ; preds = %4999
  br label %5002

5002:                                             ; preds = %4967, %5001
  %5003 = phi { ptr, i32, i32, i32 } [ %5000, %5001 ], [ %4980, %4967 ]
  br label %5004

5004:                                             ; preds = %5002
  %5005 = extractvalue { ptr, i32, i32, i32 } %5003, 0
  %5006 = load ptr, ptr %5005, align 8
  %5007 = extractvalue { ptr, i32, i32, i32 } %5003, 2
  %5008 = zext i32 %5007 to i64
  %5009 = mul i64 %5008, 32
  %5010 = getelementptr inbounds i8, ptr %5006, i64 %5009
  store i252 38, ptr %5010, align 16
  %5011 = extractvalue { ptr, i32, i32, i32 } %5003, 2
  %5012 = add i32 %5011, 1
  %5013 = insertvalue { ptr, i32, i32, i32 } %5003, i32 %5012, 2
  %5014 = getelementptr inbounds i8, ptr %5006, i32 -12
  store i32 %5012, ptr %5014, align 4
  %5015 = extractvalue { ptr, i32, i32, i32 } %5003, 3
  %5016 = icmp eq i32 %5015, 0
  br i1 %5016, label %5017, label %5031

5017:                                             ; preds = %5004
  %5018 = shl i32 %5015, 1
  %5019 = call i32 @llvm.umin.i32(i32 %5018, i32 1024)
  %5020 = add i32 %5019, %5015
  %5021 = call i32 @llvm.umax.i32(i32 %5020, i32 8)
  %5022 = zext i32 %5021 to i64
  %5023 = mul i64 %5022, 32
  %5024 = add i64 %5023, 16
  %5025 = call ptr @realloc(ptr null, i64 %5024)
  store i32 1, ptr %5025, align 4
  %5026 = getelementptr inbounds i8, ptr %5025, i32 4
  store i32 0, ptr %5026, align 4
  %5027 = getelementptr inbounds i8, ptr %5025, i32 16
  %5028 = call ptr @realloc(ptr null, i64 8)
  store ptr %5027, ptr %5028, align 8
  %5029 = insertvalue { ptr, i32, i32, i32 } %5013, ptr %5028, 0
  %5030 = insertvalue { ptr, i32, i32, i32 } %5029, i32 %5021, 3
  br label %5051

5031:                                             ; preds = %5004
  %5032 = icmp ult i32 %5012, %5015
  br i1 %5032, label %5033, label %5034

5033:                                             ; preds = %5031
  br label %5048

5034:                                             ; preds = %5031
  %5035 = shl i32 %5015, 1
  %5036 = call i32 @llvm.umin.i32(i32 %5035, i32 1024)
  %5037 = add i32 %5036, %5015
  %5038 = call i32 @llvm.umax.i32(i32 %5037, i32 8)
  %5039 = zext i32 %5038 to i64
  %5040 = mul i64 %5039, 32
  %5041 = add i64 %5040, 16
  %5042 = extractvalue { ptr, i32, i32, i32 } %5003, 0
  %5043 = load ptr, ptr %5042, align 8
  %5044 = getelementptr inbounds i8, ptr %5043, i32 -16
  %5045 = call ptr @realloc(ptr %5044, i64 %5041)
  %5046 = getelementptr inbounds i8, ptr %5045, i32 16
  store ptr %5046, ptr %5042, align 8
  %5047 = insertvalue { ptr, i32, i32, i32 } %5013, i32 %5038, 3
  br label %5048

5048:                                             ; preds = %5033, %5034
  %5049 = phi { ptr, i32, i32, i32 } [ %5047, %5034 ], [ %5013, %5033 ]
  br label %5050

5050:                                             ; preds = %5048
  br label %5051

5051:                                             ; preds = %5017, %5050
  %5052 = phi { ptr, i32, i32, i32 } [ %5049, %5050 ], [ %5030, %5017 ]
  br label %5053

5053:                                             ; preds = %5051
  %5054 = extractvalue { ptr, i32, i32, i32 } %5052, 0
  %5055 = load ptr, ptr %5054, align 8
  %5056 = extractvalue { ptr, i32, i32, i32 } %5052, 2
  %5057 = zext i32 %5056 to i64
  %5058 = mul i64 %5057, 32
  %5059 = getelementptr inbounds i8, ptr %5055, i64 %5058
  store i252 %4964, ptr %5059, align 16
  %5060 = extractvalue { ptr, i32, i32, i32 } %5052, 2
  %5061 = add i32 %5060, 1
  %5062 = insertvalue { ptr, i32, i32, i32 } %5052, i32 %5061, 2
  %5063 = getelementptr inbounds i8, ptr %5055, i32 -12
  store i32 %5061, ptr %5063, align 4
  %5064 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5062, 0
  ret { { ptr, i32, i32, i32 } } %5064

5065:                                             ; preds = %2
  %5066 = load { i6, i8 }, ptr %3, align 1
  %5067 = extractvalue { i6, i8 } %5066, 1
  %5068 = zext i8 %5067 to i252
  %5069 = extractvalue { ptr, i32, i32, i32 } %1, 3
  %5070 = icmp eq i32 %5069, 0
  br i1 %5070, label %5071, label %5085

5071:                                             ; preds = %5065
  %5072 = shl i32 %5069, 1
  %5073 = call i32 @llvm.umin.i32(i32 %5072, i32 1024)
  %5074 = add i32 %5073, %5069
  %5075 = call i32 @llvm.umax.i32(i32 %5074, i32 8)
  %5076 = zext i32 %5075 to i64
  %5077 = mul i64 %5076, 32
  %5078 = add i64 %5077, 16
  %5079 = call ptr @realloc(ptr null, i64 %5078)
  store i32 1, ptr %5079, align 4
  %5080 = getelementptr inbounds i8, ptr %5079, i32 4
  store i32 0, ptr %5080, align 4
  %5081 = getelementptr inbounds i8, ptr %5079, i32 16
  %5082 = call ptr @realloc(ptr null, i64 8)
  store ptr %5081, ptr %5082, align 8
  %5083 = insertvalue { ptr, i32, i32, i32 } %1, ptr %5082, 0
  %5084 = insertvalue { ptr, i32, i32, i32 } %5083, i32 %5075, 3
  br label %5106

5085:                                             ; preds = %5065
  %5086 = extractvalue { ptr, i32, i32, i32 } %1, 2
  %5087 = icmp ult i32 %5086, %5069
  br i1 %5087, label %5088, label %5089

5088:                                             ; preds = %5085
  br label %5103

5089:                                             ; preds = %5085
  %5090 = shl i32 %5069, 1
  %5091 = call i32 @llvm.umin.i32(i32 %5090, i32 1024)
  %5092 = add i32 %5091, %5069
  %5093 = call i32 @llvm.umax.i32(i32 %5092, i32 8)
  %5094 = zext i32 %5093 to i64
  %5095 = mul i64 %5094, 32
  %5096 = add i64 %5095, 16
  %5097 = extractvalue { ptr, i32, i32, i32 } %1, 0
  %5098 = load ptr, ptr %5097, align 8
  %5099 = getelementptr inbounds i8, ptr %5098, i32 -16
  %5100 = call ptr @realloc(ptr %5099, i64 %5096)
  %5101 = getelementptr inbounds i8, ptr %5100, i32 16
  store ptr %5101, ptr %5097, align 8
  %5102 = insertvalue { ptr, i32, i32, i32 } %1, i32 %5093, 3
  br label %5103

5103:                                             ; preds = %5088, %5089
  %5104 = phi { ptr, i32, i32, i32 } [ %5102, %5089 ], [ %1, %5088 ]
  br label %5105

5105:                                             ; preds = %5103
  br label %5106

5106:                                             ; preds = %5071, %5105
  %5107 = phi { ptr, i32, i32, i32 } [ %5104, %5105 ], [ %5084, %5071 ]
  br label %5108

5108:                                             ; preds = %5106
  %5109 = extractvalue { ptr, i32, i32, i32 } %5107, 0
  %5110 = load ptr, ptr %5109, align 8
  %5111 = extractvalue { ptr, i32, i32, i32 } %5107, 2
  %5112 = zext i32 %5111 to i64
  %5113 = mul i64 %5112, 32
  %5114 = getelementptr inbounds i8, ptr %5110, i64 %5113
  store i252 39, ptr %5114, align 16
  %5115 = extractvalue { ptr, i32, i32, i32 } %5107, 2
  %5116 = add i32 %5115, 1
  %5117 = insertvalue { ptr, i32, i32, i32 } %5107, i32 %5116, 2
  %5118 = getelementptr inbounds i8, ptr %5110, i32 -12
  store i32 %5116, ptr %5118, align 4
  %5119 = extractvalue { ptr, i32, i32, i32 } %5107, 3
  %5120 = icmp eq i32 %5119, 0
  br i1 %5120, label %5121, label %5135

5121:                                             ; preds = %5108
  %5122 = shl i32 %5119, 1
  %5123 = call i32 @llvm.umin.i32(i32 %5122, i32 1024)
  %5124 = add i32 %5123, %5119
  %5125 = call i32 @llvm.umax.i32(i32 %5124, i32 8)
  %5126 = zext i32 %5125 to i64
  %5127 = mul i64 %5126, 32
  %5128 = add i64 %5127, 16
  %5129 = call ptr @realloc(ptr null, i64 %5128)
  store i32 1, ptr %5129, align 4
  %5130 = getelementptr inbounds i8, ptr %5129, i32 4
  store i32 0, ptr %5130, align 4
  %5131 = getelementptr inbounds i8, ptr %5129, i32 16
  %5132 = call ptr @realloc(ptr null, i64 8)
  store ptr %5131, ptr %5132, align 8
  %5133 = insertvalue { ptr, i32, i32, i32 } %5117, ptr %5132, 0
  %5134 = insertvalue { ptr, i32, i32, i32 } %5133, i32 %5125, 3
  br label %5155

5135:                                             ; preds = %5108
  %5136 = icmp ult i32 %5116, %5119
  br i1 %5136, label %5137, label %5138

5137:                                             ; preds = %5135
  br label %5152

5138:                                             ; preds = %5135
  %5139 = shl i32 %5119, 1
  %5140 = call i32 @llvm.umin.i32(i32 %5139, i32 1024)
  %5141 = add i32 %5140, %5119
  %5142 = call i32 @llvm.umax.i32(i32 %5141, i32 8)
  %5143 = zext i32 %5142 to i64
  %5144 = mul i64 %5143, 32
  %5145 = add i64 %5144, 16
  %5146 = extractvalue { ptr, i32, i32, i32 } %5107, 0
  %5147 = load ptr, ptr %5146, align 8
  %5148 = getelementptr inbounds i8, ptr %5147, i32 -16
  %5149 = call ptr @realloc(ptr %5148, i64 %5145)
  %5150 = getelementptr inbounds i8, ptr %5149, i32 16
  store ptr %5150, ptr %5146, align 8
  %5151 = insertvalue { ptr, i32, i32, i32 } %5117, i32 %5142, 3
  br label %5152

5152:                                             ; preds = %5137, %5138
  %5153 = phi { ptr, i32, i32, i32 } [ %5151, %5138 ], [ %5117, %5137 ]
  br label %5154

5154:                                             ; preds = %5152
  br label %5155

5155:                                             ; preds = %5121, %5154
  %5156 = phi { ptr, i32, i32, i32 } [ %5153, %5154 ], [ %5134, %5121 ]
  br label %5157

5157:                                             ; preds = %5155
  %5158 = extractvalue { ptr, i32, i32, i32 } %5156, 0
  %5159 = load ptr, ptr %5158, align 8
  %5160 = extractvalue { ptr, i32, i32, i32 } %5156, 2
  %5161 = zext i32 %5160 to i64
  %5162 = mul i64 %5161, 32
  %5163 = getelementptr inbounds i8, ptr %5159, i64 %5162
  store i252 %5068, ptr %5163, align 16
  %5164 = extractvalue { ptr, i32, i32, i32 } %5156, 2
  %5165 = add i32 %5164, 1
  %5166 = insertvalue { ptr, i32, i32, i32 } %5156, i32 %5165, 2
  %5167 = getelementptr inbounds i8, ptr %5159, i32 -12
  store i32 %5165, ptr %5167, align 4
  %5168 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5166, 0
  ret { { ptr, i32, i32, i32 } } %5168

5169:                                             ; preds = %4423
  br i1 false, label %5170, label %5387

5170:                                             ; preds = %5169
  unreachable

5171:                                             ; preds = %4423, %2
  %5172 = phi { ptr, i32, i32, i32 } [ %4432, %4423 ], [ %1, %2 ]
  %5173 = extractvalue { ptr, i32, i32, i32 } %5172, 3
  %5174 = icmp eq i32 %5173, 0
  br i1 %5174, label %5175, label %5189

5175:                                             ; preds = %5171
  %5176 = shl i32 %5173, 1
  %5177 = call i32 @llvm.umin.i32(i32 %5176, i32 1024)
  %5178 = add i32 %5177, %5173
  %5179 = call i32 @llvm.umax.i32(i32 %5178, i32 8)
  %5180 = zext i32 %5179 to i64
  %5181 = mul i64 %5180, 32
  %5182 = add i64 %5181, 16
  %5183 = call ptr @realloc(ptr null, i64 %5182)
  store i32 1, ptr %5183, align 4
  %5184 = getelementptr inbounds i8, ptr %5183, i32 4
  store i32 0, ptr %5184, align 4
  %5185 = getelementptr inbounds i8, ptr %5183, i32 16
  %5186 = call ptr @realloc(ptr null, i64 8)
  store ptr %5185, ptr %5186, align 8
  %5187 = insertvalue { ptr, i32, i32, i32 } %5172, ptr %5186, 0
  %5188 = insertvalue { ptr, i32, i32, i32 } %5187, i32 %5179, 3
  br label %5210

5189:                                             ; preds = %5171
  %5190 = extractvalue { ptr, i32, i32, i32 } %5172, 2
  %5191 = icmp ult i32 %5190, %5173
  br i1 %5191, label %5192, label %5193

5192:                                             ; preds = %5189
  br label %5207

5193:                                             ; preds = %5189
  %5194 = shl i32 %5173, 1
  %5195 = call i32 @llvm.umin.i32(i32 %5194, i32 1024)
  %5196 = add i32 %5195, %5173
  %5197 = call i32 @llvm.umax.i32(i32 %5196, i32 8)
  %5198 = zext i32 %5197 to i64
  %5199 = mul i64 %5198, 32
  %5200 = add i64 %5199, 16
  %5201 = extractvalue { ptr, i32, i32, i32 } %5172, 0
  %5202 = load ptr, ptr %5201, align 8
  %5203 = getelementptr inbounds i8, ptr %5202, i32 -16
  %5204 = call ptr @realloc(ptr %5203, i64 %5200)
  %5205 = getelementptr inbounds i8, ptr %5204, i32 16
  store ptr %5205, ptr %5201, align 8
  %5206 = insertvalue { ptr, i32, i32, i32 } %5172, i32 %5197, 3
  br label %5207

5207:                                             ; preds = %5192, %5193
  %5208 = phi { ptr, i32, i32, i32 } [ %5206, %5193 ], [ %5172, %5192 ]
  br label %5209

5209:                                             ; preds = %5207
  br label %5210

5210:                                             ; preds = %5175, %5209
  %5211 = phi { ptr, i32, i32, i32 } [ %5208, %5209 ], [ %5188, %5175 ]
  br label %5212

5212:                                             ; preds = %5210
  %5213 = extractvalue { ptr, i32, i32, i32 } %5211, 0
  %5214 = load ptr, ptr %5213, align 8
  %5215 = extractvalue { ptr, i32, i32, i32 } %5211, 2
  %5216 = zext i32 %5215 to i64
  %5217 = mul i64 %5216, 32
  %5218 = getelementptr inbounds i8, ptr %5214, i64 %5217
  store i252 0, ptr %5218, align 16
  %5219 = extractvalue { ptr, i32, i32, i32 } %5211, 2
  %5220 = add i32 %5219, 1
  %5221 = insertvalue { ptr, i32, i32, i32 } %5211, i32 %5220, 2
  %5222 = getelementptr inbounds i8, ptr %5214, i32 -12
  store i32 %5220, ptr %5222, align 4
  %5223 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5221, 0
  ret { { ptr, i32, i32, i32 } } %5223

5224:                                             ; preds = %4423
  %5225 = phi { ptr, i32, i32, i32 } [ %4432, %4423 ]
  %5226 = phi i252 [ 1, %4423 ]
  %5227 = extractvalue { ptr, i32, i32, i32 } %5225, 3
  %5228 = icmp eq i32 %5227, 0
  br i1 %5228, label %5229, label %5243

5229:                                             ; preds = %5224
  %5230 = shl i32 %5227, 1
  %5231 = call i32 @llvm.umin.i32(i32 %5230, i32 1024)
  %5232 = add i32 %5231, %5227
  %5233 = call i32 @llvm.umax.i32(i32 %5232, i32 8)
  %5234 = zext i32 %5233 to i64
  %5235 = mul i64 %5234, 32
  %5236 = add i64 %5235, 16
  %5237 = call ptr @realloc(ptr null, i64 %5236)
  store i32 1, ptr %5237, align 4
  %5238 = getelementptr inbounds i8, ptr %5237, i32 4
  store i32 0, ptr %5238, align 4
  %5239 = getelementptr inbounds i8, ptr %5237, i32 16
  %5240 = call ptr @realloc(ptr null, i64 8)
  store ptr %5239, ptr %5240, align 8
  %5241 = insertvalue { ptr, i32, i32, i32 } %5225, ptr %5240, 0
  %5242 = insertvalue { ptr, i32, i32, i32 } %5241, i32 %5233, 3
  br label %5264

5243:                                             ; preds = %5224
  %5244 = extractvalue { ptr, i32, i32, i32 } %5225, 2
  %5245 = icmp ult i32 %5244, %5227
  br i1 %5245, label %5246, label %5247

5246:                                             ; preds = %5243
  br label %5261

5247:                                             ; preds = %5243
  %5248 = shl i32 %5227, 1
  %5249 = call i32 @llvm.umin.i32(i32 %5248, i32 1024)
  %5250 = add i32 %5249, %5227
  %5251 = call i32 @llvm.umax.i32(i32 %5250, i32 8)
  %5252 = zext i32 %5251 to i64
  %5253 = mul i64 %5252, 32
  %5254 = add i64 %5253, 16
  %5255 = extractvalue { ptr, i32, i32, i32 } %5225, 0
  %5256 = load ptr, ptr %5255, align 8
  %5257 = getelementptr inbounds i8, ptr %5256, i32 -16
  %5258 = call ptr @realloc(ptr %5257, i64 %5254)
  %5259 = getelementptr inbounds i8, ptr %5258, i32 16
  store ptr %5259, ptr %5255, align 8
  %5260 = insertvalue { ptr, i32, i32, i32 } %5225, i32 %5251, 3
  br label %5261

5261:                                             ; preds = %5246, %5247
  %5262 = phi { ptr, i32, i32, i32 } [ %5260, %5247 ], [ %5225, %5246 ]
  br label %5263

5263:                                             ; preds = %5261
  br label %5264

5264:                                             ; preds = %5229, %5263
  %5265 = phi { ptr, i32, i32, i32 } [ %5262, %5263 ], [ %5242, %5229 ]
  br label %5266

5266:                                             ; preds = %5264
  %5267 = extractvalue { ptr, i32, i32, i32 } %5265, 0
  %5268 = load ptr, ptr %5267, align 8
  %5269 = extractvalue { ptr, i32, i32, i32 } %5265, 2
  %5270 = zext i32 %5269 to i64
  %5271 = mul i64 %5270, 32
  %5272 = getelementptr inbounds i8, ptr %5268, i64 %5271
  store i252 %5226, ptr %5272, align 16
  %5273 = extractvalue { ptr, i32, i32, i32 } %5265, 2
  %5274 = add i32 %5273, 1
  %5275 = insertvalue { ptr, i32, i32, i32 } %5265, i32 %5274, 2
  %5276 = getelementptr inbounds i8, ptr %5268, i32 -12
  store i32 %5274, ptr %5276, align 4
  %5277 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5275, 0
  ret { { ptr, i32, i32, i32 } } %5277

5278:                                             ; preds = %4423
  %5279 = phi { ptr, i32, i32, i32 } [ %4432, %4423 ]
  %5280 = phi i252 [ 2, %4423 ]
  %5281 = extractvalue { ptr, i32, i32, i32 } %5279, 3
  %5282 = icmp eq i32 %5281, 0
  br i1 %5282, label %5283, label %5297

5283:                                             ; preds = %5278
  %5284 = shl i32 %5281, 1
  %5285 = call i32 @llvm.umin.i32(i32 %5284, i32 1024)
  %5286 = add i32 %5285, %5281
  %5287 = call i32 @llvm.umax.i32(i32 %5286, i32 8)
  %5288 = zext i32 %5287 to i64
  %5289 = mul i64 %5288, 32
  %5290 = add i64 %5289, 16
  %5291 = call ptr @realloc(ptr null, i64 %5290)
  store i32 1, ptr %5291, align 4
  %5292 = getelementptr inbounds i8, ptr %5291, i32 4
  store i32 0, ptr %5292, align 4
  %5293 = getelementptr inbounds i8, ptr %5291, i32 16
  %5294 = call ptr @realloc(ptr null, i64 8)
  store ptr %5293, ptr %5294, align 8
  %5295 = insertvalue { ptr, i32, i32, i32 } %5279, ptr %5294, 0
  %5296 = insertvalue { ptr, i32, i32, i32 } %5295, i32 %5287, 3
  br label %5318

5297:                                             ; preds = %5278
  %5298 = extractvalue { ptr, i32, i32, i32 } %5279, 2
  %5299 = icmp ult i32 %5298, %5281
  br i1 %5299, label %5300, label %5301

5300:                                             ; preds = %5297
  br label %5315

5301:                                             ; preds = %5297
  %5302 = shl i32 %5281, 1
  %5303 = call i32 @llvm.umin.i32(i32 %5302, i32 1024)
  %5304 = add i32 %5303, %5281
  %5305 = call i32 @llvm.umax.i32(i32 %5304, i32 8)
  %5306 = zext i32 %5305 to i64
  %5307 = mul i64 %5306, 32
  %5308 = add i64 %5307, 16
  %5309 = extractvalue { ptr, i32, i32, i32 } %5279, 0
  %5310 = load ptr, ptr %5309, align 8
  %5311 = getelementptr inbounds i8, ptr %5310, i32 -16
  %5312 = call ptr @realloc(ptr %5311, i64 %5308)
  %5313 = getelementptr inbounds i8, ptr %5312, i32 16
  store ptr %5313, ptr %5309, align 8
  %5314 = insertvalue { ptr, i32, i32, i32 } %5279, i32 %5305, 3
  br label %5315

5315:                                             ; preds = %5300, %5301
  %5316 = phi { ptr, i32, i32, i32 } [ %5314, %5301 ], [ %5279, %5300 ]
  br label %5317

5317:                                             ; preds = %5315
  br label %5318

5318:                                             ; preds = %5283, %5317
  %5319 = phi { ptr, i32, i32, i32 } [ %5316, %5317 ], [ %5296, %5283 ]
  br label %5320

5320:                                             ; preds = %5318
  %5321 = extractvalue { ptr, i32, i32, i32 } %5319, 0
  %5322 = load ptr, ptr %5321, align 8
  %5323 = extractvalue { ptr, i32, i32, i32 } %5319, 2
  %5324 = zext i32 %5323 to i64
  %5325 = mul i64 %5324, 32
  %5326 = getelementptr inbounds i8, ptr %5322, i64 %5325
  store i252 %5280, ptr %5326, align 16
  %5327 = extractvalue { ptr, i32, i32, i32 } %5319, 2
  %5328 = add i32 %5327, 1
  %5329 = insertvalue { ptr, i32, i32, i32 } %5319, i32 %5328, 2
  %5330 = getelementptr inbounds i8, ptr %5322, i32 -12
  store i32 %5328, ptr %5330, align 4
  %5331 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5329, 0
  ret { { ptr, i32, i32, i32 } } %5331

5332:                                             ; preds = %4423
  %5333 = phi { ptr, i32, i32, i32 } [ %4432, %4423 ]
  %5334 = phi i252 [ 3, %4423 ]
  %5335 = extractvalue { ptr, i32, i32, i32 } %5333, 3
  %5336 = icmp eq i32 %5335, 0
  br i1 %5336, label %5337, label %5351

5337:                                             ; preds = %5332
  %5338 = shl i32 %5335, 1
  %5339 = call i32 @llvm.umin.i32(i32 %5338, i32 1024)
  %5340 = add i32 %5339, %5335
  %5341 = call i32 @llvm.umax.i32(i32 %5340, i32 8)
  %5342 = zext i32 %5341 to i64
  %5343 = mul i64 %5342, 32
  %5344 = add i64 %5343, 16
  %5345 = call ptr @realloc(ptr null, i64 %5344)
  store i32 1, ptr %5345, align 4
  %5346 = getelementptr inbounds i8, ptr %5345, i32 4
  store i32 0, ptr %5346, align 4
  %5347 = getelementptr inbounds i8, ptr %5345, i32 16
  %5348 = call ptr @realloc(ptr null, i64 8)
  store ptr %5347, ptr %5348, align 8
  %5349 = insertvalue { ptr, i32, i32, i32 } %5333, ptr %5348, 0
  %5350 = insertvalue { ptr, i32, i32, i32 } %5349, i32 %5341, 3
  br label %5372

5351:                                             ; preds = %5332
  %5352 = extractvalue { ptr, i32, i32, i32 } %5333, 2
  %5353 = icmp ult i32 %5352, %5335
  br i1 %5353, label %5354, label %5355

5354:                                             ; preds = %5351
  br label %5369

5355:                                             ; preds = %5351
  %5356 = shl i32 %5335, 1
  %5357 = call i32 @llvm.umin.i32(i32 %5356, i32 1024)
  %5358 = add i32 %5357, %5335
  %5359 = call i32 @llvm.umax.i32(i32 %5358, i32 8)
  %5360 = zext i32 %5359 to i64
  %5361 = mul i64 %5360, 32
  %5362 = add i64 %5361, 16
  %5363 = extractvalue { ptr, i32, i32, i32 } %5333, 0
  %5364 = load ptr, ptr %5363, align 8
  %5365 = getelementptr inbounds i8, ptr %5364, i32 -16
  %5366 = call ptr @realloc(ptr %5365, i64 %5362)
  %5367 = getelementptr inbounds i8, ptr %5366, i32 16
  store ptr %5367, ptr %5363, align 8
  %5368 = insertvalue { ptr, i32, i32, i32 } %5333, i32 %5359, 3
  br label %5369

5369:                                             ; preds = %5354, %5355
  %5370 = phi { ptr, i32, i32, i32 } [ %5368, %5355 ], [ %5333, %5354 ]
  br label %5371

5371:                                             ; preds = %5369
  br label %5372

5372:                                             ; preds = %5337, %5371
  %5373 = phi { ptr, i32, i32, i32 } [ %5370, %5371 ], [ %5350, %5337 ]
  br label %5374

5374:                                             ; preds = %5372
  %5375 = extractvalue { ptr, i32, i32, i32 } %5373, 0
  %5376 = load ptr, ptr %5375, align 8
  %5377 = extractvalue { ptr, i32, i32, i32 } %5373, 2
  %5378 = zext i32 %5377 to i64
  %5379 = mul i64 %5378, 32
  %5380 = getelementptr inbounds i8, ptr %5376, i64 %5379
  store i252 %5334, ptr %5380, align 16
  %5381 = extractvalue { ptr, i32, i32, i32 } %5373, 2
  %5382 = add i32 %5381, 1
  %5383 = insertvalue { ptr, i32, i32, i32 } %5373, i32 %5382, 2
  %5384 = getelementptr inbounds i8, ptr %5376, i32 -12
  store i32 %5382, ptr %5384, align 4
  %5385 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %5383, 0
  ret { { ptr, i32, i32, i32 } } %5385

5386:                                             ; preds = %6
  call void @puts(ptr @assert_msg_170)
  call void @abort()
  unreachable

5387:                                             ; preds = %5169
  call void @puts(ptr @assert_msg_171)
  call void @abort()
  unreachable
}

define private { ptr, i32, i32, i32 } @f115(ptr %0, { ptr, i32, i32, i32 } %1) {
  %3 = call fastcc { { ptr, i32, i32, i32 } } @"impl$f115"(ptr %0, { ptr, i32, i32, i32 } %1)
  %4 = extractvalue { { ptr, i32, i32, i32 } } %3, 0
  ret { ptr, i32, i32, i32 } %4
}

define void @_mlir_ciface_f115(ptr %0, ptr %1, { ptr, i32, i32, i32 } %2) {
  %4 = call { ptr, i32, i32, i32 } @f115(ptr %1, { ptr, i32, i32, i32 } %2)
  store { ptr, i32, i32, i32 } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f116"(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, i32, i252 } %5) {
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i1, [31 x i8] }, i64 1, align 8
  %10 = alloca i64, i64 1, align 8
  %11 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %12 = alloca { { ptr, i32, i32, i32 } }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %5, 0
  %16 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %5, 1
  %17 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %5, 2
  %18 = extractvalue { { i3, [0 x i8] }, i32, i32, i252 } %5, 3
  %19 = extractvalue { i3, [0 x i8] } %15, 0
  switch i3 %19, label %20 [
    i3 0, label %22
    i3 1, label %38
    i3 2, label %52
    i3 3, label %66
    i3 -4, label %80
    i3 -3, label %94
    i3 -2, label %108
  ]

20:                                               ; preds = %6
  br i1 false, label %21, label %366

21:                                               ; preds = %20
  unreachable

22:                                               ; preds = %6
  %23 = phi i64 [ %1, %6 ]
  %24 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %25 = call ptr %24()
  %26 = load i64, ptr %25, align 8
  %27 = mul i64 %26, 100
  %28 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 %27)
  %29 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %29, align 4
  %30 = getelementptr inbounds i8, ptr %29, i32 4
  store i32 0, ptr %30, align 4
  %31 = getelementptr inbounds i8, ptr %29, i32 16
  %32 = call ptr @realloc(ptr null, i64 8)
  store ptr %31, ptr %32, align 8
  %33 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %32, 0
  %34 = insertvalue { ptr, i32, i32, i32 } %33, i32 8, 3
  %35 = load ptr, ptr %32, align 8
  store i252 0, ptr %35, align 16
  %36 = insertvalue { ptr, i32, i32, i32 } %34, i32 1, 2
  %37 = getelementptr inbounds i8, ptr %35, i32 -12
  store i32 1, ptr %37, align 4
  br label %124

38:                                               ; preds = %6
  %39 = phi i64 [ %1, %6 ]
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %39, i64 0)
  %43 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %43, align 4
  %44 = getelementptr inbounds i8, ptr %43, i32 4
  store i32 0, ptr %44, align 4
  %45 = getelementptr inbounds i8, ptr %43, i32 16
  %46 = call ptr @realloc(ptr null, i64 8)
  store ptr %45, ptr %46, align 8
  %47 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %46, 0
  %48 = insertvalue { ptr, i32, i32, i32 } %47, i32 8, 3
  %49 = load ptr, ptr %46, align 8
  store i252 1, ptr %49, align 16
  %50 = insertvalue { ptr, i32, i32, i32 } %48, i32 1, 2
  %51 = getelementptr inbounds i8, ptr %49, i32 -12
  store i32 1, ptr %51, align 4
  br label %124

52:                                               ; preds = %6
  %53 = phi i64 [ %1, %6 ]
  %54 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %55 = call ptr %54()
  %56 = call i64 @llvm.uadd.sat.i64(i64 %53, i64 0)
  %57 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %57, align 4
  %58 = getelementptr inbounds i8, ptr %57, i32 4
  store i32 0, ptr %58, align 4
  %59 = getelementptr inbounds i8, ptr %57, i32 16
  %60 = call ptr @realloc(ptr null, i64 8)
  store ptr %59, ptr %60, align 8
  %61 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %60, 0
  %62 = insertvalue { ptr, i32, i32, i32 } %61, i32 8, 3
  %63 = load ptr, ptr %60, align 8
  store i252 2, ptr %63, align 16
  %64 = insertvalue { ptr, i32, i32, i32 } %62, i32 1, 2
  %65 = getelementptr inbounds i8, ptr %63, i32 -12
  store i32 1, ptr %65, align 4
  br label %124

66:                                               ; preds = %6
  %67 = phi i64 [ %1, %6 ]
  %68 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %69 = call ptr %68()
  %70 = call i64 @llvm.uadd.sat.i64(i64 %67, i64 0)
  %71 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %71, align 4
  %72 = getelementptr inbounds i8, ptr %71, i32 4
  store i32 0, ptr %72, align 4
  %73 = getelementptr inbounds i8, ptr %71, i32 16
  %74 = call ptr @realloc(ptr null, i64 8)
  store ptr %73, ptr %74, align 8
  %75 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %74, 0
  %76 = insertvalue { ptr, i32, i32, i32 } %75, i32 8, 3
  %77 = load ptr, ptr %74, align 8
  store i252 3, ptr %77, align 16
  %78 = insertvalue { ptr, i32, i32, i32 } %76, i32 1, 2
  %79 = getelementptr inbounds i8, ptr %77, i32 -12
  store i32 1, ptr %79, align 4
  br label %124

80:                                               ; preds = %6
  %81 = phi i64 [ %1, %6 ]
  %82 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %83 = call ptr %82()
  %84 = call i64 @llvm.uadd.sat.i64(i64 %81, i64 0)
  %85 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %85, align 4
  %86 = getelementptr inbounds i8, ptr %85, i32 4
  store i32 0, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %85, i32 16
  %88 = call ptr @realloc(ptr null, i64 8)
  store ptr %87, ptr %88, align 8
  %89 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %88, 0
  %90 = insertvalue { ptr, i32, i32, i32 } %89, i32 8, 3
  %91 = load ptr, ptr %88, align 8
  store i252 4, ptr %91, align 16
  %92 = insertvalue { ptr, i32, i32, i32 } %90, i32 1, 2
  %93 = getelementptr inbounds i8, ptr %91, i32 -12
  store i32 1, ptr %93, align 4
  br label %124

94:                                               ; preds = %6
  %95 = phi i64 [ %1, %6 ]
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = call i64 @llvm.uadd.sat.i64(i64 %95, i64 0)
  %99 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %99, align 4
  %100 = getelementptr inbounds i8, ptr %99, i32 4
  store i32 0, ptr %100, align 4
  %101 = getelementptr inbounds i8, ptr %99, i32 16
  %102 = call ptr @realloc(ptr null, i64 8)
  store ptr %101, ptr %102, align 8
  %103 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %102, 0
  %104 = insertvalue { ptr, i32, i32, i32 } %103, i32 8, 3
  %105 = load ptr, ptr %102, align 8
  store i252 5, ptr %105, align 16
  %106 = insertvalue { ptr, i32, i32, i32 } %104, i32 1, 2
  %107 = getelementptr inbounds i8, ptr %105, i32 -12
  store i32 1, ptr %107, align 4
  br label %124

108:                                              ; preds = %6
  %109 = phi i64 [ %1, %6 ]
  %110 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %111 = call ptr %110()
  %112 = load i64, ptr %111, align 8
  %113 = mul i64 %112, 100
  %114 = call i64 @llvm.uadd.sat.i64(i64 %109, i64 %113)
  %115 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %115, align 4
  %116 = getelementptr inbounds i8, ptr %115, i32 4
  store i32 0, ptr %116, align 4
  %117 = getelementptr inbounds i8, ptr %115, i32 16
  %118 = call ptr @realloc(ptr null, i64 8)
  store ptr %117, ptr %118, align 8
  %119 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %118, 0
  %120 = insertvalue { ptr, i32, i32, i32 } %119, i32 8, 3
  %121 = load ptr, ptr %118, align 8
  store i252 6, ptr %121, align 16
  %122 = insertvalue { ptr, i32, i32, i32 } %120, i32 1, 2
  %123 = getelementptr inbounds i8, ptr %121, i32 -12
  store i32 1, ptr %123, align 4
  br label %124

124:                                              ; preds = %22, %38, %52, %66, %80, %94, %108
  %125 = phi i64 [ %0, %108 ], [ %0, %94 ], [ %0, %80 ], [ %0, %66 ], [ %0, %52 ], [ %0, %38 ], [ %0, %22 ]
  %126 = phi ptr [ %2, %108 ], [ %2, %94 ], [ %2, %80 ], [ %2, %66 ], [ %2, %52 ], [ %2, %38 ], [ %2, %22 ]
  %127 = phi i252 [ %3, %108 ], [ %3, %94 ], [ %3, %80 ], [ %3, %66 ], [ %3, %52 ], [ %3, %38 ], [ %3, %22 ]
  %128 = phi i252 [ %4, %108 ], [ %4, %94 ], [ %4, %80 ], [ %4, %66 ], [ %4, %52 ], [ %4, %38 ], [ %4, %22 ]
  %129 = phi i32 [ %16, %108 ], [ %16, %94 ], [ %16, %80 ], [ %16, %66 ], [ %16, %52 ], [ %16, %38 ], [ %16, %22 ]
  %130 = phi i32 [ %17, %108 ], [ %17, %94 ], [ %17, %80 ], [ %17, %66 ], [ %17, %52 ], [ %17, %38 ], [ %17, %22 ]
  %131 = phi i252 [ %18, %108 ], [ %18, %94 ], [ %18, %80 ], [ %18, %66 ], [ %18, %52 ], [ %18, %38 ], [ %18, %22 ]
  %132 = phi i64 [ %114, %108 ], [ %98, %94 ], [ %84, %80 ], [ %70, %66 ], [ %56, %52 ], [ %42, %38 ], [ %28, %22 ]
  %133 = phi { ptr, i32, i32, i32 } [ %122, %108 ], [ %106, %94 ], [ %92, %80 ], [ %78, %66 ], [ %64, %52 ], [ %50, %38 ], [ %36, %22 ]
  %134 = zext i32 %129 to i252
  %135 = zext i32 %130 to i252
  %136 = insertvalue { i252, i252, i252 } { i252 1062799989286861497646673457769309433976004466846907043354399004328696077865, i252 undef, i252 undef }, i252 %127, 1
  %137 = insertvalue { i252, i252, i252 } %136, i252 %128, 2
  %138 = call ptr @realloc(ptr null, i64 96)
  store { i252, i252, i252 } %137, ptr %138, align 16
  %139 = call ptr @realloc(ptr null, i64 112)
  store { i32, i32 } { i32 1, i32 3 }, ptr %139, align 4
  %140 = getelementptr inbounds i8, ptr %139, i32 16
  call void @llvm.memcpy.p0.p0.i64(ptr %140, ptr %138, i64 96, i1 false)
  call void @free(ptr %138)
  %141 = call ptr @realloc(ptr null, i64 8)
  store ptr %140, ptr %141, align 8
  %142 = insertvalue { ptr, i32, i32, i32 } undef, ptr %141, 0
  %143 = insertvalue { ptr, i32, i32, i32 } %142, i32 0, 1
  %144 = insertvalue { ptr, i32, i32, i32 } %143, i32 3, 2
  %145 = insertvalue { ptr, i32, i32, i32 } %144, i32 3, 3
  %146 = extractvalue { ptr, i32, i32, i32 } %133, 3
  %147 = icmp eq i32 %146, 0
  br i1 %147, label %148, label %162

148:                                              ; preds = %124
  %149 = shl i32 %146, 1
  %150 = call i32 @llvm.umin.i32(i32 %149, i32 1024)
  %151 = add i32 %150, %146
  %152 = call i32 @llvm.umax.i32(i32 %151, i32 8)
  %153 = zext i32 %152 to i64
  %154 = mul i64 %153, 32
  %155 = add i64 %154, 16
  %156 = call ptr @realloc(ptr null, i64 %155)
  store i32 1, ptr %156, align 4
  %157 = getelementptr inbounds i8, ptr %156, i32 4
  store i32 0, ptr %157, align 4
  %158 = getelementptr inbounds i8, ptr %156, i32 16
  %159 = call ptr @realloc(ptr null, i64 8)
  store ptr %158, ptr %159, align 8
  %160 = insertvalue { ptr, i32, i32, i32 } %133, ptr %159, 0
  %161 = insertvalue { ptr, i32, i32, i32 } %160, i32 %152, 3
  br label %183

162:                                              ; preds = %124
  %163 = extractvalue { ptr, i32, i32, i32 } %133, 2
  %164 = icmp ult i32 %163, %146
  br i1 %164, label %165, label %166

165:                                              ; preds = %162
  br label %180

166:                                              ; preds = %162
  %167 = shl i32 %146, 1
  %168 = call i32 @llvm.umin.i32(i32 %167, i32 1024)
  %169 = add i32 %168, %146
  %170 = call i32 @llvm.umax.i32(i32 %169, i32 8)
  %171 = zext i32 %170 to i64
  %172 = mul i64 %171, 32
  %173 = add i64 %172, 16
  %174 = extractvalue { ptr, i32, i32, i32 } %133, 0
  %175 = load ptr, ptr %174, align 8
  %176 = getelementptr inbounds i8, ptr %175, i32 -16
  %177 = call ptr @realloc(ptr %176, i64 %173)
  %178 = getelementptr inbounds i8, ptr %177, i32 16
  store ptr %178, ptr %174, align 8
  %179 = insertvalue { ptr, i32, i32, i32 } %133, i32 %170, 3
  br label %180

180:                                              ; preds = %165, %166
  %181 = phi { ptr, i32, i32, i32 } [ %179, %166 ], [ %133, %165 ]
  br label %182

182:                                              ; preds = %180
  br label %183

183:                                              ; preds = %148, %182
  %184 = phi { ptr, i32, i32, i32 } [ %181, %182 ], [ %161, %148 ]
  br label %185

185:                                              ; preds = %183
  %186 = extractvalue { ptr, i32, i32, i32 } %184, 0
  %187 = load ptr, ptr %186, align 8
  %188 = extractvalue { ptr, i32, i32, i32 } %184, 2
  %189 = zext i32 %188 to i64
  %190 = mul i64 %189, 32
  %191 = getelementptr inbounds i8, ptr %187, i64 %190
  store i252 %134, ptr %191, align 16
  %192 = extractvalue { ptr, i32, i32, i32 } %184, 2
  %193 = add i32 %192, 1
  %194 = insertvalue { ptr, i32, i32, i32 } %184, i32 %193, 2
  %195 = getelementptr inbounds i8, ptr %187, i32 -12
  store i32 %193, ptr %195, align 4
  %196 = extractvalue { ptr, i32, i32, i32 } %184, 3
  %197 = icmp eq i32 %196, 0
  br i1 %197, label %198, label %212

198:                                              ; preds = %185
  %199 = shl i32 %196, 1
  %200 = call i32 @llvm.umin.i32(i32 %199, i32 1024)
  %201 = add i32 %200, %196
  %202 = call i32 @llvm.umax.i32(i32 %201, i32 8)
  %203 = zext i32 %202 to i64
  %204 = mul i64 %203, 32
  %205 = add i64 %204, 16
  %206 = call ptr @realloc(ptr null, i64 %205)
  store i32 1, ptr %206, align 4
  %207 = getelementptr inbounds i8, ptr %206, i32 4
  store i32 0, ptr %207, align 4
  %208 = getelementptr inbounds i8, ptr %206, i32 16
  %209 = call ptr @realloc(ptr null, i64 8)
  store ptr %208, ptr %209, align 8
  %210 = insertvalue { ptr, i32, i32, i32 } %194, ptr %209, 0
  %211 = insertvalue { ptr, i32, i32, i32 } %210, i32 %202, 3
  br label %232

212:                                              ; preds = %185
  %213 = icmp ult i32 %193, %196
  br i1 %213, label %214, label %215

214:                                              ; preds = %212
  br label %229

215:                                              ; preds = %212
  %216 = shl i32 %196, 1
  %217 = call i32 @llvm.umin.i32(i32 %216, i32 1024)
  %218 = add i32 %217, %196
  %219 = call i32 @llvm.umax.i32(i32 %218, i32 8)
  %220 = zext i32 %219 to i64
  %221 = mul i64 %220, 32
  %222 = add i64 %221, 16
  %223 = extractvalue { ptr, i32, i32, i32 } %184, 0
  %224 = load ptr, ptr %223, align 8
  %225 = getelementptr inbounds i8, ptr %224, i32 -16
  %226 = call ptr @realloc(ptr %225, i64 %222)
  %227 = getelementptr inbounds i8, ptr %226, i32 16
  store ptr %227, ptr %223, align 8
  %228 = insertvalue { ptr, i32, i32, i32 } %194, i32 %219, 3
  br label %229

229:                                              ; preds = %214, %215
  %230 = phi { ptr, i32, i32, i32 } [ %228, %215 ], [ %194, %214 ]
  br label %231

231:                                              ; preds = %229
  br label %232

232:                                              ; preds = %198, %231
  %233 = phi { ptr, i32, i32, i32 } [ %230, %231 ], [ %211, %198 ]
  br label %234

234:                                              ; preds = %232
  %235 = extractvalue { ptr, i32, i32, i32 } %233, 0
  %236 = load ptr, ptr %235, align 8
  %237 = extractvalue { ptr, i32, i32, i32 } %233, 2
  %238 = zext i32 %237 to i64
  %239 = mul i64 %238, 32
  %240 = getelementptr inbounds i8, ptr %236, i64 %239
  store i252 %135, ptr %240, align 16
  %241 = extractvalue { ptr, i32, i32, i32 } %233, 2
  %242 = add i32 %241, 1
  %243 = insertvalue { ptr, i32, i32, i32 } %233, i32 %242, 2
  %244 = getelementptr inbounds i8, ptr %236, i32 -12
  store i32 %242, ptr %244, align 4
  %245 = extractvalue { ptr, i32, i32, i32 } %233, 3
  %246 = icmp eq i32 %245, 0
  br i1 %246, label %247, label %261

247:                                              ; preds = %234
  %248 = shl i32 %245, 1
  %249 = call i32 @llvm.umin.i32(i32 %248, i32 1024)
  %250 = add i32 %249, %245
  %251 = call i32 @llvm.umax.i32(i32 %250, i32 8)
  %252 = zext i32 %251 to i64
  %253 = mul i64 %252, 32
  %254 = add i64 %253, 16
  %255 = call ptr @realloc(ptr null, i64 %254)
  store i32 1, ptr %255, align 4
  %256 = getelementptr inbounds i8, ptr %255, i32 4
  store i32 0, ptr %256, align 4
  %257 = getelementptr inbounds i8, ptr %255, i32 16
  %258 = call ptr @realloc(ptr null, i64 8)
  store ptr %257, ptr %258, align 8
  %259 = insertvalue { ptr, i32, i32, i32 } %243, ptr %258, 0
  %260 = insertvalue { ptr, i32, i32, i32 } %259, i32 %251, 3
  br label %281

261:                                              ; preds = %234
  %262 = icmp ult i32 %242, %245
  br i1 %262, label %263, label %264

263:                                              ; preds = %261
  br label %278

264:                                              ; preds = %261
  %265 = shl i32 %245, 1
  %266 = call i32 @llvm.umin.i32(i32 %265, i32 1024)
  %267 = add i32 %266, %245
  %268 = call i32 @llvm.umax.i32(i32 %267, i32 8)
  %269 = zext i32 %268 to i64
  %270 = mul i64 %269, 32
  %271 = add i64 %270, 16
  %272 = extractvalue { ptr, i32, i32, i32 } %233, 0
  %273 = load ptr, ptr %272, align 8
  %274 = getelementptr inbounds i8, ptr %273, i32 -16
  %275 = call ptr @realloc(ptr %274, i64 %271)
  %276 = getelementptr inbounds i8, ptr %275, i32 16
  store ptr %276, ptr %272, align 8
  %277 = insertvalue { ptr, i32, i32, i32 } %243, i32 %268, 3
  br label %278

278:                                              ; preds = %263, %264
  %279 = phi { ptr, i32, i32, i32 } [ %277, %264 ], [ %243, %263 ]
  br label %280

280:                                              ; preds = %278
  br label %281

281:                                              ; preds = %247, %280
  %282 = phi { ptr, i32, i32, i32 } [ %279, %280 ], [ %260, %247 ]
  br label %283

283:                                              ; preds = %281
  %284 = extractvalue { ptr, i32, i32, i32 } %282, 0
  %285 = load ptr, ptr %284, align 8
  %286 = extractvalue { ptr, i32, i32, i32 } %282, 2
  %287 = zext i32 %286 to i64
  %288 = mul i64 %287, 32
  %289 = getelementptr inbounds i8, ptr %285, i64 %288
  store i252 %131, ptr %289, align 16
  %290 = extractvalue { ptr, i32, i32, i32 } %282, 2
  %291 = add i32 %290, 1
  %292 = insertvalue { ptr, i32, i32, i32 } %282, i32 %291, 2
  %293 = getelementptr inbounds i8, ptr %285, i32 -12
  store i32 %291, ptr %293, align 4
  %294 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %292)
  %295 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %294, 0
  %296 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %294, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %295)
  %297 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %296)
  %298 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %297, 0
  %299 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %297, 1
  %300 = extractvalue { ptr, i32, i32, i32 } %299, 1
  %301 = extractvalue { ptr, i32, i32, i32 } %299, 2
  %302 = sub i32 %301, %300
  call void @"drop$3"({ ptr, i32, i32, i32 } %299)
  %303 = zext i32 %302 to i252
  %304 = call ptr @realloc(ptr null, i64 272)
  store i32 1, ptr %304, align 4
  %305 = getelementptr inbounds i8, ptr %304, i32 4
  store i32 0, ptr %305, align 4
  %306 = getelementptr inbounds i8, ptr %304, i32 16
  %307 = call ptr @realloc(ptr null, i64 8)
  store ptr %306, ptr %307, align 8
  %308 = insertvalue { ptr, i32, i32, i32 } zeroinitializer, ptr %307, 0
  %309 = insertvalue { ptr, i32, i32, i32 } %308, i32 8, 3
  %310 = load ptr, ptr %307, align 8
  store i252 %303, ptr %310, align 16
  %311 = insertvalue { ptr, i32, i32, i32 } %309, i32 1, 2
  %312 = getelementptr inbounds i8, ptr %310, i32 -12
  store i32 1, ptr %312, align 4
  %313 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %298, 0
  %314 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %125, i64 %132, { { ptr, i32, i32, i32 } } %313, { ptr, i32, i32, i32 } %311)
  %315 = extractvalue { i64, i64, { i64, [24 x i8] } } %314, 0
  %316 = extractvalue { i64, i64, { i64, [24 x i8] } } %314, 1
  %317 = extractvalue { i64, i64, { i64, [24 x i8] } } %314, 2
  store { i64, [24 x i8] } %317, ptr %7, align 8
  %318 = load i1, ptr %7, align 1
  switch i1 %318, label %319 [
    i1 false, label %321
    i1 true, label %338
  ]

319:                                              ; preds = %283
  br i1 false, label %320, label %367

320:                                              ; preds = %319
  unreachable

321:                                              ; preds = %283
  %322 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %7, align 8
  %323 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %322, 1
  %324 = extractvalue { { ptr, i32, i32, i32 }, {} } %323, 0
  %325 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$2"({ ptr, i32, i32, i32 } %324)
  %326 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %325, 0
  %327 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %325, 1
  call void @"drop$2"({ ptr, i32, i32, i32 } %326)
  %328 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %145, 0
  %329 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %327, 0
  %330 = load ptr, ptr %126, align 8
  store i64 %316, ptr %10, align 8
  store { { ptr, i32, i32, i32 } } %328, ptr %11, align 8
  store { { ptr, i32, i32, i32 } } %329, ptr %12, align 8
  %331 = getelementptr inbounds ptr, ptr %126, i32 10
  %332 = load ptr, ptr %331, align 8
  call void %332(ptr %9, ptr %330, ptr %10, ptr %11, ptr %12)
  %333 = load { i1, [31 x i8] }, ptr %9, align 1
  %334 = extractvalue { i1, [31 x i8] } %333, 0
  %335 = getelementptr inbounds i8, ptr %9, i32 8
  %336 = load { ptr, i32, i32, i32 }, ptr %335, align 8
  %337 = load i64, ptr %10, align 8
  br i1 %334, label %357, label %347

338:                                              ; preds = %283
  %339 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %7, align 8
  %340 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %339, 1
  call void @"drop$3"({ ptr, i32, i32, i32 } %145)
  %341 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %340, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %341, ptr %8, align 8
  %342 = load { i64, [24 x i8] }, ptr %8, align 8
  %343 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %315, 0
  %344 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %343, i64 %316, 1
  %345 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %344, ptr %126, 2
  %346 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %345, { i64, [24 x i8] } %342, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %346

347:                                              ; preds = %321
  %348 = phi i64 [ %337, %321 ]
  %349 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %350 = call ptr %349()
  %351 = call i64 @llvm.uadd.sat.i64(i64 %348, i64 0)
  store { i1, [0 x i8] } { i1 false, [0 x i8] undef }, ptr %14, align 1
  %352 = load { i64, [24 x i8] }, ptr %14, align 8
  %353 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %315, 0
  %354 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %353, i64 %351, 1
  %355 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %354, ptr %126, 2
  %356 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %355, { i64, [24 x i8] } %352, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %356

357:                                              ; preds = %321
  %358 = phi { ptr, i32, i32, i32 } [ %336, %321 ]
  %359 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %358, 1
  %360 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %359, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %360, ptr %13, align 8
  %361 = load { i64, [24 x i8] }, ptr %13, align 8
  %362 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %315, 0
  %363 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %362, i64 %337, 1
  %364 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %363, ptr %126, 2
  %365 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %364, { i64, [24 x i8] } %361, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %365

366:                                              ; preds = %20
  call void @puts(ptr @assert_msg_172)
  call void @abort()
  unreachable

367:                                              ; preds = %319
  call void @puts(ptr @assert_msg_173)
  call void @abort()
  unreachable
}

define private { i64, i64, ptr, { i64, [24 x i8] } } @f116(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, i32, i252 } %5) {
  %7 = call fastcc { i64, i64, ptr, { i64, [24 x i8] } } @"impl$f116"(i64 %0, i64 %1, ptr %2, i252 %3, i252 %4, { { i3, [0 x i8] }, i32, i32, i252 } %5)
  %8 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 2
  %11 = extractvalue { i64, i64, ptr, { i64, [24 x i8] } } %7, 3
  %12 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %8, 0
  %13 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %9, 1
  %14 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %13, ptr %10, 2
  %15 = insertvalue { i64, i64, ptr, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %11, 3
  ret { i64, i64, ptr, { i64, [24 x i8] } } %15
}

define void @_mlir_ciface_f116(ptr %0, i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { { i3, [0 x i8] }, i32, i32, i252 } %6) {
  %8 = call { i64, i64, ptr, { i64, [24 x i8] } } @f116(i64 %1, i64 %2, ptr %3, i252 %4, i252 %5, { { i3, [0 x i8] }, i32, i32, i252 } %6)
  store { i64, i64, ptr, { i64, [24 x i8] } } %8, ptr %0, align 8
  ret void
}

define private void @"drop$68"({ { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0, 0
  call void @"drop$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  ret void
}

define private { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } @"dup$68"({ { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0) {
  %2 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0, 0
  %3 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$67"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %0, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } undef, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6, 0
  %9 = insertvalue { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %8, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %7, 1
  ret { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %9
}

define private void @"drop$69"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, 1
  call void @"drop$68"({ { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i128, [144 x i8] }, { i128, [144 x i8] } } @"dup$69"({ i128, [144 x i8] } %0) {
  %2 = alloca { i128, [144 x i8] }, i64 1, align 16
  store { i128, [144 x i8] } %0, ptr %2, align 16
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } }, ptr %2, align 16
  %6 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, 1
  %7 = call { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } @"dup$68"({ { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %6)
  %8 = extractvalue { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %7, 1
  %10 = insertvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %8, 1
  store { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %10, ptr %2, align 16
  %11 = load { i128, [144 x i8] }, ptr %2, align 16
  %12 = insertvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %5, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %9, 1
  store { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %12, ptr %2, align 16
  %13 = load { i128, [144 x i8] }, ptr %2, align 16
  %14 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %11, 0
  %15 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %14, { i128, [144 x i8] } %13, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i128, [144 x i8] }, ptr %2, align 16
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i128, [144 x i8] }, ptr %2, align 16
  %26 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } undef, { i128, [144 x i8] } %23, 0
  %27 = insertvalue { { i128, [144 x i8] }, { i128, [144 x i8] } } %26, { i128, [144 x i8] } %25, 1
  ret { { i128, [144 x i8] }, { i128, [144 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private void @"drop$45"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$44"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$42"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$45"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$44"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$42"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } undef, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %17, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$70"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$45"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$70"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$45"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [160 x i8] } } @"impl$f117"(i64 %0, i64 %1, ptr %2) {
  %4 = alloca { i128, [144 x i8] }, i64 1, align 16
  %5 = alloca { i128, [144 x i8] }, i64 1, align 16
  %6 = alloca { i128, [160 x i8] }, i64 1, align 16
  %7 = alloca { i128, [144 x i8] }, i64 1, align 16
  %8 = alloca { i128, [160 x i8] }, i64 1, align 16
  %9 = alloca { i64, [48 x i8] }, i64 1, align 8
  %10 = alloca { i128, [160 x i8] }, i64 1, align 16
  %11 = alloca { i128, [144 x i8] }, i64 1, align 16
  %12 = alloca { i128, [160 x i8] }, i64 1, align 16
  %13 = alloca { i128, [144 x i8] }, i64 1, align 16
  %14 = alloca { i128, [160 x i8] }, i64 1, align 16
  %15 = load { i128, [144 x i8] }, ptr %2, align 16
  store { i128, [144 x i8] } %15, ptr %4, align 16
  %16 = load i2, ptr %4, align 1
  switch i2 %16, label %17 [
    i2 0, label %19
    i2 1, label %35
    i2 -2, label %48
  ]

17:                                               ; preds = %3
  br i1 false, label %18, label %119

18:                                               ; preds = %17
  unreachable

19:                                               ; preds = %3
  %20 = load { i2, i252 }, ptr %4, align 16
  %21 = extractvalue { i2, i252 } %20, 1
  %22 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %23 = call ptr %22()
  %24 = load i64, ptr %23, align 8
  %25 = mul i64 %24, 13210
  %26 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %25)
  %27 = insertvalue { i2, i252 } { i2 0, i252 undef }, i252 %21, 1
  store { i2, i252 } %27, ptr %13, align 16
  %28 = load { i128, [144 x i8] }, ptr %13, align 16
  %29 = insertvalue { { i128, [144 x i8] } } undef, { i128, [144 x i8] } %28, 0
  %30 = insertvalue { i1, { { i128, [144 x i8] } } } { i1 false, { { i128, [144 x i8] } } undef }, { { i128, [144 x i8] } } %29, 1
  store { i1, { { i128, [144 x i8] } } } %30, ptr %14, align 16
  %31 = load { i128, [160 x i8] }, ptr %14, align 16
  %32 = insertvalue { i64, i64, { i128, [160 x i8] } } undef, i64 %0, 0
  %33 = insertvalue { i64, i64, { i128, [160 x i8] } } %32, i64 %26, 1
  %34 = insertvalue { i64, i64, { i128, [160 x i8] } } %33, { i128, [160 x i8] } %31, 2
  ret { i64, i64, { i128, [160 x i8] } } %34

35:                                               ; preds = %3
  %36 = load { i2, { { ptr, i32, i32, i32 }, i252, i32 } }, ptr %4, align 16
  %37 = extractvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %36, 1
  %38 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %37)
  %39 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %38, 0
  %40 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %38, 1
  %41 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %40, 0
  %42 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %43 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f126"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %42, { ptr, i32, i32, i32 } zeroinitializer)
  %44 = extractvalue { i64, i64, { i64, [48 x i8] } } %43, 0
  %45 = extractvalue { i64, i64, { i64, [48 x i8] } } %43, 1
  %46 = extractvalue { i64, i64, { i64, [48 x i8] } } %43, 2
  store { i64, [48 x i8] } %46, ptr %9, align 8
  %47 = load i1, ptr %9, align 1
  switch i1 %47, label %56 [
    i1 false, label %58
    i1 true, label %86
  ]

48:                                               ; preds = %3
  %49 = load { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } }, ptr %4, align 16
  %50 = extractvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %49, 1
  %51 = call fastcc { i64, i64, { i128, [144 x i8] } } @"impl$f127"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %50)
  %52 = extractvalue { i64, i64, { i128, [144 x i8] } } %51, 0
  %53 = extractvalue { i64, i64, { i128, [144 x i8] } } %51, 1
  %54 = extractvalue { i64, i64, { i128, [144 x i8] } } %51, 2
  store { i128, [144 x i8] } %54, ptr %5, align 16
  %55 = load i1, ptr %5, align 1
  switch i1 %55, label %94 [
    i1 false, label %96
    i1 true, label %111
  ]

56:                                               ; preds = %35
  br i1 false, label %57, label %120

57:                                               ; preds = %56
  unreachable

58:                                               ; preds = %35
  %59 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %9, align 8
  %60 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %59, 1
  %61 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %62 = call ptr %61()
  %63 = load i64, ptr %62, align 8
  %64 = mul i64 %63, 10040
  %65 = call i64 @llvm.uadd.sat.i64(i64 %45, i64 %64)
  %66 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %60, 0
  %67 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %60, 1
  call void @"drop$44"({ { ptr, i32, i32, i32 } } %66)
  %68 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %39)
  %69 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %68, 0
  %70 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %68, 1
  %71 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %70, 0
  %72 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %70, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %71)
  %73 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %69, 0
  %74 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %69, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %73)
  %75 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %67, 0
  %76 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %75, i252 %72, 1
  %77 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %76, i32 %74, 2
  %78 = insertvalue { i2, { { ptr, i32, i32, i32 }, i252, i32 } } { i2 1, { { ptr, i32, i32, i32 }, i252, i32 } undef }, { { ptr, i32, i32, i32 }, i252, i32 } %77, 1
  store { i2, { { ptr, i32, i32, i32 }, i252, i32 } } %78, ptr %11, align 16
  %79 = load { i128, [144 x i8] }, ptr %11, align 16
  %80 = insertvalue { { i128, [144 x i8] } } undef, { i128, [144 x i8] } %79, 0
  %81 = insertvalue { i1, { { i128, [144 x i8] } } } { i1 false, { { i128, [144 x i8] } } undef }, { { i128, [144 x i8] } } %80, 1
  store { i1, { { i128, [144 x i8] } } } %81, ptr %12, align 16
  %82 = load { i128, [160 x i8] }, ptr %12, align 16
  %83 = insertvalue { i64, i64, { i128, [160 x i8] } } undef, i64 %44, 0
  %84 = insertvalue { i64, i64, { i128, [160 x i8] } } %83, i64 %65, 1
  %85 = insertvalue { i64, i64, { i128, [160 x i8] } } %84, { i128, [160 x i8] } %82, 2
  ret { i64, i64, { i128, [160 x i8] } } %85

86:                                               ; preds = %35
  %87 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %9, align 8
  %88 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %87, 1
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %39)
  %89 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %88, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %89, ptr %10, align 8
  %90 = load { i128, [160 x i8] }, ptr %10, align 16
  %91 = insertvalue { i64, i64, { i128, [160 x i8] } } undef, i64 %44, 0
  %92 = insertvalue { i64, i64, { i128, [160 x i8] } } %91, i64 %45, 1
  %93 = insertvalue { i64, i64, { i128, [160 x i8] } } %92, { i128, [160 x i8] } %90, 2
  ret { i64, i64, { i128, [160 x i8] } } %93

94:                                               ; preds = %48
  br i1 false, label %95, label %121

95:                                               ; preds = %94
  unreachable

96:                                               ; preds = %48
  %97 = load { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } }, ptr %5, align 16
  %98 = extractvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %97, 1
  %99 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %100 = call ptr %99()
  %101 = call i64 @llvm.uadd.sat.i64(i64 %53, i64 0)
  %102 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %98, 0
  %103 = insertvalue { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } { i2 -2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %102, 1
  store { i2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %103, ptr %7, align 16
  %104 = load { i128, [144 x i8] }, ptr %7, align 16
  %105 = insertvalue { { i128, [144 x i8] } } undef, { i128, [144 x i8] } %104, 0
  %106 = insertvalue { i1, { { i128, [144 x i8] } } } { i1 false, { { i128, [144 x i8] } } undef }, { { i128, [144 x i8] } } %105, 1
  store { i1, { { i128, [144 x i8] } } } %106, ptr %8, align 16
  %107 = load { i128, [160 x i8] }, ptr %8, align 16
  %108 = insertvalue { i64, i64, { i128, [160 x i8] } } undef, i64 %52, 0
  %109 = insertvalue { i64, i64, { i128, [160 x i8] } } %108, i64 %101, 1
  %110 = insertvalue { i64, i64, { i128, [160 x i8] } } %109, { i128, [160 x i8] } %107, 2
  ret { i64, i64, { i128, [160 x i8] } } %110

111:                                              ; preds = %48
  %112 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %113 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %112, 1
  %114 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %113, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %114, ptr %6, align 8
  %115 = load { i128, [160 x i8] }, ptr %6, align 16
  %116 = insertvalue { i64, i64, { i128, [160 x i8] } } undef, i64 %52, 0
  %117 = insertvalue { i64, i64, { i128, [160 x i8] } } %116, i64 %53, 1
  %118 = insertvalue { i64, i64, { i128, [160 x i8] } } %117, { i128, [160 x i8] } %115, 2
  ret { i64, i64, { i128, [160 x i8] } } %118

119:                                              ; preds = %17
  call void @puts(ptr @assert_msg_174)
  call void @abort()
  unreachable

120:                                              ; preds = %56
  call void @puts(ptr @assert_msg_175)
  call void @abort()
  unreachable

121:                                              ; preds = %94
  call void @puts(ptr @assert_msg_176)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [160 x i8] } } @f117(i64 %0, i64 %1, ptr %2) {
  %4 = call fastcc { i64, i64, { i128, [160 x i8] } } @"impl$f117"(i64 %0, i64 %1, ptr %2)
  %5 = extractvalue { i64, i64, { i128, [160 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [160 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [160 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [160 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [160 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [160 x i8] } } %9, { i128, [160 x i8] } %7, 2
  ret { i64, i64, { i128, [160 x i8] } } %10
}

define void @_mlir_ciface_f117(ptr %0, i64 %1, i64 %2, ptr %3) {
  %5 = call { i64, i64, { i128, [160 x i8] } } @f117(i64 %1, i64 %2, ptr %3)
  store { i64, i64, { i128, [160 x i8] } } %5, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f118"(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  %8 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %7, 1
  %10 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 2
  call void @"drop$7"({ { ptr, i32, i32, i32 } } %11)
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %10)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = extractvalue { { ptr, i32, i32, i32 } } %14, 0
  %16 = extractvalue { ptr, i32, i32, i32 } %15, 1
  %17 = extractvalue { ptr, i32, i32, i32 } %15, 2
  %18 = sub i32 %17, %16
  call void @"drop$3"({ ptr, i32, i32, i32 } %15)
  %19 = zext i32 %18 to i252
  %20 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8)
  %21 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %20, 0
  %22 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %20, 1
  %23 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %22, 0
  %24 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %22, 1
  %25 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %22, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %24)
  call void @"drop$7"({ { ptr, i32, i32, i32 } } %25)
  %26 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %42

28:                                               ; preds = %4
  %29 = shl i32 %26, 1
  %30 = call i32 @llvm.umin.i32(i32 %29, i32 1024)
  %31 = add i32 %30, %26
  %32 = call i32 @llvm.umax.i32(i32 %31, i32 8)
  %33 = zext i32 %32 to i64
  %34 = mul i64 %33, 32
  %35 = add i64 %34, 16
  %36 = call ptr @realloc(ptr null, i64 %35)
  store i32 1, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %36, i32 4
  store i32 0, ptr %37, align 4
  %38 = getelementptr inbounds i8, ptr %36, i32 16
  %39 = call ptr @realloc(ptr null, i64 8)
  store ptr %38, ptr %39, align 8
  %40 = insertvalue { ptr, i32, i32, i32 } %3, ptr %39, 0
  %41 = insertvalue { ptr, i32, i32, i32 } %40, i32 %32, 3
  br label %63

42:                                               ; preds = %4
  %43 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %44 = icmp ult i32 %43, %26
  br i1 %44, label %45, label %46

45:                                               ; preds = %42
  br label %60

46:                                               ; preds = %42
  %47 = shl i32 %26, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %26
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %55, i32 -16
  %57 = call ptr @realloc(ptr %56, i64 %53)
  %58 = getelementptr inbounds i8, ptr %57, i32 16
  store ptr %58, ptr %54, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } %3, i32 %50, 3
  br label %60

60:                                               ; preds = %45, %46
  %61 = phi { ptr, i32, i32, i32 } [ %59, %46 ], [ %3, %45 ]
  br label %62

62:                                               ; preds = %60
  br label %63

63:                                               ; preds = %28, %62
  %64 = phi { ptr, i32, i32, i32 } [ %61, %62 ], [ %41, %28 ]
  br label %65

65:                                               ; preds = %63
  %66 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %67 = load ptr, ptr %66, align 8
  %68 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = getelementptr inbounds i8, ptr %67, i64 %70
  store i252 %23, ptr %71, align 16
  %72 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %73 = add i32 %72, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %64, i32 %73, 2
  %75 = getelementptr inbounds i8, ptr %67, i32 -12
  store i32 %73, ptr %75, align 4
  %76 = extractvalue { ptr, i32, i32, i32 } %64, 3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %78, label %92

78:                                               ; preds = %65
  %79 = shl i32 %76, 1
  %80 = call i32 @llvm.umin.i32(i32 %79, i32 1024)
  %81 = add i32 %80, %76
  %82 = call i32 @llvm.umax.i32(i32 %81, i32 8)
  %83 = zext i32 %82 to i64
  %84 = mul i64 %83, 32
  %85 = add i64 %84, 16
  %86 = call ptr @realloc(ptr null, i64 %85)
  store i32 1, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %86, i32 4
  store i32 0, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %86, i32 16
  %89 = call ptr @realloc(ptr null, i64 8)
  store ptr %88, ptr %89, align 8
  %90 = insertvalue { ptr, i32, i32, i32 } %74, ptr %89, 0
  %91 = insertvalue { ptr, i32, i32, i32 } %90, i32 %82, 3
  br label %112

92:                                               ; preds = %65
  %93 = icmp ult i32 %73, %76
  br i1 %93, label %94, label %95

94:                                               ; preds = %92
  br label %109

95:                                               ; preds = %92
  %96 = shl i32 %76, 1
  %97 = call i32 @llvm.umin.i32(i32 %96, i32 1024)
  %98 = add i32 %97, %76
  %99 = call i32 @llvm.umax.i32(i32 %98, i32 8)
  %100 = zext i32 %99 to i64
  %101 = mul i64 %100, 32
  %102 = add i64 %101, 16
  %103 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %104 = load ptr, ptr %103, align 8
  %105 = getelementptr inbounds i8, ptr %104, i32 -16
  %106 = call ptr @realloc(ptr %105, i64 %102)
  %107 = getelementptr inbounds i8, ptr %106, i32 16
  store ptr %107, ptr %103, align 8
  %108 = insertvalue { ptr, i32, i32, i32 } %74, i32 %99, 3
  br label %109

109:                                              ; preds = %94, %95
  %110 = phi { ptr, i32, i32, i32 } [ %108, %95 ], [ %74, %94 ]
  br label %111

111:                                              ; preds = %109
  br label %112

112:                                              ; preds = %78, %111
  %113 = phi { ptr, i32, i32, i32 } [ %110, %111 ], [ %91, %78 ]
  br label %114

114:                                              ; preds = %112
  %115 = extractvalue { ptr, i32, i32, i32 } %113, 0
  %116 = load ptr, ptr %115, align 8
  %117 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %118 = zext i32 %117 to i64
  %119 = mul i64 %118, 32
  %120 = getelementptr inbounds i8, ptr %116, i64 %119
  store i252 %19, ptr %120, align 16
  %121 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %122 = add i32 %121, 1
  %123 = insertvalue { ptr, i32, i32, i32 } %113, i32 %122, 2
  %124 = getelementptr inbounds i8, ptr %116, i32 -12
  store i32 %122, ptr %124, align 4
  %125 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %13, { ptr, i32, i32, i32 } %123)
  %126 = extractvalue { i64, i64, { i64, [24 x i8] } } %125, 0
  %127 = extractvalue { i64, i64, { i64, [24 x i8] } } %125, 1
  %128 = extractvalue { i64, i64, { i64, [24 x i8] } } %125, 2
  store { i64, [24 x i8] } %128, ptr %5, align 8
  %129 = load i1, ptr %5, align 1
  switch i1 %129, label %130 [
    i1 false, label %132
    i1 true, label %148
  ]

130:                                              ; preds = %114
  br i1 false, label %131, label %156

131:                                              ; preds = %130
  unreachable

132:                                              ; preds = %114
  %133 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %134 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %133, 1
  %135 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %136 = call ptr %135()
  %137 = call i64 @llvm.uadd.sat.i64(i64 %127, i64 0)
  %138 = extractvalue { { ptr, i32, i32, i32 }, {} } %134, 0
  %139 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %21, 1
  %140 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %21, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %139)
  %141 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f128"(i64 %126, i64 %137, { { ptr, i32, i32, i32 } } %140, { ptr, i32, i32, i32 } %138)
  %142 = extractvalue { i64, i64, { i64, [24 x i8] } } %141, 0
  %143 = extractvalue { i64, i64, { i64, [24 x i8] } } %141, 1
  %144 = extractvalue { i64, i64, { i64, [24 x i8] } } %141, 2
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %142, 0
  %146 = insertvalue { i64, i64, { i64, [24 x i8] } } %145, i64 %143, 1
  %147 = insertvalue { i64, i64, { i64, [24 x i8] } } %146, { i64, [24 x i8] } %144, 2
  ret { i64, i64, { i64, [24 x i8] } } %147

148:                                              ; preds = %114
  %149 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %150 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %149, 1
  call void @"drop$8"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %21)
  %151 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %150, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %151, ptr %6, align 8
  %152 = load { i64, [24 x i8] }, ptr %6, align 8
  %153 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %126, 0
  %154 = insertvalue { i64, i64, { i64, [24 x i8] } } %153, i64 %127, 1
  %155 = insertvalue { i64, i64, { i64, [24 x i8] } } %154, { i64, [24 x i8] } %152, 2
  ret { i64, i64, { i64, [24 x i8] } } %155

156:                                              ; preds = %130
  call void @puts(ptr @assert_msg_177)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f118(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f118"(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f118(ptr %0, i64 %1, i64 %2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f118(i64 %1, i64 %2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f119"(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4) {
  %6 = alloca { i1, [47 x i8] }, i64 1, align 16
  %7 = alloca i64, i64 1, align 8
  %8 = alloca i252, i64 1, align 16
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = extractvalue { i252 } %4, 0
  %12 = load ptr, ptr %3, align 8
  store i64 %1, ptr %7, align 8
  store i252 %11, ptr %8, align 16
  %13 = getelementptr inbounds ptr, ptr %3, i32 8
  %14 = load ptr, ptr %13, align 8
  call void %14(ptr %6, ptr %12, ptr %7, i32 0, ptr %8)
  %15 = load { i1, [47 x i8] }, ptr %6, align 1
  %16 = extractvalue { i1, [47 x i8] } %15, 0
  %17 = getelementptr inbounds i8, ptr %6, i32 16
  %18 = load i252, ptr %17, align 16
  %19 = getelementptr inbounds i8, ptr %6, i32 8
  %20 = load { ptr, i32, i32, i32 }, ptr %19, align 8
  %21 = load i64, ptr %7, align 8
  br i1 %16, label %56, label %22

22:                                               ; preds = %5
  %23 = phi i64 [ %0, %5 ]
  %24 = phi i252 [ %18, %5 ]
  %25 = trunc i252 %24 to i128
  %26 = lshr i252 %24, 128
  %27 = trunc i252 %26 to i128
  %28 = icmp ne i128 %27, 0
  %29 = add i64 %23, 3
  %30 = add i64 %23, 1
  %31 = select i1 %28, i64 %29, i64 %30
  br i1 %28, label %46, label %32

32:                                               ; preds = %22
  %33 = phi i64 [ %21, %22 ]
  %34 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %35 = call ptr %34()
  %36 = call i64 @llvm.uadd.sat.i64(i64 %33, i64 0)
  %37 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f129"(i64 %31, i64 %2, i128 %25)
  %38 = extractvalue { i64, i64, { i64, [24 x i8] } } %37, 0
  %39 = extractvalue { i64, i64, { i64, [24 x i8] } } %37, 1
  %40 = extractvalue { i64, i64, { i64, [24 x i8] } } %37, 2
  %41 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %38, 0
  %42 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %41, i64 %36, 1
  %43 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %42, i64 %39, 2
  %44 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %43, ptr %3, 3
  %45 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %44, { i64, [24 x i8] } %40, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %45

46:                                               ; preds = %22
  %47 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f97"()
  %48 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %47, 0
  %49 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %48, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %49, ptr %10, align 8
  %50 = load { i64, [24 x i8] }, ptr %10, align 8
  %51 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %31, 0
  %52 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %51, i64 %21, 1
  %53 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %52, i64 %2, 2
  %54 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %53, ptr %3, 3
  %55 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %54, { i64, [24 x i8] } %50, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %55

56:                                               ; preds = %5
  %57 = phi { ptr, i32, i32, i32 } [ %20, %5 ]
  %58 = insertvalue { {}, { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %57, 1
  %59 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %58, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %59, ptr %9, align 8
  %60 = load { i64, [24 x i8] }, ptr %9, align 8
  %61 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %0, 0
  %62 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %61, i64 %21, 1
  %63 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %62, i64 %2, 2
  %64 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %63, ptr %3, 3
  %65 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %64, { i64, [24 x i8] } %60, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %65
}

define private { i64, i64, i64, ptr, { i64, [24 x i8] } } @f119(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4) {
  %6 = call fastcc { i64, i64, i64, ptr, { i64, [24 x i8] } } @"impl$f119"(i64 %0, i64 %1, i64 %2, ptr %3, { i252 } %4)
  %7 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 0
  %8 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 1
  %9 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 2
  %10 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 3
  %11 = extractvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %6, 4
  %12 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } undef, i64 %7, 0
  %13 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %12, i64 %8, 1
  %14 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %13, i64 %9, 2
  %15 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %14, ptr %10, 3
  %16 = insertvalue { i64, i64, i64, ptr, { i64, [24 x i8] } } %15, { i64, [24 x i8] } %11, 4
  ret { i64, i64, i64, ptr, { i64, [24 x i8] } } %16
}

define void @_mlir_ciface_f119(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, { i252 } %5) {
  %7 = call { i64, i64, i64, ptr, { i64, [24 x i8] } } @f119(i64 %1, i64 %2, i64 %3, ptr %4, { i252 } %5)
  store { i64, i64, i64, ptr, { i64, [24 x i8] } } %7, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f120"(i64 %0, i16 %1, i16 %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = icmp eq i16 %2, 0
  br i1 %10, label %11, label %18

11:                                               ; preds = %3
  %12 = phi i16 [ %1, %3 ]
  %13 = insertvalue { i16 } undef, i16 %12, 0
  %14 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %13, 1
  store { i1, { i16 } } %14, ptr %9, align 2
  %15 = load { i64, [24 x i8] }, ptr %9, align 8
  %16 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %0, 0
  %17 = insertvalue { i64, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %15, 1
  ret { i64, { i64, [24 x i8] } } %17

18:                                               ; preds = %3
  %19 = phi i16 [ %2, %3 ]
  %20 = icmp eq i16 %19, 100
  br i1 %20, label %89, label %21

21:                                               ; preds = %18
  %22 = phi i16 [ %1, %18 ]
  %23 = icmp eq i16 %22, 100
  br i1 %23, label %89, label %24

24:                                               ; preds = %21
  %25 = phi i16 [ %22, %21 ]
  %26 = add i64 %0, 1
  %27 = call { i16, i1 } @llvm.uadd.with.overflow.i16(i16 %25, i16 %19)
  %28 = extractvalue { i16, i1 } %27, 0
  %29 = extractvalue { i16, i1 } %27, 1
  br i1 %29, label %82, label %30

30:                                               ; preds = %24
  %31 = phi i16 [ %28, %24 ]
  %32 = phi i16 [ 100, %24 ]
  %33 = zext i16 %31 to i32
  %34 = zext i16 %32 to i32
  %35 = mul i32 %33, %34
  %36 = icmp ult i32 %35, 65536
  %37 = add i64 %0, 2
  %38 = trunc i32 %35 to i16
  br i1 %36, label %39, label %74

39:                                               ; preds = %30
  %40 = phi i16 [ %25, %30 ]
  %41 = phi i16 [ %19, %30 ]
  %42 = zext i16 %40 to i32
  %43 = zext i16 %41 to i32
  %44 = mul i32 %42, %43
  %45 = icmp ult i32 %44, 65536
  %46 = add i64 %0, 3
  %47 = trunc i32 %44 to i16
  br i1 %45, label %48, label %74

48:                                               ; preds = %39
  %49 = phi i64 [ %46, %39 ]
  %50 = phi i16 [ %38, %39 ]
  %51 = phi i16 [ %47, %39 ]
  %52 = add i64 %49, 1
  %53 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 %50, i16 %51)
  %54 = extractvalue { i16, i1 } %53, 0
  %55 = extractvalue { i16, i1 } %53, 1
  br i1 %55, label %67, label %56

56:                                               ; preds = %48
  %57 = phi i64 [ %52, %48 ]
  %58 = phi i16 [ %54, %48 ]
  %59 = phi i16 [ 100, %48 ]
  %60 = add i64 %57, 3
  %61 = udiv i16 %58, %59
  %62 = insertvalue { i16 } undef, i16 %61, 0
  %63 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %62, 1
  store { i1, { i16 } } %63, ptr %8, align 2
  %64 = load { i64, [24 x i8] }, ptr %8, align 8
  %65 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %60, 0
  %66 = insertvalue { i64, { i64, [24 x i8] } } %65, { i64, [24 x i8] } %64, 1
  ret { i64, { i64, [24 x i8] } } %66

67:                                               ; preds = %48
  %68 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f130"()
  %69 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %68, 0
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %7, align 8
  %71 = load { i64, [24 x i8] }, ptr %7, align 8
  %72 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %52, 0
  %73 = insertvalue { i64, { i64, [24 x i8] } } %72, { i64, [24 x i8] } %71, 1
  ret { i64, { i64, [24 x i8] } } %73

74:                                               ; preds = %39, %30
  %75 = phi i64 [ %46, %39 ], [ %37, %30 ]
  %76 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f131"()
  %77 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %76, 0
  %78 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %77, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %78, ptr %6, align 8
  %79 = load { i64, [24 x i8] }, ptr %6, align 8
  %80 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %75, 0
  %81 = insertvalue { i64, { i64, [24 x i8] } } %80, { i64, [24 x i8] } %79, 1
  ret { i64, { i64, [24 x i8] } } %81

82:                                               ; preds = %24
  %83 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f112"()
  %84 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %83, 0
  %85 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %84, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %85, ptr %5, align 8
  %86 = load { i64, [24 x i8] }, ptr %5, align 8
  %87 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %26, 0
  %88 = insertvalue { i64, { i64, [24 x i8] } } %87, { i64, [24 x i8] } %86, 1
  ret { i64, { i64, [24 x i8] } } %88

89:                                               ; preds = %21, %18
  %90 = phi i64 [ %0, %21 ], [ %0, %18 ]
  store { i1, { i16 } } { i1 false, { i16 } { i16 100 } }, ptr %4, align 2
  %91 = load { i64, [24 x i8] }, ptr %4, align 8
  %92 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %90, 0
  %93 = insertvalue { i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %91, 1
  ret { i64, { i64, [24 x i8] } } %93
}

define private { i64, { i64, [24 x i8] } } @f120(i64 %0, i16 %1, i16 %2) {
  %4 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f120"(i64 %0, i16 %1, i16 %2)
  %5 = extractvalue { i64, { i64, [24 x i8] } } %4, 0
  %6 = extractvalue { i64, { i64, [24 x i8] } } %4, 1
  %7 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %5, 0
  %8 = insertvalue { i64, { i64, [24 x i8] } } %7, { i64, [24 x i8] } %6, 1
  ret { i64, { i64, [24 x i8] } } %8
}

define void @_mlir_ciface_f120(ptr %0, i64 %1, i16 %2, i16 %3) {
  %5 = call { i64, { i64, [24 x i8] } } @f120(i64 %1, i16 %2, i16 %3)
  store { i64, { i64, [24 x i8] } } %5, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 35797700703871609771601936749056825782135)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f121() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f121"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f121(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f121()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 139834768374498475669889972816734613367)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f122() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f122"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f122(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f122()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f123"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 608642109794502019480482122260311927)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f123() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f123"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f123(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f123()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f124"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i32, [8 x i8] }, i64 1, align 4
  %4 = alloca { i32, [8 x i8] }, i64 1, align 4
  %5 = alloca { i32, [4 x i8] }, i64 1, align 4
  %6 = alloca { i32, [8 x i8] }, i64 1, align 4
  %7 = alloca { i32, [4 x i8] }, i64 1, align 4
  %8 = alloca { i32, [8 x i8] }, i64 1, align 4
  %9 = alloca { i32, [4 x i8] }, i64 1, align 4
  %10 = alloca { i32, [8 x i8] }, i64 1, align 4
  %11 = alloca { i32, [4 x i8] }, i64 1, align 4
  %12 = alloca { i32, [8 x i8] }, i64 1, align 4
  %13 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %14 = extractvalue { ptr, i32, i32, i32 } %13, 1
  %15 = extractvalue { ptr, i32, i32, i32 } %13, 2
  %16 = sub i32 %15, %14
  %17 = icmp uge i32 %16, 1
  br i1 %17, label %18, label %142

18:                                               ; preds = %2
  %19 = extractvalue { ptr, i32, i32, i32 } %13, 0
  %20 = load ptr, ptr %19, align 8
  %21 = zext i32 %14 to i64
  %22 = mul i64 %21, 32
  %23 = getelementptr inbounds i8, ptr %20, i64 %22
  %24 = add i32 %14, 1
  %25 = insertvalue { ptr, i32, i32, i32 } %13, i32 %24, 1
  %26 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %26, ptr %23, i64 32, i1 false)
  %27 = load i252, ptr %26, align 16
  call void @free(ptr %26)
  %28 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %25)
  %29 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %28, 1
  %31 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %30, 0
  %32 = icmp eq i252 %27, 0
  br i1 %32, label %33, label %41

33:                                               ; preds = %18
  %34 = phi { ptr, i32, i32, i32 } [ %29, %18 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %34)
  store { i2, [0 x i8] } { i2 0, [0 x i8] undef }, ptr %11, align 1
  %35 = load { i32, [4 x i8] }, ptr %11, align 4
  %36 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %35, 1
  store { i1, { i32, [4 x i8] } } %36, ptr %12, align 4
  %37 = load { i32, [8 x i8] }, ptr %12, align 4
  %38 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %0, 0
  %39 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %38, { { ptr, i32, i32, i32 } } %31, 1
  %40 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %39, { i32, [8 x i8] } %37, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %40

41:                                               ; preds = %18
  %42 = phi i252 [ %27, %18 ]
  %43 = zext i252 %42 to i256
  %44 = sub i256 %43, 1
  %45 = add i256 %43, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %46 = icmp ult i256 %43, 1
  %47 = select i1 %46, i256 %45, i256 %44
  %48 = trunc i256 %47 to i252
  %49 = icmp eq i252 %48, 0
  br i1 %49, label %50, label %81

50:                                               ; preds = %41
  %51 = phi { { ptr, i32, i32, i32 } } [ %31, %41 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %51)
  %52 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %53 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %54 = sub i32 %53, %52
  %55 = icmp uge i32 %54, 1
  br i1 %55, label %56, label %142

56:                                               ; preds = %50
  %57 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %58 = load ptr, ptr %57, align 8
  %59 = zext i32 %52 to i64
  %60 = mul i64 %59, 32
  %61 = getelementptr inbounds i8, ptr %58, i64 %60
  %62 = add i32 %52, 1
  %63 = insertvalue { ptr, i32, i32, i32 } %29, i32 %62, 1
  %64 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %64, ptr %61, i64 32, i1 false)
  %65 = load i252, ptr %64, align 16
  call void @free(ptr %64)
  %66 = icmp ult i252 %65, 4294967296
  %67 = add i64 %0, 2
  %68 = add i64 %0, 3
  %69 = select i1 %66, i64 %67, i64 %68
  %70 = trunc i252 %65 to i32
  br i1 %66, label %71, label %142

71:                                               ; preds = %56
  %72 = phi { ptr, i32, i32, i32 } [ %63, %56 ]
  %73 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %72, 0
  %74 = insertvalue { i2, i32 } { i2 1, i32 undef }, i32 %70, 1
  store { i2, i32 } %74, ptr %9, align 4
  %75 = load { i32, [4 x i8] }, ptr %9, align 4
  %76 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %75, 1
  store { i1, { i32, [4 x i8] } } %76, ptr %10, align 4
  %77 = load { i32, [8 x i8] }, ptr %10, align 4
  %78 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %69, 0
  %79 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %78, { { ptr, i32, i32, i32 } } %73, 1
  %80 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %79, { i32, [8 x i8] } %77, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %80

81:                                               ; preds = %41
  %82 = phi i252 [ %42, %41 ]
  %83 = zext i252 %82 to i256
  %84 = sub i256 %83, 2
  %85 = add i256 %83, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %86 = icmp ult i256 %83, 2
  %87 = select i1 %86, i256 %85, i256 %84
  %88 = trunc i256 %87 to i252
  %89 = icmp eq i252 %88, 0
  br i1 %89, label %90, label %121

90:                                               ; preds = %81
  %91 = phi { { ptr, i32, i32, i32 } } [ %31, %81 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %91)
  %92 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %93 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %94 = sub i32 %93, %92
  %95 = icmp uge i32 %94, 1
  br i1 %95, label %96, label %142

96:                                               ; preds = %90
  %97 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %98 = load ptr, ptr %97, align 8
  %99 = zext i32 %92 to i64
  %100 = mul i64 %99, 32
  %101 = getelementptr inbounds i8, ptr %98, i64 %100
  %102 = add i32 %92, 1
  %103 = insertvalue { ptr, i32, i32, i32 } %29, i32 %102, 1
  %104 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %104, ptr %101, i64 32, i1 false)
  %105 = load i252, ptr %104, align 16
  call void @free(ptr %104)
  %106 = icmp ult i252 %105, 4294967296
  %107 = add i64 %0, 2
  %108 = add i64 %0, 3
  %109 = select i1 %106, i64 %107, i64 %108
  %110 = trunc i252 %105 to i32
  br i1 %106, label %111, label %142

111:                                              ; preds = %96
  %112 = phi { ptr, i32, i32, i32 } [ %103, %96 ]
  %113 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %112, 0
  %114 = insertvalue { i2, i32 } { i2 -2, i32 undef }, i32 %110, 1
  store { i2, i32 } %114, ptr %7, align 4
  %115 = load { i32, [4 x i8] }, ptr %7, align 4
  %116 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %115, 1
  store { i1, { i32, [4 x i8] } } %116, ptr %8, align 4
  %117 = load { i32, [8 x i8] }, ptr %8, align 4
  %118 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %109, 0
  %119 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %118, { { ptr, i32, i32, i32 } } %113, 1
  %120 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %119, { i32, [8 x i8] } %117, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %120

121:                                              ; preds = %81
  %122 = phi { ptr, i32, i32, i32 } [ %29, %81 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %122)
  %123 = zext i252 %82 to i256
  %124 = sub i256 %123, 3
  %125 = add i256 %123, 3618502788666131213697322783095070105623107215331596699973092056135872020478
  %126 = icmp ult i256 %123, 3
  %127 = select i1 %126, i256 %125, i256 %124
  %128 = trunc i256 %127 to i252
  %129 = icmp eq i252 %128, 0
  br i1 %129, label %130, label %137

130:                                              ; preds = %121
  store { i2, [0 x i8] } { i2 -1, [0 x i8] undef }, ptr %5, align 1
  %131 = load { i32, [4 x i8] }, ptr %5, align 4
  %132 = insertvalue { i1, { i32, [4 x i8] } } { i1 false, { i32, [4 x i8] } undef }, { i32, [4 x i8] } %131, 1
  store { i1, { i32, [4 x i8] } } %132, ptr %6, align 4
  %133 = load { i32, [8 x i8] }, ptr %6, align 4
  %134 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %0, 0
  %135 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %134, { { ptr, i32, i32, i32 } } %31, 1
  %136 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %135, { i32, [8 x i8] } %133, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %136

137:                                              ; preds = %121
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %138 = load { i32, [8 x i8] }, ptr %4, align 4
  %139 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %0, 0
  %140 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %139, { { ptr, i32, i32, i32 } } %31, 1
  %141 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %140, { i32, [8 x i8] } %138, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %141

142:                                              ; preds = %56, %50, %96, %90, %2
  %143 = phi i64 [ %109, %96 ], [ %0, %90 ], [ %69, %56 ], [ %0, %50 ], [ %0, %2 ]
  %144 = phi { ptr, i32, i32, i32 } [ %103, %96 ], [ %29, %90 ], [ %63, %56 ], [ %29, %50 ], [ %13, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %145 = load { i32, [8 x i8] }, ptr %3, align 4
  %146 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %144, 0
  %147 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %143, 0
  %148 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %147, { { ptr, i32, i32, i32 } } %146, 1
  %149 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %148, { i32, [8 x i8] } %145, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %149
}

define private { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @f124(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @"impl$f124"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %8, { i32, [8 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %9
}

define void @_mlir_ciface_f124(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } @f124(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i32, [8 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } @"impl$f125"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i16, [8 x i8] }, i64 1, align 2
  %4 = alloca { i16, [8 x i8] }, i64 1, align 2
  %5 = alloca { i16, [6 x i8] }, i64 1, align 2
  %6 = alloca { i16, [8 x i8] }, i64 1, align 2
  %7 = alloca { i16, [6 x i8] }, i64 1, align 2
  %8 = alloca { i16, [8 x i8] }, i64 1, align 2
  %9 = alloca { i16, [6 x i8] }, i64 1, align 2
  %10 = alloca { i16, [8 x i8] }, i64 1, align 2
  %11 = alloca { i16, [6 x i8] }, i64 1, align 2
  %12 = alloca { i16, [8 x i8] }, i64 1, align 2
  %13 = alloca { i16, [6 x i8] }, i64 1, align 2
  %14 = alloca { i16, [8 x i8] }, i64 1, align 2
  %15 = alloca { i16, [6 x i8] }, i64 1, align 2
  %16 = alloca { i16, [8 x i8] }, i64 1, align 2
  %17 = alloca { i16, [6 x i8] }, i64 1, align 2
  %18 = alloca { i16, [8 x i8] }, i64 1, align 2
  %19 = alloca { i8, [3 x i8] }, i64 1, align 1
  %20 = alloca { i16, [8 x i8] }, i64 1, align 2
  %21 = alloca { i16, [6 x i8] }, i64 1, align 2
  %22 = alloca { i16, [8 x i8] }, i64 1, align 2
  %23 = alloca { i16, [6 x i8] }, i64 1, align 2
  %24 = alloca { i16, [6 x i8] }, i64 1, align 2
  %25 = alloca { i16, [8 x i8] }, i64 1, align 2
  %26 = alloca { i8, [4 x i8] }, i64 1, align 1
  %27 = alloca { i16, [6 x i8] }, i64 1, align 2
  %28 = alloca { i16, [8 x i8] }, i64 1, align 2
  %29 = alloca { i8, [4 x i8] }, i64 1, align 1
  %30 = alloca { i16, [6 x i8] }, i64 1, align 2
  %31 = alloca { i16, [8 x i8] }, i64 1, align 2
  %32 = alloca { i16, [6 x i8] }, i64 1, align 2
  %33 = alloca { i16, [8 x i8] }, i64 1, align 2
  %34 = alloca { i16, [6 x i8] }, i64 1, align 2
  %35 = alloca { i16, [8 x i8] }, i64 1, align 2
  %36 = alloca { i16, [6 x i8] }, i64 1, align 2
  %37 = alloca { i16, [8 x i8] }, i64 1, align 2
  %38 = alloca { i16, [6 x i8] }, i64 1, align 2
  %39 = alloca { i16, [8 x i8] }, i64 1, align 2
  %40 = alloca { i16, [6 x i8] }, i64 1, align 2
  %41 = alloca { i16, [8 x i8] }, i64 1, align 2
  %42 = alloca { i16, [6 x i8] }, i64 1, align 2
  %43 = alloca { i16, [8 x i8] }, i64 1, align 2
  %44 = alloca { i16, [6 x i8] }, i64 1, align 2
  %45 = alloca { i16, [8 x i8] }, i64 1, align 2
  %46 = alloca { i16, [6 x i8] }, i64 1, align 2
  %47 = alloca { i16, [8 x i8] }, i64 1, align 2
  %48 = alloca { i16, [6 x i8] }, i64 1, align 2
  %49 = alloca { i16, [8 x i8] }, i64 1, align 2
  %50 = alloca { i16, [6 x i8] }, i64 1, align 2
  %51 = alloca { i16, [8 x i8] }, i64 1, align 2
  %52 = alloca { i16, [6 x i8] }, i64 1, align 2
  %53 = alloca { i16, [8 x i8] }, i64 1, align 2
  %54 = alloca { i16, [6 x i8] }, i64 1, align 2
  %55 = alloca { i16, [6 x i8] }, i64 1, align 2
  %56 = alloca { i16, [8 x i8] }, i64 1, align 2
  %57 = alloca { i8, [4 x i8] }, i64 1, align 1
  %58 = alloca { i16, [6 x i8] }, i64 1, align 2
  %59 = alloca { i16, [8 x i8] }, i64 1, align 2
  %60 = alloca { i8, [4 x i8] }, i64 1, align 1
  %61 = alloca { i16, [6 x i8] }, i64 1, align 2
  %62 = alloca { i16, [8 x i8] }, i64 1, align 2
  %63 = alloca { i16, [6 x i8] }, i64 1, align 2
  %64 = alloca { i16, [8 x i8] }, i64 1, align 2
  %65 = alloca { i16, [6 x i8] }, i64 1, align 2
  %66 = alloca { i16, [8 x i8] }, i64 1, align 2
  %67 = alloca { i16, [6 x i8] }, i64 1, align 2
  %68 = alloca { i16, [8 x i8] }, i64 1, align 2
  %69 = alloca { i16, [6 x i8] }, i64 1, align 2
  %70 = alloca { i16, [8 x i8] }, i64 1, align 2
  %71 = alloca { i16, [6 x i8] }, i64 1, align 2
  %72 = alloca { i16, [8 x i8] }, i64 1, align 2
  %73 = alloca { i16, [6 x i8] }, i64 1, align 2
  %74 = alloca { i16, [8 x i8] }, i64 1, align 2
  %75 = alloca { i16, [6 x i8] }, i64 1, align 2
  %76 = alloca { i16, [8 x i8] }, i64 1, align 2
  %77 = alloca { i16, [6 x i8] }, i64 1, align 2
  %78 = alloca { i16, [8 x i8] }, i64 1, align 2
  %79 = alloca { i16, [6 x i8] }, i64 1, align 2
  %80 = alloca { i16, [8 x i8] }, i64 1, align 2
  %81 = alloca { i16, [6 x i8] }, i64 1, align 2
  %82 = alloca { i16, [8 x i8] }, i64 1, align 2
  %83 = alloca { i16, [6 x i8] }, i64 1, align 2
  %84 = alloca { i16, [8 x i8] }, i64 1, align 2
  %85 = alloca { i16, [6 x i8] }, i64 1, align 2
  %86 = alloca { i16, [8 x i8] }, i64 1, align 2
  %87 = alloca { i16, [6 x i8] }, i64 1, align 2
  %88 = alloca { i16, [8 x i8] }, i64 1, align 2
  %89 = alloca { i16, [6 x i8] }, i64 1, align 2
  %90 = alloca { i16, [8 x i8] }, i64 1, align 2
  %91 = alloca { i16, [6 x i8] }, i64 1, align 2
  %92 = alloca { i16, [8 x i8] }, i64 1, align 2
  %93 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %94 = extractvalue { ptr, i32, i32, i32 } %93, 1
  %95 = extractvalue { ptr, i32, i32, i32 } %93, 2
  %96 = sub i32 %95, %94
  %97 = icmp uge i32 %96, 1
  br i1 %97, label %98, label %1483

98:                                               ; preds = %2
  %99 = extractvalue { ptr, i32, i32, i32 } %93, 0
  %100 = load ptr, ptr %99, align 8
  %101 = zext i32 %94 to i64
  %102 = mul i64 %101, 32
  %103 = getelementptr inbounds i8, ptr %100, i64 %102
  %104 = add i32 %94, 1
  %105 = insertvalue { ptr, i32, i32, i32 } %93, i32 %104, 1
  %106 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %103, i64 32, i1 false)
  %107 = load i252, ptr %106, align 16
  call void @free(ptr %106)
  %108 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$3"({ ptr, i32, i32, i32 } %105)
  %109 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %108, 0
  %110 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %108, 1
  %111 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %110, 0
  %112 = icmp ult i252 %107, 40
  %113 = add i64 %0, 2
  %114 = add i64 %0, 3
  %115 = select i1 %112, i64 %113, i64 %114
  %116 = trunc i252 %107 to i6
  br i1 %112, label %117, label %1477

117:                                              ; preds = %98
  %118 = phi i6 [ %116, %98 ]
  switch i6 %118, label %119 [
    i6 0, label %121
    i6 1, label %129
    i6 2, label %169
    i6 3, label %200
    i6 4, label %231
    i6 5, label %271
    i6 6, label %311
    i6 7, label %351
    i6 8, label %391
    i6 9, label %431
    i6 10, label %471
    i6 11, label %511
    i6 12, label %551
    i6 13, label %591
    i6 14, label %631
    i6 15, label %671
    i6 16, label %690
    i6 17, label %709
    i6 18, label %728
    i6 19, label %768
    i6 20, label %808
    i6 21, label %848
    i6 22, label %888
    i6 23, label %928
    i6 24, label %968
    i6 25, label %1008
    i6 26, label %1048
    i6 27, label %1088
    i6 28, label %1128
    i6 29, label %1168
    i6 30, label %1187
    i6 31, label %1206
    i6 -32, label %1225
    i6 -31, label %1251
    i6 -30, label %1282
    i6 -29, label %1313
    i6 -28, label %1344
    i6 -27, label %1384
    i6 -26, label %1415
    i6 -25, label %1446
  ]

119:                                              ; preds = %117
  br i1 false, label %120, label %1491

120:                                              ; preds = %119
  unreachable

121:                                              ; preds = %117
  %122 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %122)
  store { i6, [0 x i8] } { i6 0, [0 x i8] undef }, ptr %91, align 1
  %123 = load { i16, [6 x i8] }, ptr %91, align 2
  %124 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %123, 1
  store { i1, { i16, [6 x i8] } } %124, ptr %92, align 2
  %125 = load { i16, [8 x i8] }, ptr %92, align 2
  %126 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %115, 0
  %127 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %126, { { ptr, i32, i32, i32 } } %111, 1
  %128 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %127, { i16, [8 x i8] } %125, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %128

129:                                              ; preds = %117
  %130 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %130)
  %131 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %132 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %133 = sub i32 %132, %131
  %134 = icmp uge i32 %133, 1
  br i1 %134, label %135, label %1483

135:                                              ; preds = %129
  %136 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %137 = load ptr, ptr %136, align 8
  %138 = zext i32 %131 to i64
  %139 = mul i64 %138, 32
  %140 = getelementptr inbounds i8, ptr %137, i64 %139
  %141 = add i32 %131, 1
  %142 = insertvalue { ptr, i32, i32, i32 } %109, i32 %141, 1
  %143 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %143, ptr %140, i64 32, i1 false)
  %144 = load i252, ptr %143, align 16
  call void @free(ptr %143)
  %145 = icmp sge i252 %144, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %146 = icmp slt i252 %144, 32768
  %147 = and i1 %145, %146
  %148 = icmp slt i252 %144, 0
  br i1 %148, label %149, label %151

149:                                              ; preds = %135
  %150 = sub i252 %144, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %152

151:                                              ; preds = %135
  br label %152

152:                                              ; preds = %149, %151
  %153 = phi i252 [ %144, %151 ], [ %150, %149 ]
  br label %154

154:                                              ; preds = %152
  %155 = add i64 %115, 2
  %156 = add i64 %115, 3
  %157 = select i1 %147, i64 %155, i64 %156
  %158 = trunc i252 %153 to i16
  br i1 %147, label %159, label %1483

159:                                              ; preds = %154
  %160 = phi { ptr, i32, i32, i32 } [ %142, %154 ]
  %161 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %160, 0
  %162 = insertvalue { i6, i16 } { i6 1, i16 undef }, i16 %158, 1
  store { i6, i16 } %162, ptr %89, align 2
  %163 = load { i16, [6 x i8] }, ptr %89, align 2
  %164 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %163, 1
  store { i1, { i16, [6 x i8] } } %164, ptr %90, align 2
  %165 = load { i16, [8 x i8] }, ptr %90, align 2
  %166 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %157, 0
  %167 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %166, { { ptr, i32, i32, i32 } } %161, 1
  %168 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %167, { i16, [8 x i8] } %165, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %168

169:                                              ; preds = %117
  %170 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %170)
  %171 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %172 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %173 = sub i32 %172, %171
  %174 = icmp uge i32 %173, 1
  br i1 %174, label %175, label %1483

175:                                              ; preds = %169
  %176 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %177 = load ptr, ptr %176, align 8
  %178 = zext i32 %171 to i64
  %179 = mul i64 %178, 32
  %180 = getelementptr inbounds i8, ptr %177, i64 %179
  %181 = add i32 %171, 1
  %182 = insertvalue { ptr, i32, i32, i32 } %109, i32 %181, 1
  %183 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %183, ptr %180, i64 32, i1 false)
  %184 = load i252, ptr %183, align 16
  call void @free(ptr %183)
  %185 = icmp ult i252 %184, 256
  %186 = add i64 %115, 2
  %187 = add i64 %115, 3
  %188 = select i1 %185, i64 %186, i64 %187
  %189 = trunc i252 %184 to i8
  br i1 %185, label %190, label %1483

190:                                              ; preds = %175
  %191 = phi { ptr, i32, i32, i32 } [ %182, %175 ]
  %192 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %191, 0
  %193 = insertvalue { i6, i8 } { i6 2, i8 undef }, i8 %189, 1
  store { i6, i8 } %193, ptr %87, align 1
  %194 = load { i16, [6 x i8] }, ptr %87, align 2
  %195 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %194, 1
  store { i1, { i16, [6 x i8] } } %195, ptr %88, align 2
  %196 = load { i16, [8 x i8] }, ptr %88, align 2
  %197 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %188, 0
  %198 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %197, { { ptr, i32, i32, i32 } } %192, 1
  %199 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %198, { i16, [8 x i8] } %196, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %199

200:                                              ; preds = %117
  %201 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %201)
  %202 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %203 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %204 = sub i32 %203, %202
  %205 = icmp uge i32 %204, 1
  br i1 %205, label %206, label %1483

206:                                              ; preds = %200
  %207 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %208 = load ptr, ptr %207, align 8
  %209 = zext i32 %202 to i64
  %210 = mul i64 %209, 32
  %211 = getelementptr inbounds i8, ptr %208, i64 %210
  %212 = add i32 %202, 1
  %213 = insertvalue { ptr, i32, i32, i32 } %109, i32 %212, 1
  %214 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %214, ptr %211, i64 32, i1 false)
  %215 = load i252, ptr %214, align 16
  call void @free(ptr %214)
  %216 = icmp ult i252 %215, 256
  %217 = add i64 %115, 2
  %218 = add i64 %115, 3
  %219 = select i1 %216, i64 %217, i64 %218
  %220 = trunc i252 %215 to i8
  br i1 %216, label %221, label %1483

221:                                              ; preds = %206
  %222 = phi { ptr, i32, i32, i32 } [ %213, %206 ]
  %223 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %222, 0
  %224 = insertvalue { i6, i8 } { i6 3, i8 undef }, i8 %220, 1
  store { i6, i8 } %224, ptr %85, align 1
  %225 = load { i16, [6 x i8] }, ptr %85, align 2
  %226 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %225, 1
  store { i1, { i16, [6 x i8] } } %226, ptr %86, align 2
  %227 = load { i16, [8 x i8] }, ptr %86, align 2
  %228 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %219, 0
  %229 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %228, { { ptr, i32, i32, i32 } } %223, 1
  %230 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %229, { i16, [8 x i8] } %227, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %230

231:                                              ; preds = %117
  %232 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %232)
  %233 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %234 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %235 = sub i32 %234, %233
  %236 = icmp uge i32 %235, 1
  br i1 %236, label %237, label %1483

237:                                              ; preds = %231
  %238 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %239 = load ptr, ptr %238, align 8
  %240 = zext i32 %233 to i64
  %241 = mul i64 %240, 32
  %242 = getelementptr inbounds i8, ptr %239, i64 %241
  %243 = add i32 %233, 1
  %244 = insertvalue { ptr, i32, i32, i32 } %109, i32 %243, 1
  %245 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %245, ptr %242, i64 32, i1 false)
  %246 = load i252, ptr %245, align 16
  call void @free(ptr %245)
  %247 = icmp sge i252 %246, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %248 = icmp slt i252 %246, 128
  %249 = and i1 %247, %248
  %250 = icmp slt i252 %246, 0
  br i1 %250, label %251, label %253

251:                                              ; preds = %237
  %252 = sub i252 %246, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %254

253:                                              ; preds = %237
  br label %254

254:                                              ; preds = %251, %253
  %255 = phi i252 [ %246, %253 ], [ %252, %251 ]
  br label %256

256:                                              ; preds = %254
  %257 = add i64 %115, 2
  %258 = add i64 %115, 3
  %259 = select i1 %249, i64 %257, i64 %258
  %260 = trunc i252 %255 to i8
  br i1 %249, label %261, label %1483

261:                                              ; preds = %256
  %262 = phi { ptr, i32, i32, i32 } [ %244, %256 ]
  %263 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %262, 0
  %264 = insertvalue { i6, i8 } { i6 4, i8 undef }, i8 %260, 1
  store { i6, i8 } %264, ptr %83, align 1
  %265 = load { i16, [6 x i8] }, ptr %83, align 2
  %266 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %265, 1
  store { i1, { i16, [6 x i8] } } %266, ptr %84, align 2
  %267 = load { i16, [8 x i8] }, ptr %84, align 2
  %268 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %259, 0
  %269 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %268, { { ptr, i32, i32, i32 } } %263, 1
  %270 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %269, { i16, [8 x i8] } %267, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %270

271:                                              ; preds = %117
  %272 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %272)
  %273 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %274 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %275 = sub i32 %274, %273
  %276 = icmp uge i32 %275, 1
  br i1 %276, label %277, label %1483

277:                                              ; preds = %271
  %278 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %279 = load ptr, ptr %278, align 8
  %280 = zext i32 %273 to i64
  %281 = mul i64 %280, 32
  %282 = getelementptr inbounds i8, ptr %279, i64 %281
  %283 = add i32 %273, 1
  %284 = insertvalue { ptr, i32, i32, i32 } %109, i32 %283, 1
  %285 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %285, ptr %282, i64 32, i1 false)
  %286 = load i252, ptr %285, align 16
  call void @free(ptr %285)
  %287 = icmp sge i252 %286, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %288 = icmp slt i252 %286, 128
  %289 = and i1 %287, %288
  %290 = icmp slt i252 %286, 0
  br i1 %290, label %291, label %293

291:                                              ; preds = %277
  %292 = sub i252 %286, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %294

293:                                              ; preds = %277
  br label %294

294:                                              ; preds = %291, %293
  %295 = phi i252 [ %286, %293 ], [ %292, %291 ]
  br label %296

296:                                              ; preds = %294
  %297 = add i64 %115, 2
  %298 = add i64 %115, 3
  %299 = select i1 %289, i64 %297, i64 %298
  %300 = trunc i252 %295 to i8
  br i1 %289, label %301, label %1483

301:                                              ; preds = %296
  %302 = phi { ptr, i32, i32, i32 } [ %284, %296 ]
  %303 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %302, 0
  %304 = insertvalue { i6, i8 } { i6 5, i8 undef }, i8 %300, 1
  store { i6, i8 } %304, ptr %81, align 1
  %305 = load { i16, [6 x i8] }, ptr %81, align 2
  %306 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %305, 1
  store { i1, { i16, [6 x i8] } } %306, ptr %82, align 2
  %307 = load { i16, [8 x i8] }, ptr %82, align 2
  %308 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %299, 0
  %309 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %308, { { ptr, i32, i32, i32 } } %303, 1
  %310 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %309, { i16, [8 x i8] } %307, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %310

311:                                              ; preds = %117
  %312 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %312)
  %313 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %314 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %315 = sub i32 %314, %313
  %316 = icmp uge i32 %315, 1
  br i1 %316, label %317, label %1483

317:                                              ; preds = %311
  %318 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %319 = load ptr, ptr %318, align 8
  %320 = zext i32 %313 to i64
  %321 = mul i64 %320, 32
  %322 = getelementptr inbounds i8, ptr %319, i64 %321
  %323 = add i32 %313, 1
  %324 = insertvalue { ptr, i32, i32, i32 } %109, i32 %323, 1
  %325 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %325, ptr %322, i64 32, i1 false)
  %326 = load i252, ptr %325, align 16
  call void @free(ptr %325)
  %327 = icmp sge i252 %326, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %328 = icmp slt i252 %326, 128
  %329 = and i1 %327, %328
  %330 = icmp slt i252 %326, 0
  br i1 %330, label %331, label %333

331:                                              ; preds = %317
  %332 = sub i252 %326, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %334

333:                                              ; preds = %317
  br label %334

334:                                              ; preds = %331, %333
  %335 = phi i252 [ %326, %333 ], [ %332, %331 ]
  br label %336

336:                                              ; preds = %334
  %337 = add i64 %115, 2
  %338 = add i64 %115, 3
  %339 = select i1 %329, i64 %337, i64 %338
  %340 = trunc i252 %335 to i8
  br i1 %329, label %341, label %1483

341:                                              ; preds = %336
  %342 = phi { ptr, i32, i32, i32 } [ %324, %336 ]
  %343 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %342, 0
  %344 = insertvalue { i6, i8 } { i6 6, i8 undef }, i8 %340, 1
  store { i6, i8 } %344, ptr %79, align 1
  %345 = load { i16, [6 x i8] }, ptr %79, align 2
  %346 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %345, 1
  store { i1, { i16, [6 x i8] } } %346, ptr %80, align 2
  %347 = load { i16, [8 x i8] }, ptr %80, align 2
  %348 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %339, 0
  %349 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %348, { { ptr, i32, i32, i32 } } %343, 1
  %350 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %349, { i16, [8 x i8] } %347, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %350

351:                                              ; preds = %117
  %352 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %352)
  %353 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %354 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %355 = sub i32 %354, %353
  %356 = icmp uge i32 %355, 1
  br i1 %356, label %357, label %1483

357:                                              ; preds = %351
  %358 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %359 = load ptr, ptr %358, align 8
  %360 = zext i32 %353 to i64
  %361 = mul i64 %360, 32
  %362 = getelementptr inbounds i8, ptr %359, i64 %361
  %363 = add i32 %353, 1
  %364 = insertvalue { ptr, i32, i32, i32 } %109, i32 %363, 1
  %365 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %365, ptr %362, i64 32, i1 false)
  %366 = load i252, ptr %365, align 16
  call void @free(ptr %365)
  %367 = icmp sge i252 %366, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %368 = icmp slt i252 %366, 128
  %369 = and i1 %367, %368
  %370 = icmp slt i252 %366, 0
  br i1 %370, label %371, label %373

371:                                              ; preds = %357
  %372 = sub i252 %366, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %374

373:                                              ; preds = %357
  br label %374

374:                                              ; preds = %371, %373
  %375 = phi i252 [ %366, %373 ], [ %372, %371 ]
  br label %376

376:                                              ; preds = %374
  %377 = add i64 %115, 2
  %378 = add i64 %115, 3
  %379 = select i1 %369, i64 %377, i64 %378
  %380 = trunc i252 %375 to i8
  br i1 %369, label %381, label %1483

381:                                              ; preds = %376
  %382 = phi { ptr, i32, i32, i32 } [ %364, %376 ]
  %383 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %382, 0
  %384 = insertvalue { i6, i8 } { i6 7, i8 undef }, i8 %380, 1
  store { i6, i8 } %384, ptr %77, align 1
  %385 = load { i16, [6 x i8] }, ptr %77, align 2
  %386 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %385, 1
  store { i1, { i16, [6 x i8] } } %386, ptr %78, align 2
  %387 = load { i16, [8 x i8] }, ptr %78, align 2
  %388 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %379, 0
  %389 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %388, { { ptr, i32, i32, i32 } } %383, 1
  %390 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %389, { i16, [8 x i8] } %387, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %390

391:                                              ; preds = %117
  %392 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %392)
  %393 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %394 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %395 = sub i32 %394, %393
  %396 = icmp uge i32 %395, 1
  br i1 %396, label %397, label %1483

397:                                              ; preds = %391
  %398 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %399 = load ptr, ptr %398, align 8
  %400 = zext i32 %393 to i64
  %401 = mul i64 %400, 32
  %402 = getelementptr inbounds i8, ptr %399, i64 %401
  %403 = add i32 %393, 1
  %404 = insertvalue { ptr, i32, i32, i32 } %109, i32 %403, 1
  %405 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %405, ptr %402, i64 32, i1 false)
  %406 = load i252, ptr %405, align 16
  call void @free(ptr %405)
  %407 = icmp sge i252 %406, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %408 = icmp slt i252 %406, 128
  %409 = and i1 %407, %408
  %410 = icmp slt i252 %406, 0
  br i1 %410, label %411, label %413

411:                                              ; preds = %397
  %412 = sub i252 %406, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %414

413:                                              ; preds = %397
  br label %414

414:                                              ; preds = %411, %413
  %415 = phi i252 [ %406, %413 ], [ %412, %411 ]
  br label %416

416:                                              ; preds = %414
  %417 = add i64 %115, 2
  %418 = add i64 %115, 3
  %419 = select i1 %409, i64 %417, i64 %418
  %420 = trunc i252 %415 to i8
  br i1 %409, label %421, label %1483

421:                                              ; preds = %416
  %422 = phi { ptr, i32, i32, i32 } [ %404, %416 ]
  %423 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %422, 0
  %424 = insertvalue { i6, i8 } { i6 8, i8 undef }, i8 %420, 1
  store { i6, i8 } %424, ptr %75, align 1
  %425 = load { i16, [6 x i8] }, ptr %75, align 2
  %426 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %425, 1
  store { i1, { i16, [6 x i8] } } %426, ptr %76, align 2
  %427 = load { i16, [8 x i8] }, ptr %76, align 2
  %428 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %419, 0
  %429 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %428, { { ptr, i32, i32, i32 } } %423, 1
  %430 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %429, { i16, [8 x i8] } %427, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %430

431:                                              ; preds = %117
  %432 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %432)
  %433 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %434 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %435 = sub i32 %434, %433
  %436 = icmp uge i32 %435, 1
  br i1 %436, label %437, label %1483

437:                                              ; preds = %431
  %438 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %439 = load ptr, ptr %438, align 8
  %440 = zext i32 %433 to i64
  %441 = mul i64 %440, 32
  %442 = getelementptr inbounds i8, ptr %439, i64 %441
  %443 = add i32 %433, 1
  %444 = insertvalue { ptr, i32, i32, i32 } %109, i32 %443, 1
  %445 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %445, ptr %442, i64 32, i1 false)
  %446 = load i252, ptr %445, align 16
  call void @free(ptr %445)
  %447 = icmp sge i252 %446, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %448 = icmp slt i252 %446, 128
  %449 = and i1 %447, %448
  %450 = icmp slt i252 %446, 0
  br i1 %450, label %451, label %453

451:                                              ; preds = %437
  %452 = sub i252 %446, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %454

453:                                              ; preds = %437
  br label %454

454:                                              ; preds = %451, %453
  %455 = phi i252 [ %446, %453 ], [ %452, %451 ]
  br label %456

456:                                              ; preds = %454
  %457 = add i64 %115, 2
  %458 = add i64 %115, 3
  %459 = select i1 %449, i64 %457, i64 %458
  %460 = trunc i252 %455 to i8
  br i1 %449, label %461, label %1483

461:                                              ; preds = %456
  %462 = phi { ptr, i32, i32, i32 } [ %444, %456 ]
  %463 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %462, 0
  %464 = insertvalue { i6, i8 } { i6 9, i8 undef }, i8 %460, 1
  store { i6, i8 } %464, ptr %73, align 1
  %465 = load { i16, [6 x i8] }, ptr %73, align 2
  %466 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %465, 1
  store { i1, { i16, [6 x i8] } } %466, ptr %74, align 2
  %467 = load { i16, [8 x i8] }, ptr %74, align 2
  %468 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %459, 0
  %469 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %468, { { ptr, i32, i32, i32 } } %463, 1
  %470 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %469, { i16, [8 x i8] } %467, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %470

471:                                              ; preds = %117
  %472 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %472)
  %473 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %474 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %475 = sub i32 %474, %473
  %476 = icmp uge i32 %475, 1
  br i1 %476, label %477, label %1483

477:                                              ; preds = %471
  %478 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %479 = load ptr, ptr %478, align 8
  %480 = zext i32 %473 to i64
  %481 = mul i64 %480, 32
  %482 = getelementptr inbounds i8, ptr %479, i64 %481
  %483 = add i32 %473, 1
  %484 = insertvalue { ptr, i32, i32, i32 } %109, i32 %483, 1
  %485 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %485, ptr %482, i64 32, i1 false)
  %486 = load i252, ptr %485, align 16
  call void @free(ptr %485)
  %487 = icmp sge i252 %486, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %488 = icmp slt i252 %486, 128
  %489 = and i1 %487, %488
  %490 = icmp slt i252 %486, 0
  br i1 %490, label %491, label %493

491:                                              ; preds = %477
  %492 = sub i252 %486, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %494

493:                                              ; preds = %477
  br label %494

494:                                              ; preds = %491, %493
  %495 = phi i252 [ %486, %493 ], [ %492, %491 ]
  br label %496

496:                                              ; preds = %494
  %497 = add i64 %115, 2
  %498 = add i64 %115, 3
  %499 = select i1 %489, i64 %497, i64 %498
  %500 = trunc i252 %495 to i8
  br i1 %489, label %501, label %1483

501:                                              ; preds = %496
  %502 = phi { ptr, i32, i32, i32 } [ %484, %496 ]
  %503 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %502, 0
  %504 = insertvalue { i6, i8 } { i6 10, i8 undef }, i8 %500, 1
  store { i6, i8 } %504, ptr %71, align 1
  %505 = load { i16, [6 x i8] }, ptr %71, align 2
  %506 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %505, 1
  store { i1, { i16, [6 x i8] } } %506, ptr %72, align 2
  %507 = load { i16, [8 x i8] }, ptr %72, align 2
  %508 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %499, 0
  %509 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %508, { { ptr, i32, i32, i32 } } %503, 1
  %510 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %509, { i16, [8 x i8] } %507, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %510

511:                                              ; preds = %117
  %512 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %512)
  %513 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %514 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %515 = sub i32 %514, %513
  %516 = icmp uge i32 %515, 1
  br i1 %516, label %517, label %1483

517:                                              ; preds = %511
  %518 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %519 = load ptr, ptr %518, align 8
  %520 = zext i32 %513 to i64
  %521 = mul i64 %520, 32
  %522 = getelementptr inbounds i8, ptr %519, i64 %521
  %523 = add i32 %513, 1
  %524 = insertvalue { ptr, i32, i32, i32 } %109, i32 %523, 1
  %525 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %525, ptr %522, i64 32, i1 false)
  %526 = load i252, ptr %525, align 16
  call void @free(ptr %525)
  %527 = icmp sge i252 %526, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %528 = icmp slt i252 %526, 128
  %529 = and i1 %527, %528
  %530 = icmp slt i252 %526, 0
  br i1 %530, label %531, label %533

531:                                              ; preds = %517
  %532 = sub i252 %526, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %534

533:                                              ; preds = %517
  br label %534

534:                                              ; preds = %531, %533
  %535 = phi i252 [ %526, %533 ], [ %532, %531 ]
  br label %536

536:                                              ; preds = %534
  %537 = add i64 %115, 2
  %538 = add i64 %115, 3
  %539 = select i1 %529, i64 %537, i64 %538
  %540 = trunc i252 %535 to i8
  br i1 %529, label %541, label %1483

541:                                              ; preds = %536
  %542 = phi { ptr, i32, i32, i32 } [ %524, %536 ]
  %543 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %542, 0
  %544 = insertvalue { i6, i8 } { i6 11, i8 undef }, i8 %540, 1
  store { i6, i8 } %544, ptr %69, align 1
  %545 = load { i16, [6 x i8] }, ptr %69, align 2
  %546 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %545, 1
  store { i1, { i16, [6 x i8] } } %546, ptr %70, align 2
  %547 = load { i16, [8 x i8] }, ptr %70, align 2
  %548 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %539, 0
  %549 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %548, { { ptr, i32, i32, i32 } } %543, 1
  %550 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %549, { i16, [8 x i8] } %547, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %550

551:                                              ; preds = %117
  %552 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %552)
  %553 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %554 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %555 = sub i32 %554, %553
  %556 = icmp uge i32 %555, 1
  br i1 %556, label %557, label %1483

557:                                              ; preds = %551
  %558 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %559 = load ptr, ptr %558, align 8
  %560 = zext i32 %553 to i64
  %561 = mul i64 %560, 32
  %562 = getelementptr inbounds i8, ptr %559, i64 %561
  %563 = add i32 %553, 1
  %564 = insertvalue { ptr, i32, i32, i32 } %109, i32 %563, 1
  %565 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %565, ptr %562, i64 32, i1 false)
  %566 = load i252, ptr %565, align 16
  call void @free(ptr %565)
  %567 = icmp sge i252 %566, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %568 = icmp slt i252 %566, 32768
  %569 = and i1 %567, %568
  %570 = icmp slt i252 %566, 0
  br i1 %570, label %571, label %573

571:                                              ; preds = %557
  %572 = sub i252 %566, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %574

573:                                              ; preds = %557
  br label %574

574:                                              ; preds = %571, %573
  %575 = phi i252 [ %566, %573 ], [ %572, %571 ]
  br label %576

576:                                              ; preds = %574
  %577 = add i64 %115, 2
  %578 = add i64 %115, 3
  %579 = select i1 %569, i64 %577, i64 %578
  %580 = trunc i252 %575 to i16
  br i1 %569, label %581, label %1483

581:                                              ; preds = %576
  %582 = phi { ptr, i32, i32, i32 } [ %564, %576 ]
  %583 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %582, 0
  %584 = insertvalue { i6, i16 } { i6 12, i16 undef }, i16 %580, 1
  store { i6, i16 } %584, ptr %67, align 2
  %585 = load { i16, [6 x i8] }, ptr %67, align 2
  %586 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %585, 1
  store { i1, { i16, [6 x i8] } } %586, ptr %68, align 2
  %587 = load { i16, [8 x i8] }, ptr %68, align 2
  %588 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %579, 0
  %589 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %588, { { ptr, i32, i32, i32 } } %583, 1
  %590 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %589, { i16, [8 x i8] } %587, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %590

591:                                              ; preds = %117
  %592 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %592)
  %593 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %594 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %595 = sub i32 %594, %593
  %596 = icmp uge i32 %595, 1
  br i1 %596, label %597, label %1483

597:                                              ; preds = %591
  %598 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %599 = load ptr, ptr %598, align 8
  %600 = zext i32 %593 to i64
  %601 = mul i64 %600, 32
  %602 = getelementptr inbounds i8, ptr %599, i64 %601
  %603 = add i32 %593, 1
  %604 = insertvalue { ptr, i32, i32, i32 } %109, i32 %603, 1
  %605 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %605, ptr %602, i64 32, i1 false)
  %606 = load i252, ptr %605, align 16
  call void @free(ptr %605)
  %607 = icmp sge i252 %606, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %608 = icmp slt i252 %606, 32768
  %609 = and i1 %607, %608
  %610 = icmp slt i252 %606, 0
  br i1 %610, label %611, label %613

611:                                              ; preds = %597
  %612 = sub i252 %606, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %614

613:                                              ; preds = %597
  br label %614

614:                                              ; preds = %611, %613
  %615 = phi i252 [ %606, %613 ], [ %612, %611 ]
  br label %616

616:                                              ; preds = %614
  %617 = add i64 %115, 2
  %618 = add i64 %115, 3
  %619 = select i1 %609, i64 %617, i64 %618
  %620 = trunc i252 %615 to i16
  br i1 %609, label %621, label %1483

621:                                              ; preds = %616
  %622 = phi { ptr, i32, i32, i32 } [ %604, %616 ]
  %623 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %622, 0
  %624 = insertvalue { i6, i16 } { i6 13, i16 undef }, i16 %620, 1
  store { i6, i16 } %624, ptr %65, align 2
  %625 = load { i16, [6 x i8] }, ptr %65, align 2
  %626 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %625, 1
  store { i1, { i16, [6 x i8] } } %626, ptr %66, align 2
  %627 = load { i16, [8 x i8] }, ptr %66, align 2
  %628 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %619, 0
  %629 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %628, { { ptr, i32, i32, i32 } } %623, 1
  %630 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %629, { i16, [8 x i8] } %627, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %630

631:                                              ; preds = %117
  %632 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %632)
  %633 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %634 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %635 = sub i32 %634, %633
  %636 = icmp uge i32 %635, 1
  br i1 %636, label %637, label %1483

637:                                              ; preds = %631
  %638 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %639 = load ptr, ptr %638, align 8
  %640 = zext i32 %633 to i64
  %641 = mul i64 %640, 32
  %642 = getelementptr inbounds i8, ptr %639, i64 %641
  %643 = add i32 %633, 1
  %644 = insertvalue { ptr, i32, i32, i32 } %109, i32 %643, 1
  %645 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %645, ptr %642, i64 32, i1 false)
  %646 = load i252, ptr %645, align 16
  call void @free(ptr %645)
  %647 = icmp sge i252 %646, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %648 = icmp slt i252 %646, 32768
  %649 = and i1 %647, %648
  %650 = icmp slt i252 %646, 0
  br i1 %650, label %651, label %653

651:                                              ; preds = %637
  %652 = sub i252 %646, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %654

653:                                              ; preds = %637
  br label %654

654:                                              ; preds = %651, %653
  %655 = phi i252 [ %646, %653 ], [ %652, %651 ]
  br label %656

656:                                              ; preds = %654
  %657 = add i64 %115, 2
  %658 = add i64 %115, 3
  %659 = select i1 %649, i64 %657, i64 %658
  %660 = trunc i252 %655 to i16
  br i1 %649, label %661, label %1483

661:                                              ; preds = %656
  %662 = phi { ptr, i32, i32, i32 } [ %644, %656 ]
  %663 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %662, 0
  %664 = insertvalue { i6, i16 } { i6 14, i16 undef }, i16 %660, 1
  store { i6, i16 } %664, ptr %63, align 2
  %665 = load { i16, [6 x i8] }, ptr %63, align 2
  %666 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %665, 1
  store { i1, { i16, [6 x i8] } } %666, ptr %64, align 2
  %667 = load { i16, [8 x i8] }, ptr %64, align 2
  %668 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %659, 0
  %669 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %668, { { ptr, i32, i32, i32 } } %663, 1
  %670 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %669, { i16, [8 x i8] } %667, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %670

671:                                              ; preds = %117
  %672 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %672)
  %673 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f132"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %674 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %673, 0
  %675 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %673, 1
  %676 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %673, 2
  store { i8, [4 x i8] } %676, ptr %60, align 1
  %677 = load i1, ptr %60, align 1
  switch i1 %677, label %678 [
    i1 false, label %680
    i1 true, label %1244
  ]

678:                                              ; preds = %671
  br i1 false, label %679, label %1492

679:                                              ; preds = %678
  unreachable

680:                                              ; preds = %671
  %681 = load { i1, { i8, i8, i8, i8 } }, ptr %60, align 1
  %682 = extractvalue { i1, { i8, i8, i8, i8 } } %681, 1
  %683 = insertvalue { i6, { i8, i8, i8, i8 } } { i6 15, { i8, i8, i8, i8 } undef }, { i8, i8, i8, i8 } %682, 1
  store { i6, { i8, i8, i8, i8 } } %683, ptr %61, align 1
  %684 = load { i16, [6 x i8] }, ptr %61, align 2
  %685 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %684, 1
  store { i1, { i16, [6 x i8] } } %685, ptr %62, align 2
  %686 = load { i16, [8 x i8] }, ptr %62, align 2
  %687 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %674, 0
  %688 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %687, { { ptr, i32, i32, i32 } } %675, 1
  %689 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %688, { i16, [8 x i8] } %686, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %689

690:                                              ; preds = %117
  %691 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %691)
  %692 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f133"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %693 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %692, 0
  %694 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %692, 1
  %695 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %692, 2
  store { i8, [4 x i8] } %695, ptr %57, align 1
  %696 = load i1, ptr %57, align 1
  switch i1 %696, label %697 [
    i1 false, label %699
    i1 true, label %1244
  ]

697:                                              ; preds = %690
  br i1 false, label %698, label %1493

698:                                              ; preds = %697
  unreachable

699:                                              ; preds = %690
  %700 = load { i1, { i8, i8, i8, i8 } }, ptr %57, align 1
  %701 = extractvalue { i1, { i8, i8, i8, i8 } } %700, 1
  %702 = insertvalue { i6, { i8, i8, i8, i8 } } { i6 16, { i8, i8, i8, i8 } undef }, { i8, i8, i8, i8 } %701, 1
  store { i6, { i8, i8, i8, i8 } } %702, ptr %58, align 1
  %703 = load { i16, [6 x i8] }, ptr %58, align 2
  %704 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %703, 1
  store { i1, { i16, [6 x i8] } } %704, ptr %59, align 2
  %705 = load { i16, [8 x i8] }, ptr %59, align 2
  %706 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %693, 0
  %707 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %706, { { ptr, i32, i32, i32 } } %694, 1
  %708 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %707, { i16, [8 x i8] } %705, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %708

709:                                              ; preds = %117
  %710 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %710)
  %711 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } @"impl$f134"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %712 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %711, 0
  %713 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %711, 1
  %714 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %711, 2
  store { i16, [6 x i8] } %714, ptr %54, align 2
  %715 = load i1, ptr %54, align 1
  switch i1 %715, label %716 [
    i1 false, label %718
    i1 true, label %1244
  ]

716:                                              ; preds = %709
  br i1 false, label %717, label %1494

717:                                              ; preds = %716
  unreachable

718:                                              ; preds = %709
  %719 = load { i1, { i16, i16, i16 } }, ptr %54, align 2
  %720 = extractvalue { i1, { i16, i16, i16 } } %719, 1
  %721 = insertvalue { i6, { i16, i16, i16 } } { i6 17, { i16, i16, i16 } undef }, { i16, i16, i16 } %720, 1
  store { i6, { i16, i16, i16 } } %721, ptr %55, align 2
  %722 = load { i16, [6 x i8] }, ptr %55, align 2
  %723 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %722, 1
  store { i1, { i16, [6 x i8] } } %723, ptr %56, align 2
  %724 = load { i16, [8 x i8] }, ptr %56, align 2
  %725 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %712, 0
  %726 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %725, { { ptr, i32, i32, i32 } } %713, 1
  %727 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %726, { i16, [8 x i8] } %724, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %727

728:                                              ; preds = %117
  %729 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %729)
  %730 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %731 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %732 = sub i32 %731, %730
  %733 = icmp uge i32 %732, 1
  br i1 %733, label %734, label %1483

734:                                              ; preds = %728
  %735 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %736 = load ptr, ptr %735, align 8
  %737 = zext i32 %730 to i64
  %738 = mul i64 %737, 32
  %739 = getelementptr inbounds i8, ptr %736, i64 %738
  %740 = add i32 %730, 1
  %741 = insertvalue { ptr, i32, i32, i32 } %109, i32 %740, 1
  %742 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %742, ptr %739, i64 32, i1 false)
  %743 = load i252, ptr %742, align 16
  call void @free(ptr %742)
  %744 = icmp sge i252 %743, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %745 = icmp slt i252 %743, 128
  %746 = and i1 %744, %745
  %747 = icmp slt i252 %743, 0
  br i1 %747, label %748, label %750

748:                                              ; preds = %734
  %749 = sub i252 %743, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %751

750:                                              ; preds = %734
  br label %751

751:                                              ; preds = %748, %750
  %752 = phi i252 [ %743, %750 ], [ %749, %748 ]
  br label %753

753:                                              ; preds = %751
  %754 = add i64 %115, 2
  %755 = add i64 %115, 3
  %756 = select i1 %746, i64 %754, i64 %755
  %757 = trunc i252 %752 to i8
  br i1 %746, label %758, label %1483

758:                                              ; preds = %753
  %759 = phi { ptr, i32, i32, i32 } [ %741, %753 ]
  %760 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %759, 0
  %761 = insertvalue { i6, i8 } { i6 18, i8 undef }, i8 %757, 1
  store { i6, i8 } %761, ptr %52, align 1
  %762 = load { i16, [6 x i8] }, ptr %52, align 2
  %763 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %762, 1
  store { i1, { i16, [6 x i8] } } %763, ptr %53, align 2
  %764 = load { i16, [8 x i8] }, ptr %53, align 2
  %765 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %756, 0
  %766 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %765, { { ptr, i32, i32, i32 } } %760, 1
  %767 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %766, { i16, [8 x i8] } %764, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %767

768:                                              ; preds = %117
  %769 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %769)
  %770 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %771 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %772 = sub i32 %771, %770
  %773 = icmp uge i32 %772, 1
  br i1 %773, label %774, label %1483

774:                                              ; preds = %768
  %775 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %776 = load ptr, ptr %775, align 8
  %777 = zext i32 %770 to i64
  %778 = mul i64 %777, 32
  %779 = getelementptr inbounds i8, ptr %776, i64 %778
  %780 = add i32 %770, 1
  %781 = insertvalue { ptr, i32, i32, i32 } %109, i32 %780, 1
  %782 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %782, ptr %779, i64 32, i1 false)
  %783 = load i252, ptr %782, align 16
  call void @free(ptr %782)
  %784 = icmp sge i252 %783, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %785 = icmp slt i252 %783, 128
  %786 = and i1 %784, %785
  %787 = icmp slt i252 %783, 0
  br i1 %787, label %788, label %790

788:                                              ; preds = %774
  %789 = sub i252 %783, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %791

790:                                              ; preds = %774
  br label %791

791:                                              ; preds = %788, %790
  %792 = phi i252 [ %783, %790 ], [ %789, %788 ]
  br label %793

793:                                              ; preds = %791
  %794 = add i64 %115, 2
  %795 = add i64 %115, 3
  %796 = select i1 %786, i64 %794, i64 %795
  %797 = trunc i252 %792 to i8
  br i1 %786, label %798, label %1483

798:                                              ; preds = %793
  %799 = phi { ptr, i32, i32, i32 } [ %781, %793 ]
  %800 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %799, 0
  %801 = insertvalue { i6, i8 } { i6 19, i8 undef }, i8 %797, 1
  store { i6, i8 } %801, ptr %50, align 1
  %802 = load { i16, [6 x i8] }, ptr %50, align 2
  %803 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %802, 1
  store { i1, { i16, [6 x i8] } } %803, ptr %51, align 2
  %804 = load { i16, [8 x i8] }, ptr %51, align 2
  %805 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %796, 0
  %806 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %805, { { ptr, i32, i32, i32 } } %800, 1
  %807 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %806, { i16, [8 x i8] } %804, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %807

808:                                              ; preds = %117
  %809 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %809)
  %810 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %811 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %812 = sub i32 %811, %810
  %813 = icmp uge i32 %812, 1
  br i1 %813, label %814, label %1483

814:                                              ; preds = %808
  %815 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %816 = load ptr, ptr %815, align 8
  %817 = zext i32 %810 to i64
  %818 = mul i64 %817, 32
  %819 = getelementptr inbounds i8, ptr %816, i64 %818
  %820 = add i32 %810, 1
  %821 = insertvalue { ptr, i32, i32, i32 } %109, i32 %820, 1
  %822 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %822, ptr %819, i64 32, i1 false)
  %823 = load i252, ptr %822, align 16
  call void @free(ptr %822)
  %824 = icmp sge i252 %823, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %825 = icmp slt i252 %823, 128
  %826 = and i1 %824, %825
  %827 = icmp slt i252 %823, 0
  br i1 %827, label %828, label %830

828:                                              ; preds = %814
  %829 = sub i252 %823, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %831

830:                                              ; preds = %814
  br label %831

831:                                              ; preds = %828, %830
  %832 = phi i252 [ %823, %830 ], [ %829, %828 ]
  br label %833

833:                                              ; preds = %831
  %834 = add i64 %115, 2
  %835 = add i64 %115, 3
  %836 = select i1 %826, i64 %834, i64 %835
  %837 = trunc i252 %832 to i8
  br i1 %826, label %838, label %1483

838:                                              ; preds = %833
  %839 = phi { ptr, i32, i32, i32 } [ %821, %833 ]
  %840 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %839, 0
  %841 = insertvalue { i6, i8 } { i6 20, i8 undef }, i8 %837, 1
  store { i6, i8 } %841, ptr %48, align 1
  %842 = load { i16, [6 x i8] }, ptr %48, align 2
  %843 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %842, 1
  store { i1, { i16, [6 x i8] } } %843, ptr %49, align 2
  %844 = load { i16, [8 x i8] }, ptr %49, align 2
  %845 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %836, 0
  %846 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %845, { { ptr, i32, i32, i32 } } %840, 1
  %847 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %846, { i16, [8 x i8] } %844, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %847

848:                                              ; preds = %117
  %849 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %849)
  %850 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %851 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %852 = sub i32 %851, %850
  %853 = icmp uge i32 %852, 1
  br i1 %853, label %854, label %1483

854:                                              ; preds = %848
  %855 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %856 = load ptr, ptr %855, align 8
  %857 = zext i32 %850 to i64
  %858 = mul i64 %857, 32
  %859 = getelementptr inbounds i8, ptr %856, i64 %858
  %860 = add i32 %850, 1
  %861 = insertvalue { ptr, i32, i32, i32 } %109, i32 %860, 1
  %862 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %862, ptr %859, i64 32, i1 false)
  %863 = load i252, ptr %862, align 16
  call void @free(ptr %862)
  %864 = icmp sge i252 %863, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %865 = icmp slt i252 %863, 128
  %866 = and i1 %864, %865
  %867 = icmp slt i252 %863, 0
  br i1 %867, label %868, label %870

868:                                              ; preds = %854
  %869 = sub i252 %863, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %871

870:                                              ; preds = %854
  br label %871

871:                                              ; preds = %868, %870
  %872 = phi i252 [ %863, %870 ], [ %869, %868 ]
  br label %873

873:                                              ; preds = %871
  %874 = add i64 %115, 2
  %875 = add i64 %115, 3
  %876 = select i1 %866, i64 %874, i64 %875
  %877 = trunc i252 %872 to i8
  br i1 %866, label %878, label %1483

878:                                              ; preds = %873
  %879 = phi { ptr, i32, i32, i32 } [ %861, %873 ]
  %880 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %879, 0
  %881 = insertvalue { i6, i8 } { i6 21, i8 undef }, i8 %877, 1
  store { i6, i8 } %881, ptr %46, align 1
  %882 = load { i16, [6 x i8] }, ptr %46, align 2
  %883 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %882, 1
  store { i1, { i16, [6 x i8] } } %883, ptr %47, align 2
  %884 = load { i16, [8 x i8] }, ptr %47, align 2
  %885 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %876, 0
  %886 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %885, { { ptr, i32, i32, i32 } } %880, 1
  %887 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %886, { i16, [8 x i8] } %884, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %887

888:                                              ; preds = %117
  %889 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %889)
  %890 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %891 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %892 = sub i32 %891, %890
  %893 = icmp uge i32 %892, 1
  br i1 %893, label %894, label %1483

894:                                              ; preds = %888
  %895 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %896 = load ptr, ptr %895, align 8
  %897 = zext i32 %890 to i64
  %898 = mul i64 %897, 32
  %899 = getelementptr inbounds i8, ptr %896, i64 %898
  %900 = add i32 %890, 1
  %901 = insertvalue { ptr, i32, i32, i32 } %109, i32 %900, 1
  %902 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %902, ptr %899, i64 32, i1 false)
  %903 = load i252, ptr %902, align 16
  call void @free(ptr %902)
  %904 = icmp sge i252 %903, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %905 = icmp slt i252 %903, 128
  %906 = and i1 %904, %905
  %907 = icmp slt i252 %903, 0
  br i1 %907, label %908, label %910

908:                                              ; preds = %894
  %909 = sub i252 %903, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %911

910:                                              ; preds = %894
  br label %911

911:                                              ; preds = %908, %910
  %912 = phi i252 [ %903, %910 ], [ %909, %908 ]
  br label %913

913:                                              ; preds = %911
  %914 = add i64 %115, 2
  %915 = add i64 %115, 3
  %916 = select i1 %906, i64 %914, i64 %915
  %917 = trunc i252 %912 to i8
  br i1 %906, label %918, label %1483

918:                                              ; preds = %913
  %919 = phi { ptr, i32, i32, i32 } [ %901, %913 ]
  %920 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %919, 0
  %921 = insertvalue { i6, i8 } { i6 22, i8 undef }, i8 %917, 1
  store { i6, i8 } %921, ptr %44, align 1
  %922 = load { i16, [6 x i8] }, ptr %44, align 2
  %923 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %922, 1
  store { i1, { i16, [6 x i8] } } %923, ptr %45, align 2
  %924 = load { i16, [8 x i8] }, ptr %45, align 2
  %925 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %916, 0
  %926 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %925, { { ptr, i32, i32, i32 } } %920, 1
  %927 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %926, { i16, [8 x i8] } %924, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %927

928:                                              ; preds = %117
  %929 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %929)
  %930 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %931 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %932 = sub i32 %931, %930
  %933 = icmp uge i32 %932, 1
  br i1 %933, label %934, label %1483

934:                                              ; preds = %928
  %935 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %936 = load ptr, ptr %935, align 8
  %937 = zext i32 %930 to i64
  %938 = mul i64 %937, 32
  %939 = getelementptr inbounds i8, ptr %936, i64 %938
  %940 = add i32 %930, 1
  %941 = insertvalue { ptr, i32, i32, i32 } %109, i32 %940, 1
  %942 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %942, ptr %939, i64 32, i1 false)
  %943 = load i252, ptr %942, align 16
  call void @free(ptr %942)
  %944 = icmp sge i252 %943, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %945 = icmp slt i252 %943, 128
  %946 = and i1 %944, %945
  %947 = icmp slt i252 %943, 0
  br i1 %947, label %948, label %950

948:                                              ; preds = %934
  %949 = sub i252 %943, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %951

950:                                              ; preds = %934
  br label %951

951:                                              ; preds = %948, %950
  %952 = phi i252 [ %943, %950 ], [ %949, %948 ]
  br label %953

953:                                              ; preds = %951
  %954 = add i64 %115, 2
  %955 = add i64 %115, 3
  %956 = select i1 %946, i64 %954, i64 %955
  %957 = trunc i252 %952 to i8
  br i1 %946, label %958, label %1483

958:                                              ; preds = %953
  %959 = phi { ptr, i32, i32, i32 } [ %941, %953 ]
  %960 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %959, 0
  %961 = insertvalue { i6, i8 } { i6 23, i8 undef }, i8 %957, 1
  store { i6, i8 } %961, ptr %42, align 1
  %962 = load { i16, [6 x i8] }, ptr %42, align 2
  %963 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %962, 1
  store { i1, { i16, [6 x i8] } } %963, ptr %43, align 2
  %964 = load { i16, [8 x i8] }, ptr %43, align 2
  %965 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %956, 0
  %966 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %965, { { ptr, i32, i32, i32 } } %960, 1
  %967 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %966, { i16, [8 x i8] } %964, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %967

968:                                              ; preds = %117
  %969 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %969)
  %970 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %971 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %972 = sub i32 %971, %970
  %973 = icmp uge i32 %972, 1
  br i1 %973, label %974, label %1483

974:                                              ; preds = %968
  %975 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %976 = load ptr, ptr %975, align 8
  %977 = zext i32 %970 to i64
  %978 = mul i64 %977, 32
  %979 = getelementptr inbounds i8, ptr %976, i64 %978
  %980 = add i32 %970, 1
  %981 = insertvalue { ptr, i32, i32, i32 } %109, i32 %980, 1
  %982 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %982, ptr %979, i64 32, i1 false)
  %983 = load i252, ptr %982, align 16
  call void @free(ptr %982)
  %984 = icmp sge i252 %983, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %985 = icmp slt i252 %983, 128
  %986 = and i1 %984, %985
  %987 = icmp slt i252 %983, 0
  br i1 %987, label %988, label %990

988:                                              ; preds = %974
  %989 = sub i252 %983, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %991

990:                                              ; preds = %974
  br label %991

991:                                              ; preds = %988, %990
  %992 = phi i252 [ %983, %990 ], [ %989, %988 ]
  br label %993

993:                                              ; preds = %991
  %994 = add i64 %115, 2
  %995 = add i64 %115, 3
  %996 = select i1 %986, i64 %994, i64 %995
  %997 = trunc i252 %992 to i8
  br i1 %986, label %998, label %1483

998:                                              ; preds = %993
  %999 = phi { ptr, i32, i32, i32 } [ %981, %993 ]
  %1000 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %999, 0
  %1001 = insertvalue { i6, i8 } { i6 24, i8 undef }, i8 %997, 1
  store { i6, i8 } %1001, ptr %40, align 1
  %1002 = load { i16, [6 x i8] }, ptr %40, align 2
  %1003 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1002, 1
  store { i1, { i16, [6 x i8] } } %1003, ptr %41, align 2
  %1004 = load { i16, [8 x i8] }, ptr %41, align 2
  %1005 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %996, 0
  %1006 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1005, { { ptr, i32, i32, i32 } } %1000, 1
  %1007 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1006, { i16, [8 x i8] } %1004, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1007

1008:                                             ; preds = %117
  %1009 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1009)
  %1010 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1011 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1012 = sub i32 %1011, %1010
  %1013 = icmp uge i32 %1012, 1
  br i1 %1013, label %1014, label %1483

1014:                                             ; preds = %1008
  %1015 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1016 = load ptr, ptr %1015, align 8
  %1017 = zext i32 %1010 to i64
  %1018 = mul i64 %1017, 32
  %1019 = getelementptr inbounds i8, ptr %1016, i64 %1018
  %1020 = add i32 %1010, 1
  %1021 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1020, 1
  %1022 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1022, ptr %1019, i64 32, i1 false)
  %1023 = load i252, ptr %1022, align 16
  call void @free(ptr %1022)
  %1024 = icmp sge i252 %1023, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %1025 = icmp slt i252 %1023, 128
  %1026 = and i1 %1024, %1025
  %1027 = icmp slt i252 %1023, 0
  br i1 %1027, label %1028, label %1030

1028:                                             ; preds = %1014
  %1029 = sub i252 %1023, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %1031

1030:                                             ; preds = %1014
  br label %1031

1031:                                             ; preds = %1028, %1030
  %1032 = phi i252 [ %1023, %1030 ], [ %1029, %1028 ]
  br label %1033

1033:                                             ; preds = %1031
  %1034 = add i64 %115, 2
  %1035 = add i64 %115, 3
  %1036 = select i1 %1026, i64 %1034, i64 %1035
  %1037 = trunc i252 %1032 to i8
  br i1 %1026, label %1038, label %1483

1038:                                             ; preds = %1033
  %1039 = phi { ptr, i32, i32, i32 } [ %1021, %1033 ]
  %1040 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1039, 0
  %1041 = insertvalue { i6, i8 } { i6 25, i8 undef }, i8 %1037, 1
  store { i6, i8 } %1041, ptr %38, align 1
  %1042 = load { i16, [6 x i8] }, ptr %38, align 2
  %1043 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1042, 1
  store { i1, { i16, [6 x i8] } } %1043, ptr %39, align 2
  %1044 = load { i16, [8 x i8] }, ptr %39, align 2
  %1045 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1036, 0
  %1046 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1045, { { ptr, i32, i32, i32 } } %1040, 1
  %1047 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1046, { i16, [8 x i8] } %1044, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1047

1048:                                             ; preds = %117
  %1049 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1049)
  %1050 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1051 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1052 = sub i32 %1051, %1050
  %1053 = icmp uge i32 %1052, 1
  br i1 %1053, label %1054, label %1483

1054:                                             ; preds = %1048
  %1055 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1056 = load ptr, ptr %1055, align 8
  %1057 = zext i32 %1050 to i64
  %1058 = mul i64 %1057, 32
  %1059 = getelementptr inbounds i8, ptr %1056, i64 %1058
  %1060 = add i32 %1050, 1
  %1061 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1060, 1
  %1062 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1062, ptr %1059, i64 32, i1 false)
  %1063 = load i252, ptr %1062, align 16
  call void @free(ptr %1062)
  %1064 = icmp sge i252 %1063, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %1065 = icmp slt i252 %1063, 32768
  %1066 = and i1 %1064, %1065
  %1067 = icmp slt i252 %1063, 0
  br i1 %1067, label %1068, label %1070

1068:                                             ; preds = %1054
  %1069 = sub i252 %1063, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %1071

1070:                                             ; preds = %1054
  br label %1071

1071:                                             ; preds = %1068, %1070
  %1072 = phi i252 [ %1063, %1070 ], [ %1069, %1068 ]
  br label %1073

1073:                                             ; preds = %1071
  %1074 = add i64 %115, 2
  %1075 = add i64 %115, 3
  %1076 = select i1 %1066, i64 %1074, i64 %1075
  %1077 = trunc i252 %1072 to i16
  br i1 %1066, label %1078, label %1483

1078:                                             ; preds = %1073
  %1079 = phi { ptr, i32, i32, i32 } [ %1061, %1073 ]
  %1080 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1079, 0
  %1081 = insertvalue { i6, i16 } { i6 26, i16 undef }, i16 %1077, 1
  store { i6, i16 } %1081, ptr %36, align 2
  %1082 = load { i16, [6 x i8] }, ptr %36, align 2
  %1083 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1082, 1
  store { i1, { i16, [6 x i8] } } %1083, ptr %37, align 2
  %1084 = load { i16, [8 x i8] }, ptr %37, align 2
  %1085 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1076, 0
  %1086 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1085, { { ptr, i32, i32, i32 } } %1080, 1
  %1087 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1086, { i16, [8 x i8] } %1084, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1087

1088:                                             ; preds = %117
  %1089 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1089)
  %1090 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1091 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1092 = sub i32 %1091, %1090
  %1093 = icmp uge i32 %1092, 1
  br i1 %1093, label %1094, label %1483

1094:                                             ; preds = %1088
  %1095 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1096 = load ptr, ptr %1095, align 8
  %1097 = zext i32 %1090 to i64
  %1098 = mul i64 %1097, 32
  %1099 = getelementptr inbounds i8, ptr %1096, i64 %1098
  %1100 = add i32 %1090, 1
  %1101 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1100, 1
  %1102 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1102, ptr %1099, i64 32, i1 false)
  %1103 = load i252, ptr %1102, align 16
  call void @free(ptr %1102)
  %1104 = icmp sge i252 %1103, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %1105 = icmp slt i252 %1103, 32768
  %1106 = and i1 %1104, %1105
  %1107 = icmp slt i252 %1103, 0
  br i1 %1107, label %1108, label %1110

1108:                                             ; preds = %1094
  %1109 = sub i252 %1103, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %1111

1110:                                             ; preds = %1094
  br label %1111

1111:                                             ; preds = %1108, %1110
  %1112 = phi i252 [ %1103, %1110 ], [ %1109, %1108 ]
  br label %1113

1113:                                             ; preds = %1111
  %1114 = add i64 %115, 2
  %1115 = add i64 %115, 3
  %1116 = select i1 %1106, i64 %1114, i64 %1115
  %1117 = trunc i252 %1112 to i16
  br i1 %1106, label %1118, label %1483

1118:                                             ; preds = %1113
  %1119 = phi { ptr, i32, i32, i32 } [ %1101, %1113 ]
  %1120 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1119, 0
  %1121 = insertvalue { i6, i16 } { i6 27, i16 undef }, i16 %1117, 1
  store { i6, i16 } %1121, ptr %34, align 2
  %1122 = load { i16, [6 x i8] }, ptr %34, align 2
  %1123 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1122, 1
  store { i1, { i16, [6 x i8] } } %1123, ptr %35, align 2
  %1124 = load { i16, [8 x i8] }, ptr %35, align 2
  %1125 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1116, 0
  %1126 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1125, { { ptr, i32, i32, i32 } } %1120, 1
  %1127 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1126, { i16, [8 x i8] } %1124, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1127

1128:                                             ; preds = %117
  %1129 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1129)
  %1130 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1131 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1132 = sub i32 %1131, %1130
  %1133 = icmp uge i32 %1132, 1
  br i1 %1133, label %1134, label %1483

1134:                                             ; preds = %1128
  %1135 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1136 = load ptr, ptr %1135, align 8
  %1137 = zext i32 %1130 to i64
  %1138 = mul i64 %1137, 32
  %1139 = getelementptr inbounds i8, ptr %1136, i64 %1138
  %1140 = add i32 %1130, 1
  %1141 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1140, 1
  %1142 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1142, ptr %1139, i64 32, i1 false)
  %1143 = load i252, ptr %1142, align 16
  call void @free(ptr %1142)
  %1144 = icmp sge i252 %1143, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %1145 = icmp slt i252 %1143, 32768
  %1146 = and i1 %1144, %1145
  %1147 = icmp slt i252 %1143, 0
  br i1 %1147, label %1148, label %1150

1148:                                             ; preds = %1134
  %1149 = sub i252 %1143, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %1151

1150:                                             ; preds = %1134
  br label %1151

1151:                                             ; preds = %1148, %1150
  %1152 = phi i252 [ %1143, %1150 ], [ %1149, %1148 ]
  br label %1153

1153:                                             ; preds = %1151
  %1154 = add i64 %115, 2
  %1155 = add i64 %115, 3
  %1156 = select i1 %1146, i64 %1154, i64 %1155
  %1157 = trunc i252 %1152 to i16
  br i1 %1146, label %1158, label %1483

1158:                                             ; preds = %1153
  %1159 = phi { ptr, i32, i32, i32 } [ %1141, %1153 ]
  %1160 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1159, 0
  %1161 = insertvalue { i6, i16 } { i6 28, i16 undef }, i16 %1157, 1
  store { i6, i16 } %1161, ptr %32, align 2
  %1162 = load { i16, [6 x i8] }, ptr %32, align 2
  %1163 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1162, 1
  store { i1, { i16, [6 x i8] } } %1163, ptr %33, align 2
  %1164 = load { i16, [8 x i8] }, ptr %33, align 2
  %1165 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1156, 0
  %1166 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1165, { { ptr, i32, i32, i32 } } %1160, 1
  %1167 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1166, { i16, [8 x i8] } %1164, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1167

1168:                                             ; preds = %117
  %1169 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %1169)
  %1170 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f132"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %1171 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %1170, 0
  %1172 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %1170, 1
  %1173 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %1170, 2
  store { i8, [4 x i8] } %1173, ptr %29, align 1
  %1174 = load i1, ptr %29, align 1
  switch i1 %1174, label %1175 [
    i1 false, label %1177
    i1 true, label %1244
  ]

1175:                                             ; preds = %1168
  br i1 false, label %1176, label %1495

1176:                                             ; preds = %1175
  unreachable

1177:                                             ; preds = %1168
  %1178 = load { i1, { i8, i8, i8, i8 } }, ptr %29, align 1
  %1179 = extractvalue { i1, { i8, i8, i8, i8 } } %1178, 1
  %1180 = insertvalue { i6, { i8, i8, i8, i8 } } { i6 29, { i8, i8, i8, i8 } undef }, { i8, i8, i8, i8 } %1179, 1
  store { i6, { i8, i8, i8, i8 } } %1180, ptr %30, align 1
  %1181 = load { i16, [6 x i8] }, ptr %30, align 2
  %1182 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1181, 1
  store { i1, { i16, [6 x i8] } } %1182, ptr %31, align 2
  %1183 = load { i16, [8 x i8] }, ptr %31, align 2
  %1184 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1171, 0
  %1185 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1184, { { ptr, i32, i32, i32 } } %1172, 1
  %1186 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1185, { i16, [8 x i8] } %1183, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1186

1187:                                             ; preds = %117
  %1188 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %1188)
  %1189 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f133"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %1190 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %1189, 0
  %1191 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %1189, 1
  %1192 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %1189, 2
  store { i8, [4 x i8] } %1192, ptr %26, align 1
  %1193 = load i1, ptr %26, align 1
  switch i1 %1193, label %1194 [
    i1 false, label %1196
    i1 true, label %1244
  ]

1194:                                             ; preds = %1187
  br i1 false, label %1195, label %1496

1195:                                             ; preds = %1194
  unreachable

1196:                                             ; preds = %1187
  %1197 = load { i1, { i8, i8, i8, i8 } }, ptr %26, align 1
  %1198 = extractvalue { i1, { i8, i8, i8, i8 } } %1197, 1
  %1199 = insertvalue { i6, { i8, i8, i8, i8 } } { i6 30, { i8, i8, i8, i8 } undef }, { i8, i8, i8, i8 } %1198, 1
  store { i6, { i8, i8, i8, i8 } } %1199, ptr %27, align 1
  %1200 = load { i16, [6 x i8] }, ptr %27, align 2
  %1201 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1200, 1
  store { i1, { i16, [6 x i8] } } %1201, ptr %28, align 2
  %1202 = load { i16, [8 x i8] }, ptr %28, align 2
  %1203 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1190, 0
  %1204 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1203, { { ptr, i32, i32, i32 } } %1191, 1
  %1205 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1204, { i16, [8 x i8] } %1202, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1205

1206:                                             ; preds = %117
  %1207 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %1207)
  %1208 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } @"impl$f134"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %1209 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %1208, 0
  %1210 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %1208, 1
  %1211 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %1208, 2
  store { i16, [6 x i8] } %1211, ptr %23, align 2
  %1212 = load i1, ptr %23, align 1
  switch i1 %1212, label %1213 [
    i1 false, label %1215
    i1 true, label %1244
  ]

1213:                                             ; preds = %1206
  br i1 false, label %1214, label %1497

1214:                                             ; preds = %1213
  unreachable

1215:                                             ; preds = %1206
  %1216 = load { i1, { i16, i16, i16 } }, ptr %23, align 2
  %1217 = extractvalue { i1, { i16, i16, i16 } } %1216, 1
  %1218 = insertvalue { i6, { i16, i16, i16 } } { i6 31, { i16, i16, i16 } undef }, { i16, i16, i16 } %1217, 1
  store { i6, { i16, i16, i16 } } %1218, ptr %24, align 2
  %1219 = load { i16, [6 x i8] }, ptr %24, align 2
  %1220 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1219, 1
  store { i1, { i16, [6 x i8] } } %1220, ptr %25, align 2
  %1221 = load { i16, [8 x i8] }, ptr %25, align 2
  %1222 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1209, 0
  %1223 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1222, { { ptr, i32, i32, i32 } } %1210, 1
  %1224 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1223, { i16, [8 x i8] } %1221, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1224

1225:                                             ; preds = %117
  %1226 = phi { ptr, i32, i32, i32 } [ %109, %117 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %1226)
  %1227 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } @"impl$f135"(i64 %115, { { ptr, i32, i32, i32 } } %111)
  %1228 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %1227, 0
  %1229 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %1227, 1
  %1230 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %1227, 2
  store { i8, [3 x i8] } %1230, ptr %19, align 1
  %1231 = load i1, ptr %19, align 1
  switch i1 %1231, label %1232 [
    i1 false, label %1234
    i1 true, label %1244
  ]

1232:                                             ; preds = %1225
  br i1 false, label %1233, label %1498

1233:                                             ; preds = %1232
  unreachable

1234:                                             ; preds = %1225
  %1235 = load { i1, { i8, i8, { i2, [0 x i8] } } }, ptr %19, align 1
  %1236 = extractvalue { i1, { i8, i8, { i2, [0 x i8] } } } %1235, 1
  %1237 = insertvalue { i6, { i8, i8, { i2, [0 x i8] } } } { i6 -32, { i8, i8, { i2, [0 x i8] } } undef }, { i8, i8, { i2, [0 x i8] } } %1236, 1
  store { i6, { i8, i8, { i2, [0 x i8] } } } %1237, ptr %21, align 1
  %1238 = load { i16, [6 x i8] }, ptr %21, align 2
  %1239 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1238, 1
  store { i1, { i16, [6 x i8] } } %1239, ptr %22, align 2
  %1240 = load { i16, [8 x i8] }, ptr %22, align 2
  %1241 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1228, 0
  %1242 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1241, { { ptr, i32, i32, i32 } } %1229, 1
  %1243 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1242, { i16, [8 x i8] } %1240, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1243

1244:                                             ; preds = %671, %690, %709, %1168, %1187, %1206, %1225
  %1245 = phi i64 [ %1228, %1225 ], [ %1209, %1206 ], [ %1190, %1187 ], [ %1171, %1168 ], [ %712, %709 ], [ %693, %690 ], [ %674, %671 ]
  %1246 = phi { { ptr, i32, i32, i32 } } [ %1229, %1225 ], [ %1210, %1206 ], [ %1191, %1187 ], [ %1172, %1168 ], [ %713, %709 ], [ %694, %690 ], [ %675, %671 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %20, align 1
  %1247 = load { i16, [8 x i8] }, ptr %20, align 2
  %1248 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1245, 0
  %1249 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1248, { { ptr, i32, i32, i32 } } %1246, 1
  %1250 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1249, { i16, [8 x i8] } %1247, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1250

1251:                                             ; preds = %117
  %1252 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1252)
  %1253 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1254 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1255 = sub i32 %1254, %1253
  %1256 = icmp uge i32 %1255, 1
  br i1 %1256, label %1257, label %1483

1257:                                             ; preds = %1251
  %1258 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1259 = load ptr, ptr %1258, align 8
  %1260 = zext i32 %1253 to i64
  %1261 = mul i64 %1260, 32
  %1262 = getelementptr inbounds i8, ptr %1259, i64 %1261
  %1263 = add i32 %1253, 1
  %1264 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1263, 1
  %1265 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1265, ptr %1262, i64 32, i1 false)
  %1266 = load i252, ptr %1265, align 16
  call void @free(ptr %1265)
  %1267 = icmp ult i252 %1266, 256
  %1268 = add i64 %115, 2
  %1269 = add i64 %115, 3
  %1270 = select i1 %1267, i64 %1268, i64 %1269
  %1271 = trunc i252 %1266 to i8
  br i1 %1267, label %1272, label %1483

1272:                                             ; preds = %1257
  %1273 = phi { ptr, i32, i32, i32 } [ %1264, %1257 ]
  %1274 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1273, 0
  %1275 = insertvalue { i6, i8 } { i6 -31, i8 undef }, i8 %1271, 1
  store { i6, i8 } %1275, ptr %17, align 1
  %1276 = load { i16, [6 x i8] }, ptr %17, align 2
  %1277 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1276, 1
  store { i1, { i16, [6 x i8] } } %1277, ptr %18, align 2
  %1278 = load { i16, [8 x i8] }, ptr %18, align 2
  %1279 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1270, 0
  %1280 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1279, { { ptr, i32, i32, i32 } } %1274, 1
  %1281 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1280, { i16, [8 x i8] } %1278, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1281

1282:                                             ; preds = %117
  %1283 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1283)
  %1284 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1285 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1286 = sub i32 %1285, %1284
  %1287 = icmp uge i32 %1286, 1
  br i1 %1287, label %1288, label %1483

1288:                                             ; preds = %1282
  %1289 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1290 = load ptr, ptr %1289, align 8
  %1291 = zext i32 %1284 to i64
  %1292 = mul i64 %1291, 32
  %1293 = getelementptr inbounds i8, ptr %1290, i64 %1292
  %1294 = add i32 %1284, 1
  %1295 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1294, 1
  %1296 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1296, ptr %1293, i64 32, i1 false)
  %1297 = load i252, ptr %1296, align 16
  call void @free(ptr %1296)
  %1298 = icmp ult i252 %1297, 256
  %1299 = add i64 %115, 2
  %1300 = add i64 %115, 3
  %1301 = select i1 %1298, i64 %1299, i64 %1300
  %1302 = trunc i252 %1297 to i8
  br i1 %1298, label %1303, label %1483

1303:                                             ; preds = %1288
  %1304 = phi { ptr, i32, i32, i32 } [ %1295, %1288 ]
  %1305 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1304, 0
  %1306 = insertvalue { i6, i8 } { i6 -30, i8 undef }, i8 %1302, 1
  store { i6, i8 } %1306, ptr %15, align 1
  %1307 = load { i16, [6 x i8] }, ptr %15, align 2
  %1308 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1307, 1
  store { i1, { i16, [6 x i8] } } %1308, ptr %16, align 2
  %1309 = load { i16, [8 x i8] }, ptr %16, align 2
  %1310 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1301, 0
  %1311 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1310, { { ptr, i32, i32, i32 } } %1305, 1
  %1312 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1311, { i16, [8 x i8] } %1309, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1312

1313:                                             ; preds = %117
  %1314 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1314)
  %1315 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1316 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1317 = sub i32 %1316, %1315
  %1318 = icmp uge i32 %1317, 1
  br i1 %1318, label %1319, label %1483

1319:                                             ; preds = %1313
  %1320 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1321 = load ptr, ptr %1320, align 8
  %1322 = zext i32 %1315 to i64
  %1323 = mul i64 %1322, 32
  %1324 = getelementptr inbounds i8, ptr %1321, i64 %1323
  %1325 = add i32 %1315, 1
  %1326 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1325, 1
  %1327 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1327, ptr %1324, i64 32, i1 false)
  %1328 = load i252, ptr %1327, align 16
  call void @free(ptr %1327)
  %1329 = icmp ult i252 %1328, 256
  %1330 = add i64 %115, 2
  %1331 = add i64 %115, 3
  %1332 = select i1 %1329, i64 %1330, i64 %1331
  %1333 = trunc i252 %1328 to i8
  br i1 %1329, label %1334, label %1483

1334:                                             ; preds = %1319
  %1335 = phi { ptr, i32, i32, i32 } [ %1326, %1319 ]
  %1336 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1335, 0
  %1337 = insertvalue { i6, i8 } { i6 -29, i8 undef }, i8 %1333, 1
  store { i6, i8 } %1337, ptr %13, align 1
  %1338 = load { i16, [6 x i8] }, ptr %13, align 2
  %1339 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1338, 1
  store { i1, { i16, [6 x i8] } } %1339, ptr %14, align 2
  %1340 = load { i16, [8 x i8] }, ptr %14, align 2
  %1341 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1332, 0
  %1342 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1341, { { ptr, i32, i32, i32 } } %1336, 1
  %1343 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1342, { i16, [8 x i8] } %1340, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1343

1344:                                             ; preds = %117
  %1345 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1345)
  %1346 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1347 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1348 = sub i32 %1347, %1346
  %1349 = icmp uge i32 %1348, 1
  br i1 %1349, label %1350, label %1483

1350:                                             ; preds = %1344
  %1351 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1352 = load ptr, ptr %1351, align 8
  %1353 = zext i32 %1346 to i64
  %1354 = mul i64 %1353, 32
  %1355 = getelementptr inbounds i8, ptr %1352, i64 %1354
  %1356 = add i32 %1346, 1
  %1357 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1356, 1
  %1358 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1358, ptr %1355, i64 32, i1 false)
  %1359 = load i252, ptr %1358, align 16
  call void @free(ptr %1358)
  %1360 = icmp sge i252 %1359, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %1361 = icmp slt i252 %1359, 128
  %1362 = and i1 %1360, %1361
  %1363 = icmp slt i252 %1359, 0
  br i1 %1363, label %1364, label %1366

1364:                                             ; preds = %1350
  %1365 = sub i252 %1359, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %1367

1366:                                             ; preds = %1350
  br label %1367

1367:                                             ; preds = %1364, %1366
  %1368 = phi i252 [ %1359, %1366 ], [ %1365, %1364 ]
  br label %1369

1369:                                             ; preds = %1367
  %1370 = add i64 %115, 2
  %1371 = add i64 %115, 3
  %1372 = select i1 %1362, i64 %1370, i64 %1371
  %1373 = trunc i252 %1368 to i8
  br i1 %1362, label %1374, label %1483

1374:                                             ; preds = %1369
  %1375 = phi { ptr, i32, i32, i32 } [ %1357, %1369 ]
  %1376 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1375, 0
  %1377 = insertvalue { i6, i8 } { i6 -28, i8 undef }, i8 %1373, 1
  store { i6, i8 } %1377, ptr %11, align 1
  %1378 = load { i16, [6 x i8] }, ptr %11, align 2
  %1379 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1378, 1
  store { i1, { i16, [6 x i8] } } %1379, ptr %12, align 2
  %1380 = load { i16, [8 x i8] }, ptr %12, align 2
  %1381 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1372, 0
  %1382 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1381, { { ptr, i32, i32, i32 } } %1376, 1
  %1383 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1382, { i16, [8 x i8] } %1380, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1383

1384:                                             ; preds = %117
  %1385 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1385)
  %1386 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1387 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1388 = sub i32 %1387, %1386
  %1389 = icmp uge i32 %1388, 1
  br i1 %1389, label %1390, label %1483

1390:                                             ; preds = %1384
  %1391 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1392 = load ptr, ptr %1391, align 8
  %1393 = zext i32 %1386 to i64
  %1394 = mul i64 %1393, 32
  %1395 = getelementptr inbounds i8, ptr %1392, i64 %1394
  %1396 = add i32 %1386, 1
  %1397 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1396, 1
  %1398 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1398, ptr %1395, i64 32, i1 false)
  %1399 = load i252, ptr %1398, align 16
  call void @free(ptr %1398)
  %1400 = icmp ult i252 %1399, 256
  %1401 = add i64 %115, 2
  %1402 = add i64 %115, 3
  %1403 = select i1 %1400, i64 %1401, i64 %1402
  %1404 = trunc i252 %1399 to i8
  br i1 %1400, label %1405, label %1483

1405:                                             ; preds = %1390
  %1406 = phi { ptr, i32, i32, i32 } [ %1397, %1390 ]
  %1407 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1406, 0
  %1408 = insertvalue { i6, i8 } { i6 -27, i8 undef }, i8 %1404, 1
  store { i6, i8 } %1408, ptr %9, align 1
  %1409 = load { i16, [6 x i8] }, ptr %9, align 2
  %1410 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1409, 1
  store { i1, { i16, [6 x i8] } } %1410, ptr %10, align 2
  %1411 = load { i16, [8 x i8] }, ptr %10, align 2
  %1412 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1403, 0
  %1413 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1412, { { ptr, i32, i32, i32 } } %1407, 1
  %1414 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1413, { i16, [8 x i8] } %1411, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1414

1415:                                             ; preds = %117
  %1416 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1416)
  %1417 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1418 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1419 = sub i32 %1418, %1417
  %1420 = icmp uge i32 %1419, 1
  br i1 %1420, label %1421, label %1483

1421:                                             ; preds = %1415
  %1422 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1423 = load ptr, ptr %1422, align 8
  %1424 = zext i32 %1417 to i64
  %1425 = mul i64 %1424, 32
  %1426 = getelementptr inbounds i8, ptr %1423, i64 %1425
  %1427 = add i32 %1417, 1
  %1428 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1427, 1
  %1429 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1429, ptr %1426, i64 32, i1 false)
  %1430 = load i252, ptr %1429, align 16
  call void @free(ptr %1429)
  %1431 = icmp ult i252 %1430, 256
  %1432 = add i64 %115, 2
  %1433 = add i64 %115, 3
  %1434 = select i1 %1431, i64 %1432, i64 %1433
  %1435 = trunc i252 %1430 to i8
  br i1 %1431, label %1436, label %1483

1436:                                             ; preds = %1421
  %1437 = phi { ptr, i32, i32, i32 } [ %1428, %1421 ]
  %1438 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1437, 0
  %1439 = insertvalue { i6, i8 } { i6 -26, i8 undef }, i8 %1435, 1
  store { i6, i8 } %1439, ptr %7, align 1
  %1440 = load { i16, [6 x i8] }, ptr %7, align 2
  %1441 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1440, 1
  store { i1, { i16, [6 x i8] } } %1441, ptr %8, align 2
  %1442 = load { i16, [8 x i8] }, ptr %8, align 2
  %1443 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1434, 0
  %1444 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1443, { { ptr, i32, i32, i32 } } %1438, 1
  %1445 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1444, { i16, [8 x i8] } %1442, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1445

1446:                                             ; preds = %117
  %1447 = phi { { ptr, i32, i32, i32 } } [ %111, %117 ]
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %1447)
  %1448 = extractvalue { ptr, i32, i32, i32 } %109, 1
  %1449 = extractvalue { ptr, i32, i32, i32 } %109, 2
  %1450 = sub i32 %1449, %1448
  %1451 = icmp uge i32 %1450, 1
  br i1 %1451, label %1452, label %1483

1452:                                             ; preds = %1446
  %1453 = extractvalue { ptr, i32, i32, i32 } %109, 0
  %1454 = load ptr, ptr %1453, align 8
  %1455 = zext i32 %1448 to i64
  %1456 = mul i64 %1455, 32
  %1457 = getelementptr inbounds i8, ptr %1454, i64 %1456
  %1458 = add i32 %1448, 1
  %1459 = insertvalue { ptr, i32, i32, i32 } %109, i32 %1458, 1
  %1460 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %1460, ptr %1457, i64 32, i1 false)
  %1461 = load i252, ptr %1460, align 16
  call void @free(ptr %1460)
  %1462 = icmp ult i252 %1461, 256
  %1463 = add i64 %115, 2
  %1464 = add i64 %115, 3
  %1465 = select i1 %1462, i64 %1463, i64 %1464
  %1466 = trunc i252 %1461 to i8
  br i1 %1462, label %1467, label %1483

1467:                                             ; preds = %1452
  %1468 = phi { ptr, i32, i32, i32 } [ %1459, %1452 ]
  %1469 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1468, 0
  %1470 = insertvalue { i6, i8 } { i6 -25, i8 undef }, i8 %1466, 1
  store { i6, i8 } %1470, ptr %5, align 1
  %1471 = load { i16, [6 x i8] }, ptr %5, align 2
  %1472 = insertvalue { i1, { i16, [6 x i8] } } { i1 false, { i16, [6 x i8] } undef }, { i16, [6 x i8] } %1471, 1
  store { i1, { i16, [6 x i8] } } %1472, ptr %6, align 2
  %1473 = load { i16, [8 x i8] }, ptr %6, align 2
  %1474 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1465, 0
  %1475 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1474, { { ptr, i32, i32, i32 } } %1469, 1
  %1476 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1475, { i16, [8 x i8] } %1473, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1476

1477:                                             ; preds = %98
  %1478 = phi { ptr, i32, i32, i32 } [ %109, %98 ]
  call void @"drop$3"({ ptr, i32, i32, i32 } %1478)
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %4, align 1
  %1479 = load { i16, [8 x i8] }, ptr %4, align 2
  %1480 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %115, 0
  %1481 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1480, { { ptr, i32, i32, i32 } } %111, 1
  %1482 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1481, { i16, [8 x i8] } %1479, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1482

1483:                                             ; preds = %154, %129, %175, %169, %206, %200, %256, %231, %296, %271, %336, %311, %376, %351, %416, %391, %456, %431, %496, %471, %536, %511, %576, %551, %616, %591, %656, %631, %753, %728, %793, %768, %833, %808, %873, %848, %913, %888, %953, %928, %993, %968, %1033, %1008, %1073, %1048, %1113, %1088, %1153, %1128, %1257, %1251, %1288, %1282, %1319, %1313, %1369, %1344, %1390, %1384, %1421, %1415, %1452, %1446, %2
  %1484 = phi i64 [ %1465, %1452 ], [ %115, %1446 ], [ %1434, %1421 ], [ %115, %1415 ], [ %1403, %1390 ], [ %115, %1384 ], [ %1372, %1369 ], [ %115, %1344 ], [ %1332, %1319 ], [ %115, %1313 ], [ %1301, %1288 ], [ %115, %1282 ], [ %1270, %1257 ], [ %115, %1251 ], [ %1156, %1153 ], [ %115, %1128 ], [ %1116, %1113 ], [ %115, %1088 ], [ %1076, %1073 ], [ %115, %1048 ], [ %1036, %1033 ], [ %115, %1008 ], [ %996, %993 ], [ %115, %968 ], [ %956, %953 ], [ %115, %928 ], [ %916, %913 ], [ %115, %888 ], [ %876, %873 ], [ %115, %848 ], [ %836, %833 ], [ %115, %808 ], [ %796, %793 ], [ %115, %768 ], [ %756, %753 ], [ %115, %728 ], [ %659, %656 ], [ %115, %631 ], [ %619, %616 ], [ %115, %591 ], [ %579, %576 ], [ %115, %551 ], [ %539, %536 ], [ %115, %511 ], [ %499, %496 ], [ %115, %471 ], [ %459, %456 ], [ %115, %431 ], [ %419, %416 ], [ %115, %391 ], [ %379, %376 ], [ %115, %351 ], [ %339, %336 ], [ %115, %311 ], [ %299, %296 ], [ %115, %271 ], [ %259, %256 ], [ %115, %231 ], [ %219, %206 ], [ %115, %200 ], [ %188, %175 ], [ %115, %169 ], [ %157, %154 ], [ %115, %129 ], [ %0, %2 ]
  %1485 = phi { ptr, i32, i32, i32 } [ %1459, %1452 ], [ %109, %1446 ], [ %1428, %1421 ], [ %109, %1415 ], [ %1397, %1390 ], [ %109, %1384 ], [ %1357, %1369 ], [ %109, %1344 ], [ %1326, %1319 ], [ %109, %1313 ], [ %1295, %1288 ], [ %109, %1282 ], [ %1264, %1257 ], [ %109, %1251 ], [ %1141, %1153 ], [ %109, %1128 ], [ %1101, %1113 ], [ %109, %1088 ], [ %1061, %1073 ], [ %109, %1048 ], [ %1021, %1033 ], [ %109, %1008 ], [ %981, %993 ], [ %109, %968 ], [ %941, %953 ], [ %109, %928 ], [ %901, %913 ], [ %109, %888 ], [ %861, %873 ], [ %109, %848 ], [ %821, %833 ], [ %109, %808 ], [ %781, %793 ], [ %109, %768 ], [ %741, %753 ], [ %109, %728 ], [ %644, %656 ], [ %109, %631 ], [ %604, %616 ], [ %109, %591 ], [ %564, %576 ], [ %109, %551 ], [ %524, %536 ], [ %109, %511 ], [ %484, %496 ], [ %109, %471 ], [ %444, %456 ], [ %109, %431 ], [ %404, %416 ], [ %109, %391 ], [ %364, %376 ], [ %109, %351 ], [ %324, %336 ], [ %109, %311 ], [ %284, %296 ], [ %109, %271 ], [ %244, %256 ], [ %109, %231 ], [ %213, %206 ], [ %109, %200 ], [ %182, %175 ], [ %109, %169 ], [ %142, %154 ], [ %109, %129 ], [ %93, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %1486 = load { i16, [8 x i8] }, ptr %3, align 2
  %1487 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %1485, 0
  %1488 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %1484, 0
  %1489 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1488, { { ptr, i32, i32, i32 } } %1487, 1
  %1490 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1489, { i16, [8 x i8] } %1486, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %1490

1491:                                             ; preds = %119
  call void @puts(ptr @assert_msg_178)
  call void @abort()
  unreachable

1492:                                             ; preds = %678
  call void @puts(ptr @assert_msg_179)
  call void @abort()
  unreachable

1493:                                             ; preds = %697
  call void @puts(ptr @assert_msg_180)
  call void @abort()
  unreachable

1494:                                             ; preds = %716
  call void @puts(ptr @assert_msg_181)
  call void @abort()
  unreachable

1495:                                             ; preds = %1175
  call void @puts(ptr @assert_msg_182)
  call void @abort()
  unreachable

1496:                                             ; preds = %1194
  call void @puts(ptr @assert_msg_183)
  call void @abort()
  unreachable

1497:                                             ; preds = %1213
  call void @puts(ptr @assert_msg_184)
  call void @abort()
  unreachable

1498:                                             ; preds = %1232
  call void @puts(ptr @assert_msg_185)
  call void @abort()
  unreachable
}

define private { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } @f125(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } @"impl$f125"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %8, { i16, [8 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %9
}

define void @_mlir_ciface_f125(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } @f125(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i16, [8 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f126"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [48 x i8] }, i64 1, align 8
  %11 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %12

12:                                               ; preds = %83, %4
  %13 = phi i64 [ %17, %83 ], [ %0, %4 ]
  %14 = phi i64 [ %42, %83 ], [ %1, %4 ]
  %15 = phi { { ptr, i32, i32, i32 } } [ %94, %83 ], [ %2, %4 ]
  %16 = phi { ptr, i32, i32, i32 } [ %92, %83 ], [ %3, %4 ]
  %17 = add i64 %13, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 1570
  %22 = icmp uge i64 %14, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %14, i64 %21)
  br i1 %22, label %24, label %133

24:                                               ; preds = %12
  %25 = phi { { ptr, i32, i32, i32 } } [ %15, %12 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %112

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 32
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 32, i1 false)
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 0)
  %43 = load i248, ptr %39, align 16
  call void @free(ptr %39)
  %44 = extractvalue { ptr, i32, i32, i32 } %16, 3
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %60

46:                                               ; preds = %31
  %47 = shl i32 %44, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %44
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = call ptr @realloc(ptr null, i64 %53)
  store i32 1, ptr %54, align 4
  %55 = getelementptr inbounds i8, ptr %54, i32 4
  store i32 0, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %54, i32 16
  %57 = call ptr @realloc(ptr null, i64 8)
  store ptr %56, ptr %57, align 8
  %58 = insertvalue { ptr, i32, i32, i32 } %16, ptr %57, 0
  %59 = insertvalue { ptr, i32, i32, i32 } %58, i32 %50, 3
  br label %81

60:                                               ; preds = %31
  %61 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %62 = icmp ult i32 %61, %44
  br i1 %62, label %63, label %64

63:                                               ; preds = %60
  br label %78

64:                                               ; preds = %60
  %65 = shl i32 %44, 1
  %66 = call i32 @llvm.umin.i32(i32 %65, i32 1024)
  %67 = add i32 %66, %44
  %68 = call i32 @llvm.umax.i32(i32 %67, i32 8)
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = add i64 %70, 16
  %72 = extractvalue { ptr, i32, i32, i32 } %16, 0
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %73, i32 -16
  %75 = call ptr @realloc(ptr %74, i64 %71)
  %76 = getelementptr inbounds i8, ptr %75, i32 16
  store ptr %76, ptr %72, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } %16, i32 %68, 3
  br label %78

78:                                               ; preds = %63, %64
  %79 = phi { ptr, i32, i32, i32 } [ %77, %64 ], [ %16, %63 ]
  br label %80

80:                                               ; preds = %78
  br label %81

81:                                               ; preds = %46, %80
  %82 = phi { ptr, i32, i32, i32 } [ %79, %80 ], [ %59, %46 ]
  br label %83

83:                                               ; preds = %81
  %84 = extractvalue { ptr, i32, i32, i32 } %82, 0
  %85 = load ptr, ptr %84, align 8
  %86 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %87 = zext i32 %86 to i64
  %88 = mul i64 %87, 32
  %89 = getelementptr inbounds i8, ptr %85, i64 %88
  store i248 %43, ptr %89, align 16
  %90 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %91 = add i32 %90, 1
  %92 = insertvalue { ptr, i32, i32, i32 } %82, i32 %91, 2
  %93 = getelementptr inbounds i8, ptr %85, i32 -12
  store i32 %91, ptr %93, align 4
  %94 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %38, 0
  %95 = extractvalue { ptr, ptr, i64 } %8, 1
  %96 = load i64, ptr %95, align 8
  %97 = add i64 %96, 1
  %98 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %97, ptr %98, align 8
  br label %12

99:                                               ; preds = %99, %112, %133
  %100 = phi i64 [ %17, %133 ], [ %17, %112 ], [ %100, %99 ]
  %101 = phi i64 [ %14, %133 ], [ %118, %112 ], [ %101, %99 ]
  %102 = phi { i64, [48 x i8] } [ %138, %133 ], [ %123, %112 ], [ %102, %99 ]
  %103 = extractvalue { ptr, ptr, i64 } %8, 1
  %104 = load i64, ptr %103, align 8
  %105 = icmp eq i64 %104, 0
  %106 = sub i64 %104, 1
  %107 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %106, ptr %107, align 8
  br i1 %105, label %108, label %99

108:                                              ; preds = %99
  %109 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %100, 0
  %110 = insertvalue { i64, i64, { i64, [48 x i8] } } %109, i64 %101, 1
  %111 = insertvalue { i64, i64, { i64, [48 x i8] } } %110, { i64, [48 x i8] } %102, 2
  ret { i64, i64, { i64, [48 x i8] } } %111

112:                                              ; preds = %24
  %113 = phi i64 [ %23, %24 ]
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = load i64, ptr %115, align 8
  %117 = mul i64 %116, 2270
  %118 = call i64 @llvm.uadd.sat.i64(i64 %113, i64 %117)
  %119 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %26, 0
  %120 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %119, 0
  %121 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %120, { ptr, i32, i32, i32 } %16, 1
  %122 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %121, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %122, ptr %11, align 8
  %123 = load { i64, [48 x i8] }, ptr %11, align 8
  %124 = extractvalue { ptr, ptr, i64 } %8, 1
  %125 = load i64, ptr %124, align 8
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %125, 1
  %128 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %127, ptr %128, align 8
  br i1 %126, label %129, label %99

129:                                              ; preds = %112
  %130 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %17, 0
  %131 = insertvalue { i64, i64, { i64, [48 x i8] } } %130, i64 %118, 1
  %132 = insertvalue { i64, i64, { i64, [48 x i8] } } %131, { i64, [48 x i8] } %123, 2
  ret { i64, i64, { i64, [48 x i8] } } %132

133:                                              ; preds = %12
  %134 = phi { ptr, i32, i32, i32 } [ %16, %12 ]
  call void @"drop$42"({ ptr, i32, i32, i32 } %134)
  call void @"drop$44"({ { ptr, i32, i32, i32 } } %15)
  %135 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %136 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %135, 0
  %137 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %136, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %137, ptr %10, align 8
  %138 = load { i64, [48 x i8] }, ptr %10, align 8
  %139 = extractvalue { ptr, ptr, i64 } %8, 1
  %140 = load i64, ptr %139, align 8
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %140, 1
  %143 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %142, ptr %143, align 8
  br i1 %141, label %144, label %99

144:                                              ; preds = %133
  %145 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %17, 0
  %146 = insertvalue { i64, i64, { i64, [48 x i8] } } %145, i64 %14, 1
  %147 = insertvalue { i64, i64, { i64, [48 x i8] } } %146, { i64, [48 x i8] } %138, 2
  ret { i64, i64, { i64, [48 x i8] } } %147
}

define private { i64, i64, { i64, [48 x i8] } } @f126(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f126"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [48 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [48 x i8] } } %10, { i64, [48 x i8] } %8, 2
  ret { i64, i64, { i64, [48 x i8] } } %11
}

define void @_mlir_ciface_f126(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [48 x i8] } } @f126(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [48 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$40"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  call void @"drop$39"({ { ptr, i32, i32, i32 } } %2)
  %3 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  call void @"drop$37"({ ptr, i32, i32, i32 } %3)
  ret void
}

define private { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$40"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0) {
  %2 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 0
  %3 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$39"({ { ptr, i32, i32, i32 } } %2)
  %4 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 0
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, 1
  %6 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, { { ptr, i32, i32, i32 } } %4, 0
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 1
  %9 = call { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } @"dup$37"({ ptr, i32, i32, i32 } %8)
  %10 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 0
  %11 = extractvalue { { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %9, 1
  %12 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6, { ptr, i32, i32, i32 } %10, 1
  %13 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %7, { ptr, i32, i32, i32 } %11, 1
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %0, 2
  %15 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %12, {} %14, 2
  %16 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %13, {} %14, 2
  %17 = insertvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } undef, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %15, 0
  %18 = insertvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %17, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %16, 1
  ret { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %18
}

define private void @"drop$41"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %10 [
    i1 false, label %4
    i1 true, label %7
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  call void @"drop$40"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  ret void

7:                                                ; preds = %1
  %8 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %9 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %8, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %9)
  ret void

10:                                               ; preds = %1
  unreachable
}

define private { { i64, [48 x i8] }, { i64, [48 x i8] } } @"dup$41"({ i64, [48 x i8] } %0) {
  %2 = alloca { i64, [48 x i8] }, i64 1, align 8
  store { i64, [48 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %28 [
    i1 false, label %4
    i1 true, label %16
  ]

4:                                                ; preds = %1
  %5 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %2, align 8
  %6 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, 1
  %7 = call { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } @"dup$40"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %6)
  %8 = extractvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 0
  %9 = extractvalue { { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %7, 1
  %10 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %8, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %10, ptr %2, align 8
  %11 = load { i64, [48 x i8] }, ptr %2, align 8
  %12 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %5, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %9, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %12, ptr %2, align 8
  %13 = load { i64, [48 x i8] }, ptr %2, align 8
  %14 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %11, 0
  %15 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %14, { i64, [48 x i8] } %13, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %15

16:                                               ; preds = %1
  %17 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %18 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, 1
  %19 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %18)
  %20 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 0
  %21 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %19, 1
  %22 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %20, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %22, ptr %2, align 8
  %23 = load { i64, [48 x i8] }, ptr %2, align 8
  %24 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %17, { {}, { ptr, i32, i32, i32 } } %21, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %24, ptr %2, align 8
  %25 = load { i64, [48 x i8] }, ptr %2, align 8
  %26 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } undef, { i64, [48 x i8] } %23, 0
  %27 = insertvalue { { i64, [48 x i8] }, { i64, [48 x i8] } } %26, { i64, [48 x i8] } %25, 1
  ret { { i64, [48 x i8] }, { i64, [48 x i8] } } %27

28:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i128, [144 x i8] } } @"impl$f127"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2) {
  %4 = alloca { i64, [48 x i8] }, i64 1, align 8
  %5 = alloca { i128, [144 x i8] }, i64 1, align 16
  %6 = alloca { i64, [48 x i8] }, i64 1, align 8
  %7 = alloca { i128, [144 x i8] }, i64 1, align 16
  %8 = alloca { i64, [48 x i8] }, i64 1, align 8
  %9 = alloca { i128, [144 x i8] }, i64 1, align 16
  %10 = alloca { i128, [144 x i8] }, i64 1, align 16
  %11 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  %12 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %11, 0
  %13 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %11, 1
  %14 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13, 0
  %15 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13, 4
  %16 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %13, 5
  call void @"drop$38"({ ptr, i32, i32, i32 } %15)
  call void @"drop$38"({ ptr, i32, i32, i32 } %16)
  %17 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %14)
  %18 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %17, 0
  %19 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %17, 1
  %20 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %19, 0
  %21 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %20, 0
  %22 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f126"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %21, { ptr, i32, i32, i32 } zeroinitializer)
  %23 = extractvalue { i64, i64, { i64, [48 x i8] } } %22, 0
  %24 = extractvalue { i64, i64, { i64, [48 x i8] } } %22, 1
  %25 = extractvalue { i64, i64, { i64, [48 x i8] } } %22, 2
  store { i64, [48 x i8] } %25, ptr %4, align 8
  %26 = load i1, ptr %4, align 1
  switch i1 %26, label %27 [
    i1 false, label %29
    i1 true, label %44
  ]

27:                                               ; preds = %3
  br i1 false, label %28, label %139

28:                                               ; preds = %27
  unreachable

29:                                               ; preds = %3
  %30 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %4, align 8
  %31 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %30, 1
  %32 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12)
  %33 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %32, 0
  %34 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %32, 1
  %35 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %34, 0
  %36 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %34, 4
  %37 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %34, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %35)
  call void @"drop$38"({ ptr, i32, i32, i32 } %37)
  %38 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %36, 0
  %39 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f136"(i64 %23, i64 %24, { { ptr, i32, i32, i32 } } %38, { ptr, i32, i32, i32 } zeroinitializer)
  %40 = extractvalue { i64, i64, { i64, [48 x i8] } } %39, 0
  %41 = extractvalue { i64, i64, { i64, [48 x i8] } } %39, 1
  %42 = extractvalue { i64, i64, { i64, [48 x i8] } } %39, 2
  store { i64, [48 x i8] } %42, ptr %6, align 8
  %43 = load i1, ptr %6, align 1
  switch i1 %43, label %52 [
    i1 false, label %54
    i1 true, label %69
  ]

44:                                               ; preds = %3
  %45 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %4, align 8
  %46 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %45, 1
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %18)
  call void @"drop$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %12)
  %47 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %46, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %47, ptr %5, align 8
  %48 = load { i128, [144 x i8] }, ptr %5, align 16
  %49 = insertvalue { i64, i64, { i128, [144 x i8] } } undef, i64 %23, 0
  %50 = insertvalue { i64, i64, { i128, [144 x i8] } } %49, i64 %24, 1
  %51 = insertvalue { i64, i64, { i128, [144 x i8] } } %50, { i128, [144 x i8] } %48, 2
  ret { i64, i64, { i128, [144 x i8] } } %51

52:                                               ; preds = %29
  br i1 false, label %53, label %140

53:                                               ; preds = %52
  unreachable

54:                                               ; preds = %29
  %55 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %6, align 8
  %56 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %55, 1
  %57 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %33)
  %58 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %57, 0
  %59 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %57, 1
  %60 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 0
  %61 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 4
  %62 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %59, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %60)
  call void @"drop$38"({ ptr, i32, i32, i32 } %61)
  %63 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 0
  %64 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f136"(i64 %40, i64 %41, { { ptr, i32, i32, i32 } } %63, { ptr, i32, i32, i32 } zeroinitializer)
  %65 = extractvalue { i64, i64, { i64, [48 x i8] } } %64, 0
  %66 = extractvalue { i64, i64, { i64, [48 x i8] } } %64, 1
  %67 = extractvalue { i64, i64, { i64, [48 x i8] } } %64, 2
  store { i64, [48 x i8] } %67, ptr %8, align 8
  %68 = load i1, ptr %8, align 1
  switch i1 %68, label %77 [
    i1 false, label %79
    i1 true, label %131
  ]

69:                                               ; preds = %29
  %70 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %6, align 8
  %71 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %70, 1
  call void @"drop$45"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %31)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %18)
  call void @"drop$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %33)
  %72 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %71, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %72, ptr %7, align 8
  %73 = load { i128, [144 x i8] }, ptr %7, align 16
  %74 = insertvalue { i64, i64, { i128, [144 x i8] } } undef, i64 %40, 0
  %75 = insertvalue { i64, i64, { i128, [144 x i8] } } %74, i64 %41, 1
  %76 = insertvalue { i64, i64, { i128, [144 x i8] } } %75, { i128, [144 x i8] } %73, 2
  ret { i64, i64, { i128, [144 x i8] } } %76

77:                                               ; preds = %54
  br i1 false, label %78, label %141

78:                                               ; preds = %77
  unreachable

79:                                               ; preds = %54
  %80 = load { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } }, ptr %8, align 8
  %81 = extractvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %80, 1
  %82 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %83 = call ptr %82()
  %84 = call i64 @llvm.uadd.sat.i64(i64 %66, i64 0)
  %85 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %31, 0
  %86 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %31, 1
  call void @"drop$44"({ { ptr, i32, i32, i32 } } %85)
  %87 = call { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } @"dup$320"({ { ptr, i32, i32, i32 }, i252, i32 } %18)
  %88 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %87, 0
  %89 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, { { ptr, i32, i32, i32 }, i252, i32 } } %87, 1
  %90 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %89, 0
  %91 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %89, 1
  call void @"drop$43"({ ptr, i32, i32, i32 } %90)
  %92 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %88, 0
  %93 = extractvalue { { ptr, i32, i32, i32 }, i252, i32 } %88, 2
  call void @"drop$43"({ ptr, i32, i32, i32 } %92)
  %94 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %58)
  %95 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %94, 0
  %96 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %94, 1
  %97 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %96, 0
  %98 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %96, 1
  %99 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %96, 4
  %100 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %96, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %97)
  call void @"drop$38"({ ptr, i32, i32, i32 } %99)
  call void @"drop$38"({ ptr, i32, i32, i32 } %100)
  %101 = call { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } @"dup$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %95)
  %102 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %101, 0
  %103 = extractvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } }, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %101, 1
  %104 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 0
  %105 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 2
  %106 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 4
  %107 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %103, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %104)
  call void @"drop$38"({ ptr, i32, i32, i32 } %106)
  call void @"drop$38"({ ptr, i32, i32, i32 } %107)
  %108 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %102, 0
  %109 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %102, 3
  %110 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %102, 4
  %111 = extractvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %102, 5
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %108)
  call void @"drop$38"({ ptr, i32, i32, i32 } %110)
  call void @"drop$38"({ ptr, i32, i32, i32 } %111)
  %112 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %56, 0
  %113 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %56, 1
  call void @"drop$39"({ { ptr, i32, i32, i32 } } %112)
  %114 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %81, 0
  %115 = extractvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %81, 1
  call void @"drop$39"({ { ptr, i32, i32, i32 } } %114)
  %116 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } undef, { ptr, i32, i32, i32 } %86, 0
  %117 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %116, i252 %91, 1
  %118 = insertvalue { { ptr, i32, i32, i32 }, i252, i32 } %117, i32 %93, 2
  %119 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } undef, { { ptr, i32, i32, i32 }, i252, i32 } %118, 0
  %120 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %119, i16 %98, 1
  %121 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %120, i8 %105, 2
  %122 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %121, i32 %109, 3
  %123 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %122, { ptr, i32, i32, i32 } %113, 4
  %124 = insertvalue { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %123, { ptr, i32, i32, i32 } %115, 5
  %125 = insertvalue { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %124, 0
  %126 = insertvalue { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } { i1 false, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } undef }, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } %125, 1
  store { i1, { { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } } } %126, ptr %10, align 16
  %127 = load { i128, [144 x i8] }, ptr %10, align 16
  %128 = insertvalue { i64, i64, { i128, [144 x i8] } } undef, i64 %65, 0
  %129 = insertvalue { i64, i64, { i128, [144 x i8] } } %128, i64 %84, 1
  %130 = insertvalue { i64, i64, { i128, [144 x i8] } } %129, { i128, [144 x i8] } %127, 2
  ret { i64, i64, { i128, [144 x i8] } } %130

131:                                              ; preds = %54
  %132 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %133 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %132, 1
  call void @"drop$45"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %31)
  call void @"drop$320"({ { ptr, i32, i32, i32 }, i252, i32 } %18)
  call void @"drop$40"({ { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %56)
  call void @"drop$322"({ { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %58)
  %134 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %133, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %134, ptr %9, align 8
  %135 = load { i128, [144 x i8] }, ptr %9, align 16
  %136 = insertvalue { i64, i64, { i128, [144 x i8] } } undef, i64 %65, 0
  %137 = insertvalue { i64, i64, { i128, [144 x i8] } } %136, i64 %66, 1
  %138 = insertvalue { i64, i64, { i128, [144 x i8] } } %137, { i128, [144 x i8] } %135, 2
  ret { i64, i64, { i128, [144 x i8] } } %138

139:                                              ; preds = %27
  call void @puts(ptr @assert_msg_186)
  call void @abort()
  unreachable

140:                                              ; preds = %52
  call void @puts(ptr @assert_msg_187)
  call void @abort()
  unreachable

141:                                              ; preds = %77
  call void @puts(ptr @assert_msg_188)
  call void @abort()
  unreachable
}

define private { i64, i64, { i128, [144 x i8] } } @f127(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2) {
  %4 = call fastcc { i64, i64, { i128, [144 x i8] } } @"impl$f127"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %2)
  %5 = extractvalue { i64, i64, { i128, [144 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i128, [144 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i128, [144 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i128, [144 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i128, [144 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i128, [144 x i8] } } %9, { i128, [144 x i8] } %7, 2
  ret { i64, i64, { i128, [144 x i8] } } %10
}

define void @_mlir_ciface_f127(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3) {
  %5 = call { i64, i64, { i128, [144 x i8] } } @f127(i64 %1, i64 %2, { { { ptr, i32, i32, i32 }, i252, i32 }, i16, i8, i32, { ptr, i32, i32, i32 }, { ptr, i32, i32, i32 } } %3)
  store { i64, i64, { i128, [144 x i8] } } %5, ptr %0, align 16
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f128"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$7"({ { ptr, i32, i32, i32 } } %2)
  %6 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 0
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 1
  %8 = extractvalue { { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { ptr, i32, i32, i32 } %8, 1
  %10 = extractvalue { ptr, i32, i32, i32 } %8, 2
  %11 = sub i32 %10, %9
  call void @"drop$6"({ ptr, i32, i32, i32 } %8)
  %12 = zext i32 %11 to i252
  %13 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %29

15:                                               ; preds = %4
  %16 = shl i32 %13, 1
  %17 = call i32 @llvm.umin.i32(i32 %16, i32 1024)
  %18 = add i32 %17, %13
  %19 = call i32 @llvm.umax.i32(i32 %18, i32 8)
  %20 = zext i32 %19 to i64
  %21 = mul i64 %20, 32
  %22 = add i64 %21, 16
  %23 = call ptr @realloc(ptr null, i64 %22)
  store i32 1, ptr %23, align 4
  %24 = getelementptr inbounds i8, ptr %23, i32 4
  store i32 0, ptr %24, align 4
  %25 = getelementptr inbounds i8, ptr %23, i32 16
  %26 = call ptr @realloc(ptr null, i64 8)
  store ptr %25, ptr %26, align 8
  %27 = insertvalue { ptr, i32, i32, i32 } %3, ptr %26, 0
  %28 = insertvalue { ptr, i32, i32, i32 } %27, i32 %19, 3
  br label %50

29:                                               ; preds = %4
  %30 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %31 = icmp ult i32 %30, %13
  br i1 %31, label %32, label %33

32:                                               ; preds = %29
  br label %47

33:                                               ; preds = %29
  %34 = shl i32 %13, 1
  %35 = call i32 @llvm.umin.i32(i32 %34, i32 1024)
  %36 = add i32 %35, %13
  %37 = call i32 @llvm.umax.i32(i32 %36, i32 8)
  %38 = zext i32 %37 to i64
  %39 = mul i64 %38, 32
  %40 = add i64 %39, 16
  %41 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr inbounds i8, ptr %42, i32 -16
  %44 = call ptr @realloc(ptr %43, i64 %40)
  %45 = getelementptr inbounds i8, ptr %44, i32 16
  store ptr %45, ptr %41, align 8
  %46 = insertvalue { ptr, i32, i32, i32 } %3, i32 %37, 3
  br label %47

47:                                               ; preds = %32, %33
  %48 = phi { ptr, i32, i32, i32 } [ %46, %33 ], [ %3, %32 ]
  br label %49

49:                                               ; preds = %47
  br label %50

50:                                               ; preds = %15, %49
  %51 = phi { ptr, i32, i32, i32 } [ %48, %49 ], [ %28, %15 ]
  br label %52

52:                                               ; preds = %50
  %53 = extractvalue { ptr, i32, i32, i32 } %51, 0
  %54 = load ptr, ptr %53, align 8
  %55 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %56 = zext i32 %55 to i64
  %57 = mul i64 %56, 32
  %58 = getelementptr inbounds i8, ptr %54, i64 %57
  store i252 %12, ptr %58, align 16
  %59 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %60 = add i32 %59, 1
  %61 = insertvalue { ptr, i32, i32, i32 } %51, i32 %60, 2
  %62 = getelementptr inbounds i8, ptr %54, i32 -12
  store i32 %60, ptr %62, align 4
  %63 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f137"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %6, { ptr, i32, i32, i32 } %61)
  %64 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 0
  %65 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 1
  %66 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 2
  %67 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %64, 0
  %68 = insertvalue { i64, i64, { i64, [24 x i8] } } %67, i64 %65, 1
  %69 = insertvalue { i64, i64, { i64, [24 x i8] } } %68, { i64, [24 x i8] } %66, 2
  ret { i64, i64, { i64, [24 x i8] } } %69
}

define private { i64, i64, { i64, [24 x i8] } } @f128(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f128"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f128(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f128(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$36"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$36"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i8 } }, ptr %2, align 1
  %6 = extractvalue { i1, { i8 } } %5, 1
  %7 = insertvalue { i1, { i8 } } %5, { i8 } %6, 1
  store { i1, { i8 } } %7, ptr %2, align 1
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { i8 } } %5, { i8 } %6, 1
  store { i1, { i8 } } %9, ptr %2, align 1
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private void @"drop$33"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %8 [
    i1 false, label %4
    i1 true, label %5
  ]

4:                                                ; preds = %1
  ret void

5:                                                ; preds = %1
  %6 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %7 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %6, 1
  call void @"drop$32"({ {}, { ptr, i32, i32, i32 } } %7)
  ret void

8:                                                ; preds = %1
  unreachable
}

define private { { i64, [24 x i8] }, { i64, [24 x i8] } } @"dup$33"({ i64, [24 x i8] } %0) {
  %2 = alloca { i64, [24 x i8] }, i64 1, align 8
  store { i64, [24 x i8] } %0, ptr %2, align 8
  %3 = load i1, ptr %2, align 1
  switch i1 %3, label %25 [
    i1 false, label %4
    i1 true, label %13
  ]

4:                                                ; preds = %1
  %5 = load { i1, { i16 } }, ptr %2, align 2
  %6 = extractvalue { i1, { i16 } } %5, 1
  %7 = insertvalue { i1, { i16 } } %5, { i16 } %6, 1
  store { i1, { i16 } } %7, ptr %2, align 2
  %8 = load { i64, [24 x i8] }, ptr %2, align 8
  %9 = insertvalue { i1, { i16 } } %5, { i16 } %6, 1
  store { i1, { i16 } } %9, ptr %2, align 2
  %10 = load { i64, [24 x i8] }, ptr %2, align 8
  %11 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %8, 0
  %12 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %11, { i64, [24 x i8] } %10, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %12

13:                                               ; preds = %1
  %14 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %2, align 8
  %15 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, 1
  %16 = call { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } @"dup$32"({ {}, { ptr, i32, i32, i32 } } %15)
  %17 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 0
  %18 = extractvalue { { {}, { ptr, i32, i32, i32 } }, { {}, { ptr, i32, i32, i32 } } } %16, 1
  %19 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %17, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %19, ptr %2, align 8
  %20 = load { i64, [24 x i8] }, ptr %2, align 8
  %21 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } %14, { {}, { ptr, i32, i32, i32 } } %18, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %21, ptr %2, align 8
  %22 = load { i64, [24 x i8] }, ptr %2, align 8
  %23 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } undef, { i64, [24 x i8] } %20, 0
  %24 = insertvalue { { i64, [24 x i8] }, { i64, [24 x i8] } } %23, { i64, [24 x i8] } %22, 1
  ret { { i64, [24 x i8] }, { i64, [24 x i8] } } %24

25:                                               ; preds = %1
  unreachable
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f129"(i64 %0, i64 %1, i128 %2) {
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i64, [24 x i8] }, i64 1, align 8
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  %15 = alloca { i64, [24 x i8] }, i64 1, align 8
  %16 = alloca { i64, [24 x i8] }, i64 1, align 8
  %17 = alloca { i64, [24 x i8] }, i64 1, align 8
  %18 = alloca { i64, [24 x i8] }, i64 1, align 8
  %19 = alloca { i64, [24 x i8] }, i64 1, align 8
  %20 = alloca { i64, [24 x i8] }, i64 1, align 8
  %21 = alloca { i64, [24 x i8] }, i64 1, align 8
  %22 = alloca { i64, [24 x i8] }, i64 1, align 8
  %23 = alloca { i64, [24 x i8] }, i64 1, align 8
  %24 = alloca { i64, [24 x i8] }, i64 1, align 8
  %25 = alloca { i64, [24 x i8] }, i64 1, align 8
  %26 = alloca { i64, [24 x i8] }, i64 1, align 8
  %27 = add i64 %1, 5
  %28 = and i128 %2, 255
  %29 = icmp ult i128 %28, 256
  %30 = add i64 %0, 1
  %31 = trunc i128 %28 to i8
  br i1 %29, label %32, label %315

32:                                               ; preds = %3
  %33 = phi i64 [ %30, %3 ]
  %34 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f138"(i64 %33, i8 %31)
  %35 = extractvalue { i64, { i64, [24 x i8] } } %34, 0
  %36 = extractvalue { i64, { i64, [24 x i8] } } %34, 1
  store { i64, [24 x i8] } %36, ptr %5, align 8
  %37 = load i1, ptr %5, align 1
  switch i1 %37, label %38 [
    i1 false, label %40
    i1 true, label %49
  ]

38:                                               ; preds = %32
  br i1 false, label %39, label %323

39:                                               ; preds = %38
  unreachable

40:                                               ; preds = %32
  %41 = load { i1, { i8 } }, ptr %5, align 1
  %42 = extractvalue { i1, { i8 } } %41, 1
  %43 = udiv i128 %2, 256
  %44 = add i64 %1, 10
  %45 = and i128 %43, 255
  %46 = icmp ult i128 %45, 256
  %47 = add i64 %35, 5
  %48 = trunc i128 %45 to i8
  br i1 %46, label %57, label %307

49:                                               ; preds = %32
  %50 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %51 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %50, 1
  %52 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %51, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %52, ptr %6, align 8
  %53 = load { i64, [24 x i8] }, ptr %6, align 8
  %54 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %35, 0
  %55 = insertvalue { i64, i64, { i64, [24 x i8] } } %54, i64 %27, 1
  %56 = insertvalue { i64, i64, { i64, [24 x i8] } } %55, { i64, [24 x i8] } %53, 2
  ret { i64, i64, { i64, [24 x i8] } } %56

57:                                               ; preds = %40
  %58 = phi i64 [ %47, %40 ]
  %59 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f138"(i64 %58, i8 %48)
  %60 = extractvalue { i64, { i64, [24 x i8] } } %59, 0
  %61 = extractvalue { i64, { i64, [24 x i8] } } %59, 1
  store { i64, [24 x i8] } %61, ptr %8, align 8
  %62 = load i1, ptr %8, align 1
  switch i1 %62, label %63 [
    i1 false, label %65
    i1 true, label %74
  ]

63:                                               ; preds = %57
  br i1 false, label %64, label %324

64:                                               ; preds = %63
  unreachable

65:                                               ; preds = %57
  %66 = load { i1, { i8 } }, ptr %8, align 1
  %67 = extractvalue { i1, { i8 } } %66, 1
  %68 = udiv i128 %2, 65536
  %69 = add i64 %1, 15
  %70 = and i128 %68, 255
  %71 = icmp ult i128 %70, 256
  %72 = add i64 %60, 5
  %73 = trunc i128 %70 to i8
  br i1 %71, label %82, label %299

74:                                               ; preds = %57
  %75 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %8, align 8
  %76 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %75, 1
  %77 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %76, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %77, ptr %9, align 8
  %78 = load { i64, [24 x i8] }, ptr %9, align 8
  %79 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %60, 0
  %80 = insertvalue { i64, i64, { i64, [24 x i8] } } %79, i64 %44, 1
  %81 = insertvalue { i64, i64, { i64, [24 x i8] } } %80, { i64, [24 x i8] } %78, 2
  ret { i64, i64, { i64, [24 x i8] } } %81

82:                                               ; preds = %65
  %83 = phi i64 [ %72, %65 ]
  %84 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f138"(i64 %83, i8 %73)
  %85 = extractvalue { i64, { i64, [24 x i8] } } %84, 0
  %86 = extractvalue { i64, { i64, [24 x i8] } } %84, 1
  store { i64, [24 x i8] } %86, ptr %11, align 8
  %87 = load i1, ptr %11, align 1
  switch i1 %87, label %88 [
    i1 false, label %90
    i1 true, label %99
  ]

88:                                               ; preds = %82
  br i1 false, label %89, label %325

89:                                               ; preds = %88
  unreachable

90:                                               ; preds = %82
  %91 = load { i1, { i8 } }, ptr %11, align 1
  %92 = extractvalue { i1, { i8 } } %91, 1
  %93 = udiv i128 %2, 16777216
  %94 = add i64 %1, 20
  %95 = and i128 %93, 255
  %96 = icmp ult i128 %95, 256
  %97 = add i64 %85, 5
  %98 = trunc i128 %95 to i8
  br i1 %96, label %107, label %291

99:                                               ; preds = %82
  %100 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %11, align 8
  %101 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %100, 1
  %102 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %101, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %102, ptr %12, align 8
  %103 = load { i64, [24 x i8] }, ptr %12, align 8
  %104 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %85, 0
  %105 = insertvalue { i64, i64, { i64, [24 x i8] } } %104, i64 %69, 1
  %106 = insertvalue { i64, i64, { i64, [24 x i8] } } %105, { i64, [24 x i8] } %103, 2
  ret { i64, i64, { i64, [24 x i8] } } %106

107:                                              ; preds = %90
  %108 = phi i64 [ %97, %90 ]
  %109 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f138"(i64 %108, i8 %98)
  %110 = extractvalue { i64, { i64, [24 x i8] } } %109, 0
  %111 = extractvalue { i64, { i64, [24 x i8] } } %109, 1
  store { i64, [24 x i8] } %111, ptr %14, align 8
  %112 = load i1, ptr %14, align 1
  switch i1 %112, label %113 [
    i1 false, label %115
    i1 true, label %124
  ]

113:                                              ; preds = %107
  br i1 false, label %114, label %326

114:                                              ; preds = %113
  unreachable

115:                                              ; preds = %107
  %116 = load { i1, { i8 } }, ptr %14, align 1
  %117 = extractvalue { i1, { i8 } } %116, 1
  %118 = udiv i128 %2, 4294967296
  %119 = add i64 %1, 25
  %120 = and i128 %118, 255
  %121 = icmp ult i128 %120, 256
  %122 = add i64 %110, 5
  %123 = trunc i128 %120 to i8
  br i1 %121, label %132, label %281

124:                                              ; preds = %107
  %125 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %14, align 8
  %126 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %125, 1
  %127 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %126, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %127, ptr %15, align 8
  %128 = load { i64, [24 x i8] }, ptr %15, align 8
  %129 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %110, 0
  %130 = insertvalue { i64, i64, { i64, [24 x i8] } } %129, i64 %94, 1
  %131 = insertvalue { i64, i64, { i64, [24 x i8] } } %130, { i64, [24 x i8] } %128, 2
  ret { i64, i64, { i64, [24 x i8] } } %131

132:                                              ; preds = %115
  %133 = phi i128 [ %2, %115 ]
  %134 = udiv i128 %133, 1099511627776
  %135 = add i64 %1, 30
  %136 = and i128 %134, 255
  %137 = icmp ult i128 %136, 256
  %138 = add i64 %110, 10
  %139 = trunc i128 %136 to i8
  br i1 %137, label %140, label %281

140:                                              ; preds = %132
  %141 = phi i128 [ %133, %132 ]
  %142 = udiv i128 %141, 281474976710656
  %143 = add i64 %1, 35
  %144 = and i128 %142, 255
  %145 = icmp ult i128 %144, 256
  %146 = add i64 %110, 15
  %147 = trunc i128 %144 to i8
  br i1 %145, label %148, label %281

148:                                              ; preds = %140
  %149 = phi i128 [ %141, %140 ]
  %150 = udiv i128 %149, 72057594037927936
  %151 = add i64 %1, 40
  %152 = and i128 %150, 255
  %153 = icmp ult i128 %152, 256
  %154 = add i64 %110, 20
  %155 = trunc i128 %152 to i8
  br i1 %153, label %156, label %281

156:                                              ; preds = %148
  %157 = phi i128 [ %149, %148 ]
  %158 = udiv i128 %157, 18446744073709551616
  %159 = add i64 %1, 45
  %160 = and i128 %158, 65535
  %161 = icmp ult i128 %160, 65536
  %162 = add i64 %110, 25
  %163 = trunc i128 %160 to i16
  br i1 %161, label %164, label %273

164:                                              ; preds = %156
  %165 = phi i64 [ %162, %156 ]
  %166 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f139"(i64 %165, i16 %163)
  %167 = extractvalue { i64, { i64, [24 x i8] } } %166, 0
  %168 = extractvalue { i64, { i64, [24 x i8] } } %166, 1
  store { i64, [24 x i8] } %168, ptr %18, align 8
  %169 = load i1, ptr %18, align 1
  switch i1 %169, label %170 [
    i1 false, label %172
    i1 true, label %181
  ]

170:                                              ; preds = %164
  br i1 false, label %171, label %327

171:                                              ; preds = %170
  unreachable

172:                                              ; preds = %164
  %173 = load { i1, { i16 } }, ptr %18, align 2
  %174 = extractvalue { i1, { i16 } } %173, 1
  %175 = udiv i128 %157, 1208925819614629174706176
  %176 = add i64 %1, 50
  %177 = and i128 %175, 65535
  %178 = icmp ult i128 %177, 65536
  %179 = add i64 %167, 5
  %180 = trunc i128 %177 to i16
  br i1 %178, label %189, label %265

181:                                              ; preds = %164
  %182 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %18, align 8
  %183 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %182, 1
  %184 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %183, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %184, ptr %19, align 8
  %185 = load { i64, [24 x i8] }, ptr %19, align 8
  %186 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %167, 0
  %187 = insertvalue { i64, i64, { i64, [24 x i8] } } %186, i64 %159, 1
  %188 = insertvalue { i64, i64, { i64, [24 x i8] } } %187, { i64, [24 x i8] } %185, 2
  ret { i64, i64, { i64, [24 x i8] } } %188

189:                                              ; preds = %172
  %190 = phi i64 [ %179, %172 ]
  %191 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f139"(i64 %190, i16 %180)
  %192 = extractvalue { i64, { i64, [24 x i8] } } %191, 0
  %193 = extractvalue { i64, { i64, [24 x i8] } } %191, 1
  store { i64, [24 x i8] } %193, ptr %21, align 8
  %194 = load i1, ptr %21, align 1
  switch i1 %194, label %195 [
    i1 false, label %197
    i1 true, label %206
  ]

195:                                              ; preds = %189
  br i1 false, label %196, label %328

196:                                              ; preds = %195
  unreachable

197:                                              ; preds = %189
  %198 = load { i1, { i16 } }, ptr %21, align 2
  %199 = extractvalue { i1, { i16 } } %198, 1
  %200 = udiv i128 %157, 79228162514264337593543950336
  %201 = add i64 %1, 55
  %202 = and i128 %200, 65535
  %203 = icmp ult i128 %202, 65536
  %204 = add i64 %192, 5
  %205 = trunc i128 %202 to i16
  br i1 %203, label %214, label %257

206:                                              ; preds = %189
  %207 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %21, align 8
  %208 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %207, 1
  %209 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %208, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %209, ptr %22, align 8
  %210 = load { i64, [24 x i8] }, ptr %22, align 8
  %211 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %192, 0
  %212 = insertvalue { i64, i64, { i64, [24 x i8] } } %211, i64 %176, 1
  %213 = insertvalue { i64, i64, { i64, [24 x i8] } } %212, { i64, [24 x i8] } %210, 2
  ret { i64, i64, { i64, [24 x i8] } } %213

214:                                              ; preds = %197
  %215 = phi i64 [ %204, %197 ]
  %216 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f139"(i64 %215, i16 %205)
  %217 = extractvalue { i64, { i64, [24 x i8] } } %216, 0
  %218 = extractvalue { i64, { i64, [24 x i8] } } %216, 1
  store { i64, [24 x i8] } %218, ptr %24, align 8
  %219 = load i1, ptr %24, align 1
  switch i1 %219, label %220 [
    i1 false, label %222
    i1 true, label %249
  ]

220:                                              ; preds = %214
  br i1 false, label %221, label %329

221:                                              ; preds = %220
  unreachable

222:                                              ; preds = %214
  %223 = load { i1, { i16 } }, ptr %24, align 2
  %224 = extractvalue { i1, { i16 } } %223, 1
  %225 = extractvalue { i8 } %42, 0
  %226 = extractvalue { i8 } %67, 0
  %227 = extractvalue { i8 } %92, 0
  %228 = extractvalue { i8 } %117, 0
  %229 = extractvalue { i16 } %174, 0
  %230 = extractvalue { i16 } %199, 0
  %231 = extractvalue { i16 } %224, 0
  %232 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } undef, i8 %225, 0
  %233 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %232, i8 %226, 1
  %234 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %233, i8 %227, 2
  %235 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %234, i8 %228, 3
  %236 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %235, i8 %123, 4
  %237 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %236, i8 %139, 5
  %238 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %237, i8 %147, 6
  %239 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %238, i8 %155, 7
  %240 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %239, i16 %229, 8
  %241 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %240, i16 %230, 9
  %242 = insertvalue { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %241, i16 %231, 10
  %243 = insertvalue { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef, { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } %242, 0
  %244 = insertvalue { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } { i1 false, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } undef }, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } %243, 1
  store { i1, { { i8, i8, i8, i8, i8, i8, i8, i8, i16, i16, i16 } } } %244, ptr %26, align 2
  %245 = load { i64, [24 x i8] }, ptr %26, align 8
  %246 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %217, 0
  %247 = insertvalue { i64, i64, { i64, [24 x i8] } } %246, i64 %201, 1
  %248 = insertvalue { i64, i64, { i64, [24 x i8] } } %247, { i64, [24 x i8] } %245, 2
  ret { i64, i64, { i64, [24 x i8] } } %248

249:                                              ; preds = %214
  %250 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %24, align 8
  %251 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %250, 1
  %252 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %251, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %252, ptr %25, align 8
  %253 = load { i64, [24 x i8] }, ptr %25, align 8
  %254 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %217, 0
  %255 = insertvalue { i64, i64, { i64, [24 x i8] } } %254, i64 %201, 1
  %256 = insertvalue { i64, i64, { i64, [24 x i8] } } %255, { i64, [24 x i8] } %253, 2
  ret { i64, i64, { i64, [24 x i8] } } %256

257:                                              ; preds = %197
  %258 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %259 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %258, 0
  %260 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %259, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %260, ptr %23, align 8
  %261 = load { i64, [24 x i8] }, ptr %23, align 8
  %262 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %204, 0
  %263 = insertvalue { i64, i64, { i64, [24 x i8] } } %262, i64 %201, 1
  %264 = insertvalue { i64, i64, { i64, [24 x i8] } } %263, { i64, [24 x i8] } %261, 2
  ret { i64, i64, { i64, [24 x i8] } } %264

265:                                              ; preds = %172
  %266 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %267 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %266, 0
  %268 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %267, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %268, ptr %20, align 8
  %269 = load { i64, [24 x i8] }, ptr %20, align 8
  %270 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %179, 0
  %271 = insertvalue { i64, i64, { i64, [24 x i8] } } %270, i64 %176, 1
  %272 = insertvalue { i64, i64, { i64, [24 x i8] } } %271, { i64, [24 x i8] } %269, 2
  ret { i64, i64, { i64, [24 x i8] } } %272

273:                                              ; preds = %156
  %274 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %275 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %274, 0
  %276 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %275, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %276, ptr %17, align 8
  %277 = load { i64, [24 x i8] }, ptr %17, align 8
  %278 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %162, 0
  %279 = insertvalue { i64, i64, { i64, [24 x i8] } } %278, i64 %159, 1
  %280 = insertvalue { i64, i64, { i64, [24 x i8] } } %279, { i64, [24 x i8] } %277, 2
  ret { i64, i64, { i64, [24 x i8] } } %280

281:                                              ; preds = %148, %140, %132, %115
  %282 = phi i64 [ %154, %148 ], [ %146, %140 ], [ %138, %132 ], [ %122, %115 ]
  %283 = phi i64 [ %151, %148 ], [ %143, %140 ], [ %135, %132 ], [ %119, %115 ]
  %284 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %285 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %284, 0
  %286 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %285, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %286, ptr %16, align 8
  %287 = load { i64, [24 x i8] }, ptr %16, align 8
  %288 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %282, 0
  %289 = insertvalue { i64, i64, { i64, [24 x i8] } } %288, i64 %283, 1
  %290 = insertvalue { i64, i64, { i64, [24 x i8] } } %289, { i64, [24 x i8] } %287, 2
  ret { i64, i64, { i64, [24 x i8] } } %290

291:                                              ; preds = %90
  %292 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %293 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %292, 0
  %294 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %293, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %294, ptr %13, align 8
  %295 = load { i64, [24 x i8] }, ptr %13, align 8
  %296 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %97, 0
  %297 = insertvalue { i64, i64, { i64, [24 x i8] } } %296, i64 %94, 1
  %298 = insertvalue { i64, i64, { i64, [24 x i8] } } %297, { i64, [24 x i8] } %295, 2
  ret { i64, i64, { i64, [24 x i8] } } %298

299:                                              ; preds = %65
  %300 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %301 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %300, 0
  %302 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %301, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %302, ptr %10, align 8
  %303 = load { i64, [24 x i8] }, ptr %10, align 8
  %304 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %72, 0
  %305 = insertvalue { i64, i64, { i64, [24 x i8] } } %304, i64 %69, 1
  %306 = insertvalue { i64, i64, { i64, [24 x i8] } } %305, { i64, [24 x i8] } %303, 2
  ret { i64, i64, { i64, [24 x i8] } } %306

307:                                              ; preds = %40
  %308 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %309 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %308, 0
  %310 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %309, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %310, ptr %7, align 8
  %311 = load { i64, [24 x i8] }, ptr %7, align 8
  %312 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %47, 0
  %313 = insertvalue { i64, i64, { i64, [24 x i8] } } %312, i64 %44, 1
  %314 = insertvalue { i64, i64, { i64, [24 x i8] } } %313, { i64, [24 x i8] } %311, 2
  ret { i64, i64, { i64, [24 x i8] } } %314

315:                                              ; preds = %3
  %316 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %317 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %316, 0
  %318 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %317, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %318, ptr %4, align 8
  %319 = load { i64, [24 x i8] }, ptr %4, align 8
  %320 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %30, 0
  %321 = insertvalue { i64, i64, { i64, [24 x i8] } } %320, i64 %27, 1
  %322 = insertvalue { i64, i64, { i64, [24 x i8] } } %321, { i64, [24 x i8] } %319, 2
  ret { i64, i64, { i64, [24 x i8] } } %322

323:                                              ; preds = %38
  call void @puts(ptr @assert_msg_189)
  call void @abort()
  unreachable

324:                                              ; preds = %63
  call void @puts(ptr @assert_msg_190)
  call void @abort()
  unreachable

325:                                              ; preds = %88
  call void @puts(ptr @assert_msg_191)
  call void @abort()
  unreachable

326:                                              ; preds = %113
  call void @puts(ptr @assert_msg_192)
  call void @abort()
  unreachable

327:                                              ; preds = %170
  call void @puts(ptr @assert_msg_193)
  call void @abort()
  unreachable

328:                                              ; preds = %195
  call void @puts(ptr @assert_msg_194)
  call void @abort()
  unreachable

329:                                              ; preds = %220
  call void @puts(ptr @assert_msg_195)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f129(i64 %0, i64 %1, i128 %2) {
  %4 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f129"(i64 %0, i64 %1, i128 %2)
  %5 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 0
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 1
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %4, 2
  %8 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %5, 0
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } %8, i64 %6, 1
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, { i64, [24 x i8] } %7, 2
  ret { i64, i64, { i64, [24 x i8] } } %10
}

define void @_mlir_ciface_f129(ptr %0, i64 %1, i64 %2, i128 %3) {
  %5 = call { i64, i64, { i64, [24 x i8] } } @f129(i64 %1, i64 %2, i128 %3)
  store { i64, i64, { i64, [24 x i8] } } %5, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f130"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 155775200865430083567144986530171088759)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f130() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f130"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f130(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f130()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f131"() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f42"(i252 155775200863573220731881744814274539383)
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  %3 = insertvalue { { {}, { ptr, i32, i32, i32 } } } undef, { {}, { ptr, i32, i32, i32 } } %2, 0
  ret { { {}, { ptr, i32, i32, i32 } } } %3
}

define private { {}, { ptr, i32, i32, i32 } } @f131() {
  %1 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f131"()
  %2 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %1, 0
  ret { {}, { ptr, i32, i32, i32 } } %2
}

define void @_mlir_ciface_f131(ptr %0) {
  %2 = call { {}, { ptr, i32, i32, i32 } } @f131()
  store { {}, { ptr, i32, i32, i32 } } %2, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f132"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i8, [4 x i8] }, i64 1, align 1
  %4 = alloca { i8, [4 x i8] }, i64 1, align 1
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %136

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp sge i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %21 = icmp slt i252 %19, 128
  %22 = and i1 %20, %21
  %23 = icmp slt i252 %19, 0
  br i1 %23, label %24, label %26

24:                                               ; preds = %10
  %25 = sub i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %27

26:                                               ; preds = %10
  br label %27

27:                                               ; preds = %24, %26
  %28 = phi i252 [ %19, %26 ], [ %25, %24 ]
  br label %29

29:                                               ; preds = %27
  %30 = add i64 %0, 2
  %31 = add i64 %0, 3
  %32 = select i1 %22, i64 %30, i64 %31
  %33 = trunc i252 %28 to i8
  br i1 %22, label %34, label %136

34:                                               ; preds = %29
  %35 = phi { ptr, i32, i32, i32 } [ %17, %29 ]
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %136

40:                                               ; preds = %34
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = icmp sge i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %51 = icmp slt i252 %49, 128
  %52 = and i1 %50, %51
  %53 = icmp slt i252 %49, 0
  br i1 %53, label %54, label %56

54:                                               ; preds = %40
  %55 = sub i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %57

56:                                               ; preds = %40
  br label %57

57:                                               ; preds = %54, %56
  %58 = phi i252 [ %49, %56 ], [ %55, %54 ]
  br label %59

59:                                               ; preds = %57
  %60 = add i64 %32, 2
  %61 = add i64 %32, 3
  %62 = select i1 %52, i64 %60, i64 %61
  %63 = trunc i252 %58 to i8
  br i1 %52, label %64, label %136

64:                                               ; preds = %59
  %65 = phi { ptr, i32, i32, i32 } [ %47, %59 ]
  %66 = extractvalue { ptr, i32, i32, i32 } %65, 1
  %67 = extractvalue { ptr, i32, i32, i32 } %65, 2
  %68 = sub i32 %67, %66
  %69 = icmp uge i32 %68, 1
  br i1 %69, label %70, label %136

70:                                               ; preds = %64
  %71 = extractvalue { ptr, i32, i32, i32 } %65, 0
  %72 = load ptr, ptr %71, align 8
  %73 = zext i32 %66 to i64
  %74 = mul i64 %73, 32
  %75 = getelementptr inbounds i8, ptr %72, i64 %74
  %76 = add i32 %66, 1
  %77 = insertvalue { ptr, i32, i32, i32 } %65, i32 %76, 1
  %78 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %78, ptr %75, i64 32, i1 false)
  %79 = load i252, ptr %78, align 16
  call void @free(ptr %78)
  %80 = icmp sge i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %81 = icmp slt i252 %79, 128
  %82 = and i1 %80, %81
  %83 = icmp slt i252 %79, 0
  br i1 %83, label %84, label %86

84:                                               ; preds = %70
  %85 = sub i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %87

86:                                               ; preds = %70
  br label %87

87:                                               ; preds = %84, %86
  %88 = phi i252 [ %79, %86 ], [ %85, %84 ]
  br label %89

89:                                               ; preds = %87
  %90 = add i64 %62, 2
  %91 = add i64 %62, 3
  %92 = select i1 %82, i64 %90, i64 %91
  %93 = trunc i252 %88 to i8
  br i1 %82, label %94, label %136

94:                                               ; preds = %89
  %95 = phi { ptr, i32, i32, i32 } [ %77, %89 ]
  %96 = extractvalue { ptr, i32, i32, i32 } %95, 1
  %97 = extractvalue { ptr, i32, i32, i32 } %95, 2
  %98 = sub i32 %97, %96
  %99 = icmp uge i32 %98, 1
  br i1 %99, label %100, label %136

100:                                              ; preds = %94
  %101 = extractvalue { ptr, i32, i32, i32 } %95, 0
  %102 = load ptr, ptr %101, align 8
  %103 = zext i32 %96 to i64
  %104 = mul i64 %103, 32
  %105 = getelementptr inbounds i8, ptr %102, i64 %104
  %106 = add i32 %96, 1
  %107 = insertvalue { ptr, i32, i32, i32 } %95, i32 %106, 1
  %108 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %108, ptr %105, i64 32, i1 false)
  %109 = load i252, ptr %108, align 16
  call void @free(ptr %108)
  %110 = icmp sge i252 %109, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %111 = icmp slt i252 %109, 128
  %112 = and i1 %110, %111
  %113 = icmp slt i252 %109, 0
  br i1 %113, label %114, label %116

114:                                              ; preds = %100
  %115 = sub i252 %109, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %117

116:                                              ; preds = %100
  br label %117

117:                                              ; preds = %114, %116
  %118 = phi i252 [ %109, %116 ], [ %115, %114 ]
  br label %119

119:                                              ; preds = %117
  %120 = add i64 %92, 2
  %121 = add i64 %92, 3
  %122 = select i1 %112, i64 %120, i64 %121
  %123 = trunc i252 %118 to i8
  br i1 %112, label %124, label %136

124:                                              ; preds = %119
  %125 = phi { ptr, i32, i32, i32 } [ %107, %119 ]
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %125, 0
  %127 = insertvalue { i8, i8, i8, i8 } undef, i8 %33, 0
  %128 = insertvalue { i8, i8, i8, i8 } %127, i8 %63, 1
  %129 = insertvalue { i8, i8, i8, i8 } %128, i8 %93, 2
  %130 = insertvalue { i8, i8, i8, i8 } %129, i8 %123, 3
  %131 = insertvalue { i1, { i8, i8, i8, i8 } } { i1 false, { i8, i8, i8, i8 } undef }, { i8, i8, i8, i8 } %130, 1
  store { i1, { i8, i8, i8, i8 } } %131, ptr %4, align 1
  %132 = load { i8, [4 x i8] }, ptr %4, align 1
  %133 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } undef, i64 %122, 0
  %134 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %133, { { ptr, i32, i32, i32 } } %126, 1
  %135 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %134, { i8, [4 x i8] } %132, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %135

136:                                              ; preds = %119, %94, %89, %64, %59, %34, %29, %2
  %137 = phi i64 [ %122, %119 ], [ %92, %94 ], [ %92, %89 ], [ %62, %64 ], [ %62, %59 ], [ %32, %34 ], [ %32, %29 ], [ %0, %2 ]
  %138 = phi { ptr, i32, i32, i32 } [ %107, %119 ], [ %95, %94 ], [ %77, %89 ], [ %65, %64 ], [ %47, %59 ], [ %35, %34 ], [ %17, %29 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %139 = load { i8, [4 x i8] }, ptr %3, align 1
  %140 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %138, 0
  %141 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } undef, i64 %137, 0
  %142 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %141, { { ptr, i32, i32, i32 } } %140, 1
  %143 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %142, { i8, [4 x i8] } %139, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %143
}

define private { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @f132(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f132"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %8, { i8, [4 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %9
}

define void @_mlir_ciface_f132(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @f132(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f133"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i8, [4 x i8] }, i64 1, align 1
  %4 = alloca { i8, [4 x i8] }, i64 1, align 1
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %136

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp sge i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %21 = icmp slt i252 %19, 128
  %22 = and i1 %20, %21
  %23 = icmp slt i252 %19, 0
  br i1 %23, label %24, label %26

24:                                               ; preds = %10
  %25 = sub i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %27

26:                                               ; preds = %10
  br label %27

27:                                               ; preds = %24, %26
  %28 = phi i252 [ %19, %26 ], [ %25, %24 ]
  br label %29

29:                                               ; preds = %27
  %30 = add i64 %0, 2
  %31 = add i64 %0, 3
  %32 = select i1 %22, i64 %30, i64 %31
  %33 = trunc i252 %28 to i8
  br i1 %22, label %34, label %136

34:                                               ; preds = %29
  %35 = phi { ptr, i32, i32, i32 } [ %17, %29 ]
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %136

40:                                               ; preds = %34
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = icmp sge i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %51 = icmp slt i252 %49, 128
  %52 = and i1 %50, %51
  %53 = icmp slt i252 %49, 0
  br i1 %53, label %54, label %56

54:                                               ; preds = %40
  %55 = sub i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %57

56:                                               ; preds = %40
  br label %57

57:                                               ; preds = %54, %56
  %58 = phi i252 [ %49, %56 ], [ %55, %54 ]
  br label %59

59:                                               ; preds = %57
  %60 = add i64 %32, 2
  %61 = add i64 %32, 3
  %62 = select i1 %52, i64 %60, i64 %61
  %63 = trunc i252 %58 to i8
  br i1 %52, label %64, label %136

64:                                               ; preds = %59
  %65 = phi { ptr, i32, i32, i32 } [ %47, %59 ]
  %66 = extractvalue { ptr, i32, i32, i32 } %65, 1
  %67 = extractvalue { ptr, i32, i32, i32 } %65, 2
  %68 = sub i32 %67, %66
  %69 = icmp uge i32 %68, 1
  br i1 %69, label %70, label %136

70:                                               ; preds = %64
  %71 = extractvalue { ptr, i32, i32, i32 } %65, 0
  %72 = load ptr, ptr %71, align 8
  %73 = zext i32 %66 to i64
  %74 = mul i64 %73, 32
  %75 = getelementptr inbounds i8, ptr %72, i64 %74
  %76 = add i32 %66, 1
  %77 = insertvalue { ptr, i32, i32, i32 } %65, i32 %76, 1
  %78 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %78, ptr %75, i64 32, i1 false)
  %79 = load i252, ptr %78, align 16
  call void @free(ptr %78)
  %80 = icmp sge i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %81 = icmp slt i252 %79, 128
  %82 = and i1 %80, %81
  %83 = icmp slt i252 %79, 0
  br i1 %83, label %84, label %86

84:                                               ; preds = %70
  %85 = sub i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %87

86:                                               ; preds = %70
  br label %87

87:                                               ; preds = %84, %86
  %88 = phi i252 [ %79, %86 ], [ %85, %84 ]
  br label %89

89:                                               ; preds = %87
  %90 = add i64 %62, 2
  %91 = add i64 %62, 3
  %92 = select i1 %82, i64 %90, i64 %91
  %93 = trunc i252 %88 to i8
  br i1 %82, label %94, label %136

94:                                               ; preds = %89
  %95 = phi { ptr, i32, i32, i32 } [ %77, %89 ]
  %96 = extractvalue { ptr, i32, i32, i32 } %95, 1
  %97 = extractvalue { ptr, i32, i32, i32 } %95, 2
  %98 = sub i32 %97, %96
  %99 = icmp uge i32 %98, 1
  br i1 %99, label %100, label %136

100:                                              ; preds = %94
  %101 = extractvalue { ptr, i32, i32, i32 } %95, 0
  %102 = load ptr, ptr %101, align 8
  %103 = zext i32 %96 to i64
  %104 = mul i64 %103, 32
  %105 = getelementptr inbounds i8, ptr %102, i64 %104
  %106 = add i32 %96, 1
  %107 = insertvalue { ptr, i32, i32, i32 } %95, i32 %106, 1
  %108 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %108, ptr %105, i64 32, i1 false)
  %109 = load i252, ptr %108, align 16
  call void @free(ptr %108)
  %110 = icmp sge i252 %109, -3618502788666131000275863779947924135206266826270938552493006944358698582143
  %111 = icmp slt i252 %109, 128
  %112 = and i1 %110, %111
  %113 = icmp slt i252 %109, 0
  br i1 %113, label %114, label %116

114:                                              ; preds = %100
  %115 = sub i252 %109, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %117

116:                                              ; preds = %100
  br label %117

117:                                              ; preds = %114, %116
  %118 = phi i252 [ %109, %116 ], [ %115, %114 ]
  br label %119

119:                                              ; preds = %117
  %120 = add i64 %92, 2
  %121 = add i64 %92, 3
  %122 = select i1 %112, i64 %120, i64 %121
  %123 = trunc i252 %118 to i8
  br i1 %112, label %124, label %136

124:                                              ; preds = %119
  %125 = phi { ptr, i32, i32, i32 } [ %107, %119 ]
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %125, 0
  %127 = insertvalue { i8, i8, i8, i8 } undef, i8 %33, 0
  %128 = insertvalue { i8, i8, i8, i8 } %127, i8 %63, 1
  %129 = insertvalue { i8, i8, i8, i8 } %128, i8 %93, 2
  %130 = insertvalue { i8, i8, i8, i8 } %129, i8 %123, 3
  %131 = insertvalue { i1, { i8, i8, i8, i8 } } { i1 false, { i8, i8, i8, i8 } undef }, { i8, i8, i8, i8 } %130, 1
  store { i1, { i8, i8, i8, i8 } } %131, ptr %4, align 1
  %132 = load { i8, [4 x i8] }, ptr %4, align 1
  %133 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } undef, i64 %122, 0
  %134 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %133, { { ptr, i32, i32, i32 } } %126, 1
  %135 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %134, { i8, [4 x i8] } %132, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %135

136:                                              ; preds = %119, %94, %89, %64, %59, %34, %29, %2
  %137 = phi i64 [ %122, %119 ], [ %92, %94 ], [ %92, %89 ], [ %62, %64 ], [ %62, %59 ], [ %32, %34 ], [ %32, %29 ], [ %0, %2 ]
  %138 = phi { ptr, i32, i32, i32 } [ %107, %119 ], [ %95, %94 ], [ %77, %89 ], [ %65, %64 ], [ %47, %59 ], [ %35, %34 ], [ %17, %29 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %139 = load { i8, [4 x i8] }, ptr %3, align 1
  %140 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %138, 0
  %141 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } undef, i64 %137, 0
  %142 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %141, { { ptr, i32, i32, i32 } } %140, 1
  %143 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %142, { i8, [4 x i8] } %139, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %143
}

define private { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @f133(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @"impl$f133"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %8, { i8, [4 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %9
}

define void @_mlir_ciface_f133(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } @f133(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i8, [4 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } @"impl$f134"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i16, [6 x i8] }, i64 1, align 2
  %4 = alloca { i16, [6 x i8] }, i64 1, align 2
  %5 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %6 = extractvalue { ptr, i32, i32, i32 } %5, 1
  %7 = extractvalue { ptr, i32, i32, i32 } %5, 2
  %8 = sub i32 %7, %6
  %9 = icmp uge i32 %8, 1
  br i1 %9, label %10, label %105

10:                                               ; preds = %2
  %11 = extractvalue { ptr, i32, i32, i32 } %5, 0
  %12 = load ptr, ptr %11, align 8
  %13 = zext i32 %6 to i64
  %14 = mul i64 %13, 32
  %15 = getelementptr inbounds i8, ptr %12, i64 %14
  %16 = add i32 %6, 1
  %17 = insertvalue { ptr, i32, i32, i32 } %5, i32 %16, 1
  %18 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %18, ptr %15, i64 32, i1 false)
  %19 = load i252, ptr %18, align 16
  call void @free(ptr %18)
  %20 = icmp sge i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %21 = icmp slt i252 %19, 32768
  %22 = and i1 %20, %21
  %23 = icmp slt i252 %19, 0
  br i1 %23, label %24, label %26

24:                                               ; preds = %10
  %25 = sub i252 %19, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %27

26:                                               ; preds = %10
  br label %27

27:                                               ; preds = %24, %26
  %28 = phi i252 [ %19, %26 ], [ %25, %24 ]
  br label %29

29:                                               ; preds = %27
  %30 = add i64 %0, 2
  %31 = add i64 %0, 3
  %32 = select i1 %22, i64 %30, i64 %31
  %33 = trunc i252 %28 to i16
  br i1 %22, label %34, label %105

34:                                               ; preds = %29
  %35 = phi { ptr, i32, i32, i32 } [ %17, %29 ]
  %36 = extractvalue { ptr, i32, i32, i32 } %35, 1
  %37 = extractvalue { ptr, i32, i32, i32 } %35, 2
  %38 = sub i32 %37, %36
  %39 = icmp uge i32 %38, 1
  br i1 %39, label %40, label %105

40:                                               ; preds = %34
  %41 = extractvalue { ptr, i32, i32, i32 } %35, 0
  %42 = load ptr, ptr %41, align 8
  %43 = zext i32 %36 to i64
  %44 = mul i64 %43, 32
  %45 = getelementptr inbounds i8, ptr %42, i64 %44
  %46 = add i32 %36, 1
  %47 = insertvalue { ptr, i32, i32, i32 } %35, i32 %46, 1
  %48 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %48, ptr %45, i64 32, i1 false)
  %49 = load i252, ptr %48, align 16
  call void @free(ptr %48)
  %50 = icmp sge i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %51 = icmp slt i252 %49, 32768
  %52 = and i1 %50, %51
  %53 = icmp slt i252 %49, 0
  br i1 %53, label %54, label %56

54:                                               ; preds = %40
  %55 = sub i252 %49, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %57

56:                                               ; preds = %40
  br label %57

57:                                               ; preds = %54, %56
  %58 = phi i252 [ %49, %56 ], [ %55, %54 ]
  br label %59

59:                                               ; preds = %57
  %60 = add i64 %32, 2
  %61 = add i64 %32, 3
  %62 = select i1 %52, i64 %60, i64 %61
  %63 = trunc i252 %58 to i16
  br i1 %52, label %64, label %105

64:                                               ; preds = %59
  %65 = phi { ptr, i32, i32, i32 } [ %47, %59 ]
  %66 = extractvalue { ptr, i32, i32, i32 } %65, 1
  %67 = extractvalue { ptr, i32, i32, i32 } %65, 2
  %68 = sub i32 %67, %66
  %69 = icmp uge i32 %68, 1
  br i1 %69, label %70, label %105

70:                                               ; preds = %64
  %71 = extractvalue { ptr, i32, i32, i32 } %65, 0
  %72 = load ptr, ptr %71, align 8
  %73 = zext i32 %66 to i64
  %74 = mul i64 %73, 32
  %75 = getelementptr inbounds i8, ptr %72, i64 %74
  %76 = add i32 %66, 1
  %77 = insertvalue { ptr, i32, i32, i32 } %65, i32 %76, 1
  %78 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %78, ptr %75, i64 32, i1 false)
  %79 = load i252, ptr %78, align 16
  call void @free(ptr %78)
  %80 = icmp sge i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698614783
  %81 = icmp slt i252 %79, 32768
  %82 = and i1 %80, %81
  %83 = icmp slt i252 %79, 0
  br i1 %83, label %84, label %86

84:                                               ; preds = %70
  %85 = sub i252 %79, -3618502788666131000275863779947924135206266826270938552493006944358698582015
  br label %87

86:                                               ; preds = %70
  br label %87

87:                                               ; preds = %84, %86
  %88 = phi i252 [ %79, %86 ], [ %85, %84 ]
  br label %89

89:                                               ; preds = %87
  %90 = add i64 %62, 2
  %91 = add i64 %62, 3
  %92 = select i1 %82, i64 %90, i64 %91
  %93 = trunc i252 %88 to i16
  br i1 %82, label %94, label %105

94:                                               ; preds = %89
  %95 = phi { ptr, i32, i32, i32 } [ %77, %89 ]
  %96 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %95, 0
  %97 = insertvalue { i16, i16, i16 } undef, i16 %33, 0
  %98 = insertvalue { i16, i16, i16 } %97, i16 %63, 1
  %99 = insertvalue { i16, i16, i16 } %98, i16 %93, 2
  %100 = insertvalue { i1, { i16, i16, i16 } } { i1 false, { i16, i16, i16 } undef }, { i16, i16, i16 } %99, 1
  store { i1, { i16, i16, i16 } } %100, ptr %4, align 2
  %101 = load { i16, [6 x i8] }, ptr %4, align 2
  %102 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } undef, i64 %92, 0
  %103 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %102, { { ptr, i32, i32, i32 } } %96, 1
  %104 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %103, { i16, [6 x i8] } %101, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %104

105:                                              ; preds = %89, %64, %59, %34, %29, %2
  %106 = phi i64 [ %92, %89 ], [ %62, %64 ], [ %62, %59 ], [ %32, %34 ], [ %32, %29 ], [ %0, %2 ]
  %107 = phi { ptr, i32, i32, i32 } [ %77, %89 ], [ %65, %64 ], [ %47, %59 ], [ %35, %34 ], [ %17, %29 ], [ %5, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %108 = load { i16, [6 x i8] }, ptr %3, align 2
  %109 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %107, 0
  %110 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } undef, i64 %106, 0
  %111 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %110, { { ptr, i32, i32, i32 } } %109, 1
  %112 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %111, { i16, [6 x i8] } %108, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %112
}

define private { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } @f134(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } @"impl$f134"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %8, { i16, [6 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %9
}

define void @_mlir_ciface_f134(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } @f134(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i16, [6 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } @"impl$f135"(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = alloca { i8, [3 x i8] }, i64 1, align 1
  %4 = alloca { i8, [3 x i8] }, i64 1, align 1
  %5 = alloca { i8, [3 x i8] }, i64 1, align 1
  %6 = alloca { i8, [3 x i8] }, i64 1, align 1
  %7 = alloca { i8, [3 x i8] }, i64 1, align 1
  %8 = extractvalue { { ptr, i32, i32, i32 } } %1, 0
  %9 = extractvalue { ptr, i32, i32, i32 } %8, 1
  %10 = extractvalue { ptr, i32, i32, i32 } %8, 2
  %11 = sub i32 %10, %9
  %12 = icmp uge i32 %11, 1
  br i1 %12, label %13, label %135

13:                                               ; preds = %2
  %14 = extractvalue { ptr, i32, i32, i32 } %8, 0
  %15 = load ptr, ptr %14, align 8
  %16 = zext i32 %9 to i64
  %17 = mul i64 %16, 32
  %18 = getelementptr inbounds i8, ptr %15, i64 %17
  %19 = add i32 %9, 1
  %20 = insertvalue { ptr, i32, i32, i32 } %8, i32 %19, 1
  %21 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %21, ptr %18, i64 32, i1 false)
  %22 = load i252, ptr %21, align 16
  call void @free(ptr %21)
  %23 = icmp ult i252 %22, 256
  %24 = add i64 %0, 2
  %25 = add i64 %0, 3
  %26 = select i1 %23, i64 %24, i64 %25
  %27 = trunc i252 %22 to i8
  br i1 %23, label %28, label %135

28:                                               ; preds = %13
  %29 = phi { ptr, i32, i32, i32 } [ %20, %13 ]
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %135

34:                                               ; preds = %28
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 32
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %42, ptr %39, i64 32, i1 false)
  %43 = load i252, ptr %42, align 16
  call void @free(ptr %42)
  %44 = icmp ult i252 %43, 256
  %45 = add i64 %26, 2
  %46 = add i64 %26, 3
  %47 = select i1 %44, i64 %45, i64 %46
  %48 = trunc i252 %43 to i8
  br i1 %44, label %49, label %135

49:                                               ; preds = %34
  %50 = phi { ptr, i32, i32, i32 } [ %41, %34 ]
  %51 = extractvalue { ptr, i32, i32, i32 } %50, 1
  %52 = extractvalue { ptr, i32, i32, i32 } %50, 2
  %53 = sub i32 %52, %51
  %54 = icmp uge i32 %53, 1
  br i1 %54, label %55, label %135

55:                                               ; preds = %49
  %56 = extractvalue { ptr, i32, i32, i32 } %50, 0
  %57 = load ptr, ptr %56, align 8
  %58 = zext i32 %51 to i64
  %59 = mul i64 %58, 32
  %60 = getelementptr inbounds i8, ptr %57, i64 %59
  %61 = add i32 %51, 1
  %62 = insertvalue { ptr, i32, i32, i32 } %50, i32 %61, 1
  %63 = call ptr @realloc(ptr null, i64 32)
  call void @llvm.memcpy.p0.p0.i64(ptr %63, ptr %60, i64 32, i1 false)
  %64 = load i252, ptr %63, align 16
  call void @free(ptr %63)
  %65 = icmp eq i252 %64, 0
  br i1 %65, label %66, label %76

66:                                               ; preds = %55
  %67 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 0
  %68 = insertvalue { i8, i8, { i2, [0 x i8] } } undef, i8 %27, 0
  %69 = insertvalue { i8, i8, { i2, [0 x i8] } } %68, i8 %48, 1
  %70 = insertvalue { i8, i8, { i2, [0 x i8] } } %69, { i2, [0 x i8] } { i2 0, [0 x i8] undef }, 2
  %71 = insertvalue { i1, { i8, i8, { i2, [0 x i8] } } } { i1 false, { i8, i8, { i2, [0 x i8] } } undef }, { i8, i8, { i2, [0 x i8] } } %70, 1
  store { i1, { i8, i8, { i2, [0 x i8] } } } %71, ptr %7, align 1
  %72 = load { i8, [3 x i8] }, ptr %7, align 1
  %73 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } undef, i64 %47, 0
  %74 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %73, { { ptr, i32, i32, i32 } } %67, 1
  %75 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %74, { i8, [3 x i8] } %72, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %75

76:                                               ; preds = %55
  %77 = phi i252 [ %64, %55 ]
  %78 = zext i252 %77 to i256
  %79 = sub i256 %78, 1
  %80 = add i256 %78, 3618502788666131213697322783095070105623107215331596699973092056135872020480
  %81 = icmp ult i256 %78, 1
  %82 = select i1 %81, i256 %80, i256 %79
  %83 = trunc i256 %82 to i252
  %84 = icmp eq i252 %83, 0
  br i1 %84, label %85, label %95

85:                                               ; preds = %76
  %86 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 0
  %87 = insertvalue { i8, i8, { i2, [0 x i8] } } undef, i8 %27, 0
  %88 = insertvalue { i8, i8, { i2, [0 x i8] } } %87, i8 %48, 1
  %89 = insertvalue { i8, i8, { i2, [0 x i8] } } %88, { i2, [0 x i8] } { i2 1, [0 x i8] undef }, 2
  %90 = insertvalue { i1, { i8, i8, { i2, [0 x i8] } } } { i1 false, { i8, i8, { i2, [0 x i8] } } undef }, { i8, i8, { i2, [0 x i8] } } %89, 1
  store { i1, { i8, i8, { i2, [0 x i8] } } } %90, ptr %6, align 1
  %91 = load { i8, [3 x i8] }, ptr %6, align 1
  %92 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } undef, i64 %47, 0
  %93 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %92, { { ptr, i32, i32, i32 } } %86, 1
  %94 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %93, { i8, [3 x i8] } %91, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %94

95:                                               ; preds = %76
  %96 = phi i252 [ %77, %76 ]
  %97 = zext i252 %96 to i256
  %98 = sub i256 %97, 2
  %99 = add i256 %97, 3618502788666131213697322783095070105623107215331596699973092056135872020479
  %100 = icmp ult i256 %97, 2
  %101 = select i1 %100, i256 %99, i256 %98
  %102 = trunc i256 %101 to i252
  %103 = icmp eq i252 %102, 0
  br i1 %103, label %104, label %114

104:                                              ; preds = %95
  %105 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 0
  %106 = insertvalue { i8, i8, { i2, [0 x i8] } } undef, i8 %27, 0
  %107 = insertvalue { i8, i8, { i2, [0 x i8] } } %106, i8 %48, 1
  %108 = insertvalue { i8, i8, { i2, [0 x i8] } } %107, { i2, [0 x i8] } { i2 -2, [0 x i8] undef }, 2
  %109 = insertvalue { i1, { i8, i8, { i2, [0 x i8] } } } { i1 false, { i8, i8, { i2, [0 x i8] } } undef }, { i8, i8, { i2, [0 x i8] } } %108, 1
  store { i1, { i8, i8, { i2, [0 x i8] } } } %109, ptr %5, align 1
  %110 = load { i8, [3 x i8] }, ptr %5, align 1
  %111 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } undef, i64 %47, 0
  %112 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %111, { { ptr, i32, i32, i32 } } %105, 1
  %113 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %112, { i8, [3 x i8] } %110, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %113

114:                                              ; preds = %95
  %115 = phi i252 [ %96, %95 ]
  %116 = phi i252 [ 3, %95 ]
  %117 = zext i252 %115 to i256
  %118 = zext i252 %116 to i256
  %119 = sub i256 %117, %118
  %120 = add i256 %119, 3618502788666131213697322783095070105623107215331596699973092056135872020481
  %121 = icmp ult i256 %117, %118
  %122 = select i1 %121, i256 %120, i256 %119
  %123 = trunc i256 %122 to i252
  %124 = icmp eq i252 %123, 0
  br i1 %124, label %125, label %135

125:                                              ; preds = %114
  %126 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %62, 0
  %127 = insertvalue { i8, i8, { i2, [0 x i8] } } undef, i8 %27, 0
  %128 = insertvalue { i8, i8, { i2, [0 x i8] } } %127, i8 %48, 1
  %129 = insertvalue { i8, i8, { i2, [0 x i8] } } %128, { i2, [0 x i8] } { i2 -1, [0 x i8] undef }, 2
  %130 = insertvalue { i1, { i8, i8, { i2, [0 x i8] } } } { i1 false, { i8, i8, { i2, [0 x i8] } } undef }, { i8, i8, { i2, [0 x i8] } } %129, 1
  store { i1, { i8, i8, { i2, [0 x i8] } } } %130, ptr %4, align 1
  %131 = load { i8, [3 x i8] }, ptr %4, align 1
  %132 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } undef, i64 %47, 0
  %133 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %132, { { ptr, i32, i32, i32 } } %126, 1
  %134 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %133, { i8, [3 x i8] } %131, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %134

135:                                              ; preds = %114, %49, %34, %28, %13, %2
  %136 = phi i64 [ %47, %114 ], [ %47, %49 ], [ %47, %34 ], [ %26, %28 ], [ %26, %13 ], [ %0, %2 ]
  %137 = phi { ptr, i32, i32, i32 } [ %62, %114 ], [ %50, %49 ], [ %41, %34 ], [ %29, %28 ], [ %20, %13 ], [ %8, %2 ]
  store { i1, [0 x i8] } { i1 true, [0 x i8] undef }, ptr %3, align 1
  %138 = load { i8, [3 x i8] }, ptr %3, align 1
  %139 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %137, 0
  %140 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } undef, i64 %136, 0
  %141 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %140, { { ptr, i32, i32, i32 } } %139, 1
  %142 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %141, { i8, [3 x i8] } %138, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %142
}

define private { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } @f135(i64 %0, { { ptr, i32, i32, i32 } } %1) {
  %3 = call fastcc { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } @"impl$f135"(i64 %0, { { ptr, i32, i32, i32 } } %1)
  %4 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %3, 0
  %5 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %3, 1
  %6 = extractvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %3, 2
  %7 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } undef, i64 %4, 0
  %8 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %7, { { ptr, i32, i32, i32 } } %5, 1
  %9 = insertvalue { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %8, { i8, [3 x i8] } %6, 2
  ret { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %9
}

define void @_mlir_ciface_f135(ptr %0, i64 %1, { { ptr, i32, i32, i32 } } %2) {
  %4 = call { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } @f135(i64 %1, { { ptr, i32, i32, i32 } } %2)
  store { i64, { { ptr, i32, i32, i32 } }, { i8, [3 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f136"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [48 x i8] }, i64 1, align 8
  %11 = alloca { i64, [48 x i8] }, i64 1, align 8
  br label %12

12:                                               ; preds = %83, %4
  %13 = phi i64 [ %17, %83 ], [ %0, %4 ]
  %14 = phi i64 [ %42, %83 ], [ %1, %4 ]
  %15 = phi { { ptr, i32, i32, i32 } } [ %94, %83 ], [ %2, %4 ]
  %16 = phi { ptr, i32, i32, i32 } [ %92, %83 ], [ %3, %4 ]
  %17 = add i64 %13, 1
  %18 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %19 = call ptr %18()
  %20 = load i64, ptr %19, align 8
  %21 = mul i64 %20, 2970
  %22 = icmp uge i64 %14, %21
  %23 = call i64 @llvm.usub.sat.i64(i64 %14, i64 %21)
  br i1 %22, label %24, label %133

24:                                               ; preds = %12
  %25 = phi { { ptr, i32, i32, i32 } } [ %15, %12 ]
  %26 = extractvalue { { ptr, i32, i32, i32 } } %25, 0
  %27 = extractvalue { ptr, i32, i32, i32 } %26, 1
  %28 = extractvalue { ptr, i32, i32, i32 } %26, 2
  %29 = sub i32 %28, %27
  %30 = icmp uge i32 %29, 1
  br i1 %30, label %31, label %112

31:                                               ; preds = %24
  %32 = extractvalue { ptr, i32, i32, i32 } %26, 0
  %33 = load ptr, ptr %32, align 8
  %34 = zext i32 %27 to i64
  %35 = mul i64 %34, 20
  %36 = getelementptr inbounds i8, ptr %33, i64 %35
  %37 = add i32 %27, 1
  %38 = insertvalue { ptr, i32, i32, i32 } %26, i32 %37, 1
  %39 = call ptr @realloc(ptr null, i64 20)
  call void @llvm.memcpy.p0.p0.i64(ptr %39, ptr %36, i64 20, i1 false)
  %40 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %41 = call ptr %40()
  %42 = call i64 @llvm.uadd.sat.i64(i64 %23, i64 0)
  %43 = load { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } }, ptr %39, align 4
  call void @free(ptr %39)
  %44 = extractvalue { ptr, i32, i32, i32 } %16, 3
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %60

46:                                               ; preds = %31
  %47 = shl i32 %44, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %44
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 20
  %53 = add i64 %52, 8
  %54 = call ptr @realloc(ptr null, i64 %53)
  store i32 1, ptr %54, align 4
  %55 = getelementptr inbounds i8, ptr %54, i32 4
  store i32 0, ptr %55, align 4
  %56 = getelementptr inbounds i8, ptr %54, i32 8
  %57 = call ptr @realloc(ptr null, i64 8)
  store ptr %56, ptr %57, align 8
  %58 = insertvalue { ptr, i32, i32, i32 } %16, ptr %57, 0
  %59 = insertvalue { ptr, i32, i32, i32 } %58, i32 %50, 3
  br label %81

60:                                               ; preds = %31
  %61 = extractvalue { ptr, i32, i32, i32 } %16, 2
  %62 = icmp ult i32 %61, %44
  br i1 %62, label %63, label %64

63:                                               ; preds = %60
  br label %78

64:                                               ; preds = %60
  %65 = shl i32 %44, 1
  %66 = call i32 @llvm.umin.i32(i32 %65, i32 1024)
  %67 = add i32 %66, %44
  %68 = call i32 @llvm.umax.i32(i32 %67, i32 8)
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 20
  %71 = add i64 %70, 8
  %72 = extractvalue { ptr, i32, i32, i32 } %16, 0
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr inbounds i8, ptr %73, i32 -8
  %75 = call ptr @realloc(ptr %74, i64 %71)
  %76 = getelementptr inbounds i8, ptr %75, i32 8
  store ptr %76, ptr %72, align 8
  %77 = insertvalue { ptr, i32, i32, i32 } %16, i32 %68, 3
  br label %78

78:                                               ; preds = %63, %64
  %79 = phi { ptr, i32, i32, i32 } [ %77, %64 ], [ %16, %63 ]
  br label %80

80:                                               ; preds = %78
  br label %81

81:                                               ; preds = %46, %80
  %82 = phi { ptr, i32, i32, i32 } [ %79, %80 ], [ %59, %46 ]
  br label %83

83:                                               ; preds = %81
  %84 = extractvalue { ptr, i32, i32, i32 } %82, 0
  %85 = load ptr, ptr %84, align 8
  %86 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %87 = zext i32 %86 to i64
  %88 = mul i64 %87, 20
  %89 = getelementptr inbounds i8, ptr %85, i64 %88
  store { { i1, [0 x i8] }, { i32, [4 x i8] }, { i16, [6 x i8] } } %43, ptr %89, align 4
  %90 = extractvalue { ptr, i32, i32, i32 } %82, 2
  %91 = add i32 %90, 1
  %92 = insertvalue { ptr, i32, i32, i32 } %82, i32 %91, 2
  %93 = getelementptr inbounds i8, ptr %85, i32 -4
  store i32 %91, ptr %93, align 4
  %94 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %38, 0
  %95 = extractvalue { ptr, ptr, i64 } %8, 1
  %96 = load i64, ptr %95, align 8
  %97 = add i64 %96, 1
  %98 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %97, ptr %98, align 8
  br label %12

99:                                               ; preds = %99, %112, %133
  %100 = phi i64 [ %17, %133 ], [ %17, %112 ], [ %100, %99 ]
  %101 = phi i64 [ %14, %133 ], [ %118, %112 ], [ %101, %99 ]
  %102 = phi { i64, [48 x i8] } [ %138, %133 ], [ %123, %112 ], [ %102, %99 ]
  %103 = extractvalue { ptr, ptr, i64 } %8, 1
  %104 = load i64, ptr %103, align 8
  %105 = icmp eq i64 %104, 0
  %106 = sub i64 %104, 1
  %107 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %106, ptr %107, align 8
  br i1 %105, label %108, label %99

108:                                              ; preds = %99
  %109 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %100, 0
  %110 = insertvalue { i64, i64, { i64, [48 x i8] } } %109, i64 %101, 1
  %111 = insertvalue { i64, i64, { i64, [48 x i8] } } %110, { i64, [48 x i8] } %102, 2
  ret { i64, i64, { i64, [48 x i8] } } %111

112:                                              ; preds = %24
  %113 = phi i64 [ %23, %24 ]
  %114 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %115 = call ptr %114()
  %116 = load i64, ptr %115, align 8
  %117 = mul i64 %116, 3670
  %118 = call i64 @llvm.uadd.sat.i64(i64 %113, i64 %117)
  %119 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %26, 0
  %120 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef, { { ptr, i32, i32, i32 } } %119, 0
  %121 = insertvalue { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %120, { ptr, i32, i32, i32 } %16, 1
  %122 = insertvalue { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } { i1 false, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } undef }, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } %121, 1
  store { i1, { { { ptr, i32, i32, i32 } }, { ptr, i32, i32, i32 }, {} } } %122, ptr %11, align 8
  %123 = load { i64, [48 x i8] }, ptr %11, align 8
  %124 = extractvalue { ptr, ptr, i64 } %8, 1
  %125 = load i64, ptr %124, align 8
  %126 = icmp eq i64 %125, 0
  %127 = sub i64 %125, 1
  %128 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %127, ptr %128, align 8
  br i1 %126, label %129, label %99

129:                                              ; preds = %112
  %130 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %17, 0
  %131 = insertvalue { i64, i64, { i64, [48 x i8] } } %130, i64 %118, 1
  %132 = insertvalue { i64, i64, { i64, [48 x i8] } } %131, { i64, [48 x i8] } %123, 2
  ret { i64, i64, { i64, [48 x i8] } } %132

133:                                              ; preds = %12
  %134 = phi { ptr, i32, i32, i32 } [ %16, %12 ]
  call void @"drop$37"({ ptr, i32, i32, i32 } %134)
  call void @"drop$39"({ { ptr, i32, i32, i32 } } %15)
  %135 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %136 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %135, 0
  %137 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %136, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %137, ptr %10, align 8
  %138 = load { i64, [48 x i8] }, ptr %10, align 8
  %139 = extractvalue { ptr, ptr, i64 } %8, 1
  %140 = load i64, ptr %139, align 8
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %140, 1
  %143 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %142, ptr %143, align 8
  br i1 %141, label %144, label %99

144:                                              ; preds = %133
  %145 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %17, 0
  %146 = insertvalue { i64, i64, { i64, [48 x i8] } } %145, i64 %14, 1
  %147 = insertvalue { i64, i64, { i64, [48 x i8] } } %146, { i64, [48 x i8] } %138, 2
  ret { i64, i64, { i64, [48 x i8] } } %147
}

define private { i64, i64, { i64, [48 x i8] } } @f136(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [48 x i8] } } @"impl$f136"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [48 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [48 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [48 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [48 x i8] } } %10, { i64, [48 x i8] } %8, 2
  ret { i64, i64, { i64, [48 x i8] } } %11
}

define void @_mlir_ciface_f136(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [48 x i8] } } @f136(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [48 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$25"(ptr %0) {
  %2 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %0, align 16
  call void @"drop$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$25"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 160)
  %3 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %0, align 16
  %4 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %3)
  %5 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %4, 0
  %6 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %4, 1
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %5, ptr %0, align 16
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f137"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %55, %4
  %16 = phi i64 [ %49, %55 ], [ %0, %4 ]
  %17 = phi i64 [ %60, %55 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %61, %55 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %62, %55 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 16000
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %113

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %94

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 160
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 160)
  %43 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %39, align 16
  %44 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %43)
  %45 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %44, 0
  %46 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %44, 1
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %45, ptr %39, align 16
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %46, ptr %42, align 16
  %47 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %42, align 16
  call void @free(ptr %42)
  store { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %47, ptr %12, align 16
  %48 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f140"(i64 %20, i64 %26, ptr %12, { ptr, i32, i32, i32 } %19)
  %49 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 1
  %51 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 2
  store { i64, [24 x i8] } %51, ptr %13, align 8
  %52 = load i1, ptr %13, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %67
  ]

53:                                               ; preds = %34
  br i1 false, label %54, label %128

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %34
  %56 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %57 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %56, 1
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 0)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %62 = extractvalue { { ptr, i32, i32, i32 }, {} } %57, 0
  %63 = extractvalue { ptr, ptr, i64 } %8, 1
  %64 = load i64, ptr %63, align 8
  %65 = add i64 %64, 1
  %66 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %65, ptr %66, align 8
  br label %15

67:                                               ; preds = %34
  %68 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %69 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %68, 1
  call void @"drop$6"({ ptr, i32, i32, i32 } %41)
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %14, align 8
  %71 = load { i64, [24 x i8] }, ptr %14, align 8
  %72 = extractvalue { ptr, ptr, i64 } %8, 1
  %73 = load i64, ptr %72, align 8
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %73, 1
  %76 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %75, ptr %76, align 8
  br i1 %74, label %90, label %77

77:                                               ; preds = %77, %67, %94, %113
  %78 = phi i64 [ %20, %113 ], [ %20, %94 ], [ %78, %77 ], [ %49, %67 ]
  %79 = phi i64 [ %17, %113 ], [ %100, %94 ], [ %79, %77 ], [ %50, %67 ]
  %80 = phi { i64, [24 x i8] } [ %118, %113 ], [ %103, %94 ], [ %80, %77 ], [ %71, %67 ]
  %81 = extractvalue { ptr, ptr, i64 } %8, 1
  %82 = load i64, ptr %81, align 8
  %83 = icmp eq i64 %82, 0
  %84 = sub i64 %82, 1
  %85 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %84, ptr %85, align 8
  br i1 %83, label %86, label %77

86:                                               ; preds = %77
  %87 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %78, 0
  %88 = insertvalue { i64, i64, { i64, [24 x i8] } } %87, i64 %79, 1
  %89 = insertvalue { i64, i64, { i64, [24 x i8] } } %88, { i64, [24 x i8] } %80, 2
  ret { i64, i64, { i64, [24 x i8] } } %89

90:                                               ; preds = %67
  %91 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %49, 0
  %92 = insertvalue { i64, i64, { i64, [24 x i8] } } %91, i64 %50, 1
  %93 = insertvalue { i64, i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %71, 2
  ret { i64, i64, { i64, [24 x i8] } } %93

94:                                               ; preds = %27
  %95 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$6"({ ptr, i32, i32, i32 } %95)
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = load i64, ptr %97, align 8
  %99 = mul i64 %98, 16700
  %100 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %99)
  %101 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %19, 0
  %102 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %101, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %102, ptr %11, align 8
  %103 = load { i64, [24 x i8] }, ptr %11, align 8
  %104 = extractvalue { ptr, ptr, i64 } %8, 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %105, 1
  %108 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %107, ptr %108, align 8
  br i1 %106, label %109, label %77

109:                                              ; preds = %94
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, i64 %100, 1
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %103, 2
  ret { i64, i64, { i64, [24 x i8] } } %112

113:                                              ; preds = %15
  %114 = phi { ptr, i32, i32, i32 } [ %19, %15 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %114)
  call void @"drop$7"({ { ptr, i32, i32, i32 } } %18)
  %115 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %116 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %115, 0
  %117 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %116, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %117, ptr %10, align 8
  %118 = load { i64, [24 x i8] }, ptr %10, align 8
  %119 = extractvalue { ptr, ptr, i64 } %8, 1
  %120 = load i64, ptr %119, align 8
  %121 = icmp eq i64 %120, 0
  %122 = sub i64 %120, 1
  %123 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %122, ptr %123, align 8
  br i1 %121, label %124, label %77

124:                                              ; preds = %113
  %125 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %126 = insertvalue { i64, i64, { i64, [24 x i8] } } %125, i64 %17, 1
  %127 = insertvalue { i64, i64, { i64, [24 x i8] } } %126, { i64, [24 x i8] } %118, 2
  ret { i64, i64, { i64, [24 x i8] } } %127

128:                                              ; preds = %53
  call void @puts(ptr @assert_msg_196)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f137(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f137"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f137(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f137(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f138"(i64 %0, i8 %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = icmp eq i8 %1, -1
  br i1 %10, label %87, label %11

11:                                               ; preds = %2
  %12 = phi i8 [ %1, %2 ]
  %13 = add i64 %0, 1
  %14 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 %12, i8 -128)
  %15 = extractvalue { i8, i1 } %14, 1
  br i1 %15, label %67, label %16

16:                                               ; preds = %11
  %17 = phi i64 [ %13, %11 ]
  %18 = phi i8 [ %12, %11 ]
  %19 = phi i8 [ -128, %11 ]
  %20 = add i64 %17, 1
  %21 = call { i8, i1 } @llvm.usub.with.overflow.i8(i8 %18, i8 %19)
  %22 = extractvalue { i8, i1 } %21, 0
  %23 = extractvalue { i8, i1 } %21, 1
  br i1 %23, label %60, label %24

24:                                               ; preds = %16
  %25 = phi i64 [ %20, %16 ]
  %26 = phi i8 [ %22, %16 ]
  %27 = icmp ult i8 %26, -128
  %28 = add i64 %25, 1
  br i1 %27, label %29, label %79

29:                                               ; preds = %24
  %30 = phi i64 [ %28, %24 ]
  %31 = phi i8 [ 0, %24 ]
  %32 = phi i8 [ %26, %24 ]
  %33 = add i64 %30, 1
  %34 = call { i8, i1 } @llvm.ssub.with.overflow.i8(i8 %31, i8 %32)
  %35 = extractvalue { i8, i1 } %34, 0
  %36 = extractvalue { i8, i1 } %34, 1
  br i1 %36, label %44, label %37

37:                                               ; preds = %29
  %38 = add i64 %30, 2
  %39 = insertvalue { i8 } undef, i8 %35, 0
  %40 = insertvalue { i1, { i8 } } { i1 false, { i8 } undef }, { i8 } %39, 1
  store { i1, { i8 } } %40, ptr %9, align 1
  %41 = load { i64, [24 x i8] }, ptr %9, align 8
  %42 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %38, 0
  %43 = insertvalue { i64, { i64, [24 x i8] } } %42, { i64, [24 x i8] } %41, 1
  ret { i64, { i64, [24 x i8] } } %43

44:                                               ; preds = %29
  %45 = icmp sge i8 %35, 0
  br i1 %45, label %46, label %53

46:                                               ; preds = %44
  %47 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f110"()
  %48 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %47, 0
  %49 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %48, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %49, ptr %8, align 8
  %50 = load { i64, [24 x i8] }, ptr %8, align 8
  %51 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %33, 0
  %52 = insertvalue { i64, { i64, [24 x i8] } } %51, { i64, [24 x i8] } %50, 1
  ret { i64, { i64, [24 x i8] } } %52

53:                                               ; preds = %44
  %54 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f111"()
  %55 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %54, 0
  %56 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %55, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %56, ptr %7, align 8
  %57 = load { i64, [24 x i8] }, ptr %7, align 8
  %58 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %33, 0
  %59 = insertvalue { i64, { i64, [24 x i8] } } %58, { i64, [24 x i8] } %57, 1
  ret { i64, { i64, [24 x i8] } } %59

60:                                               ; preds = %16
  %61 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f123"()
  %62 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %61, 0
  %63 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %62, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %63, ptr %6, align 8
  %64 = load { i64, [24 x i8] }, ptr %6, align 8
  %65 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %66 = insertvalue { i64, { i64, [24 x i8] } } %65, { i64, [24 x i8] } %64, 1
  ret { i64, { i64, [24 x i8] } } %66

67:                                               ; preds = %11
  %68 = phi i64 [ %13, %11 ]
  %69 = phi i8 [ %12, %11 ]
  %70 = icmp ult i8 %69, -128
  %71 = add i64 %68, 1
  br i1 %70, label %72, label %79

72:                                               ; preds = %67
  %73 = phi i8 [ %69, %67 ]
  %74 = insertvalue { i8 } undef, i8 %73, 0
  %75 = insertvalue { i1, { i8 } } { i1 false, { i8 } undef }, { i8 } %74, 1
  store { i1, { i8 } } %75, ptr %5, align 1
  %76 = load { i64, [24 x i8] }, ptr %5, align 8
  %77 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %71, 0
  %78 = insertvalue { i64, { i64, [24 x i8] } } %77, { i64, [24 x i8] } %76, 1
  ret { i64, { i64, [24 x i8] } } %78

79:                                               ; preds = %67, %24
  %80 = phi i64 [ %71, %67 ], [ %28, %24 ]
  %81 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %82 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %81, 0
  %83 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %82, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %83, ptr %4, align 8
  %84 = load { i64, [24 x i8] }, ptr %4, align 8
  %85 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %80, 0
  %86 = insertvalue { i64, { i64, [24 x i8] } } %85, { i64, [24 x i8] } %84, 1
  ret { i64, { i64, [24 x i8] } } %86

87:                                               ; preds = %2
  %88 = phi i8 [ -128, %2 ]
  %89 = insertvalue { i8 } undef, i8 %88, 0
  %90 = insertvalue { i1, { i8 } } { i1 false, { i8 } undef }, { i8 } %89, 1
  store { i1, { i8 } } %90, ptr %3, align 1
  %91 = load { i64, [24 x i8] }, ptr %3, align 8
  %92 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %0, 0
  %93 = insertvalue { i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %91, 1
  ret { i64, { i64, [24 x i8] } } %93
}

define private { i64, { i64, [24 x i8] } } @f138(i64 %0, i8 %1) {
  %3 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f138"(i64 %0, i8 %1)
  %4 = extractvalue { i64, { i64, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { i64, [24 x i8] } } %3, 1
  %6 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %5, 1
  ret { i64, { i64, [24 x i8] } } %7
}

define void @_mlir_ciface_f138(ptr %0, i64 %1, i8 %2) {
  %4 = call { i64, { i64, [24 x i8] } } @f138(i64 %1, i8 %2)
  store { i64, { i64, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, { i64, [24 x i8] } } @"impl$f139"(i64 %0, i16 %1) {
  %3 = alloca { i64, [24 x i8] }, i64 1, align 8
  %4 = alloca { i64, [24 x i8] }, i64 1, align 8
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = alloca { i64, [24 x i8] }, i64 1, align 8
  %9 = alloca { i64, [24 x i8] }, i64 1, align 8
  %10 = icmp eq i16 %1, -1
  br i1 %10, label %87, label %11

11:                                               ; preds = %2
  %12 = phi i16 [ %1, %2 ]
  %13 = add i64 %0, 1
  %14 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 %12, i16 -32768)
  %15 = extractvalue { i16, i1 } %14, 1
  br i1 %15, label %67, label %16

16:                                               ; preds = %11
  %17 = phi i64 [ %13, %11 ]
  %18 = phi i16 [ %12, %11 ]
  %19 = phi i16 [ -32768, %11 ]
  %20 = add i64 %17, 1
  %21 = call { i16, i1 } @llvm.usub.with.overflow.i16(i16 %18, i16 %19)
  %22 = extractvalue { i16, i1 } %21, 0
  %23 = extractvalue { i16, i1 } %21, 1
  br i1 %23, label %60, label %24

24:                                               ; preds = %16
  %25 = phi i64 [ %20, %16 ]
  %26 = phi i16 [ %22, %16 ]
  %27 = icmp ult i16 %26, -32768
  %28 = add i64 %25, 1
  br i1 %27, label %29, label %79

29:                                               ; preds = %24
  %30 = phi i64 [ %28, %24 ]
  %31 = phi i16 [ 0, %24 ]
  %32 = phi i16 [ %26, %24 ]
  %33 = add i64 %30, 1
  %34 = call { i16, i1 } @llvm.ssub.with.overflow.i16(i16 %31, i16 %32)
  %35 = extractvalue { i16, i1 } %34, 0
  %36 = extractvalue { i16, i1 } %34, 1
  br i1 %36, label %44, label %37

37:                                               ; preds = %29
  %38 = add i64 %30, 2
  %39 = insertvalue { i16 } undef, i16 %35, 0
  %40 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %39, 1
  store { i1, { i16 } } %40, ptr %9, align 2
  %41 = load { i64, [24 x i8] }, ptr %9, align 8
  %42 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %38, 0
  %43 = insertvalue { i64, { i64, [24 x i8] } } %42, { i64, [24 x i8] } %41, 1
  ret { i64, { i64, [24 x i8] } } %43

44:                                               ; preds = %29
  %45 = icmp sge i16 %35, 0
  br i1 %45, label %46, label %53

46:                                               ; preds = %44
  %47 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f113"()
  %48 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %47, 0
  %49 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %48, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %49, ptr %8, align 8
  %50 = load { i64, [24 x i8] }, ptr %8, align 8
  %51 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %33, 0
  %52 = insertvalue { i64, { i64, [24 x i8] } } %51, { i64, [24 x i8] } %50, 1
  ret { i64, { i64, [24 x i8] } } %52

53:                                               ; preds = %44
  %54 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f114"()
  %55 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %54, 0
  %56 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %55, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %56, ptr %7, align 8
  %57 = load { i64, [24 x i8] }, ptr %7, align 8
  %58 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %33, 0
  %59 = insertvalue { i64, { i64, [24 x i8] } } %58, { i64, [24 x i8] } %57, 1
  ret { i64, { i64, [24 x i8] } } %59

60:                                               ; preds = %16
  %61 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f130"()
  %62 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %61, 0
  %63 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %62, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %63, ptr %6, align 8
  %64 = load { i64, [24 x i8] }, ptr %6, align 8
  %65 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %66 = insertvalue { i64, { i64, [24 x i8] } } %65, { i64, [24 x i8] } %64, 1
  ret { i64, { i64, [24 x i8] } } %66

67:                                               ; preds = %11
  %68 = phi i64 [ %13, %11 ]
  %69 = phi i16 [ %12, %11 ]
  %70 = icmp ult i16 %69, -32768
  %71 = add i64 %68, 1
  br i1 %70, label %72, label %79

72:                                               ; preds = %67
  %73 = phi i16 [ %69, %67 ]
  %74 = insertvalue { i16 } undef, i16 %73, 0
  %75 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %74, 1
  store { i1, { i16 } } %75, ptr %5, align 2
  %76 = load { i64, [24 x i8] }, ptr %5, align 8
  %77 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %71, 0
  %78 = insertvalue { i64, { i64, [24 x i8] } } %77, { i64, [24 x i8] } %76, 1
  ret { i64, { i64, [24 x i8] } } %78

79:                                               ; preds = %67, %24
  %80 = phi i64 [ %71, %67 ], [ %28, %24 ]
  %81 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f77"()
  %82 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %81, 0
  %83 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %82, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %83, ptr %4, align 8
  %84 = load { i64, [24 x i8] }, ptr %4, align 8
  %85 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %80, 0
  %86 = insertvalue { i64, { i64, [24 x i8] } } %85, { i64, [24 x i8] } %84, 1
  ret { i64, { i64, [24 x i8] } } %86

87:                                               ; preds = %2
  %88 = phi i16 [ -32768, %2 ]
  %89 = insertvalue { i16 } undef, i16 %88, 0
  %90 = insertvalue { i1, { i16 } } { i1 false, { i16 } undef }, { i16 } %89, 1
  store { i1, { i16 } } %90, ptr %3, align 2
  %91 = load { i64, [24 x i8] }, ptr %3, align 8
  %92 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %0, 0
  %93 = insertvalue { i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %91, 1
  ret { i64, { i64, [24 x i8] } } %93
}

define private { i64, { i64, [24 x i8] } } @f139(i64 %0, i16 %1) {
  %3 = call fastcc { i64, { i64, [24 x i8] } } @"impl$f139"(i64 %0, i16 %1)
  %4 = extractvalue { i64, { i64, [24 x i8] } } %3, 0
  %5 = extractvalue { i64, { i64, [24 x i8] } } %3, 1
  %6 = insertvalue { i64, { i64, [24 x i8] } } undef, i64 %4, 0
  %7 = insertvalue { i64, { i64, [24 x i8] } } %6, { i64, [24 x i8] } %5, 1
  ret { i64, { i64, [24 x i8] } } %7
}

define void @_mlir_ciface_f139(ptr %0, i64 %1, i16 %2) {
  %4 = call { i64, { i64, [24 x i8] } } @f139(i64 %1, i16 %2)
  store { i64, { i64, [24 x i8] } } %4, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f140"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i128, [80 x i8] }, i64 1, align 16
  %8 = load { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, ptr %2, align 16
  %9 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %8)
  %10 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %9, 0
  %11 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %9, 1
  %12 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %11, 1
  %13 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %11, 2
  call void @"drop$19"({ i128, [80 x i8] } %13)
  %14 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %12)
  %15 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %14, 0
  %16 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %14, 1
  %17 = extractvalue { { ptr, i32, i32, i32 } } %16, 0
  %18 = extractvalue { ptr, i32, i32, i32 } %17, 1
  %19 = extractvalue { ptr, i32, i32, i32 } %17, 2
  %20 = sub i32 %19, %18
  call void @"drop$3"({ ptr, i32, i32, i32 } %17)
  %21 = zext i32 %20 to i252
  %22 = call { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } @"dup$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %10)
  %23 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %22, 0
  %24 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } }, { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } } %22, 1
  %25 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %24, 0
  %26 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %24, 1
  %27 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %24, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %26)
  call void @"drop$19"({ i128, [80 x i8] } %27)
  %28 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %30, label %44

30:                                               ; preds = %4
  %31 = shl i32 %28, 1
  %32 = call i32 @llvm.umin.i32(i32 %31, i32 1024)
  %33 = add i32 %32, %28
  %34 = call i32 @llvm.umax.i32(i32 %33, i32 8)
  %35 = zext i32 %34 to i64
  %36 = mul i64 %35, 32
  %37 = add i64 %36, 16
  %38 = call ptr @realloc(ptr null, i64 %37)
  store i32 1, ptr %38, align 4
  %39 = getelementptr inbounds i8, ptr %38, i32 4
  store i32 0, ptr %39, align 4
  %40 = getelementptr inbounds i8, ptr %38, i32 16
  %41 = call ptr @realloc(ptr null, i64 8)
  store ptr %40, ptr %41, align 8
  %42 = insertvalue { ptr, i32, i32, i32 } %3, ptr %41, 0
  %43 = insertvalue { ptr, i32, i32, i32 } %42, i32 %34, 3
  br label %65

44:                                               ; preds = %4
  %45 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %46 = icmp ult i32 %45, %28
  br i1 %46, label %47, label %48

47:                                               ; preds = %44
  br label %62

48:                                               ; preds = %44
  %49 = shl i32 %28, 1
  %50 = call i32 @llvm.umin.i32(i32 %49, i32 1024)
  %51 = add i32 %50, %28
  %52 = call i32 @llvm.umax.i32(i32 %51, i32 8)
  %53 = zext i32 %52 to i64
  %54 = mul i64 %53, 32
  %55 = add i64 %54, 16
  %56 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr inbounds i8, ptr %57, i32 -16
  %59 = call ptr @realloc(ptr %58, i64 %55)
  %60 = getelementptr inbounds i8, ptr %59, i32 16
  store ptr %60, ptr %56, align 8
  %61 = insertvalue { ptr, i32, i32, i32 } %3, i32 %52, 3
  br label %62

62:                                               ; preds = %47, %48
  %63 = phi { ptr, i32, i32, i32 } [ %61, %48 ], [ %3, %47 ]
  br label %64

64:                                               ; preds = %62
  br label %65

65:                                               ; preds = %30, %64
  %66 = phi { ptr, i32, i32, i32 } [ %63, %64 ], [ %43, %30 ]
  br label %67

67:                                               ; preds = %65
  %68 = extractvalue { ptr, i32, i32, i32 } %66, 0
  %69 = load ptr, ptr %68, align 8
  %70 = extractvalue { ptr, i32, i32, i32 } %66, 2
  %71 = zext i32 %70 to i64
  %72 = mul i64 %71, 32
  %73 = getelementptr inbounds i8, ptr %69, i64 %72
  store i252 %25, ptr %73, align 16
  %74 = extractvalue { ptr, i32, i32, i32 } %66, 2
  %75 = add i32 %74, 1
  %76 = insertvalue { ptr, i32, i32, i32 } %66, i32 %75, 2
  %77 = getelementptr inbounds i8, ptr %69, i32 -12
  store i32 %75, ptr %77, align 4
  %78 = extractvalue { ptr, i32, i32, i32 } %66, 3
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %94

80:                                               ; preds = %67
  %81 = shl i32 %78, 1
  %82 = call i32 @llvm.umin.i32(i32 %81, i32 1024)
  %83 = add i32 %82, %78
  %84 = call i32 @llvm.umax.i32(i32 %83, i32 8)
  %85 = zext i32 %84 to i64
  %86 = mul i64 %85, 32
  %87 = add i64 %86, 16
  %88 = call ptr @realloc(ptr null, i64 %87)
  store i32 1, ptr %88, align 4
  %89 = getelementptr inbounds i8, ptr %88, i32 4
  store i32 0, ptr %89, align 4
  %90 = getelementptr inbounds i8, ptr %88, i32 16
  %91 = call ptr @realloc(ptr null, i64 8)
  store ptr %90, ptr %91, align 8
  %92 = insertvalue { ptr, i32, i32, i32 } %76, ptr %91, 0
  %93 = insertvalue { ptr, i32, i32, i32 } %92, i32 %84, 3
  br label %114

94:                                               ; preds = %67
  %95 = icmp ult i32 %75, %78
  br i1 %95, label %96, label %97

96:                                               ; preds = %94
  br label %111

97:                                               ; preds = %94
  %98 = shl i32 %78, 1
  %99 = call i32 @llvm.umin.i32(i32 %98, i32 1024)
  %100 = add i32 %99, %78
  %101 = call i32 @llvm.umax.i32(i32 %100, i32 8)
  %102 = zext i32 %101 to i64
  %103 = mul i64 %102, 32
  %104 = add i64 %103, 16
  %105 = extractvalue { ptr, i32, i32, i32 } %66, 0
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr inbounds i8, ptr %106, i32 -16
  %108 = call ptr @realloc(ptr %107, i64 %104)
  %109 = getelementptr inbounds i8, ptr %108, i32 16
  store ptr %109, ptr %105, align 8
  %110 = insertvalue { ptr, i32, i32, i32 } %76, i32 %101, 3
  br label %111

111:                                              ; preds = %96, %97
  %112 = phi { ptr, i32, i32, i32 } [ %110, %97 ], [ %76, %96 ]
  br label %113

113:                                              ; preds = %111
  br label %114

114:                                              ; preds = %80, %113
  %115 = phi { ptr, i32, i32, i32 } [ %112, %113 ], [ %93, %80 ]
  br label %116

116:                                              ; preds = %114
  %117 = extractvalue { ptr, i32, i32, i32 } %115, 0
  %118 = load ptr, ptr %117, align 8
  %119 = extractvalue { ptr, i32, i32, i32 } %115, 2
  %120 = zext i32 %119 to i64
  %121 = mul i64 %120, 32
  %122 = getelementptr inbounds i8, ptr %118, i64 %121
  store i252 %21, ptr %122, align 16
  %123 = extractvalue { ptr, i32, i32, i32 } %115, 2
  %124 = add i32 %123, 1
  %125 = insertvalue { ptr, i32, i32, i32 } %115, i32 %124, 2
  %126 = getelementptr inbounds i8, ptr %118, i32 -12
  store i32 %124, ptr %126, align 4
  %127 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %15, { ptr, i32, i32, i32 } %125)
  %128 = extractvalue { i64, i64, { i64, [24 x i8] } } %127, 0
  %129 = extractvalue { i64, i64, { i64, [24 x i8] } } %127, 1
  %130 = extractvalue { i64, i64, { i64, [24 x i8] } } %127, 2
  store { i64, [24 x i8] } %130, ptr %5, align 8
  %131 = load i1, ptr %5, align 1
  switch i1 %131, label %132 [
    i1 false, label %134
    i1 true, label %150
  ]

132:                                              ; preds = %116
  br i1 false, label %133, label %158

133:                                              ; preds = %132
  unreachable

134:                                              ; preds = %116
  %135 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %136 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %135, 1
  %137 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %138 = call ptr %137()
  %139 = call i64 @llvm.uadd.sat.i64(i64 %129, i64 0)
  %140 = extractvalue { { ptr, i32, i32, i32 }, {} } %136, 0
  %141 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %23, 1
  %142 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %23, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %141)
  store { i128, [80 x i8] } %142, ptr %7, align 16
  %143 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f141"(i64 %128, i64 %139, ptr %7, { ptr, i32, i32, i32 } %140)
  %144 = extractvalue { i64, i64, { i64, [24 x i8] } } %143, 0
  %145 = extractvalue { i64, i64, { i64, [24 x i8] } } %143, 1
  %146 = extractvalue { i64, i64, { i64, [24 x i8] } } %143, 2
  %147 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %144, 0
  %148 = insertvalue { i64, i64, { i64, [24 x i8] } } %147, i64 %145, 1
  %149 = insertvalue { i64, i64, { i64, [24 x i8] } } %148, { i64, [24 x i8] } %146, 2
  ret { i64, i64, { i64, [24 x i8] } } %149

150:                                              ; preds = %116
  %151 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %152 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %151, 1
  call void @"drop$281"({ i252, { { ptr, i32, i32, i32 } }, { i128, [80 x i8] } } %23)
  %153 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %152, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %153, ptr %6, align 8
  %154 = load { i64, [24 x i8] }, ptr %6, align 8
  %155 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %128, 0
  %156 = insertvalue { i64, i64, { i64, [24 x i8] } } %155, i64 %129, 1
  %157 = insertvalue { i64, i64, { i64, [24 x i8] } } %156, { i64, [24 x i8] } %154, 2
  ret { i64, i64, { i64, [24 x i8] } } %157

158:                                              ; preds = %132
  call void @puts(ptr @assert_msg_197)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f140(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f140"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f140(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f140(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f141"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = load { i128, [80 x i8] }, ptr %2, align 16
  store { i128, [80 x i8] } %7, ptr %5, align 16
  %8 = load i3, ptr %5, align 1
  switch i3 %8, label %9 [
    i3 0, label %11
    i3 1, label %118
    i3 2, label %181
    i3 3, label %244
    i3 -4, label %309
    i3 -3, label %374
    i3 -2, label %430
  ]

9:                                                ; preds = %4
  br i1 false, label %10, label %505

10:                                               ; preds = %9
  unreachable

11:                                               ; preds = %4
  %12 = load { i3, i252 }, ptr %5, align 16
  %13 = extractvalue { i3, i252 } %12, 1
  %14 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %15 = call ptr %14()
  %16 = load i64, ptr %15, align 8
  %17 = mul i64 %16, 7160
  %18 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %17)
  %19 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %35

21:                                               ; preds = %11
  %22 = shl i32 %19, 1
  %23 = call i32 @llvm.umin.i32(i32 %22, i32 1024)
  %24 = add i32 %23, %19
  %25 = call i32 @llvm.umax.i32(i32 %24, i32 8)
  %26 = zext i32 %25 to i64
  %27 = mul i64 %26, 32
  %28 = add i64 %27, 16
  %29 = call ptr @realloc(ptr null, i64 %28)
  store i32 1, ptr %29, align 4
  %30 = getelementptr inbounds i8, ptr %29, i32 4
  store i32 0, ptr %30, align 4
  %31 = getelementptr inbounds i8, ptr %29, i32 16
  %32 = call ptr @realloc(ptr null, i64 8)
  store ptr %31, ptr %32, align 8
  %33 = insertvalue { ptr, i32, i32, i32 } %3, ptr %32, 0
  %34 = insertvalue { ptr, i32, i32, i32 } %33, i32 %25, 3
  br label %56

35:                                               ; preds = %11
  %36 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %37 = icmp ult i32 %36, %19
  br i1 %37, label %38, label %39

38:                                               ; preds = %35
  br label %53

39:                                               ; preds = %35
  %40 = shl i32 %19, 1
  %41 = call i32 @llvm.umin.i32(i32 %40, i32 1024)
  %42 = add i32 %41, %19
  %43 = call i32 @llvm.umax.i32(i32 %42, i32 8)
  %44 = zext i32 %43 to i64
  %45 = mul i64 %44, 32
  %46 = add i64 %45, 16
  %47 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr inbounds i8, ptr %48, i32 -16
  %50 = call ptr @realloc(ptr %49, i64 %46)
  %51 = getelementptr inbounds i8, ptr %50, i32 16
  store ptr %51, ptr %47, align 8
  %52 = insertvalue { ptr, i32, i32, i32 } %3, i32 %43, 3
  br label %53

53:                                               ; preds = %38, %39
  %54 = phi { ptr, i32, i32, i32 } [ %52, %39 ], [ %3, %38 ]
  br label %55

55:                                               ; preds = %53
  br label %56

56:                                               ; preds = %21, %55
  %57 = phi { ptr, i32, i32, i32 } [ %54, %55 ], [ %34, %21 ]
  br label %58

58:                                               ; preds = %56
  %59 = extractvalue { ptr, i32, i32, i32 } %57, 0
  %60 = load ptr, ptr %59, align 8
  %61 = extractvalue { ptr, i32, i32, i32 } %57, 2
  %62 = zext i32 %61 to i64
  %63 = mul i64 %62, 32
  %64 = getelementptr inbounds i8, ptr %60, i64 %63
  store i252 0, ptr %64, align 16
  %65 = extractvalue { ptr, i32, i32, i32 } %57, 2
  %66 = add i32 %65, 1
  %67 = insertvalue { ptr, i32, i32, i32 } %57, i32 %66, 2
  %68 = getelementptr inbounds i8, ptr %60, i32 -12
  store i32 %66, ptr %68, align 4
  %69 = extractvalue { ptr, i32, i32, i32 } %57, 3
  %70 = icmp eq i32 %69, 0
  br i1 %70, label %71, label %85

71:                                               ; preds = %58
  %72 = shl i32 %69, 1
  %73 = call i32 @llvm.umin.i32(i32 %72, i32 1024)
  %74 = add i32 %73, %69
  %75 = call i32 @llvm.umax.i32(i32 %74, i32 8)
  %76 = zext i32 %75 to i64
  %77 = mul i64 %76, 32
  %78 = add i64 %77, 16
  %79 = call ptr @realloc(ptr null, i64 %78)
  store i32 1, ptr %79, align 4
  %80 = getelementptr inbounds i8, ptr %79, i32 4
  store i32 0, ptr %80, align 4
  %81 = getelementptr inbounds i8, ptr %79, i32 16
  %82 = call ptr @realloc(ptr null, i64 8)
  store ptr %81, ptr %82, align 8
  %83 = insertvalue { ptr, i32, i32, i32 } %67, ptr %82, 0
  %84 = insertvalue { ptr, i32, i32, i32 } %83, i32 %75, 3
  br label %105

85:                                               ; preds = %58
  %86 = icmp ult i32 %66, %69
  br i1 %86, label %87, label %88

87:                                               ; preds = %85
  br label %102

88:                                               ; preds = %85
  %89 = shl i32 %69, 1
  %90 = call i32 @llvm.umin.i32(i32 %89, i32 1024)
  %91 = add i32 %90, %69
  %92 = call i32 @llvm.umax.i32(i32 %91, i32 8)
  %93 = zext i32 %92 to i64
  %94 = mul i64 %93, 32
  %95 = add i64 %94, 16
  %96 = extractvalue { ptr, i32, i32, i32 } %57, 0
  %97 = load ptr, ptr %96, align 8
  %98 = getelementptr inbounds i8, ptr %97, i32 -16
  %99 = call ptr @realloc(ptr %98, i64 %95)
  %100 = getelementptr inbounds i8, ptr %99, i32 16
  store ptr %100, ptr %96, align 8
  %101 = insertvalue { ptr, i32, i32, i32 } %67, i32 %92, 3
  br label %102

102:                                              ; preds = %87, %88
  %103 = phi { ptr, i32, i32, i32 } [ %101, %88 ], [ %67, %87 ]
  br label %104

104:                                              ; preds = %102
  br label %105

105:                                              ; preds = %71, %104
  %106 = phi { ptr, i32, i32, i32 } [ %103, %104 ], [ %84, %71 ]
  br label %107

107:                                              ; preds = %105
  %108 = extractvalue { ptr, i32, i32, i32 } %106, 0
  %109 = load ptr, ptr %108, align 8
  %110 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %111 = zext i32 %110 to i64
  %112 = mul i64 %111, 32
  %113 = getelementptr inbounds i8, ptr %109, i64 %112
  store i252 %13, ptr %113, align 16
  %114 = extractvalue { ptr, i32, i32, i32 } %106, 2
  %115 = add i32 %114, 1
  %116 = insertvalue { ptr, i32, i32, i32 } %106, i32 %115, 2
  %117 = getelementptr inbounds i8, ptr %109, i32 -12
  store i32 %115, ptr %117, align 4
  br label %495

118:                                              ; preds = %4
  %119 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %5, align 16
  %120 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %119, 1
  %121 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %122 = call ptr %121()
  %123 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %124 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %125 = icmp eq i32 %124, 0
  br i1 %125, label %126, label %140

126:                                              ; preds = %118
  %127 = shl i32 %124, 1
  %128 = call i32 @llvm.umin.i32(i32 %127, i32 1024)
  %129 = add i32 %128, %124
  %130 = call i32 @llvm.umax.i32(i32 %129, i32 8)
  %131 = zext i32 %130 to i64
  %132 = mul i64 %131, 32
  %133 = add i64 %132, 16
  %134 = call ptr @realloc(ptr null, i64 %133)
  store i32 1, ptr %134, align 4
  %135 = getelementptr inbounds i8, ptr %134, i32 4
  store i32 0, ptr %135, align 4
  %136 = getelementptr inbounds i8, ptr %134, i32 16
  %137 = call ptr @realloc(ptr null, i64 8)
  store ptr %136, ptr %137, align 8
  %138 = insertvalue { ptr, i32, i32, i32 } %3, ptr %137, 0
  %139 = insertvalue { ptr, i32, i32, i32 } %138, i32 %130, 3
  br label %161

140:                                              ; preds = %118
  %141 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %142 = icmp ult i32 %141, %124
  br i1 %142, label %143, label %144

143:                                              ; preds = %140
  br label %158

144:                                              ; preds = %140
  %145 = shl i32 %124, 1
  %146 = call i32 @llvm.umin.i32(i32 %145, i32 1024)
  %147 = add i32 %146, %124
  %148 = call i32 @llvm.umax.i32(i32 %147, i32 8)
  %149 = zext i32 %148 to i64
  %150 = mul i64 %149, 32
  %151 = add i64 %150, 16
  %152 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %153 = load ptr, ptr %152, align 8
  %154 = getelementptr inbounds i8, ptr %153, i32 -16
  %155 = call ptr @realloc(ptr %154, i64 %151)
  %156 = getelementptr inbounds i8, ptr %155, i32 16
  store ptr %156, ptr %152, align 8
  %157 = insertvalue { ptr, i32, i32, i32 } %3, i32 %148, 3
  br label %158

158:                                              ; preds = %143, %144
  %159 = phi { ptr, i32, i32, i32 } [ %157, %144 ], [ %3, %143 ]
  br label %160

160:                                              ; preds = %158
  br label %161

161:                                              ; preds = %126, %160
  %162 = phi { ptr, i32, i32, i32 } [ %159, %160 ], [ %139, %126 ]
  br label %163

163:                                              ; preds = %161
  %164 = extractvalue { ptr, i32, i32, i32 } %162, 0
  %165 = load ptr, ptr %164, align 8
  %166 = extractvalue { ptr, i32, i32, i32 } %162, 2
  %167 = zext i32 %166 to i64
  %168 = mul i64 %167, 32
  %169 = getelementptr inbounds i8, ptr %165, i64 %168
  store i252 1, ptr %169, align 16
  %170 = extractvalue { ptr, i32, i32, i32 } %162, 2
  %171 = add i32 %170, 1
  %172 = insertvalue { ptr, i32, i32, i32 } %162, i32 %171, 2
  %173 = getelementptr inbounds i8, ptr %165, i32 -12
  store i32 %171, ptr %173, align 4
  %174 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f118"(i64 %0, i64 %123, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %120, { ptr, i32, i32, i32 } %172)
  %175 = extractvalue { i64, i64, { i64, [24 x i8] } } %174, 0
  %176 = extractvalue { i64, i64, { i64, [24 x i8] } } %174, 1
  %177 = extractvalue { i64, i64, { i64, [24 x i8] } } %174, 2
  %178 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %175, 0
  %179 = insertvalue { i64, i64, { i64, [24 x i8] } } %178, i64 %176, 1
  %180 = insertvalue { i64, i64, { i64, [24 x i8] } } %179, { i64, [24 x i8] } %177, 2
  ret { i64, i64, { i64, [24 x i8] } } %180

181:                                              ; preds = %4
  %182 = load { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } }, ptr %5, align 16
  %183 = extractvalue { i3, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %182, 1
  %184 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %185 = call ptr %184()
  %186 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 0)
  %187 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %188 = icmp eq i32 %187, 0
  br i1 %188, label %189, label %203

189:                                              ; preds = %181
  %190 = shl i32 %187, 1
  %191 = call i32 @llvm.umin.i32(i32 %190, i32 1024)
  %192 = add i32 %191, %187
  %193 = call i32 @llvm.umax.i32(i32 %192, i32 8)
  %194 = zext i32 %193 to i64
  %195 = mul i64 %194, 32
  %196 = add i64 %195, 16
  %197 = call ptr @realloc(ptr null, i64 %196)
  store i32 1, ptr %197, align 4
  %198 = getelementptr inbounds i8, ptr %197, i32 4
  store i32 0, ptr %198, align 4
  %199 = getelementptr inbounds i8, ptr %197, i32 16
  %200 = call ptr @realloc(ptr null, i64 8)
  store ptr %199, ptr %200, align 8
  %201 = insertvalue { ptr, i32, i32, i32 } %3, ptr %200, 0
  %202 = insertvalue { ptr, i32, i32, i32 } %201, i32 %193, 3
  br label %224

203:                                              ; preds = %181
  %204 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %205 = icmp ult i32 %204, %187
  br i1 %205, label %206, label %207

206:                                              ; preds = %203
  br label %221

207:                                              ; preds = %203
  %208 = shl i32 %187, 1
  %209 = call i32 @llvm.umin.i32(i32 %208, i32 1024)
  %210 = add i32 %209, %187
  %211 = call i32 @llvm.umax.i32(i32 %210, i32 8)
  %212 = zext i32 %211 to i64
  %213 = mul i64 %212, 32
  %214 = add i64 %213, 16
  %215 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %216 = load ptr, ptr %215, align 8
  %217 = getelementptr inbounds i8, ptr %216, i32 -16
  %218 = call ptr @realloc(ptr %217, i64 %214)
  %219 = getelementptr inbounds i8, ptr %218, i32 16
  store ptr %219, ptr %215, align 8
  %220 = insertvalue { ptr, i32, i32, i32 } %3, i32 %211, 3
  br label %221

221:                                              ; preds = %206, %207
  %222 = phi { ptr, i32, i32, i32 } [ %220, %207 ], [ %3, %206 ]
  br label %223

223:                                              ; preds = %221
  br label %224

224:                                              ; preds = %189, %223
  %225 = phi { ptr, i32, i32, i32 } [ %222, %223 ], [ %202, %189 ]
  br label %226

226:                                              ; preds = %224
  %227 = extractvalue { ptr, i32, i32, i32 } %225, 0
  %228 = load ptr, ptr %227, align 8
  %229 = extractvalue { ptr, i32, i32, i32 } %225, 2
  %230 = zext i32 %229 to i64
  %231 = mul i64 %230, 32
  %232 = getelementptr inbounds i8, ptr %228, i64 %231
  store i252 2, ptr %232, align 16
  %233 = extractvalue { ptr, i32, i32, i32 } %225, 2
  %234 = add i32 %233, 1
  %235 = insertvalue { ptr, i32, i32, i32 } %225, i32 %234, 2
  %236 = getelementptr inbounds i8, ptr %228, i32 -12
  store i32 %234, ptr %236, align 4
  %237 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f142"(i64 %0, i64 %186, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %183, { ptr, i32, i32, i32 } %235)
  %238 = extractvalue { i64, i64, { i64, [24 x i8] } } %237, 0
  %239 = extractvalue { i64, i64, { i64, [24 x i8] } } %237, 1
  %240 = extractvalue { i64, i64, { i64, [24 x i8] } } %237, 2
  %241 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %238, 0
  %242 = insertvalue { i64, i64, { i64, [24 x i8] } } %241, i64 %239, 1
  %243 = insertvalue { i64, i64, { i64, [24 x i8] } } %242, { i64, [24 x i8] } %240, 2
  ret { i64, i64, { i64, [24 x i8] } } %243

244:                                              ; preds = %4
  %245 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %246 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %245, 1
  %247 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %248 = call ptr %247()
  %249 = load i64, ptr %248, align 8
  %250 = mul i64 %249, 4170
  %251 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %250)
  %252 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %253 = icmp eq i32 %252, 0
  br i1 %253, label %254, label %268

254:                                              ; preds = %244
  %255 = shl i32 %252, 1
  %256 = call i32 @llvm.umin.i32(i32 %255, i32 1024)
  %257 = add i32 %256, %252
  %258 = call i32 @llvm.umax.i32(i32 %257, i32 8)
  %259 = zext i32 %258 to i64
  %260 = mul i64 %259, 32
  %261 = add i64 %260, 16
  %262 = call ptr @realloc(ptr null, i64 %261)
  store i32 1, ptr %262, align 4
  %263 = getelementptr inbounds i8, ptr %262, i32 4
  store i32 0, ptr %263, align 4
  %264 = getelementptr inbounds i8, ptr %262, i32 16
  %265 = call ptr @realloc(ptr null, i64 8)
  store ptr %264, ptr %265, align 8
  %266 = insertvalue { ptr, i32, i32, i32 } %3, ptr %265, 0
  %267 = insertvalue { ptr, i32, i32, i32 } %266, i32 %258, 3
  br label %289

268:                                              ; preds = %244
  %269 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %270 = icmp ult i32 %269, %252
  br i1 %270, label %271, label %272

271:                                              ; preds = %268
  br label %286

272:                                              ; preds = %268
  %273 = shl i32 %252, 1
  %274 = call i32 @llvm.umin.i32(i32 %273, i32 1024)
  %275 = add i32 %274, %252
  %276 = call i32 @llvm.umax.i32(i32 %275, i32 8)
  %277 = zext i32 %276 to i64
  %278 = mul i64 %277, 32
  %279 = add i64 %278, 16
  %280 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %281 = load ptr, ptr %280, align 8
  %282 = getelementptr inbounds i8, ptr %281, i32 -16
  %283 = call ptr @realloc(ptr %282, i64 %279)
  %284 = getelementptr inbounds i8, ptr %283, i32 16
  store ptr %284, ptr %280, align 8
  %285 = insertvalue { ptr, i32, i32, i32 } %3, i32 %276, 3
  br label %286

286:                                              ; preds = %271, %272
  %287 = phi { ptr, i32, i32, i32 } [ %285, %272 ], [ %3, %271 ]
  br label %288

288:                                              ; preds = %286
  br label %289

289:                                              ; preds = %254, %288
  %290 = phi { ptr, i32, i32, i32 } [ %287, %288 ], [ %267, %254 ]
  br label %291

291:                                              ; preds = %289
  %292 = extractvalue { ptr, i32, i32, i32 } %290, 0
  %293 = load ptr, ptr %292, align 8
  %294 = extractvalue { ptr, i32, i32, i32 } %290, 2
  %295 = zext i32 %294 to i64
  %296 = mul i64 %295, 32
  %297 = getelementptr inbounds i8, ptr %293, i64 %296
  store i252 3, ptr %297, align 16
  %298 = extractvalue { ptr, i32, i32, i32 } %290, 2
  %299 = add i32 %298, 1
  %300 = insertvalue { ptr, i32, i32, i32 } %290, i32 %299, 2
  %301 = getelementptr inbounds i8, ptr %293, i32 -12
  store i32 %299, ptr %301, align 4
  %302 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f143"(i64 %0, i64 %251, { { ptr, i32, i32, i32 } } %246, { ptr, i32, i32, i32 } %300)
  %303 = extractvalue { i64, i64, { i64, [24 x i8] } } %302, 0
  %304 = extractvalue { i64, i64, { i64, [24 x i8] } } %302, 1
  %305 = extractvalue { i64, i64, { i64, [24 x i8] } } %302, 2
  %306 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %303, 0
  %307 = insertvalue { i64, i64, { i64, [24 x i8] } } %306, i64 %304, 1
  %308 = insertvalue { i64, i64, { i64, [24 x i8] } } %307, { i64, [24 x i8] } %305, 2
  ret { i64, i64, { i64, [24 x i8] } } %308

309:                                              ; preds = %4
  %310 = load { i3, { { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %311 = extractvalue { i3, { { ptr, i32, i32, i32 } } } %310, 1
  %312 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %313 = call ptr %312()
  %314 = load i64, ptr %313, align 8
  %315 = mul i64 %314, 4170
  %316 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %315)
  %317 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %318 = icmp eq i32 %317, 0
  br i1 %318, label %319, label %333

319:                                              ; preds = %309
  %320 = shl i32 %317, 1
  %321 = call i32 @llvm.umin.i32(i32 %320, i32 1024)
  %322 = add i32 %321, %317
  %323 = call i32 @llvm.umax.i32(i32 %322, i32 8)
  %324 = zext i32 %323 to i64
  %325 = mul i64 %324, 32
  %326 = add i64 %325, 16
  %327 = call ptr @realloc(ptr null, i64 %326)
  store i32 1, ptr %327, align 4
  %328 = getelementptr inbounds i8, ptr %327, i32 4
  store i32 0, ptr %328, align 4
  %329 = getelementptr inbounds i8, ptr %327, i32 16
  %330 = call ptr @realloc(ptr null, i64 8)
  store ptr %329, ptr %330, align 8
  %331 = insertvalue { ptr, i32, i32, i32 } %3, ptr %330, 0
  %332 = insertvalue { ptr, i32, i32, i32 } %331, i32 %323, 3
  br label %354

333:                                              ; preds = %309
  %334 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %335 = icmp ult i32 %334, %317
  br i1 %335, label %336, label %337

336:                                              ; preds = %333
  br label %351

337:                                              ; preds = %333
  %338 = shl i32 %317, 1
  %339 = call i32 @llvm.umin.i32(i32 %338, i32 1024)
  %340 = add i32 %339, %317
  %341 = call i32 @llvm.umax.i32(i32 %340, i32 8)
  %342 = zext i32 %341 to i64
  %343 = mul i64 %342, 32
  %344 = add i64 %343, 16
  %345 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %346 = load ptr, ptr %345, align 8
  %347 = getelementptr inbounds i8, ptr %346, i32 -16
  %348 = call ptr @realloc(ptr %347, i64 %344)
  %349 = getelementptr inbounds i8, ptr %348, i32 16
  store ptr %349, ptr %345, align 8
  %350 = insertvalue { ptr, i32, i32, i32 } %3, i32 %341, 3
  br label %351

351:                                              ; preds = %336, %337
  %352 = phi { ptr, i32, i32, i32 } [ %350, %337 ], [ %3, %336 ]
  br label %353

353:                                              ; preds = %351
  br label %354

354:                                              ; preds = %319, %353
  %355 = phi { ptr, i32, i32, i32 } [ %352, %353 ], [ %332, %319 ]
  br label %356

356:                                              ; preds = %354
  %357 = extractvalue { ptr, i32, i32, i32 } %355, 0
  %358 = load ptr, ptr %357, align 8
  %359 = extractvalue { ptr, i32, i32, i32 } %355, 2
  %360 = zext i32 %359 to i64
  %361 = mul i64 %360, 32
  %362 = getelementptr inbounds i8, ptr %358, i64 %361
  store i252 4, ptr %362, align 16
  %363 = extractvalue { ptr, i32, i32, i32 } %355, 2
  %364 = add i32 %363, 1
  %365 = insertvalue { ptr, i32, i32, i32 } %355, i32 %364, 2
  %366 = getelementptr inbounds i8, ptr %358, i32 -12
  store i32 %364, ptr %366, align 4
  %367 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f143"(i64 %0, i64 %316, { { ptr, i32, i32, i32 } } %311, { ptr, i32, i32, i32 } %365)
  %368 = extractvalue { i64, i64, { i64, [24 x i8] } } %367, 0
  %369 = extractvalue { i64, i64, { i64, [24 x i8] } } %367, 1
  %370 = extractvalue { i64, i64, { i64, [24 x i8] } } %367, 2
  %371 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %368, 0
  %372 = insertvalue { i64, i64, { i64, [24 x i8] } } %371, i64 %369, 1
  %373 = insertvalue { i64, i64, { i64, [24 x i8] } } %372, { i64, [24 x i8] } %370, 2
  ret { i64, i64, { i64, [24 x i8] } } %373

374:                                              ; preds = %4
  %375 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %376 = call ptr %375()
  %377 = load i64, ptr %376, align 8
  %378 = mul i64 %377, 7260
  %379 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %378)
  %380 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %381 = icmp eq i32 %380, 0
  br i1 %381, label %382, label %396

382:                                              ; preds = %374
  %383 = shl i32 %380, 1
  %384 = call i32 @llvm.umin.i32(i32 %383, i32 1024)
  %385 = add i32 %384, %380
  %386 = call i32 @llvm.umax.i32(i32 %385, i32 8)
  %387 = zext i32 %386 to i64
  %388 = mul i64 %387, 32
  %389 = add i64 %388, 16
  %390 = call ptr @realloc(ptr null, i64 %389)
  store i32 1, ptr %390, align 4
  %391 = getelementptr inbounds i8, ptr %390, i32 4
  store i32 0, ptr %391, align 4
  %392 = getelementptr inbounds i8, ptr %390, i32 16
  %393 = call ptr @realloc(ptr null, i64 8)
  store ptr %392, ptr %393, align 8
  %394 = insertvalue { ptr, i32, i32, i32 } %3, ptr %393, 0
  %395 = insertvalue { ptr, i32, i32, i32 } %394, i32 %386, 3
  br label %417

396:                                              ; preds = %374
  %397 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %398 = icmp ult i32 %397, %380
  br i1 %398, label %399, label %400

399:                                              ; preds = %396
  br label %414

400:                                              ; preds = %396
  %401 = shl i32 %380, 1
  %402 = call i32 @llvm.umin.i32(i32 %401, i32 1024)
  %403 = add i32 %402, %380
  %404 = call i32 @llvm.umax.i32(i32 %403, i32 8)
  %405 = zext i32 %404 to i64
  %406 = mul i64 %405, 32
  %407 = add i64 %406, 16
  %408 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %409 = load ptr, ptr %408, align 8
  %410 = getelementptr inbounds i8, ptr %409, i32 -16
  %411 = call ptr @realloc(ptr %410, i64 %407)
  %412 = getelementptr inbounds i8, ptr %411, i32 16
  store ptr %412, ptr %408, align 8
  %413 = insertvalue { ptr, i32, i32, i32 } %3, i32 %404, 3
  br label %414

414:                                              ; preds = %399, %400
  %415 = phi { ptr, i32, i32, i32 } [ %413, %400 ], [ %3, %399 ]
  br label %416

416:                                              ; preds = %414
  br label %417

417:                                              ; preds = %382, %416
  %418 = phi { ptr, i32, i32, i32 } [ %415, %416 ], [ %395, %382 ]
  br label %419

419:                                              ; preds = %417
  %420 = extractvalue { ptr, i32, i32, i32 } %418, 0
  %421 = load ptr, ptr %420, align 8
  %422 = extractvalue { ptr, i32, i32, i32 } %418, 2
  %423 = zext i32 %422 to i64
  %424 = mul i64 %423, 32
  %425 = getelementptr inbounds i8, ptr %421, i64 %424
  store i252 5, ptr %425, align 16
  %426 = extractvalue { ptr, i32, i32, i32 } %418, 2
  %427 = add i32 %426, 1
  %428 = insertvalue { ptr, i32, i32, i32 } %418, i32 %427, 2
  %429 = getelementptr inbounds i8, ptr %421, i32 -12
  store i32 %427, ptr %429, align 4
  br label %495

430:                                              ; preds = %4
  %431 = load { i3, { { { ptr, i32, i32, i32 } }, i32 } }, ptr %5, align 8
  %432 = extractvalue { i3, { { { ptr, i32, i32, i32 } }, i32 } } %431, 1
  %433 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %434 = call ptr %433()
  %435 = load i64, ptr %434, align 8
  %436 = mul i64 %435, 870
  %437 = call i64 @llvm.uadd.sat.i64(i64 %1, i64 %436)
  %438 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %439 = icmp eq i32 %438, 0
  br i1 %439, label %440, label %454

440:                                              ; preds = %430
  %441 = shl i32 %438, 1
  %442 = call i32 @llvm.umin.i32(i32 %441, i32 1024)
  %443 = add i32 %442, %438
  %444 = call i32 @llvm.umax.i32(i32 %443, i32 8)
  %445 = zext i32 %444 to i64
  %446 = mul i64 %445, 32
  %447 = add i64 %446, 16
  %448 = call ptr @realloc(ptr null, i64 %447)
  store i32 1, ptr %448, align 4
  %449 = getelementptr inbounds i8, ptr %448, i32 4
  store i32 0, ptr %449, align 4
  %450 = getelementptr inbounds i8, ptr %448, i32 16
  %451 = call ptr @realloc(ptr null, i64 8)
  store ptr %450, ptr %451, align 8
  %452 = insertvalue { ptr, i32, i32, i32 } %3, ptr %451, 0
  %453 = insertvalue { ptr, i32, i32, i32 } %452, i32 %444, 3
  br label %475

454:                                              ; preds = %430
  %455 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %456 = icmp ult i32 %455, %438
  br i1 %456, label %457, label %458

457:                                              ; preds = %454
  br label %472

458:                                              ; preds = %454
  %459 = shl i32 %438, 1
  %460 = call i32 @llvm.umin.i32(i32 %459, i32 1024)
  %461 = add i32 %460, %438
  %462 = call i32 @llvm.umax.i32(i32 %461, i32 8)
  %463 = zext i32 %462 to i64
  %464 = mul i64 %463, 32
  %465 = add i64 %464, 16
  %466 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %467 = load ptr, ptr %466, align 8
  %468 = getelementptr inbounds i8, ptr %467, i32 -16
  %469 = call ptr @realloc(ptr %468, i64 %465)
  %470 = getelementptr inbounds i8, ptr %469, i32 16
  store ptr %470, ptr %466, align 8
  %471 = insertvalue { ptr, i32, i32, i32 } %3, i32 %462, 3
  br label %472

472:                                              ; preds = %457, %458
  %473 = phi { ptr, i32, i32, i32 } [ %471, %458 ], [ %3, %457 ]
  br label %474

474:                                              ; preds = %472
  br label %475

475:                                              ; preds = %440, %474
  %476 = phi { ptr, i32, i32, i32 } [ %473, %474 ], [ %453, %440 ]
  br label %477

477:                                              ; preds = %475
  %478 = extractvalue { ptr, i32, i32, i32 } %476, 0
  %479 = load ptr, ptr %478, align 8
  %480 = extractvalue { ptr, i32, i32, i32 } %476, 2
  %481 = zext i32 %480 to i64
  %482 = mul i64 %481, 32
  %483 = getelementptr inbounds i8, ptr %479, i64 %482
  store i252 6, ptr %483, align 16
  %484 = extractvalue { ptr, i32, i32, i32 } %476, 2
  %485 = add i32 %484, 1
  %486 = insertvalue { ptr, i32, i32, i32 } %476, i32 %485, 2
  %487 = getelementptr inbounds i8, ptr %479, i32 -12
  store i32 %485, ptr %487, align 4
  %488 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f144"(i64 %0, i64 %437, { { { ptr, i32, i32, i32 } }, i32 } %432, { ptr, i32, i32, i32 } %486)
  %489 = extractvalue { i64, i64, { i64, [24 x i8] } } %488, 0
  %490 = extractvalue { i64, i64, { i64, [24 x i8] } } %488, 1
  %491 = extractvalue { i64, i64, { i64, [24 x i8] } } %488, 2
  %492 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %489, 0
  %493 = insertvalue { i64, i64, { i64, [24 x i8] } } %492, i64 %490, 1
  %494 = insertvalue { i64, i64, { i64, [24 x i8] } } %493, { i64, [24 x i8] } %491, 2
  ret { i64, i64, { i64, [24 x i8] } } %494

495:                                              ; preds = %107, %419
  %496 = phi i64 [ %0, %419 ], [ %0, %107 ]
  %497 = phi i64 [ %379, %419 ], [ %18, %107 ]
  %498 = phi { ptr, i32, i32, i32 } [ %428, %419 ], [ %116, %107 ]
  %499 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %498, 0
  %500 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %499, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %500, ptr %6, align 8
  %501 = load { i64, [24 x i8] }, ptr %6, align 8
  %502 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %496, 0
  %503 = insertvalue { i64, i64, { i64, [24 x i8] } } %502, i64 %497, 1
  %504 = insertvalue { i64, i64, { i64, [24 x i8] } } %503, { i64, [24 x i8] } %501, 2
  ret { i64, i64, { i64, [24 x i8] } } %504

505:                                              ; preds = %9
  call void @puts(ptr @assert_msg_198)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f141(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f141"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f141(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f141(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f142"(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2)
  %8 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %7, 0
  %9 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %7, 1
  %10 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 1
  %11 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %9, 2
  call void @"drop$11"({ { ptr, i32, i32, i32 } } %11)
  %12 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$4"({ { ptr, i32, i32, i32 } } %10)
  %13 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 0
  %14 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %12, 1
  %15 = extractvalue { { ptr, i32, i32, i32 } } %14, 0
  %16 = extractvalue { ptr, i32, i32, i32 } %15, 1
  %17 = extractvalue { ptr, i32, i32, i32 } %15, 2
  %18 = sub i32 %17, %16
  call void @"drop$3"({ ptr, i32, i32, i32 } %15)
  %19 = zext i32 %18 to i252
  %20 = call { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } @"dup$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %8)
  %21 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %20, 0
  %22 = extractvalue { { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } }, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } } %20, 1
  %23 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %22, 0
  %24 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %22, 1
  %25 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %22, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %24)
  call void @"drop$11"({ { ptr, i32, i32, i32 } } %25)
  %26 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %42

28:                                               ; preds = %4
  %29 = shl i32 %26, 1
  %30 = call i32 @llvm.umin.i32(i32 %29, i32 1024)
  %31 = add i32 %30, %26
  %32 = call i32 @llvm.umax.i32(i32 %31, i32 8)
  %33 = zext i32 %32 to i64
  %34 = mul i64 %33, 32
  %35 = add i64 %34, 16
  %36 = call ptr @realloc(ptr null, i64 %35)
  store i32 1, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %36, i32 4
  store i32 0, ptr %37, align 4
  %38 = getelementptr inbounds i8, ptr %36, i32 16
  %39 = call ptr @realloc(ptr null, i64 8)
  store ptr %38, ptr %39, align 8
  %40 = insertvalue { ptr, i32, i32, i32 } %3, ptr %39, 0
  %41 = insertvalue { ptr, i32, i32, i32 } %40, i32 %32, 3
  br label %63

42:                                               ; preds = %4
  %43 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %44 = icmp ult i32 %43, %26
  br i1 %44, label %45, label %46

45:                                               ; preds = %42
  br label %60

46:                                               ; preds = %42
  %47 = shl i32 %26, 1
  %48 = call i32 @llvm.umin.i32(i32 %47, i32 1024)
  %49 = add i32 %48, %26
  %50 = call i32 @llvm.umax.i32(i32 %49, i32 8)
  %51 = zext i32 %50 to i64
  %52 = mul i64 %51, 32
  %53 = add i64 %52, 16
  %54 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr inbounds i8, ptr %55, i32 -16
  %57 = call ptr @realloc(ptr %56, i64 %53)
  %58 = getelementptr inbounds i8, ptr %57, i32 16
  store ptr %58, ptr %54, align 8
  %59 = insertvalue { ptr, i32, i32, i32 } %3, i32 %50, 3
  br label %60

60:                                               ; preds = %45, %46
  %61 = phi { ptr, i32, i32, i32 } [ %59, %46 ], [ %3, %45 ]
  br label %62

62:                                               ; preds = %60
  br label %63

63:                                               ; preds = %28, %62
  %64 = phi { ptr, i32, i32, i32 } [ %61, %62 ], [ %41, %28 ]
  br label %65

65:                                               ; preds = %63
  %66 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %67 = load ptr, ptr %66, align 8
  %68 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %69 = zext i32 %68 to i64
  %70 = mul i64 %69, 32
  %71 = getelementptr inbounds i8, ptr %67, i64 %70
  store i252 %23, ptr %71, align 16
  %72 = extractvalue { ptr, i32, i32, i32 } %64, 2
  %73 = add i32 %72, 1
  %74 = insertvalue { ptr, i32, i32, i32 } %64, i32 %73, 2
  %75 = getelementptr inbounds i8, ptr %67, i32 -12
  store i32 %73, ptr %75, align 4
  %76 = extractvalue { ptr, i32, i32, i32 } %64, 3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %78, label %92

78:                                               ; preds = %65
  %79 = shl i32 %76, 1
  %80 = call i32 @llvm.umin.i32(i32 %79, i32 1024)
  %81 = add i32 %80, %76
  %82 = call i32 @llvm.umax.i32(i32 %81, i32 8)
  %83 = zext i32 %82 to i64
  %84 = mul i64 %83, 32
  %85 = add i64 %84, 16
  %86 = call ptr @realloc(ptr null, i64 %85)
  store i32 1, ptr %86, align 4
  %87 = getelementptr inbounds i8, ptr %86, i32 4
  store i32 0, ptr %87, align 4
  %88 = getelementptr inbounds i8, ptr %86, i32 16
  %89 = call ptr @realloc(ptr null, i64 8)
  store ptr %88, ptr %89, align 8
  %90 = insertvalue { ptr, i32, i32, i32 } %74, ptr %89, 0
  %91 = insertvalue { ptr, i32, i32, i32 } %90, i32 %82, 3
  br label %112

92:                                               ; preds = %65
  %93 = icmp ult i32 %73, %76
  br i1 %93, label %94, label %95

94:                                               ; preds = %92
  br label %109

95:                                               ; preds = %92
  %96 = shl i32 %76, 1
  %97 = call i32 @llvm.umin.i32(i32 %96, i32 1024)
  %98 = add i32 %97, %76
  %99 = call i32 @llvm.umax.i32(i32 %98, i32 8)
  %100 = zext i32 %99 to i64
  %101 = mul i64 %100, 32
  %102 = add i64 %101, 16
  %103 = extractvalue { ptr, i32, i32, i32 } %64, 0
  %104 = load ptr, ptr %103, align 8
  %105 = getelementptr inbounds i8, ptr %104, i32 -16
  %106 = call ptr @realloc(ptr %105, i64 %102)
  %107 = getelementptr inbounds i8, ptr %106, i32 16
  store ptr %107, ptr %103, align 8
  %108 = insertvalue { ptr, i32, i32, i32 } %74, i32 %99, 3
  br label %109

109:                                              ; preds = %94, %95
  %110 = phi { ptr, i32, i32, i32 } [ %108, %95 ], [ %74, %94 ]
  br label %111

111:                                              ; preds = %109
  br label %112

112:                                              ; preds = %78, %111
  %113 = phi { ptr, i32, i32, i32 } [ %110, %111 ], [ %91, %78 ]
  br label %114

114:                                              ; preds = %112
  %115 = extractvalue { ptr, i32, i32, i32 } %113, 0
  %116 = load ptr, ptr %115, align 8
  %117 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %118 = zext i32 %117 to i64
  %119 = mul i64 %118, 32
  %120 = getelementptr inbounds i8, ptr %116, i64 %119
  store i252 %19, ptr %120, align 16
  %121 = extractvalue { ptr, i32, i32, i32 } %113, 2
  %122 = add i32 %121, 1
  %123 = insertvalue { ptr, i32, i32, i32 } %113, i32 %122, 2
  %124 = getelementptr inbounds i8, ptr %116, i32 -12
  store i32 %122, ptr %124, align 4
  %125 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f20"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %13, { ptr, i32, i32, i32 } %123)
  %126 = extractvalue { i64, i64, { i64, [24 x i8] } } %125, 0
  %127 = extractvalue { i64, i64, { i64, [24 x i8] } } %125, 1
  %128 = extractvalue { i64, i64, { i64, [24 x i8] } } %125, 2
  store { i64, [24 x i8] } %128, ptr %5, align 8
  %129 = load i1, ptr %5, align 1
  switch i1 %129, label %130 [
    i1 false, label %132
    i1 true, label %148
  ]

130:                                              ; preds = %114
  br i1 false, label %131, label %156

131:                                              ; preds = %130
  unreachable

132:                                              ; preds = %114
  %133 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %134 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %133, 1
  %135 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %136 = call ptr %135()
  %137 = call i64 @llvm.uadd.sat.i64(i64 %127, i64 0)
  %138 = extractvalue { { ptr, i32, i32, i32 }, {} } %134, 0
  %139 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %21, 1
  %140 = extractvalue { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %21, 2
  call void @"drop$4"({ { ptr, i32, i32, i32 } } %139)
  %141 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f145"(i64 %126, i64 %137, { { ptr, i32, i32, i32 } } %140, { ptr, i32, i32, i32 } %138)
  %142 = extractvalue { i64, i64, { i64, [24 x i8] } } %141, 0
  %143 = extractvalue { i64, i64, { i64, [24 x i8] } } %141, 1
  %144 = extractvalue { i64, i64, { i64, [24 x i8] } } %141, 2
  %145 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %142, 0
  %146 = insertvalue { i64, i64, { i64, [24 x i8] } } %145, i64 %143, 1
  %147 = insertvalue { i64, i64, { i64, [24 x i8] } } %146, { i64, [24 x i8] } %144, 2
  ret { i64, i64, { i64, [24 x i8] } } %147

148:                                              ; preds = %114
  %149 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %150 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %149, 1
  call void @"drop$12"({ i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %21)
  %151 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %150, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %151, ptr %6, align 8
  %152 = load { i64, [24 x i8] }, ptr %6, align 8
  %153 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %126, 0
  %154 = insertvalue { i64, i64, { i64, [24 x i8] } } %153, i64 %127, 1
  %155 = insertvalue { i64, i64, { i64, [24 x i8] } } %154, { i64, [24 x i8] } %152, 2
  ret { i64, i64, { i64, [24 x i8] } } %155

156:                                              ; preds = %130
  call void @puts(ptr @assert_msg_199)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f142(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f142"(i64 %0, i64 %1, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f142(ptr %0, i64 %1, i64 %2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f142(i64 %1, i64 %2, { i252, { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f143"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$15"({ { ptr, i32, i32, i32 } } %2)
  %6 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 0
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 1
  %8 = extractvalue { { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { ptr, i32, i32, i32 } %8, 1
  %10 = extractvalue { ptr, i32, i32, i32 } %8, 2
  %11 = sub i32 %10, %9
  call void @"drop$14"({ ptr, i32, i32, i32 } %8)
  %12 = zext i32 %11 to i252
  %13 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %29

15:                                               ; preds = %4
  %16 = shl i32 %13, 1
  %17 = call i32 @llvm.umin.i32(i32 %16, i32 1024)
  %18 = add i32 %17, %13
  %19 = call i32 @llvm.umax.i32(i32 %18, i32 8)
  %20 = zext i32 %19 to i64
  %21 = mul i64 %20, 32
  %22 = add i64 %21, 16
  %23 = call ptr @realloc(ptr null, i64 %22)
  store i32 1, ptr %23, align 4
  %24 = getelementptr inbounds i8, ptr %23, i32 4
  store i32 0, ptr %24, align 4
  %25 = getelementptr inbounds i8, ptr %23, i32 16
  %26 = call ptr @realloc(ptr null, i64 8)
  store ptr %25, ptr %26, align 8
  %27 = insertvalue { ptr, i32, i32, i32 } %3, ptr %26, 0
  %28 = insertvalue { ptr, i32, i32, i32 } %27, i32 %19, 3
  br label %50

29:                                               ; preds = %4
  %30 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %31 = icmp ult i32 %30, %13
  br i1 %31, label %32, label %33

32:                                               ; preds = %29
  br label %47

33:                                               ; preds = %29
  %34 = shl i32 %13, 1
  %35 = call i32 @llvm.umin.i32(i32 %34, i32 1024)
  %36 = add i32 %35, %13
  %37 = call i32 @llvm.umax.i32(i32 %36, i32 8)
  %38 = zext i32 %37 to i64
  %39 = mul i64 %38, 32
  %40 = add i64 %39, 16
  %41 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr inbounds i8, ptr %42, i32 -16
  %44 = call ptr @realloc(ptr %43, i64 %40)
  %45 = getelementptr inbounds i8, ptr %44, i32 16
  store ptr %45, ptr %41, align 8
  %46 = insertvalue { ptr, i32, i32, i32 } %3, i32 %37, 3
  br label %47

47:                                               ; preds = %32, %33
  %48 = phi { ptr, i32, i32, i32 } [ %46, %33 ], [ %3, %32 ]
  br label %49

49:                                               ; preds = %47
  br label %50

50:                                               ; preds = %15, %49
  %51 = phi { ptr, i32, i32, i32 } [ %48, %49 ], [ %28, %15 ]
  br label %52

52:                                               ; preds = %50
  %53 = extractvalue { ptr, i32, i32, i32 } %51, 0
  %54 = load ptr, ptr %53, align 8
  %55 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %56 = zext i32 %55 to i64
  %57 = mul i64 %56, 32
  %58 = getelementptr inbounds i8, ptr %54, i64 %57
  store i252 %12, ptr %58, align 16
  %59 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %60 = add i32 %59, 1
  %61 = insertvalue { ptr, i32, i32, i32 } %51, i32 %60, 2
  %62 = getelementptr inbounds i8, ptr %54, i32 -12
  store i32 %60, ptr %62, align 4
  %63 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f146"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %6, { ptr, i32, i32, i32 } %61)
  %64 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 0
  %65 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 1
  %66 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 2
  %67 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %64, 0
  %68 = insertvalue { i64, i64, { i64, [24 x i8] } } %67, i64 %65, 1
  %69 = insertvalue { i64, i64, { i64, [24 x i8] } } %68, { i64, [24 x i8] } %66, 2
  ret { i64, i64, { i64, [24 x i8] } } %69
}

define private { i64, i64, { i64, [24 x i8] } } @f143(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f143"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f143(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f143(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f144"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3) {
  %5 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %2, 0
  %6 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %2, 1
  %7 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } undef, { { ptr, i32, i32, i32 } } %5, 0
  %8 = insertvalue { { { ptr, i32, i32, i32 } }, i32 } %7, i32 %6, 1
  %9 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f147"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %8, { ptr, i32, i32, i32 } %3)
  %10 = extractvalue { i64, i64, { i64, [24 x i8] } } %9, 0
  %11 = extractvalue { i64, i64, { i64, [24 x i8] } } %9, 1
  %12 = extractvalue { i64, i64, { i64, [24 x i8] } } %9, 2
  %13 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %10, 0
  %14 = insertvalue { i64, i64, { i64, [24 x i8] } } %13, i64 %11, 1
  %15 = insertvalue { i64, i64, { i64, [24 x i8] } } %14, { i64, [24 x i8] } %12, 2
  ret { i64, i64, { i64, [24 x i8] } } %15
}

define private { i64, i64, { i64, [24 x i8] } } @f144(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f144"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f144(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 } }, i32 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f144(i64 %1, i64 %2, { { { ptr, i32, i32, i32 } }, i32 } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f145"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } @"dup$11"({ { ptr, i32, i32, i32 } } %2)
  %6 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 0
  %7 = extractvalue { { { ptr, i32, i32, i32 } }, { { ptr, i32, i32, i32 } } } %5, 1
  %8 = extractvalue { { ptr, i32, i32, i32 } } %7, 0
  %9 = extractvalue { ptr, i32, i32, i32 } %8, 1
  %10 = extractvalue { ptr, i32, i32, i32 } %8, 2
  %11 = sub i32 %10, %9
  call void @"drop$10"({ ptr, i32, i32, i32 } %8)
  %12 = zext i32 %11 to i252
  %13 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %29

15:                                               ; preds = %4
  %16 = shl i32 %13, 1
  %17 = call i32 @llvm.umin.i32(i32 %16, i32 1024)
  %18 = add i32 %17, %13
  %19 = call i32 @llvm.umax.i32(i32 %18, i32 8)
  %20 = zext i32 %19 to i64
  %21 = mul i64 %20, 32
  %22 = add i64 %21, 16
  %23 = call ptr @realloc(ptr null, i64 %22)
  store i32 1, ptr %23, align 4
  %24 = getelementptr inbounds i8, ptr %23, i32 4
  store i32 0, ptr %24, align 4
  %25 = getelementptr inbounds i8, ptr %23, i32 16
  %26 = call ptr @realloc(ptr null, i64 8)
  store ptr %25, ptr %26, align 8
  %27 = insertvalue { ptr, i32, i32, i32 } %3, ptr %26, 0
  %28 = insertvalue { ptr, i32, i32, i32 } %27, i32 %19, 3
  br label %50

29:                                               ; preds = %4
  %30 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %31 = icmp ult i32 %30, %13
  br i1 %31, label %32, label %33

32:                                               ; preds = %29
  br label %47

33:                                               ; preds = %29
  %34 = shl i32 %13, 1
  %35 = call i32 @llvm.umin.i32(i32 %34, i32 1024)
  %36 = add i32 %35, %13
  %37 = call i32 @llvm.umax.i32(i32 %36, i32 8)
  %38 = zext i32 %37 to i64
  %39 = mul i64 %38, 32
  %40 = add i64 %39, 16
  %41 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr inbounds i8, ptr %42, i32 -16
  %44 = call ptr @realloc(ptr %43, i64 %40)
  %45 = getelementptr inbounds i8, ptr %44, i32 16
  store ptr %45, ptr %41, align 8
  %46 = insertvalue { ptr, i32, i32, i32 } %3, i32 %37, 3
  br label %47

47:                                               ; preds = %32, %33
  %48 = phi { ptr, i32, i32, i32 } [ %46, %33 ], [ %3, %32 ]
  br label %49

49:                                               ; preds = %47
  br label %50

50:                                               ; preds = %15, %49
  %51 = phi { ptr, i32, i32, i32 } [ %48, %49 ], [ %28, %15 ]
  br label %52

52:                                               ; preds = %50
  %53 = extractvalue { ptr, i32, i32, i32 } %51, 0
  %54 = load ptr, ptr %53, align 8
  %55 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %56 = zext i32 %55 to i64
  %57 = mul i64 %56, 32
  %58 = getelementptr inbounds i8, ptr %54, i64 %57
  store i252 %12, ptr %58, align 16
  %59 = extractvalue { ptr, i32, i32, i32 } %51, 2
  %60 = add i32 %59, 1
  %61 = insertvalue { ptr, i32, i32, i32 } %51, i32 %60, 2
  %62 = getelementptr inbounds i8, ptr %54, i32 -12
  store i32 %60, ptr %62, align 4
  %63 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f148"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %6, { ptr, i32, i32, i32 } %61)
  %64 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 0
  %65 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 1
  %66 = extractvalue { i64, i64, { i64, [24 x i8] } } %63, 2
  %67 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %64, 0
  %68 = insertvalue { i64, i64, { i64, [24 x i8] } } %67, i64 %65, 1
  %69 = insertvalue { i64, i64, { i64, [24 x i8] } } %68, { i64, [24 x i8] } %66, 2
  ret { i64, i64, { i64, [24 x i8] } } %69
}

define private { i64, i64, { i64, [24 x i8] } } @f145(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f145"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f145(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f145(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$23"(ptr %0) {
  %2 = load { i128, [80 x i8] }, ptr %0, align 16
  call void @"drop$19"({ i128, [80 x i8] } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$23"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 96)
  %3 = load { i128, [80 x i8] }, ptr %0, align 16
  %4 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$19"({ i128, [80 x i8] } %3)
  %5 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %4, 0
  %6 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %4, 1
  store { i128, [80 x i8] } %5, ptr %0, align 16
  store { i128, [80 x i8] } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f146"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i128, [80 x i8] }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %55, %4
  %16 = phi i64 [ %49, %55 ], [ %0, %4 ]
  %17 = phi i64 [ %60, %55 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %61, %55 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %62, %55 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 11430
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %113

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %94

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 96
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 96)
  %43 = load { i128, [80 x i8] }, ptr %39, align 16
  %44 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$19"({ i128, [80 x i8] } %43)
  %45 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %44, 0
  %46 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %44, 1
  store { i128, [80 x i8] } %45, ptr %39, align 16
  store { i128, [80 x i8] } %46, ptr %42, align 16
  %47 = load { i128, [80 x i8] }, ptr %42, align 16
  call void @free(ptr %42)
  store { i128, [80 x i8] } %47, ptr %12, align 16
  %48 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f141"(i64 %20, i64 %26, ptr %12, { ptr, i32, i32, i32 } %19)
  %49 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 1
  %51 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 2
  store { i64, [24 x i8] } %51, ptr %13, align 8
  %52 = load i1, ptr %13, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %67
  ]

53:                                               ; preds = %34
  br i1 false, label %54, label %128

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %34
  %56 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %57 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %56, 1
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 0)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %62 = extractvalue { { ptr, i32, i32, i32 }, {} } %57, 0
  %63 = extractvalue { ptr, ptr, i64 } %8, 1
  %64 = load i64, ptr %63, align 8
  %65 = add i64 %64, 1
  %66 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %65, ptr %66, align 8
  br label %15

67:                                               ; preds = %34
  %68 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %69 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %68, 1
  call void @"drop$14"({ ptr, i32, i32, i32 } %41)
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %14, align 8
  %71 = load { i64, [24 x i8] }, ptr %14, align 8
  %72 = extractvalue { ptr, ptr, i64 } %8, 1
  %73 = load i64, ptr %72, align 8
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %73, 1
  %76 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %75, ptr %76, align 8
  br i1 %74, label %90, label %77

77:                                               ; preds = %77, %67, %94, %113
  %78 = phi i64 [ %20, %113 ], [ %20, %94 ], [ %78, %77 ], [ %49, %67 ]
  %79 = phi i64 [ %17, %113 ], [ %100, %94 ], [ %79, %77 ], [ %50, %67 ]
  %80 = phi { i64, [24 x i8] } [ %118, %113 ], [ %103, %94 ], [ %80, %77 ], [ %71, %67 ]
  %81 = extractvalue { ptr, ptr, i64 } %8, 1
  %82 = load i64, ptr %81, align 8
  %83 = icmp eq i64 %82, 0
  %84 = sub i64 %82, 1
  %85 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %84, ptr %85, align 8
  br i1 %83, label %86, label %77

86:                                               ; preds = %77
  %87 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %78, 0
  %88 = insertvalue { i64, i64, { i64, [24 x i8] } } %87, i64 %79, 1
  %89 = insertvalue { i64, i64, { i64, [24 x i8] } } %88, { i64, [24 x i8] } %80, 2
  ret { i64, i64, { i64, [24 x i8] } } %89

90:                                               ; preds = %67
  %91 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %49, 0
  %92 = insertvalue { i64, i64, { i64, [24 x i8] } } %91, i64 %50, 1
  %93 = insertvalue { i64, i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %71, 2
  ret { i64, i64, { i64, [24 x i8] } } %93

94:                                               ; preds = %27
  %95 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$14"({ ptr, i32, i32, i32 } %95)
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = load i64, ptr %97, align 8
  %99 = mul i64 %98, 12130
  %100 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %99)
  %101 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %19, 0
  %102 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %101, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %102, ptr %11, align 8
  %103 = load { i64, [24 x i8] }, ptr %11, align 8
  %104 = extractvalue { ptr, ptr, i64 } %8, 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %105, 1
  %108 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %107, ptr %108, align 8
  br i1 %106, label %109, label %77

109:                                              ; preds = %94
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, i64 %100, 1
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %103, 2
  ret { i64, i64, { i64, [24 x i8] } } %112

113:                                              ; preds = %15
  %114 = phi { ptr, i32, i32, i32 } [ %19, %15 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %114)
  call void @"drop$15"({ { ptr, i32, i32, i32 } } %18)
  %115 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %116 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %115, 0
  %117 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %116, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %117, ptr %10, align 8
  %118 = load { i64, [24 x i8] }, ptr %10, align 8
  %119 = extractvalue { ptr, ptr, i64 } %8, 1
  %120 = load i64, ptr %119, align 8
  %121 = icmp eq i64 %120, 0
  %122 = sub i64 %120, 1
  %123 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %122, ptr %123, align 8
  br i1 %121, label %124, label %77

124:                                              ; preds = %113
  %125 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %126 = insertvalue { i64, i64, { i64, [24 x i8] } } %125, i64 %17, 1
  %127 = insertvalue { i64, i64, { i64, [24 x i8] } } %126, { i64, [24 x i8] } %118, 2
  ret { i64, i64, { i64, [24 x i8] } } %127

128:                                              ; preds = %53
  call void @puts(ptr @assert_msg_200)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f146(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f146"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f146(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f146(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f147"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i64, [24 x i8] }, i64 1, align 8
  %6 = alloca { i64, [24 x i8] }, i64 1, align 8
  %7 = alloca { i64, [24 x i8] }, i64 1, align 8
  %8 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %2, 0
  %9 = extractvalue { { { ptr, i32, i32, i32 } }, i32 } %2, 1
  %10 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f149"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %8, { ptr, i32, i32, i32 } %3)
  %11 = extractvalue { i64, i64, { i64, [24 x i8] } } %10, 0
  %12 = extractvalue { i64, i64, { i64, [24 x i8] } } %10, 1
  %13 = extractvalue { i64, i64, { i64, [24 x i8] } } %10, 2
  store { i64, [24 x i8] } %13, ptr %5, align 8
  %14 = load i1, ptr %5, align 1
  switch i1 %14, label %15 [
    i1 false, label %17
    i1 true, label %81
  ]

15:                                               ; preds = %4
  br i1 false, label %16, label %89

16:                                               ; preds = %15
  unreachable

17:                                               ; preds = %4
  %18 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %5, align 8
  %19 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %18, 1
  %20 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %21 = call ptr %20()
  %22 = call i64 @llvm.uadd.sat.i64(i64 %12, i64 0)
  %23 = zext i32 %9 to i252
  %24 = extractvalue { { ptr, i32, i32, i32 }, {} } %19, 0
  %25 = extractvalue { ptr, i32, i32, i32 } %24, 3
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %27, label %41

27:                                               ; preds = %17
  %28 = shl i32 %25, 1
  %29 = call i32 @llvm.umin.i32(i32 %28, i32 1024)
  %30 = add i32 %29, %25
  %31 = call i32 @llvm.umax.i32(i32 %30, i32 8)
  %32 = zext i32 %31 to i64
  %33 = mul i64 %32, 32
  %34 = add i64 %33, 16
  %35 = call ptr @realloc(ptr null, i64 %34)
  store i32 1, ptr %35, align 4
  %36 = getelementptr inbounds i8, ptr %35, i32 4
  store i32 0, ptr %36, align 4
  %37 = getelementptr inbounds i8, ptr %35, i32 16
  %38 = call ptr @realloc(ptr null, i64 8)
  store ptr %37, ptr %38, align 8
  %39 = insertvalue { ptr, i32, i32, i32 } %24, ptr %38, 0
  %40 = insertvalue { ptr, i32, i32, i32 } %39, i32 %31, 3
  br label %62

41:                                               ; preds = %17
  %42 = extractvalue { ptr, i32, i32, i32 } %24, 2
  %43 = icmp ult i32 %42, %25
  br i1 %43, label %44, label %45

44:                                               ; preds = %41
  br label %59

45:                                               ; preds = %41
  %46 = shl i32 %25, 1
  %47 = call i32 @llvm.umin.i32(i32 %46, i32 1024)
  %48 = add i32 %47, %25
  %49 = call i32 @llvm.umax.i32(i32 %48, i32 8)
  %50 = zext i32 %49 to i64
  %51 = mul i64 %50, 32
  %52 = add i64 %51, 16
  %53 = extractvalue { ptr, i32, i32, i32 } %24, 0
  %54 = load ptr, ptr %53, align 8
  %55 = getelementptr inbounds i8, ptr %54, i32 -16
  %56 = call ptr @realloc(ptr %55, i64 %52)
  %57 = getelementptr inbounds i8, ptr %56, i32 16
  store ptr %57, ptr %53, align 8
  %58 = insertvalue { ptr, i32, i32, i32 } %24, i32 %49, 3
  br label %59

59:                                               ; preds = %44, %45
  %60 = phi { ptr, i32, i32, i32 } [ %58, %45 ], [ %24, %44 ]
  br label %61

61:                                               ; preds = %59
  br label %62

62:                                               ; preds = %27, %61
  %63 = phi { ptr, i32, i32, i32 } [ %60, %61 ], [ %40, %27 ]
  br label %64

64:                                               ; preds = %62
  %65 = extractvalue { ptr, i32, i32, i32 } %63, 0
  %66 = load ptr, ptr %65, align 8
  %67 = extractvalue { ptr, i32, i32, i32 } %63, 2
  %68 = zext i32 %67 to i64
  %69 = mul i64 %68, 32
  %70 = getelementptr inbounds i8, ptr %66, i64 %69
  store i252 %23, ptr %70, align 16
  %71 = extractvalue { ptr, i32, i32, i32 } %63, 2
  %72 = add i32 %71, 1
  %73 = insertvalue { ptr, i32, i32, i32 } %63, i32 %72, 2
  %74 = getelementptr inbounds i8, ptr %66, i32 -12
  store i32 %72, ptr %74, align 4
  %75 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %73, 0
  %76 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %75, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %76, ptr %7, align 8
  %77 = load { i64, [24 x i8] }, ptr %7, align 8
  %78 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %11, 0
  %79 = insertvalue { i64, i64, { i64, [24 x i8] } } %78, i64 %22, 1
  %80 = insertvalue { i64, i64, { i64, [24 x i8] } } %79, { i64, [24 x i8] } %77, 2
  ret { i64, i64, { i64, [24 x i8] } } %80

81:                                               ; preds = %4
  %82 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %5, align 8
  %83 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %82, 1
  %84 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %83, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %84, ptr %6, align 8
  %85 = load { i64, [24 x i8] }, ptr %6, align 8
  %86 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %11, 0
  %87 = insertvalue { i64, i64, { i64, [24 x i8] } } %86, i64 %12, 1
  %88 = insertvalue { i64, i64, { i64, [24 x i8] } } %87, { i64, [24 x i8] } %85, 2
  ret { i64, i64, { i64, [24 x i8] } } %88

89:                                               ; preds = %15
  call void @puts(ptr @assert_msg_201)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f147(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f147"(i64 %0, i64 %1, { { { ptr, i32, i32, i32 } }, i32 } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f147(ptr %0, i64 %1, i64 %2, { { { ptr, i32, i32, i32 } }, i32 } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f147(i64 %1, i64 %2, { { { ptr, i32, i32, i32 } }, i32 } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$21"(ptr %0) {
  %2 = load { i252, { i128, [80 x i8] } }, ptr %0, align 16
  call void @"drop$278"({ i252, { i128, [80 x i8] } } %2)
  call void @free(ptr %0)
  ret void
}

define private { ptr, ptr } @"dup$21"(ptr %0) {
  %2 = call ptr @realloc(ptr null, i64 128)
  %3 = load { i252, { i128, [80 x i8] } }, ptr %0, align 16
  %4 = call { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } @"dup$278"({ i252, { i128, [80 x i8] } } %3)
  %5 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %4, 0
  %6 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %4, 1
  store { i252, { i128, [80 x i8] } } %5, ptr %0, align 16
  store { i252, { i128, [80 x i8] } } %6, ptr %2, align 16
  %7 = insertvalue { ptr, ptr } undef, ptr %0, 0
  %8 = insertvalue { ptr, ptr } %7, ptr %2, 1
  ret { ptr, ptr } %8
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f148"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca i64, i64 1, align 8
  %6 = insertvalue { ptr, ptr, i64 } undef, ptr %5, 0
  %7 = insertvalue { ptr, ptr, i64 } %6, ptr %5, 1
  %8 = insertvalue { ptr, ptr, i64 } %7, i64 0, 2
  %9 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 0, ptr %9, align 8
  %10 = alloca { i64, [24 x i8] }, i64 1, align 8
  %11 = alloca { i64, [24 x i8] }, i64 1, align 8
  %12 = alloca { i252, { i128, [80 x i8] } }, i64 1, align 16
  %13 = alloca { i64, [24 x i8] }, i64 1, align 8
  %14 = alloca { i64, [24 x i8] }, i64 1, align 8
  br label %15

15:                                               ; preds = %55, %4
  %16 = phi i64 [ %49, %55 ], [ %0, %4 ]
  %17 = phi i64 [ %60, %55 ], [ %1, %4 ]
  %18 = phi { { ptr, i32, i32, i32 } } [ %61, %55 ], [ %2, %4 ]
  %19 = phi { ptr, i32, i32, i32 } [ %62, %55 ], [ %3, %4 ]
  %20 = add i64 %16, 1
  %21 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %22 = call ptr %21()
  %23 = load i64, ptr %22, align 8
  %24 = mul i64 %23, 16530
  %25 = icmp uge i64 %17, %24
  %26 = call i64 @llvm.usub.sat.i64(i64 %17, i64 %24)
  br i1 %25, label %27, label %113

27:                                               ; preds = %15
  %28 = phi { { ptr, i32, i32, i32 } } [ %18, %15 ]
  %29 = extractvalue { { ptr, i32, i32, i32 } } %28, 0
  %30 = extractvalue { ptr, i32, i32, i32 } %29, 1
  %31 = extractvalue { ptr, i32, i32, i32 } %29, 2
  %32 = sub i32 %31, %30
  %33 = icmp uge i32 %32, 1
  br i1 %33, label %34, label %94

34:                                               ; preds = %27
  %35 = extractvalue { ptr, i32, i32, i32 } %29, 0
  %36 = load ptr, ptr %35, align 8
  %37 = zext i32 %30 to i64
  %38 = mul i64 %37, 128
  %39 = getelementptr inbounds i8, ptr %36, i64 %38
  %40 = add i32 %30, 1
  %41 = insertvalue { ptr, i32, i32, i32 } %29, i32 %40, 1
  %42 = call ptr @realloc(ptr null, i64 128)
  %43 = load { i252, { i128, [80 x i8] } }, ptr %39, align 16
  %44 = call { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } @"dup$278"({ i252, { i128, [80 x i8] } } %43)
  %45 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %44, 0
  %46 = extractvalue { { i252, { i128, [80 x i8] } }, { i252, { i128, [80 x i8] } } } %44, 1
  store { i252, { i128, [80 x i8] } } %45, ptr %39, align 16
  store { i252, { i128, [80 x i8] } } %46, ptr %42, align 16
  %47 = load { i252, { i128, [80 x i8] } }, ptr %42, align 16
  call void @free(ptr %42)
  store { i252, { i128, [80 x i8] } } %47, ptr %12, align 16
  %48 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f150"(i64 %20, i64 %26, ptr %12, { ptr, i32, i32, i32 } %19)
  %49 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 0
  %50 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 1
  %51 = extractvalue { i64, i64, { i64, [24 x i8] } } %48, 2
  store { i64, [24 x i8] } %51, ptr %13, align 8
  %52 = load i1, ptr %13, align 1
  switch i1 %52, label %53 [
    i1 false, label %55
    i1 true, label %67
  ]

53:                                               ; preds = %34
  br i1 false, label %54, label %128

54:                                               ; preds = %53
  unreachable

55:                                               ; preds = %34
  %56 = load { i1, { { ptr, i32, i32, i32 }, {} } }, ptr %13, align 8
  %57 = extractvalue { i1, { { ptr, i32, i32, i32 }, {} } } %56, 1
  %58 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %59 = call ptr %58()
  %60 = call i64 @llvm.uadd.sat.i64(i64 %50, i64 0)
  %61 = insertvalue { { ptr, i32, i32, i32 } } undef, { ptr, i32, i32, i32 } %41, 0
  %62 = extractvalue { { ptr, i32, i32, i32 }, {} } %57, 0
  %63 = extractvalue { ptr, ptr, i64 } %8, 1
  %64 = load i64, ptr %63, align 8
  %65 = add i64 %64, 1
  %66 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %65, ptr %66, align 8
  br label %15

67:                                               ; preds = %34
  %68 = load { i1, { {}, { ptr, i32, i32, i32 } } }, ptr %13, align 8
  %69 = extractvalue { i1, { {}, { ptr, i32, i32, i32 } } } %68, 1
  call void @"drop$10"({ ptr, i32, i32, i32 } %41)
  %70 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %69, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %70, ptr %14, align 8
  %71 = load { i64, [24 x i8] }, ptr %14, align 8
  %72 = extractvalue { ptr, ptr, i64 } %8, 1
  %73 = load i64, ptr %72, align 8
  %74 = icmp eq i64 %73, 0
  %75 = sub i64 %73, 1
  %76 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %75, ptr %76, align 8
  br i1 %74, label %90, label %77

77:                                               ; preds = %77, %67, %94, %113
  %78 = phi i64 [ %20, %113 ], [ %20, %94 ], [ %78, %77 ], [ %49, %67 ]
  %79 = phi i64 [ %17, %113 ], [ %100, %94 ], [ %79, %77 ], [ %50, %67 ]
  %80 = phi { i64, [24 x i8] } [ %118, %113 ], [ %103, %94 ], [ %80, %77 ], [ %71, %67 ]
  %81 = extractvalue { ptr, ptr, i64 } %8, 1
  %82 = load i64, ptr %81, align 8
  %83 = icmp eq i64 %82, 0
  %84 = sub i64 %82, 1
  %85 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %84, ptr %85, align 8
  br i1 %83, label %86, label %77

86:                                               ; preds = %77
  %87 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %78, 0
  %88 = insertvalue { i64, i64, { i64, [24 x i8] } } %87, i64 %79, 1
  %89 = insertvalue { i64, i64, { i64, [24 x i8] } } %88, { i64, [24 x i8] } %80, 2
  ret { i64, i64, { i64, [24 x i8] } } %89

90:                                               ; preds = %67
  %91 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %49, 0
  %92 = insertvalue { i64, i64, { i64, [24 x i8] } } %91, i64 %50, 1
  %93 = insertvalue { i64, i64, { i64, [24 x i8] } } %92, { i64, [24 x i8] } %71, 2
  ret { i64, i64, { i64, [24 x i8] } } %93

94:                                               ; preds = %27
  %95 = phi { ptr, i32, i32, i32 } [ %29, %27 ]
  call void @"drop$10"({ ptr, i32, i32, i32 } %95)
  %96 = load ptr, ptr @cairo_native__get_costs_builtin, align 8
  %97 = call ptr %96()
  %98 = load i64, ptr %97, align 8
  %99 = mul i64 %98, 17230
  %100 = call i64 @llvm.uadd.sat.i64(i64 %26, i64 %99)
  %101 = insertvalue { { ptr, i32, i32, i32 }, {} } undef, { ptr, i32, i32, i32 } %19, 0
  %102 = insertvalue { i1, { { ptr, i32, i32, i32 }, {} } } { i1 false, { { ptr, i32, i32, i32 }, {} } undef }, { { ptr, i32, i32, i32 }, {} } %101, 1
  store { i1, { { ptr, i32, i32, i32 }, {} } } %102, ptr %11, align 8
  %103 = load { i64, [24 x i8] }, ptr %11, align 8
  %104 = extractvalue { ptr, ptr, i64 } %8, 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %105, 1
  %108 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %107, ptr %108, align 8
  br i1 %106, label %109, label %77

109:                                              ; preds = %94
  %110 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %111 = insertvalue { i64, i64, { i64, [24 x i8] } } %110, i64 %100, 1
  %112 = insertvalue { i64, i64, { i64, [24 x i8] } } %111, { i64, [24 x i8] } %103, 2
  ret { i64, i64, { i64, [24 x i8] } } %112

113:                                              ; preds = %15
  %114 = phi { ptr, i32, i32, i32 } [ %19, %15 ]
  call void @"drop$2"({ ptr, i32, i32, i32 } %114)
  call void @"drop$11"({ { ptr, i32, i32, i32 } } %18)
  %115 = call fastcc { { {}, { ptr, i32, i32, i32 } } } @"impl$f17"()
  %116 = extractvalue { { {}, { ptr, i32, i32, i32 } } } %115, 0
  %117 = insertvalue { i1, { {}, { ptr, i32, i32, i32 } } } { i1 true, { {}, { ptr, i32, i32, i32 } } undef }, { {}, { ptr, i32, i32, i32 } } %116, 1
  store { i1, { {}, { ptr, i32, i32, i32 } } } %117, ptr %10, align 8
  %118 = load { i64, [24 x i8] }, ptr %10, align 8
  %119 = extractvalue { ptr, ptr, i64 } %8, 1
  %120 = load i64, ptr %119, align 8
  %121 = icmp eq i64 %120, 0
  %122 = sub i64 %120, 1
  %123 = extractvalue { ptr, ptr, i64 } %8, 1
  store i64 %122, ptr %123, align 8
  br i1 %121, label %124, label %77

124:                                              ; preds = %113
  %125 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %20, 0
  %126 = insertvalue { i64, i64, { i64, [24 x i8] } } %125, i64 %17, 1
  %127 = insertvalue { i64, i64, { i64, [24 x i8] } } %126, { i64, [24 x i8] } %118, 2
  ret { i64, i64, { i64, [24 x i8] } } %127

128:                                              ; preds = %53
  call void @puts(ptr @assert_msg_202)
  call void @abort()
  unreachable
}

define private { i64, i64, { i64, [24 x i8] } } @f148(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f148"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f148(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f148(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f149"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f143"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define private { i64, i64, { i64, [24 x i8] } } @f149(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f149"(i64 %0, i64 %1, { { ptr, i32, i32, i32 } } %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f149(ptr %0, i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f149(i64 %1, i64 %2, { { ptr, i32, i32, i32 } } %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f150"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i252, { i128, [80 x i8] } }, i64 1, align 16
  %6 = load { i252, { i128, [80 x i8] } }, ptr %2, align 16
  %7 = extractvalue { i252, { i128, [80 x i8] } } %6, 0
  %8 = extractvalue { i252, { i128, [80 x i8] } } %6, 1
  %9 = insertvalue { i252, { i128, [80 x i8] } } undef, i252 %7, 0
  %10 = insertvalue { i252, { i128, [80 x i8] } } %9, { i128, [80 x i8] } %8, 1
  store { i252, { i128, [80 x i8] } } %10, ptr %5, align 16
  %11 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f151"(i64 %0, i64 %1, ptr %5, { ptr, i32, i32, i32 } %3)
  %12 = extractvalue { i64, i64, { i64, [24 x i8] } } %11, 0
  %13 = extractvalue { i64, i64, { i64, [24 x i8] } } %11, 1
  %14 = extractvalue { i64, i64, { i64, [24 x i8] } } %11, 2
  %15 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %12, 0
  %16 = insertvalue { i64, i64, { i64, [24 x i8] } } %15, i64 %13, 1
  %17 = insertvalue { i64, i64, { i64, [24 x i8] } } %16, { i64, [24 x i8] } %14, 2
  ret { i64, i64, { i64, [24 x i8] } } %17
}

define private { i64, i64, { i64, [24 x i8] } } @f150(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f150"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f150(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f150(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private void @"drop$20"({ { i128, [80 x i8] } } %0) {
  %2 = extractvalue { { i128, [80 x i8] } } %0, 0
  call void @"drop$19"({ i128, [80 x i8] } %2)
  ret void
}

define private { { { i128, [80 x i8] } }, { { i128, [80 x i8] } } } @"dup$20"({ { i128, [80 x i8] } } %0) {
  %2 = extractvalue { { i128, [80 x i8] } } %0, 0
  %3 = call { { i128, [80 x i8] }, { i128, [80 x i8] } } @"dup$19"({ i128, [80 x i8] } %2)
  %4 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %3, 0
  %5 = extractvalue { { i128, [80 x i8] }, { i128, [80 x i8] } } %3, 1
  %6 = insertvalue { { i128, [80 x i8] } } %0, { i128, [80 x i8] } %4, 0
  %7 = insertvalue { { i128, [80 x i8] } } undef, { i128, [80 x i8] } %5, 0
  %8 = insertvalue { { { i128, [80 x i8] } }, { { i128, [80 x i8] } } } undef, { { i128, [80 x i8] } } %6, 0
  %9 = insertvalue { { { i128, [80 x i8] } }, { { i128, [80 x i8] } } } %8, { { i128, [80 x i8] } } %7, 1
  ret { { { i128, [80 x i8] } }, { { i128, [80 x i8] } } } %9
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f151"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { { i128, [80 x i8] } }, i64 1, align 16
  %6 = load { i252, { i128, [80 x i8] } }, ptr %2, align 16
  %7 = extractvalue { i252, { i128, [80 x i8] } } %6, 0
  %8 = extractvalue { i252, { i128, [80 x i8] } } %6, 1
  %9 = extractvalue { ptr, i32, i32, i32 } %3, 3
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %25

11:                                               ; preds = %4
  %12 = shl i32 %9, 1
  %13 = call i32 @llvm.umin.i32(i32 %12, i32 1024)
  %14 = add i32 %13, %9
  %15 = call i32 @llvm.umax.i32(i32 %14, i32 8)
  %16 = zext i32 %15 to i64
  %17 = mul i64 %16, 32
  %18 = add i64 %17, 16
  %19 = call ptr @realloc(ptr null, i64 %18)
  store i32 1, ptr %19, align 4
  %20 = getelementptr inbounds i8, ptr %19, i32 4
  store i32 0, ptr %20, align 4
  %21 = getelementptr inbounds i8, ptr %19, i32 16
  %22 = call ptr @realloc(ptr null, i64 8)
  store ptr %21, ptr %22, align 8
  %23 = insertvalue { ptr, i32, i32, i32 } %3, ptr %22, 0
  %24 = insertvalue { ptr, i32, i32, i32 } %23, i32 %15, 3
  br label %46

25:                                               ; preds = %4
  %26 = extractvalue { ptr, i32, i32, i32 } %3, 2
  %27 = icmp ult i32 %26, %9
  br i1 %27, label %28, label %29

28:                                               ; preds = %25
  br label %43

29:                                               ; preds = %25
  %30 = shl i32 %9, 1
  %31 = call i32 @llvm.umin.i32(i32 %30, i32 1024)
  %32 = add i32 %31, %9
  %33 = call i32 @llvm.umax.i32(i32 %32, i32 8)
  %34 = zext i32 %33 to i64
  %35 = mul i64 %34, 32
  %36 = add i64 %35, 16
  %37 = extractvalue { ptr, i32, i32, i32 } %3, 0
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr inbounds i8, ptr %38, i32 -16
  %40 = call ptr @realloc(ptr %39, i64 %36)
  %41 = getelementptr inbounds i8, ptr %40, i32 16
  store ptr %41, ptr %37, align 8
  %42 = insertvalue { ptr, i32, i32, i32 } %3, i32 %33, 3
  br label %43

43:                                               ; preds = %28, %29
  %44 = phi { ptr, i32, i32, i32 } [ %42, %29 ], [ %3, %28 ]
  br label %45

45:                                               ; preds = %43
  br label %46

46:                                               ; preds = %11, %45
  %47 = phi { ptr, i32, i32, i32 } [ %44, %45 ], [ %24, %11 ]
  br label %48

48:                                               ; preds = %46
  %49 = extractvalue { ptr, i32, i32, i32 } %47, 0
  %50 = load ptr, ptr %49, align 8
  %51 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %52 = zext i32 %51 to i64
  %53 = mul i64 %52, 32
  %54 = getelementptr inbounds i8, ptr %50, i64 %53
  store i252 %7, ptr %54, align 16
  %55 = extractvalue { ptr, i32, i32, i32 } %47, 2
  %56 = add i32 %55, 1
  %57 = insertvalue { ptr, i32, i32, i32 } %47, i32 %56, 2
  %58 = getelementptr inbounds i8, ptr %50, i32 -12
  store i32 %56, ptr %58, align 4
  %59 = insertvalue { { i128, [80 x i8] } } undef, { i128, [80 x i8] } %8, 0
  store { { i128, [80 x i8] } } %59, ptr %5, align 16
  %60 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f152"(i64 %0, i64 %1, ptr %5, { ptr, i32, i32, i32 } %57)
  %61 = extractvalue { i64, i64, { i64, [24 x i8] } } %60, 0
  %62 = extractvalue { i64, i64, { i64, [24 x i8] } } %60, 1
  %63 = extractvalue { i64, i64, { i64, [24 x i8] } } %60, 2
  %64 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %61, 0
  %65 = insertvalue { i64, i64, { i64, [24 x i8] } } %64, i64 %62, 1
  %66 = insertvalue { i64, i64, { i64, [24 x i8] } } %65, { i64, [24 x i8] } %63, 2
  ret { i64, i64, { i64, [24 x i8] } } %66
}

define private { i64, i64, { i64, [24 x i8] } } @f151(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f151"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f151(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f151(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f152"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = load { { i128, [80 x i8] } }, ptr %2, align 16
  %7 = extractvalue { { i128, [80 x i8] } } %6, 0
  store { i128, [80 x i8] } %7, ptr %5, align 16
  %8 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f153"(i64 %0, i64 %1, ptr %5, { ptr, i32, i32, i32 } %3)
  %9 = extractvalue { i64, i64, { i64, [24 x i8] } } %8, 0
  %10 = extractvalue { i64, i64, { i64, [24 x i8] } } %8, 1
  %11 = extractvalue { i64, i64, { i64, [24 x i8] } } %8, 2
  %12 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %9, 0
  %13 = insertvalue { i64, i64, { i64, [24 x i8] } } %12, i64 %10, 1
  %14 = insertvalue { i64, i64, { i64, [24 x i8] } } %13, { i64, [24 x i8] } %11, 2
  ret { i64, i64, { i64, [24 x i8] } } %14
}

define private { i64, i64, { i64, [24 x i8] } } @f152(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f152"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f152(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f152(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

define private fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f153"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = alloca { i128, [80 x i8] }, i64 1, align 16
  %6 = load { i128, [80 x i8] }, ptr %2, align 16
  store { i128, [80 x i8] } %6, ptr %5, align 16
  %7 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f141"(i64 %0, i64 %1, ptr %5, { ptr, i32, i32, i32 } %3)
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %7, 0
  %9 = extractvalue { i64, i64, { i64, [24 x i8] } } %7, 1
  %10 = extractvalue { i64, i64, { i64, [24 x i8] } } %7, 2
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %8, 0
  %12 = insertvalue { i64, i64, { i64, [24 x i8] } } %11, i64 %9, 1
  %13 = insertvalue { i64, i64, { i64, [24 x i8] } } %12, { i64, [24 x i8] } %10, 2
  ret { i64, i64, { i64, [24 x i8] } } %13
}

define private { i64, i64, { i64, [24 x i8] } } @f153(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3) {
  %5 = call fastcc { i64, i64, { i64, [24 x i8] } } @"impl$f153"(i64 %0, i64 %1, ptr %2, { ptr, i32, i32, i32 } %3)
  %6 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 0
  %7 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 1
  %8 = extractvalue { i64, i64, { i64, [24 x i8] } } %5, 2
  %9 = insertvalue { i64, i64, { i64, [24 x i8] } } undef, i64 %6, 0
  %10 = insertvalue { i64, i64, { i64, [24 x i8] } } %9, i64 %7, 1
  %11 = insertvalue { i64, i64, { i64, [24 x i8] } } %10, { i64, [24 x i8] } %8, 2
  ret { i64, i64, { i64, [24 x i8] } } %11
}

define void @_mlir_ciface_f153(ptr %0, i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4) {
  %6 = call { i64, i64, { i64, [24 x i8] } } @f153(i64 %1, i64 %2, ptr %3, { ptr, i32, i32, i32 } %4)
  store { i64, i64, { i64, [24 x i8] } } %6, ptr %0, align 8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.usub.sat.i64(i64, i64) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.uadd.sat.i64(i64, i64) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umin.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umax.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i128, i1 } @llvm.uadd.with.overflow.i128(i128, i128) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i32, i1 } @llvm.uadd.with.overflow.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i32, i1 } @llvm.usub.with.overflow.i32(i32, i32) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i16, i1 } @llvm.usub.with.overflow.i16(i16, i16) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i8, i1 } @llvm.usub.with.overflow.i8(i8, i8) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i8, i1 } @llvm.ssub.with.overflow.i8(i8, i8) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i8, i1 } @llvm.uadd.with.overflow.i8(i8, i8) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i16, i1 } @llvm.ssub.with.overflow.i16(i16, i16) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i16, i1 } @llvm.uadd.with.overflow.i16(i16, i16) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.abs.i8(i8, i1 immarg) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i16 @llvm.abs.i16(i16, i1 immarg) #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i32, i1 } @llvm.sadd.with.overflow.i32(i32, i32) #1

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
